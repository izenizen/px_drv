//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;
typedef uint64_t uint128_t;

// ----------------- Float Types Definitions ------------------

typedef long double float80_t;

// ------------------- Function Prototypes --------------------

int64_t __class_create(int64_t a1, int64_t a2, int64_t a3);
int64_t __init_waitqueue_head(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t __kmalloc(int64_t a1, int64_t * a2, int64_t a3);
int64_t __mutex_init(int64_t a1, int64_t a2, int64_t a3);
int64_t __pci_register_driver(int64_t a1, int64_t a2, int64_t a3);
int64_t __stack_chk_fail(void);
int64_t __udelay(int64_t a1);
int64_t Adapter_GetSignaLevel_S(char * DevExt, char DevCH);
int64_t Adapter_GetSignaLevel_S2(int64_t a1, uint64_t a2);
int64_t Adapter_GetSignaLevel_T(char * DevExt, char DevCH);
int64_t Adapter_GetSignaLevel_T2(int64_t a1, uint64_t a2);
char Adapter_ReadSNR_S(char * DevExt, char DevCH);
int64_t Adapter_ReadSNR_S2(int64_t a1, uint64_t a2);
char Adapter_ReadSNR_T(char * DevExt, char DevCH);
int64_t Adapter_ReadSNR_T2(int64_t a1, uint64_t a2);
char Adapter_SetTsOutput(char * DevExt, char DevCH, int32_t ts_outputpin, int32_t sig_source);
int64_t Adapter_SetTsOutput2(void);
char Adapter_StopTsOutput(char * DevExt, char DevCH, int32_t ts_outputpin);
int64_t Adapter_StopTsOutput2(void);
char Adapter_TSIDRead(char * DevExt, char DevCH, int32_t * tsidList, char bufferlength);
int64_t Adapter_TSIDRead2(int64_t a1, uint64_t a2, int64_t a3, int64_t a4);
char Adapter_TSIDWrite(char * DevExt, char DevCH, int32_t tsid);
int64_t Adapter_TSIDWrite2(int64_t a1, int64_t a2);
void Add(int64_t * pulResMSB, int64_t * pulResLSB, int64_t ulAddMSB, int64_t ulAddLSB);
int64_t Add2(int64_t a1, int64_t result);
int32_t add_ref_multi2(char * m2);
int64_t add_ref_multi2_(void);
char Adpater_SetFreqISDBS(char * hTuner, char DevCH, int64_t freq, char ucRs);
int64_t Adpater_SetFreqISDBS2(int64_t a1, uint64_t a2, int64_t a3);
char Adpater_SetFreqISDBS_1(char * hTuner, char DevCH, int64_t freq, char ucRs);
int64_t Adpater_SetFreqISDBS_1_(int64_t a1, uint64_t a2, int64_t a3);
char Adpater_SetFreqISDBT(char * DevExt, char DevCH, int64_t Frequency, char ucRs);
int64_t Adpater_SetFreqISDBT2(int64_t a1, uint64_t a2, uint64_t a3);
char Adpater_TunerS_RegRead(char * DevExt, char DevCH, char byReg, char * pBuffer, char cnt);
char Adpater_TunerS_RegWrite(char * DevExt, char DevCH, char byReg, char * pBuffer, char cnt);
char Adpater_TunerT_RegRead(char * hExt, char DevCH, char subAddress, char * pData, char cnt);
int64_t Adpater_TunerT_RegRead2(void);
char Adpater_TunerT_RegWrite(char * hExt, char DevCH, char subAddress, char * pData, char cnt);
int64_t Adpater_TunerT_RegWrite2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int64_t * a5);
int64_t alloc_chrdev_region(int64_t a1, int32_t a2, int32_t a3, int64_t a4);
int32_t append_work_buffer(int64_t buf, char * data, int32_t size);
int64_t append_work_buffer2(int64_t a1, int64_t a2, int32_t a3);
int64_t AsicenAllocateStreamBuffer(int64_t deviceExtension, char DataStream_Num, int64_t TransferObjBufSize, int64_t StreamBufSize);
int64_t AsicenAllocateStreamBuffer2(int64_t a1, int64_t a2, uint64_t a3, uint64_t a4);
void AsicenFreeStreamBuffer(int64_t StreamObject);
int64_t AsicenFreeStreamBuffer2(int64_t a1);
void ASV5220_BcasThread(char * Context);
int64_t ASV5220_BcasThread2(int64_t a1);
void ASV5220_BcasThreadClose(int64_t pTnim);
int64_t ASV5220_BcasThreadClose2(int64_t a1);
int32_t ASV5220_BcasThreadInit(int64_t pTnim);
int64_t ASV5220_BcasThreadInit2(int64_t a1);
char ASV5220_bReadBCAS_Data(int64_t pTuner, char * DataBuf, int32_t * GetLen, char bRdATR, char bRdEcm, int32_t BufferSz);
int64_t ASV5220_bReadBCAS_Data2(int64_t a1, int64_t * a2, int64_t * a3, int64_t a4, int64_t a5, int64_t a6);
char ASV5220_bWtBCAS_Data(int64_t pTuner, char * DataBuf, int32_t WtLen);
int64_t ASV5220_bWtBCAS_Data2(int64_t a1, char * a2, int64_t * a3);
void asv5220_fini(void);
int64_t asv5220_fini2(void);
int64_t asv5220_finidev(int64_t a1);
char ASV5220_Get_BCAS_INFO(int64_t BCAS_Dev);
int64_t ASV5220_Get_BCAS_INFO2(int64_t a1);
int64_t ASV5220_GetCardInDetect(char * pCardDetect, int64_t hDEV);
int64_t ASV5220_GetCardInDetect2(char * a1);
int64_t asv5220_initdev(int64_t a1);
int64_t ASV5220_InitUart(int64_t hDEV);
int64_t ASV5220_InitUart2(int64_t a1);
int32_t asv5220_ioctl(int64_t inode, int64_t file, int32_t cmd, char * arg);
int64_t asv5220_ioctl2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t asv5220_open(int64_t inode, int64_t file);
int64_t asv5220_open2(int64_t a1, int64_t a2);
int64_t asv5220_read(int64_t file, char * buf, int64_t cnt, int64_t * ppos);
int64_t asv5220_read2(int64_t a1, int64_t a2, uint64_t a3);
int64_t ASV5220_ReadResponse(char * RdData, int32_t RdLen, int64_t TimeOut, int64_t hDEV);
int64_t ASV5220_ReadResponse2(int64_t a1, char * a2, char * a3, int64_t a4);
int32_t asv5220_release(int64_t inode, int64_t file);
int64_t asv5220_release2(int64_t a1, int64_t a2);
int64_t ASV5220_ResetUart(int64_t hDEV);
int64_t ASV5220_ResetUart2(int64_t a1);
int64_t asv5220_resume(int64_t a1);
int64_t ASV5220_SetBaudrate(int64_t hDEV);
int64_t ASV5220_SetBaudrate2(int64_t a1);
int32_t asv5220_suspend(int64_t pci_dev, int64_t state);
int64_t asv5220_suspend2(int64_t a1, int64_t a2);
int64_t ASV5220_WriteCommand(char * WrData, int32_t WrLen, int64_t hDEV);
int64_t ASV5220_WriteCommand2(int64_t a1, uint64_t a2, int64_t a3);
char bBCardInit(int64_t BCAS_Dev);
int64_t bBCardInit2(int64_t a1);
char bBCardUninit(int64_t BCAS_Dev);
int64_t bBCardUninit2(int64_t a1, int64_t a2);
char BCAS_CMDGet_Ext(char * PDev, char * PTuner, char * Status, char * size, char * buffer, int64_t BufferSz);
int64_t BCAS_CMDGet_Ext2(int64_t a1, int64_t a2, int64_t * a3, char * a4, int64_t * a5, int64_t a6, int64_t a7);
int32_t BCAS_CMDSet(char * PDev, char * buffer, int32_t size, char bInitCmd, char * bcas);
int64_t BCAS_CMDSet2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
char BCAS_CMDSet_Ext(char * PDev, char * PTuner, char * buffer, int32_t size);
int64_t BCAS_CMDSet_Ext2(int64_t a1, int64_t a2, int64_t * a3, char a4);
char Ber_to_Signal_Quality(int32_t berdat, int32_t pecycle, char DevCH, int32_t src_select);
int64_t Ber_to_Signal_Quality2(int32_t a1, int64_t a2, int64_t a3, int64_t * a4);
char BLACKWIDOW_ConfigureGainMode(int64_t ptCommunication, int64_t ptThrehold, int64_t ptGainModeConfiguration);
int64_t BLACKWIDOW_ConfigureGainMode2(int64_t a1, int64_t a2, int64_t a3);
char BLACKWIDOW_EnableLoopThrough(int64_t ptCommunication, char bEnable);
int64_t BLACKWIDOW_EnableLoopThrough2(int64_t a1, int64_t * a2);
char BLACKWIDOW_GetChipInfo(int64_t ptCommunication, char ** ppcTunerString, int64_t * pulChipVersion, int64_t * pulChipId);
int64_t BLACKWIDOW_GetChipInfo2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
char BLACKWIDOW_GetDriverVersion(int64_t ptDriverVersion);
int64_t BLACKWIDOW_GetDriverVersion2(int64_t a1);
char BLACKWIDOW_GetEnableBlocks(int64_t ptCommunication, int64_t ptEnableBlocks);
int64_t BLACKWIDOW_GetEnableBlocks2(int64_t a1, int64_t a2, int64_t a3);
char BLACKWIDOW_GetGainLowCurrentConfig(int64_t ptCommunication, int64_t ptGainLowCurrent);
int64_t BLACKWIDOW_GetGainLowCurrentConfig2(int64_t a1, int64_t a2);
char BLACKWIDOW_GetGainMode(int64_t ptCommunication, int64_t ptThrehold, int32_t * peGainMode);
int64_t BLACKWIDOW_GetGainMode2(int64_t a1, int64_t a2, int64_t a3);
char BLACKWIDOW_GetLoConfig(int64_t ptCommunication, int64_t ptLoSettings);
int64_t BLACKWIDOW_GetLoConfig2(int64_t a1, int64_t * a2, int64_t a3);
char BLACKWIDOW_GetPllDividerConfig(int64_t ptCommunication, int64_t ptPllDividerSettings);
int64_t BLACKWIDOW_GetPllDividerConfig2(int64_t a1, int32_t * a2, int64_t a3);
char BLACKWIDOW_GetPllDsmOrderAndFractCorrect(int64_t ptCommunication, int32_t * peDsmOrder, int32_t * peDsmFrac);
int64_t BLACKWIDOW_GetPllDsmOrderAndFractCorrect2(int64_t a1, int64_t * a2, int32_t * a3);
char BLACKWIDOW_GetPLLFrequency(int64_t ptCommunication, int64_t * pulPllFrequencyKhz);
int64_t BLACKWIDOW_GetPLLFrequency2(int64_t a1, int64_t a2, int64_t a3);
char BLACKWIDOW_GetPLLLockStatus(int64_t ptCommunication, char * pbPllLockStatus);
int64_t BLACKWIDOW_GetPLLLockStatus2(int64_t a1, int64_t a2, int64_t a3);
char BLACKWIDOW_GetPowerDetect(int64_t ptCommunication, int32_t * ptPowerDetect);
int64_t BLACKWIDOW_GetPowerDetect2(int64_t a1, int32_t * a2);
char BLACKWIDOW_GetPowerMode(int64_t ptCommunication, int32_t * pePowerMode);
int64_t BLACKWIDOW_GetPowerMode2(int64_t a1, int64_t a2);
char BLACKWIDOW_GetSelectedGainMode(int64_t ptCommunication, int32_t * peGainMode, int32_t * pePowerDetectValue);
int64_t BLACKWIDOW_GetSelectedGainMode2(int64_t a1, int64_t a2, int64_t a3);
char BLACKWIDOW_GetStatus(int64_t ptCommunication, int64_t ptStatus);
int64_t BLACKWIDOW_GetStatus2(int64_t a1, int64_t a2, int64_t a3);
char BLACKWIDOW_GetVcoStatus(int64_t ptCommunication, int64_t ptStatus);
int64_t BLACKWIDOW_GetVcoStatus2(int64_t a1, int32_t * a2, int64_t a3);
char BLACKWIDOW_GetXtalExtClkSettings(int64_t ptCommunication, char * pExtClkOvr, char * pExtClkEn, int32_t * pExtClkFiltSel, int32_t * pExtDivSel);
int64_t BLACKWIDOW_GetXtalExtClkSettings2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t BLACKWIDOW_GetXtalFreqHz(int64_t ptCommunication);
int64_t BLACKWIDOW_GetXtalFreqHz2(int64_t a1);
char BLACKWIDOW_GetXtalSettings(int64_t ptCommunication, int64_t ptXtalSettings);
int64_t BLACKWIDOW_GetXtalSettings2(int64_t a1, int64_t a2);
char BLACKWIDOW_Initialize(int64_t ptCommunication, int64_t ptConfig);
int64_t BLACKWIDOW_Initialize2(int64_t a1, int32_t * a2, int64_t a3);
char BLACKWIDOW_ProgramPllPor(int64_t ptCommunication);
int64_t BLACKWIDOW_ProgramPllPor2(int64_t a1);
char BLACKWIDOW_ProgramVcoChannelChange(int64_t ptCommunication);
int64_t BLACKWIDOW_ProgramVcoChannelChange2(int64_t a1);
char BLACKWIDOW_ProgramVcoChannelChangeSpi(int64_t ptCommunication);
int64_t BLACKWIDOW_ProgramVcoChannelChangeSpi2(int64_t a1);
char BLACKWIDOW_ProgramVcoPor(int64_t ptCommunication);
int64_t BLACKWIDOW_ProgramVcoPor2(int64_t a1);
char BLACKWIDOW_SetBandwidthConfig(int64_t ptCommunication, int32_t eFilterBandwidth, int32_t eGmcBandwidth);
int64_t BLACKWIDOW_SetBandwidthConfig2(int64_t a1, int64_t a2, int32_t a3);
char BLACKWIDOW_SetEnableBlocks(int64_t ptCommunication, int64_t ptEnableBlocks);
int64_t BLACKWIDOW_SetEnableBlocks2(int64_t a1, int64_t a2, int64_t a3);
char BLACKWIDOW_SetFilterBandwidth(int64_t ptCommunication, int64_t ulBandwidthKhz);
int64_t BLACKWIDOW_SetFilterBandwidth2(int64_t a1, int64_t a2);
char BLACKWIDOW_SetFreq(int64_t ptCommunication, int64_t ulFreqkHz, int32_t loDiv);
int64_t BLACKWIDOW_SetFreq2(int64_t a1, uint64_t a2, int64_t * a3);
char BLACKWIDOW_SetFrequency(int64_t ptCommunication, int64_t ulFreqkHz);
int64_t BLACKWIDOW_SetFrequency2(int64_t a1);
char BLACKWIDOW_SetFrequencyAndBandwidth(int64_t ptCommunication, int64_t ptChannelObj);
int64_t BLACKWIDOW_SetFrequencyAndBandwidth2(int64_t a1, int64_t a2, int64_t a3);
char BLACKWIDOW_SetGain(int64_t ptCommunication);
int64_t BLACKWIDOW_SetGain2(int64_t a1);
char BLACKWIDOW_SetGainConfig(int64_t ptCommunication, int64_t ptGain);
int64_t BLACKWIDOW_SetGainConfig2(int64_t a1, int64_t a2, int64_t a3);
char BLACKWIDOW_SetGainLowCurrentConfig(int64_t ptCommunication, int64_t ptGainLowCurrent);
int64_t BLACKWIDOW_SetGainLowCurrentConfig2(int64_t a1, int64_t a2, int64_t a3);
char BLACKWIDOW_SetGainMode(int64_t ptCommunication, int32_t eGainMode);
int64_t BLACKWIDOW_SetGainMode2(int64_t a1, uint32_t a2);
char BLACKWIDOW_SetLoConfig(int64_t ptCommunication, int64_t ptLoSettings);
int64_t BLACKWIDOW_SetLoConfig2(int64_t a1, int64_t * a2, int64_t a3);
char BLACKWIDOW_SetPllDividerConfig(int64_t ptCommunication, int64_t ptPllDividerSettings);
int64_t BLACKWIDOW_SetPllDividerConfig2(int64_t a1, int32_t * a2, int128_t a3);
char BLACKWIDOW_SetPowerDetectorConfig(int64_t ptCommunication, int32_t eGainShiftValue);
int64_t BLACKWIDOW_SetPowerDetectorConfig2(int64_t a1, int64_t a2);
char BLACKWIDOW_SetPowerMode(int64_t ptCommunication, int32_t ePowerMode);
int64_t BLACKWIDOW_SetPowerMode2(int64_t a1, int64_t a2);
char BLACKWIDOW_SetXtalExtClkSettings(int64_t ptCommunication, char extClkOvr, char extClkEn, int32_t extClkFiltSel, int32_t extDivSel);
int64_t BLACKWIDOW_SetXtalExtClkSettings2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
void BLACKWIDOW_SetXtalFreqHz(int64_t ptCommunication, int64_t ulFreqHz);
int64_t BLACKWIDOW_SetXtalFreqHz2(void);
char BLACKWIDOW_SetXtalSettings(int64_t ptCommunication, int64_t ptXtalSettings);
int64_t BLACKWIDOW_SetXtalSettings2(int64_t a1, int64_t a2, int64_t a3);
void BLACKWIDOW_Sleep(int64_t ulTimeUs);
int64_t BLACKWIDOW_Sleep2(void);
char BLACKWIDOW_Tune(int64_t ptCommunication, int64_t ptChannelObj);
int64_t BLACKWIDOW_Tune2(int64_t a1);
char bReadBCAS_Data(char * DevExt, char * DataBuf, int32_t * GetLen, char bRdATR, int32_t BufferSz, char ASIE5606Ver);
int64_t bReadBCAS_Data2(int64_t a1, int64_t * a2, int64_t * a3, int64_t a4, int64_t a5, char a6);
char bReadI2CEncData(char Slave_Addr, char RegOffset, int16_t u16ReadLen, char * pDataBuf, char I2CFlag, int64_t hCtrlTransfer);
int64_t bReadI2CEncData2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
char bReadMPUI2CData(char MPU_Slave_Addr, char Target_Slave_Addr, char RegOffset, char u16ReadLen, char * pDataBuf, char withRSA, int64_t hCtrlTransfer);
int64_t bReadMPUI2CData2(int64_t a1, int64_t a2, uint64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7);
char bReadPcieCfgReg(int16_t RegOffset, int16_t u16ReadLen, char * pDataBuf, int64_t hCtrlTransfer);
int64_t bReadPcieCfgReg2(int64_t a1, int64_t * a2, int64_t * a3, int64_t a4);
char bReadPcieReg(uint16_t RegOffset, uint16_t u16ReadLen, char * pDataBuf, int64_t hCtrlTransfer);
char bTunerReset(char u8ChanNum, char ResetPin, char * hCtrlTransfer);
int64_t bTunerReset2(int64_t a1, int64_t a2, int64_t a3);
char bWriteI2CEncData(char Slave_Addr, char RegOffset, int16_t u16WriteLen, char * pDataBuf, int64_t hCtrlTransfer);
int64_t bWriteI2CEncData2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
char bWriteMPUI2CData(char MPU_Slave_Addr, char Target_Slave_Addr, char RegOffset, char u16WriteLen, char * pDataBuf, char withRSA, int64_t hCtrlTransfer);
int64_t bWriteMPUI2CData2(int64_t a1);
char bWritePcieReg(int16_t RegOffset, int16_t u16WriteLen, char * pDataBuf, int64_t hCtrlTransfer);
char bWtBCAS_Data(char * DevExt, char * DataBuf, int32_t WtLen, char ASIE5606Ver);
int64_t bWtBCAS_Data2(int64_t a1, char * a2, int64_t * a3, char a4);
int64_t cdev_add(int64_t a1, int32_t a2, int64_t * a3);
int64_t cdev_del(int64_t a1);
int64_t cdev_init(int64_t a1, int64_t a2);
int64_t cfg_access(char bIsRead, int64_t pFdoData, int16_t regAddr, int64_t length, char * Data);
int64_t cfg_access2(int64_t * a1, int64_t a2, uint64_t a3, int64_t * a4, int64_t * a5);
int64_t cfg_read(int64_t pFdoData, int16_t regAddr, int64_t length, char * readData);
int64_t cfg_read2(int64_t a1, uint64_t a2, int64_t a3, int64_t * a4);
int64_t cfg_write(int64_t pFdoData, int16_t regAddr, int64_t length, char * writeData);
int64_t cfg_write2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4);
char ChangeEndian(char Input);
int64_t ChangeEndian2(int64_t a1);
int32_t check_ecm_complete(int64_t prv);
int64_t check_ecm_complete2(int64_t a1);
int32_t check_pmt_complete(int64_t prv);
int64_t check_pmt_complete2(int64_t a1);
int32_t check_ts_section(int64_t sect);
int64_t check_ts_section2(int64_t a1);
int32_t check_ts_section_crc(int64_t sect);
int64_t check_ts_section_crc2(int64_t a1);
char CheckThresholdValidity(int64_t ptThrehold);
int64_t CheckThresholdValidity2(int64_t a1, int64_t a2, int64_t a3);
int32_t cipherInit(int64_t cipher, char mode, char * IV);
int64_t cipherInit2(int64_t a1, int64_t * a2, int64_t a3);
int32_t cipherUpdateRounds(int64_t cipher, int64_t key, char * input, int32_t inputLen, char * outBuffer, int32_t rounds, int64_t pTable);
int64_t cipherUpdateRounds2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int64_t a5, int32_t a6, int64_t a7);
int64_t class_destroy(int64_t a1);
int32_t clear_scramble_key_multi2(char * m2);
int64_t clear_scramble_key_multi2_(void);
int32_t compare_ts_section(int64_t curr, int64_t next);
int64_t compare_ts_section2(int64_t a1);
int64_t complete(int64_t a1);
int32_t connect_card(int64_t prv, int64_t bcas);
int64_t connect_card2(int64_t a1, int64_t a2);
void Convert_Function1_Driver(char * datain, char * dataout);
int64_t Convert_Function1_Driver2(void);
void Convert_Function2_Driver(char * datain, char * dataout);
int64_t Convert_Function2_Driver2(void);
void Convert_Function3_Driver(char * datain, char * dataout);
int64_t Convert_Function3_Driver2(void);
void Convert_Function4_Driver(char * datain, char * dataout);
int64_t Convert_Function4_Driver2(void);
int64_t copy_from_user(int64_t * a1, int64_t a2, int64_t * a3);
int64_t copy_to_user(int64_t a1, int32_t * a2, int64_t * a3);
void core_encrypt(int64_t dst, int64_t src, int64_t w, int32_t round);
int64_t core_encrypt2(int32_t * a1, int32_t * a2, int64_t a3, int32_t a4);
void core_pi1(int64_t dst, int64_t src);
int64_t core_pi1_(int64_t * a1);
void core_pi2(int64_t dst, int64_t src, int32_t a);
int64_t core_pi2_(int64_t * a1, int64_t * a2, int32_t a3);
void core_pi3(int64_t dst, int64_t src, int32_t a, int32_t b);
int64_t core_pi3_(int64_t a1, int64_t a2, int64_t a3);
void core_pi4(int64_t dst, int64_t src, int32_t a);
int64_t core_pi4_(int64_t a1, int64_t a2, int32_t a3);
void core_schedule(int64_t work, int64_t skey, int64_t dkey);
int64_t core_schedule2(int64_t a1, int64_t a2, int64_t a3);
int64_t create_arib_std_b25(void);
int64_t create_arib_std_b25_(void);
int64_t create_b_cas_card(char * DevExt, int32_t (*bcas_callback)(char *, char *, int32_t, char, char *));
int64_t create_b_cas_card2(int64_t a1, int64_t a2);
int64_t create_multi2(void);
int64_t create_multi2_(void);
int32_t decrypt_multi2(char * m2, int32_t type, char * buf, int32_t size);
int64_t decrypt_multi2_(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void DecryptBlock(char * cipherkey, char * input, char * output, int64_t pTable);
int64_t DecryptBlock2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void DelayMilliseconds(int32_t ms);
int64_t DelayMilliseconds2(int64_t * a1, int64_t a2);
void DelayMilliseconds_i2c(int32_t ms);
int64_t DelayMilliseconds_i2c2(int64_t * a1);
void DelayNanoseconds(int32_t delay);
int64_t DelayNanoseconds2(int64_t * a1);
char DemodRegRead(char * DevExt, char DevCH, char byReg, char * pBuffer, char byCount, int32_t sig_source);
int64_t DemodRegRead2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t * a5, int64_t * a6);
char DemodRegWrite(char * DevExt, char DevCH, char byReg, char * pBuffer, char byCount, int32_t sig_source);
int64_t DemodRegWrite2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int64_t * a5, int64_t a6);
void des_crypt_ecb(int64_t ctx, char * input, char * output, int64_t pTable);
int64_t des_crypt_ecb2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void des_crypt_ecb_Multi(int64_t ctx, char * input, char * output, int64_t pTable, int32_t BlockNum);
int64_t des_crypt_ecb_Multi2(int64_t a1, int64_t * a2, int64_t a3, int64_t a4, int64_t * a5);
void des_setkey(int64_t * SK, char * key, int64_t pTable);
int64_t des_setkey2(int64_t a1, int64_t a2, int64_t a3);
void des_setkey_dec(int64_t ctx, char * key, int64_t pTable);
int64_t des_setkey_dec2(int64_t a1);
void des_setkey_enc(int64_t ctx, char * key, int64_t pTable);
int64_t des_setkey_enc2(int64_t a1);
int64_t dev_get_drvdata(int64_t a1);
int64_t dev_set_drvdata(int64_t a1, int64_t a2);
int64_t device_create(int64_t a1, int64_t a2, int32_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t device_destroy(int64_t a1, int32_t a2);
char DispatchByRuleTable(char dmaCH, char * wtPtr, char * fp, int64_t length);
int64_t DispatchByRuleTable2(int32_t a1, int64_t a2, int64_t a3, int64_t a4);
void Div(int64_t ulNumMSB, int64_t ulNumLSB, int64_t ulDenom, int64_t * pulResMSB, int64_t * pulResLSB);
int64_t Div2(int64_t a1, int64_t a2, int64_t result, int64_t * a4, int64_t * a5);
int64_t down(int64_t a1, int64_t a2);
void DriverDebugMessage(char * Msg);
int64_t DriverDebugMessage2(int64_t a1);
void DriverDebugPrint(char * format, ...);
int64_t DriverDebugPrint2(int64_t a1, int64_t a2);
int64_t DriverEntry(char * DriverObject, char * RegistryPath);
int64_t DriverEntry2(int64_t a1);
void DriverInterfaceDec(int64_t pTuner, char * Input188B, char * Output188B);
int64_t DriverInterfaceDec2(int64_t a1, int64_t a2, int64_t result);
void DriverInterfaceDec_Multi(int64_t pTuner, char * TSData_In, int32_t FrameNum, char * TSData_Out);
int64_t DriverInterfaceDec_Multi2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void DriverInterfaceEnc(int64_t pTuner, char * Input188B, char * Output188B);
int64_t DriverInterfaceEnc2(int64_t a1, int64_t a2, int64_t a3);
void DriverInterfaceEnc_Multi(int64_t pTuner, char * TSData_In, int32_t FrameNum, char * TSData_Out);
int64_t DriverInterfaceEnc_Multi2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
char DTV_5606B2_KeyTransfer1(int64_t pTuner);
int64_t DTV_5606B2_KeyTransfer1_(int64_t a1);
char DTV_5606B2_KeyTransfer2(int64_t pTuner);
int64_t DTV_5606B2_KeyTransfer2_(int64_t a1);
int32_t DTV_Calculate_Final_Key(int64_t pTuner, char * VID, char * PID, char * EEPROM8b, char * APEncSeed, char * PCKey);
int64_t DTV_Calculate_Final_Key2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int32_t DTV_CheckSync(char * Buffer, int32_t ChkFrameNum);
int64_t DTV_CheckSync2(int64_t a1, int64_t * a2);
int32_t DTV_CleanEncFlag(char * Buffer, int32_t FrameNum);
int64_t DTV_CleanEncFlag2(int64_t a1, int32_t a2, int32_t a3, int32_t a4);
char DTV_DecEncChip_I2C_Read(int64_t pTuner, char I2C_Addr, char byReg, char * pBuffer, char byCount, char withRSA);
int64_t DTV_DecEncChip_I2C_Read2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
char DTV_DecEncChip_I2C_Write(uint64_t pTuner, unsigned char I2C_Addr, unsigned char byReg, char * pBuffer, char byCount, unsigned char withRSA);
int64_t DTV_DecEncChip_I2C_Write2(int64_t a1, char a2, int64_t * a3, char * a4, int64_t * a5);
int32_t DTV_DecrypMultiTS(int64_t pTnim, char * TSData_In, int32_t FrameNum, char * TSData_Out);
int64_t DTV_DecrypMultiTS2(int64_t a1, int64_t a2, uint32_t a3, int64_t a4);
int32_t DTV_DecrypMultiTS_no_decrypt_multi2(int64_t pTnim, char * TSData_In, int32_t FrameNum, char * TSData_Out);
int64_t DTV_DecrypMultiTS_no_decrypt_multi2_(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t DTV_DecrypTS(int64_t pTuner, char * Input188B, char * Output188B);
int64_t DTV_DecrypTS2(int64_t a1, int64_t a2, int64_t a3);
int32_t DTV_DecrypTS_5607(int64_t pTuner, char * Input188B, char * Output188B, int32_t buffersize);
int64_t DTV_DecrypTS_5607_(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
char DTV_EnableEncryptionChipTSOutput(int64_t pTnim);
int64_t DTV_EnableEncryptionChipTSOutput2(int64_t a1);
int32_t DTV_EncAES_MultiTS(int64_t pTuner, char * TSData_In, int32_t FrameNum, char * TSData_Out);
int64_t DTV_EncAES_MultiTS2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t DTV_EncAES_TS(int64_t pTuner, char * Input188B, char * Output188B);
int64_t DTV_EncAES_TS2(int64_t a1, int64_t a2, int64_t a3);
int32_t DTV_GenEncSeed(int64_t pTnim, char * APEncSeed, char APEncSeedLen, char * PCKey, char PCKeyLen);
int64_t DTV_GenEncSeed2(int64_t a1, int64_t a2, char a3, int64_t a4, char a5);
char DTV_GetAGCValue(int64_t pTnim, char u8TunerNum, int64_t * agcvalue);
int64_t DTV_GetAGCValue2(int64_t a1, int64_t a2, int64_t a3);
int32_t DTV_GetBCASCommand(int64_t pTuner, int64_t bcas_command, int64_t GetLen);
int64_t DTV_GetBCASCommand2(int64_t a1, int64_t a2, uint64_t a3);
int32_t DTV_GetBcasReturnCode(int64_t pTuner, char * pu8OutPutBuf, int64_t GetLen);
int64_t DTV_GetBcasReturnCode2(int64_t a1, int64_t a2, int64_t a3);
char DTV_GetBERValue(int64_t pTnim, char u8TunerNum, int64_t * BER1, int64_t * BER2);
int64_t DTV_GetBERValue2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
char DTV_GetCNRegisterValue(int64_t pTnim, unsigned char u8TunerNum, int64_t * cnvalue);
int64_t DTV_GetCNRegisterValue2(int64_t a1, char a2, int64_t * a3);
char DTV_GetCNValue(int64_t pTnim, unsigned char u8TunerNum, int64_t * cnvalue);
int64_t DTV_GetCNValue2(int64_t a1, int64_t a2, int64_t a3);
char DTV_GetContentAvailabilityDescriptor(int64_t pTuner, int32_t Pid, char * Buffer, int32_t * real_length);
int64_t DTV_GetContentAvailabilityDescriptor2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
char DTV_GetDecryptionInformation(int64_t pTuner, char * keyarray, int32_t * hw_version);
int64_t DTV_GetDecryptionInformation2(void);
char DTV_GetDigitalCopyControlDescriptor(int64_t pTuner, int32_t Pid, char * Buffer, int32_t * real_length);
int64_t DTV_GetDigitalCopyControlDescriptor2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
char DTV_GetEmergencyAlarmStatus(int64_t pTnim, char u8TunerNum, char * emergencyAlarmStatus);
int64_t DTV_GetEmergencyAlarmStatus2(int64_t a1, int64_t a2, int64_t a3);
char DTV_GetIRData(int64_t pTuner, char * pu8OutPutBuf, char * valid_cnt);
int64_t DTV_GetIRData2(int64_t a1, int64_t a2);
char DTV_GetIsStreamScramble(int64_t pTuner, char * isStreamScramble);
int64_t DTV_GetIsStreamScramble2(int64_t a1);
char DTV_GetProgramIDList(int64_t pTuner, int32_t * program_id_list, unsigned char list_length);
int64_t DTV_GetProgramIDList2(int64_t a1, int64_t a2, int64_t a3);
void DTV_GetProgramIDList_Ex(int64_t pTuner, int64_t program_id_list, char * program_number_count);
int64_t DTV_GetProgramIDList_Ex2(int64_t a1, int64_t a2, int64_t a3);
char DTV_GetProgramNumber_ByPID(int64_t pTuner, int32_t Pid, int32_t * program_number);
int64_t DTV_GetProgramNumber_ByPID2(int64_t a1, int64_t a2, int64_t a3);
char DTV_GetResetMulti2LibFlag(int64_t pTuner, char * isNeedResetMulti2Lib);
int64_t DTV_GetResetMulti2LibFlag2(int64_t a1);
int32_t DTV_GetTSReSync(int64_t pTuner, char * pu8OutPutBuf, int64_t GetLen);
int64_t DTV_GetTSReSync2(int64_t a1, int64_t a2, uint64_t a3);
char DTV_GetTunerCurrentTSID(int64_t pTuner, int32_t * tsid);
int64_t DTV_GetTunerCurrentTSID2(int64_t a1);
int32_t DTV_GetTunerSignalLevel(int64_t pTnim, char * SNR, int64_t * IF_AGC);
int64_t DTV_GetTunerSignalLevel2(int64_t a1, int64_t a2, int64_t a3);
char DTV_GetTunerTSIDList(int64_t pTuner, int32_t * tsidList, char listLength);
int64_t DTV_GetTunerTSIDList2(int64_t a1);
int32_t DTV_GetUSB_MODE(int64_t pTnim);
int64_t DTV_GetUSB_MODE2(int64_t a1);
void DTV_HardwareDecrypt(int64_t pTuner, char * Input188B, char * Output188B);
int64_t DTV_HardwareDecrypt2(int64_t a1, int64_t * a2, int64_t a3);
void DTV_HardwareDecrypt_5211Ver01(int64_t pTuner, char * Input188B, char * Output188B);
int64_t DTV_HardwareDecrypt_5211Ver01_(int64_t a1, int64_t * a2, int64_t a3);
void DTV_HardwareDecrypt_ASV5606(int64_t pTuner, char * Input188B, char * Output188B);
int64_t DTV_HardwareDecrypt_ASV5606_(int64_t a1, int64_t a2, int64_t a3);
void DTV_HardwareDecrypt_Ver01(int64_t pTuner, char * Input188B, char * Output188B);
int64_t DTV_HardwareDecrypt_Ver01_(int64_t a1, int64_t * a2, int64_t a3);
int32_t DTV_Init(int64_t pTnim, int32_t Mode, char bAPKeyIdenfy);
int64_t DTV_Init2(int64_t a1, int64_t * a2, int64_t * a3);
char DTV_IsSlowDownICExisted(int64_t pTuner);
int64_t DTV_IsSlowDownICExisted2(int64_t a1);
int32_t DTV_Muli2LibEnable(int64_t pTnim, char * pMulti2LibStartKey, char StartKeyLen);
int64_t DTV_Muli2LibEnable2(int64_t a1, int64_t * a2, char a3);
void DTV_PollingDeviceThread(char * Context);
int64_t DTV_PollingDeviceThread2(int64_t a1);
void DTV_PollingDeviceThreadClose(int64_t deviceExtension);
int64_t DTV_PollingDeviceThreadClose2(int64_t a1);
int32_t DTV_PollingDeviceThreadInit(int64_t deviceExtension);
int64_t DTV_PollingDeviceThreadInit2(int64_t a1);
void DTV_PollingThread(char * Context);
int64_t DTV_PollingThread2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void DTV_PollingThreadClose(int64_t pTnim);
int64_t DTV_PollingThreadClose2(int64_t a1);
int32_t DTV_PollingThreadInit(int64_t pTnim);
int64_t DTV_PollingThreadInit2(int64_t a1);
void DTV_PollingWDThread(char * Context);
int64_t DTV_PollingWDThread2(void);
void DTV_PollingWDThreadClose(int64_t pTnim);
int64_t DTV_PollingWDThreadClose2(int64_t a1);
int32_t DTV_PollingWDThreadInit(int64_t pTnim);
int64_t DTV_PollingWDThreadInit2(int64_t a1);
char DTV_ReadI2CEncData(int64_t pTuner, char I2C_Addr, char byReg, char byCount, char * pBuffer, char I2CFlag, char withRSA);
int64_t DTV_ReadI2CEncData2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int64_t a5, int64_t a6, int32_t a7);
int32_t DTV_Reset_EncChip(int64_t pTnim);
int64_t DTV_Reset_EncChip2(int64_t a1);
int32_t DTV_Reset_EncChipEx(int64_t pTuner);
int64_t DTV_Reset_EncChipEx2(int64_t a1, int64_t a2, int64_t a3);
char DTV_SaveBCASCommand(int64_t pTuner, int64_t bcas_command);
int64_t DTV_SaveBCASCommand2(int64_t a1, int64_t a2);
char DTV_SaveBcasReturnCode(int64_t pTuner, char * pReceiveDataBuf);
int64_t DTV_SaveBcasReturnCode2(int64_t a1, char * a2);
char DTV_SaveTSReSync(int64_t pTuner, char * pReceiveDataBuf);
int64_t DTV_SaveTSReSync2(int64_t a1, char * a2);
int32_t DTV_Set_EncSeedReg(int64_t pTnim, char * EncSeed_CE, char EncSeedLen);
int64_t DTV_Set_EncSeedReg2(int64_t a1, int64_t a2, int64_t * a3);
int32_t DTV_Set_EncSeedRegASV5606(int64_t pTuner, char * EncSeed_CE, char EncSeedLen);
int64_t DTV_Set_EncSeedRegASV5606_(int64_t a1, int64_t a2, int64_t * a3);
int32_t DTV_Set_EncSeedRegEx(int64_t pTuner, char * EncSeed_CE, char EncSeedLen);
int64_t DTV_Set_EncSeedRegEx2(int64_t a1, int64_t a2, int64_t * a3);
char DTV_SetBCASCardExist(int64_t pTuner, char isExist);
int64_t DTV_SetBCASCardExist2(int64_t a1);
char DTV_SetIsStreamScramble(int64_t pTuner, char isStreamScramble);
int64_t DTV_SetIsStreamScramble2(int64_t a1);
int32_t DTV_SetPidFilterBoundary(int64_t pTuner, int32_t Start, int32_t End);
int64_t DTV_SetPidFilterBoundary2(int64_t a1, int64_t a2, int64_t a3);
int32_t DTV_SetPidTable(int64_t pTnim, int32_t * PID_TableBuf, char WordLen);
int64_t DTV_SetPidTable2(int64_t a1, int64_t a2, uint64_t a3);
char DTV_SetProgramID(int64_t pTuner, int32_t program_id);
int64_t DTV_SetProgramID2(int64_t a1, int64_t a2);
int32_t DTV_SetTunerFreq(int64_t pTnim, int64_t Freq, char BW);
int64_t DTV_SetTunerFreq2(int64_t a1, uint64_t a2, int64_t * a3);
char DTV_SetTunerTSID(int64_t pTuner, int32_t tsid, char preset);
int64_t DTV_SetTunerTSID2(int64_t a1, uint32_t a2, uint64_t a3);
void DTV_Software_process_5606B2(int64_t pTuner, char * Input188B, char * Output188B);
int64_t DTV_Software_process_5606B2_(int64_t result, int64_t a2, int64_t a3);
int32_t DTV_StartStop_Enc(int64_t pTnim, char bStart);
int64_t DTV_StartStop_Enc2(int64_t a1, int64_t a2);
int32_t DTV_StreamDataRead(int64_t pTnim, char * Buffer, int32_t MaxReadLen);
int64_t DTV_StreamDataRead2(int64_t a1, int64_t a2, int64_t a3);
int32_t DTV_StreamThreadRun(int64_t pTnim);
int64_t DTV_StreamThreadRun2(int64_t a1);
int32_t DTV_StreamThreadStop(int64_t pTnim, char bRstTuner);
int64_t DTV_StreamThreadStop2(int64_t a1, int64_t a2);
int32_t DTV_TunerHardReset(int64_t deviceExtension, unsigned char TunerNum);
int64_t DTV_TunerHardReset2(int64_t a1, int64_t a2);
int32_t DTV_TunerLockCheck(int64_t pTnim);
int64_t DTV_TunerLockCheck2(int64_t a1);
int32_t DTV_TunerPower(int64_t pTnim, char bPowerOn);
int64_t DTV_TunerPower2(int64_t result);
int32_t DTV_UnInit(int64_t pTnim);
int64_t DTV_UnInit2(int64_t a1);
char DTV_WriteI2CEncData(uint64_t pTuner, unsigned char I2C_Addr, char byReg, char byCount, char * pBuffer, char withRSA);
int64_t DTV_WriteI2CEncData2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, char * a5);
int32_t enable_prognum_proc(char * std_b25, unsigned char enable);
int64_t enable_prognum_proc2(int64_t a1, int64_t a2);
int32_t encrypt_multi2(char * m2, int32_t type, char * buf, int32_t size);
int64_t encrypt_multi2_(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void EncryptBlock(char * cipherkey, char * input, char * output, int64_t pTable);
int64_t EncryptBlock2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
char Erase_Customization_Data(char * DevExt, char DevCH, int64_t offset, int64_t bytesofpData, char * tuner_globe_data);
int64_t Erase_Customization_Data2(void);
void extract_ts_header(int64_t dst, char * src);
int64_t extract_ts_header2(int64_t * a1, int64_t a2);
void extract_ts_section_header(int64_t dst, char * src);
int64_t extract_ts_section_header2(int64_t a1, int64_t a2);
char FC0012_RSSI_Calibration(char * DevExt, char DevCH);
int64_t FC0012_RSSI_Calibration2(int64_t a1, uint64_t a2);
int32_t find_pmt(int64_t prv);
int64_t find_pmt2(int64_t a1);
int32_t findRingbufNumToDispatchByRuleTable(char dmaCH, char * p, int64_t table, int32_t tablesize);
int64_t findRingbufNumToDispatchByRuleTable2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t Fiti_LAN_Gain(char * DevExt, char * StartPolling, char total_tuner_num, char * tuner_globe_data);
int64_t Fiti_LAN_Gain2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t flush_arib_std_b25(char * std_b25);
int64_t flush_arib_std_b25_(int64_t a1);
int64_t FPCIEDTV_Cmd_I2CRead(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16ReadLen, char * pDataBuf, char slvMode);
int64_t FPCIEDTV_Cmd_I2CRead2(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int64_t a5, int64_t * a6);
int64_t FPCIEDTV_Cmd_I2CWrite(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16WriteLen, char * pDataBuf, char slvMode);
int64_t FPCIEDTV_Cmd_I2CWrite2(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int64_t a5, int64_t * a6);
int64_t free_irq(int64_t a1, int64_t a2);
int64_t function_10d5a(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8);
int64_t function_111b8(void);
int64_t function_119e3(void);
int64_t function_127a1(uint64_t a1, uint64_t a2, uint64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_150db(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_150ef(void);
int64_t function_155b2(void);
int64_t function_15f9f(int64_t a1, int64_t a2, int64_t a3);
int64_t function_1610d(int64_t a1, int64_t a2);
int64_t function_17881(void);
int64_t function_17afc(int64_t a1, int64_t a2, int64_t a3);
int64_t function_17bee(int64_t a1);
int64_t function_17fda(int64_t a1);
int64_t function_182f9(int64_t a1);
int64_t function_1830a(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_18311(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_1832b(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_18332(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_1834c(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1839f(void);
int64_t function_183b5(void);
int64_t function_183c9(void);
int64_t function_183cb(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_183db(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_18c6c(int64_t a1, int64_t a2);
int64_t function_191e2(int64_t a1, int64_t a2);
int64_t function_19497(void);
int64_t function_197c2(int64_t a1);
int64_t function_197df(void);
int64_t function_197e7(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_19bbd(void);
int64_t function_19bc0(void);
int64_t function_1c4b0(int64_t a1, int64_t a2);
int64_t function_1c5b5(int64_t a1);
int64_t function_1c5d3(int64_t a1, int64_t a2);
int64_t function_1c612(void);
int64_t function_1c643(void);
int64_t function_1c64c(void);
int64_t function_1c655(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_1cb83(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1cc32(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_1ccd3(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_1ce09(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1ce9e(int64_t a1);
int64_t function_1d246(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1d695(void);
int64_t function_1d8a(void);
int64_t function_1e8df(void);
int64_t function_1e8f7(void);
int64_t function_1e90c(void);
int64_t function_1e921(void);
int64_t function_1e936(void);
int64_t function_1ea52(void);
int64_t function_1f7f7(void);
int64_t function_2014d(void);
int64_t function_20dcd(void);
int64_t function_20dd6(void);
int64_t function_21a05(void);
int64_t function_22358(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_23c95(int64_t a1);
int64_t function_23fe8(void);
int64_t function_240ba(void);
int64_t function_240bd(int64_t a1);
int64_t function_24580(void);
int64_t function_245ed(void);
int64_t function_25336(void);
int64_t function_25679(void);
int64_t function_25944(int64_t a1, int64_t a2);
int64_t function_266d7(void);
int64_t function_26bd5(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_26c22(void);
int64_t function_26c96(void);
int64_t function_26c9c(void);
int64_t function_26ca6(int64_t a1, int64_t a2, int64_t a3);
int64_t function_26d2e(void);
int64_t function_26e53(void);
int64_t function_26e57(int64_t a1);
int64_t function_27abc(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_27f47(int64_t a1, int64_t a2);
int64_t function_28069(void);
int64_t function_283d3(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_28681(int64_t a1, int64_t a2);
int64_t function_2a749(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_2a7ad(int64_t a1, int64_t a2);
int64_t function_2a81e(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_2b2e5(void);
int64_t function_2b378(void);
int64_t function_3a39(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_4c00000118bec209(void);
int64_t function_533f(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_53b3(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_53e5(void);
int64_t function_53ff(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_6152(void);
int64_t function_633a(void);
int64_t function_633c(int64_t a1, int64_t a2);
int64_t function_6342(int64_t a1, int64_t a2);
int64_t function_634a(void);
int64_t function_634c(int64_t a1, int64_t a2);
int64_t function_6352(int64_t a1, int64_t a2);
int64_t function_66db(void);
int64_t function_6fa5(void);
int64_t function_83f7(void);
int64_t function_9669(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_9bbe(void);
int64_t function_9bc5(void);
int64_t function_9bcc(uint64_t a1, uint64_t a2, int64_t a3, uint64_t a4);
int64_t function_9c01(int64_t a1, int64_t a2, uint64_t a3, uint64_t a4);
int64_t function_ac03(void);
int64_t function_af70(void);
int64_t function_b27(int64_t a1);
int64_t function_b45(int64_t a1);
int64_t function_b63(int64_t a1);
int64_t function_b81(int64_t a1);
int64_t function_b9f(int64_t a1);
int64_t function_bbd(int64_t a1);
int64_t function_bdb(int64_t a1);
int64_t function_bf9(int64_t a1);
int64_t function_c17(int64_t a1);
int64_t function_c35(int64_t a1);
int64_t function_c53(int64_t a1);
int64_t function_c646(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_c71(int64_t a1);
int64_t function_c7d6(int64_t a1);
int64_t function_c8a05c8(void);
int64_t function_c8c(int64_t a1);
int64_t function_c8c0(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_ca7(int64_t a1);
int64_t function_cb2e(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_cb49(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_cc2(int64_t a1);
int64_t function_cd6a(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_eee5a94(void);
int64_t function_efbc(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_fa26(void);
int64_t function_fa2c(void);
int64_t function_ffffffff8a024063(void);
int64_t function_ffffffffc801ed24(void);
int64_t function_fffffffff3c9dcc7(void);
int64_t FUSB_CallUSBD(char * DeviceObject, char * Urb);
int64_t FUSB_ConfigureDevice(char * DeviceObject);
int64_t FUSB_CreateDeviceObject(char * DriverObject, char * PhysicalDeviceObject, char ** DeviceObject, char * DeviceExtensionForBDA, char bForBDA);
int64_t FUSB_CreateDeviceObject2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t * a5);
int64_t FUSB_DecrementIoCount(char * DeviceObject);
int64_t FUSB_DecrementIoCount2(int64_t a1);
char * FUSB_ExAllocatePool(char PoolType, int64_t NumberOfBytes);
int64_t FUSB_ExAllocatePool2(int64_t a1, int64_t a2);
void FUSB_ExFreePool(char * p);
int64_t FUSB_ExFreePool2(int32_t a1, int64_t a2);
void FUSB_IncrementIoCount(char * DeviceObject);
int64_t FUSB_IncrementIoCount2(int64_t a1);
int64_t FUSB_ProcessSysControlIrp(char * DeviceObject, char * Irp);
int64_t FUSB_ProcessSysControlIrp2(void);
int64_t FUSB_ResetPipe(char * DeviceObject, char * PipeInfo, char ClearStall);
int64_t FUSB_ResetPipe2(void);
void FUSB_RstBulkPipe(int64_t deviceExtension, char TunerNum);
int64_t FUSB_RstBulkPipe2(int64_t a1, int64_t a2);
int64_t FUSB_SelectInterface(char * DeviceObject, char * ConfigurationDescriptor);
void FUSB_Unload(char * DriverObject);
int64_t FUSB_Unload2(void);
int64_t FUSBDTV_Add(int64_t deviceExtension_input);
int64_t FUSBDTV_Add2(int64_t * a1);
int64_t FUSBDTV_AddUSBDevice(char * FunctionalDeviceObject, char * NextDeviceObject, char * PhysicalDeviceObject, int64_t deviceExtension);
int64_t FUSBDTV_AddUSBDevice2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int32_t FUSBDTV_BDAQueueProcessThread(char * Context);
int64_t FUSBDTV_BDAQueueProcessThread2(int64_t a1);
void FUSBDTV_BDAQueueProcessThreadClose(int64_t streamObject);
int64_t FUSBDTV_BDAQueueProcessThreadClose2(int64_t a1);
int32_t FUSBDTV_BDAQueueProcessThreadInit(int64_t streamObject);
int64_t FUSBDTV_BDAQueueProcessThreadInit2(int64_t a1);
int64_t FUSBDTV_BulkIrp_Complete(char * DeviceObject, char * Irp, char * Context);
int64_t FUSBDTV_Cmd_CFRead(int64_t deviceExtension, char CF_Num, char RegOffset, int16_t u16ReadLen, char * pDataBuf);
int64_t FUSBDTV_Cmd_CFWrite(int64_t deviceExtension, char CF_Num, char RegOffset, int16_t u16WriteLen, char * pDataBuf);
int64_t FUSBDTV_Cmd_EncRead(int64_t deviceExtension, char CF_Num, char RegOffset, int16_t u16ReadLen, char * pDataBuf);
int64_t FUSBDTV_Cmd_EncWrite(int64_t deviceExtension, char CF_Num, char RegOffset, int16_t u16WriteLen, char * pDataBuf);
int64_t FUSBDTV_Cmd_Get_DevRandomKey(int64_t deviceExtension);
int64_t FUSBDTV_Cmd_Get_DevRandomKey2(int64_t a1);
int64_t FUSBDTV_Cmd_Get_GPIO(int64_t deviceExtension, char * GPIO_Value);
int64_t FUSBDTV_Cmd_Get_GPIO2(int64_t a1, int64_t a2);
int64_t FUSBDTV_Cmd_Get_GPIO_Ex(int64_t deviceExtension, char * GPIO_Value);
int64_t FUSBDTV_Cmd_Get_GPIO_Ex2(int64_t a1, int64_t a2);
int64_t FUSBDTV_Cmd_GetCusInfo(int64_t deviceExtension, char * pDataBuf);
int64_t FUSBDTV_Cmd_GetCusInfo2(int64_t a1, int64_t a2);
int64_t FUSBDTV_Cmd_GetDev_Speed(int64_t deviceExtension, char * bHighSpeed);
int64_t FUSBDTV_Cmd_I2CBufFill(int64_t deviceExtension, char u8BufOffset, int16_t u16WriteLen, char * pDataBuf);
int64_t FUSBDTV_Cmd_I2CBufSend(int64_t deviceExtension, char Slave_Addr, int16_t u16WriteLen, char NoSendStopByte);
int64_t FUSBDTV_Cmd_I2CRead(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16ReadLen, char * pDataBuf, char byI2CFlag);
int64_t FUSBDTV_Cmd_I2CRead_NoWt(int64_t deviceExtension, char Slave_Addr, int16_t u16ReadLen, char * pDataBuf);
int64_t FUSBDTV_Cmd_I2CReadEnc(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16ReadLen, char * pDataBuf, char byI2CFlag);
int64_t FUSBDTV_Cmd_I2CReadEnc2(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int64_t a5);
int64_t FUSBDTV_Cmd_I2CWrite(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16WriteLen, char * pDataBuf);
int64_t FUSBDTV_Cmd_I2CWrite_noStop(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16WriteLen, char * pDataBuf);
int64_t FUSBDTV_Cmd_I2CWriteEnc(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16WriteLen, char * pDataBuf);
int64_t FUSBDTV_Cmd_I2CWriteEnc2(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int64_t a5);
int64_t FUSBDTV_Cmd_MPU_I2CRead(int64_t DeviceObject, char mpu_slave_address, char target_slave_address, char RegOffset, char data_length, char * pDataBuf, char withRSA);
int64_t FUSBDTV_Cmd_MPU_I2CRead2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, uint64_t a5, int64_t a6, int64_t a7);
int64_t FUSBDTV_Cmd_MPU_I2CWrite(int64_t DeviceObject, char mpu_slave_address, char target_slave_address, char RegOffset, char data_length, char * pDataBuf, char withRSA);
int64_t FUSBDTV_Cmd_MPU_I2CWrite2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7);
int64_t FUSBDTV_Cmd_ReadIR(int64_t deviceExtension, char * pDataBuf);
int64_t FUSBDTV_Cmd_RePlugInDevice(int64_t DeviceObject, char wait_time);
int64_t FUSBDTV_Cmd_RePlugInDevice2(void);
int64_t FUSBDTV_Cmd_Reset_Channel(int64_t deviceExtension, char Channel_Num, char bSerial);
int64_t FUSBDTV_Cmd_Rst_Enc(int64_t deviceExtension);
int64_t FUSBDTV_Cmd_Set_GPIO(int64_t deviceExtension, char GPIO_Value, char GPIO_Mask);
int64_t FUSBDTV_Cmd_Set_GPIO2(int64_t a1, int64_t * a2, int64_t a3);
int64_t FUSBDTV_Cmd_Set_GPIO_Ex(int64_t deviceExtension, char GPIO_Value, char GPIO_Mask);
int64_t FUSBDTV_Cmd_Set_GPIO_Ex2(int64_t a1, int64_t a2, int64_t * a3);
int64_t FUSBDTV_Cmd_Set_RandomKey(int64_t deviceExtension, char I2C_Addr);
int64_t FUSBDTV_Cmd_SetIRMode(int64_t deviceExtension, char ModeSel);
int64_t FUSBDTV_Cmd_Simulation_Enable(int64_t deviceExtension, char u8Enable);
int64_t FUSBDTV_Cmd_StartDSC(int64_t deviceExtension, char DSC_Num);
int64_t FUSBDTV_Cmd_StopDSC(int64_t deviceExtension, char DSC_Num);
int64_t FUSBDTV_Cmd_SysCtrlRead(int64_t deviceExtension, char RegOffset, int16_t u16ReadLen, char * pDataBuf);
int64_t FUSBDTV_Cmd_SysCtrlRead2(int64_t a1, int64_t * a2, int64_t * a3, int64_t * a4);
int64_t FUSBDTV_Cmd_SysCtrlWrite(int64_t deviceExtension, char RegOffset, int16_t u16WriteLen, char * pDataBuf);
int64_t FUSBDTV_Cmd_T_confirm(int64_t deviceExtension, char ChannelNum);
int64_t FUSBDTV_Cmd_TimerStartStop(int64_t deviceExtension, char ChannelNum, char bStart);
int64_t FUSBDTV_Cmd_WriteEncReg(int64_t deviceExtension, char RegOffset, char RegData);
int64_t FUSBDTV_DecrementIoCount(int64_t deviceExtension);
int64_t FUSBDTV_DecrementIoCount2(void);
int64_t FUSBDTV_GetCusGUIDInfo(int64_t deviceExtension);
int64_t FUSBDTV_GetCusGUIDInfo2(int64_t a1);
void FUSBDTV_IncrementIoCount(int64_t deviceExtension);
int64_t FUSBDTV_IncrementIoCount2(void);
int64_t FUSBDTV_InitializeStreamUrb(int64_t TransferObject);
int64_t FUSBDTV_InitializeStreamUrb2(void);
int64_t FUSBDTV_InitializeStreamUrb_ISR(int64_t TransferObject);
int64_t FUSBDTV_InitializeStreamUrb_ISR2(void);
int64_t FUSBDTV_ProcessSysControlIrp(char * DeviceObject, char * Irp);
int64_t FUSBDTV_ProcessTransfer(int64_t TransferObject);
int64_t FUSBDTV_Query_Capabilities(int64_t Device, char * Irp, char * Capabilities);
int64_t FUSBDTV_Query_Capabilities2(void);
void FUSBDTV_Remove(int64_t deviceExtension);
int64_t FUSBDTV_Remove2(int64_t a1);
int64_t FUSBDTV_RemoveUSBDevice(int64_t deviceExtension);
int64_t FUSBDTV_RemoveUSBDevice2(int64_t a1);
int64_t FUSBDTV_ResetParentPort(char * DeviceObject);
int64_t FUSBDTV_SendTVCmd(int64_t deviceExtension, char * pCxOut5bytes, char * pCxInData, int16_t CxInLen, int16_t TimeOUT);
int64_t FUSBDTV_SendTVCmd_Ex(int64_t deviceExtension, char * pCxOut5bytes, char * pCxInData, int16_t CxInLen, char CxDirect, int16_t TimeOUT);
int64_t FUSBDTV_SendTVCmd_Ex2(void);
void FUSBDTV_SetFakeDeviceObj(char * FunctionalDeviceObject, int64_t deviceExtension, char * FakeDeviceObject);
int64_t FUSBDTV_SetFakeDeviceObj2(int64_t result, int64_t a2, int64_t a3);
int64_t FUSBDTV_SetPowerUSBDevice(char * Irp, char * FunctionalDeviceObject, int64_t deviceExtension);
int64_t FUSBDTV_SetPowerUSBDevice2(void);
int64_t FUSBDTV_Start(int64_t deviceExtension);
int64_t FUSBDTV_Start2(int64_t a1);
int64_t FUSBDTV_StartBulkStream(int64_t deviceExtension, char DataStream_Num, int64_t TransferObjBufSize, int64_t StreamBufSize, char * Contex);
int64_t FUSBDTV_StartBulkStream2(int64_t a1, int64_t a2, uint64_t a3, uint64_t a4, int64_t a5);
int64_t FUSBDTV_StartTransfer(int64_t deviceExtension, int64_t StreamObject, int64_t TransferObjBufSize, int64_t Index);
int64_t FUSBDTV_StartTransfer2(int64_t a1, int64_t a2);
int64_t FUSBDTV_StartUSBDevice(char * FunctionalDeviceObject, int64_t deviceExtension);
int64_t FUSBDTV_StartUSBDevice2(int64_t a1, int64_t a2);
void FUSBDTV_Stop(int64_t deviceExtension);
int64_t FUSBDTV_Stop2(int64_t a1);
int64_t FUSBDTV_StopBulkStream(int64_t deviceExtension, char DataStream_Num);
int64_t FUSBDTV_StopBulkStream2(int64_t a1, uint64_t a2);
int64_t FUSBDTV_StopUSBDevice(int64_t deviceExtension);
int64_t FUSBDTV_StopUSBDevice2(int64_t a1);
int32_t FUSBDTV_Wait(int64_t dwMilliseconds);
int64_t FUSBDTV_Wait2(int64_t * a1);
void Gen_Identify_Key(char * OutputKey, char * InputKey, char * RandomKey);
int64_t Gen_Identify_Key2(int64_t a1, int64_t a2);
int32_t Gen_Identify_Key_01(char * OutputKey, char * InputKey, char * RandomKey);
int64_t Gen_Identify_Key_01_(int64_t a1, int64_t a2, int64_t a3);
void GenEncCmd(char bIndex, char * pData, char DataLen, char * u8DevRandomKey);
int64_t GenEncCmd2(int64_t a1, int64_t a2, int64_t a3);
int32_t GenerateCertificateKey(char * indata, char * outdata);
int64_t GenerateCertificateKey2(void);
int32_t get_arib_std_b25(char * std_b25, int64_t buf);
int64_t get_arib_std_b25_(int64_t a1, int64_t a2);
int64_t get_b_cas_card_arib_std_b25(char * std_b25);
int64_t get_b_cas_card_arib_std_b25_(void);
char Get_BCAS_INFO(int64_t BCAS_Dev);
int64_t Get_BCAS_INFO2(int64_t a1);
char Get_CARD_INFO(char * PDev, char * PTuner, char * Status, char * size, char * buffer, int64_t BufferSz);
int64_t Get_CARD_INFO2(int64_t a1, int64_t a2, int64_t a3, int64_t result, int64_t a5);
int32_t get_ContentAvailabilityDescriptor(char * std_b25, int16_t pid, char * databuffer);
int64_t get_ContentAvailabilityDescriptor2(int64_t a1, int64_t a2, int64_t a3);
char Get_Customization_Data_Size(char * DevExt, char DevCH, int64_t * customization_data_size, char * tuner_globe_data);
int64_t Get_Customization_Data_Size2(void);
int32_t get_DigitalCopyControlDescriptor(char * std_b25, int16_t pid, char * databuffer);
int64_t get_DigitalCopyControlDescriptor2(int64_t a1, int64_t a2, int64_t a3);
int32_t get_init_status_b_cas_card(char * bcas, int64_t stat);
int64_t get_init_status_b_cas_card2(int64_t a1, int64_t a2);
int32_t get_is_streamscramble(char * std_b25, char * isScramble);
int64_t get_is_streamscramble2(int64_t a1, int64_t a2);
int32_t get_prognum(char * std_b25, char index, int16_t * prognum);
int64_t get_prognum2(void);
int32_t get_prognum_ex(char * std_b25, char * prognum);
int64_t get_prognum_ex2(int64_t a1, int64_t a2);
int32_t get_ProgramNumberByPid(char * std_b25, int16_t pid, int32_t * program_number);
int64_t get_ProgramNumberByPid2(int64_t a1, int64_t a2, int64_t a3);
int32_t get_reset_multi2_lib_flag(char * std_b25, char * isNeedResetMulti2Lib);
int64_t get_reset_multi2_lib_flag2(int64_t a1, int64_t a2);
char Get_Tuner_Extra_Data_Size(int64_t * tuner_Extra_Data_Size);
int64_t Get_Tuner_Extra_Data_Size2(int64_t * a1);
void Get_Unique_ID(int64_t pTuner, char * ID);
int64_t Get_Unique_ID2(int64_t a1, int64_t a2);
void GetDeviceUniqueString(int64_t deviceExtension, char * buf, int32_t * len);
int64_t GetDeviceUniqueString2(int64_t a1, int64_t str, int64_t a3);
int64_t GetISDBTAGC(char * DevExt, char DevCH, int64_t ptuner_globe_data);
int64_t GetISDBTAGC2(void);
int64_t GetISDBTBER(char * DevExt, char DevCH, int64_t * BER1, int64_t * BER2, int64_t ptuner_globe_data);
int64_t GetISDBTBER2(int64_t a1, uint64_t a2, int64_t a3, int64_t a4);
int64_t GetISDBTCN(char * DevExt, char DevCH, int64_t ptuner_globe_data);
int64_t GetISDBTCN2(int64_t a1, uint64_t a2);
int64_t GetISDBTCNRegister(char * DevExt, char DevCH, int64_t ptuner_globe_data);
int64_t GetISDBTCNRegister2(int64_t a1, int64_t a2);
char GetISDBTEmergencyAlarmStatus(char * DevExt, char DevCH, int64_t ptuner_globe_data);
int64_t GetPCIBusInterfaceStandard(char * DeviceObject, char * BusInterfaceStandard);
int64_t GetPCIBusInterfaceStandard2(int64_t a1, int64_t a2);
int64_t GetSatelliteAGC(char * DevExt, char DevCH, int64_t ptuner_globe_data);
int64_t GetSatelliteAGC2(void);
int64_t GetSatelliteBER(char * DevExt, char DevCH, int64_t * BER1, int64_t * BER2, int64_t ptuner_globe_data);
int64_t GetSatelliteBER2(int64_t a1, uint64_t a2, int64_t a3, int64_t a4);
int64_t GetSatelliteCN(char * DevExt, char DevCH, int64_t ptuner_globe_data);
int64_t GetSatelliteCN2(int64_t a1, uint64_t a2);
int64_t GetSatelliteCNRegister(char * DevExt, char DevCH, int64_t ptuner_globe_data);
int64_t GetSatelliteCNRegister2(int64_t a1, int64_t a2);
char GetSatelliteEmergencyAlarmStatus(char * DevExt, char DevCH, int64_t ptuner_globe_data);
int64_t Hardware_GetSignalLock(int64_t device);
int64_t Hardware_GetSignalLock2(void);
int64_t Hardware_GetSignalQuality(int64_t device);
int64_t Hardware_GetSignalStrength(int64_t device);
int64_t Hardware_Init(int64_t device);
int64_t Hardware_Init2(int64_t a1);
char Hardware_PowerDown(int64_t device);
int64_t Hardware_PowerDown2(int64_t a1);
char Hardware_PowerUp(int64_t device);
int64_t Hardware_PowerUp2(int64_t a1);
void Hardware_RemoveDevice(int64_t device);
int64_t Hardware_RemoveDevice2(void);
int64_t Hardware_StartTSStream(int64_t device, char tuner_number);
int64_t Hardware_StartTSStream2(int64_t a1, unsigned char a2);
int64_t Hardware_StartTSStream_Force(int64_t device, char tuner_number);
int64_t Hardware_StartTSStream_Force2(int64_t a1, uint64_t a2);
void Hardware_Stop(int64_t device);
int64_t Hardware_Stop2(void);
void Hardware_StopTSStream(int64_t device, char tuner_number);
int64_t Hardware_StopTSStream2(int64_t a1, uint64_t a2);
void Hardware_StopTSStream_Force(int64_t device, char tuner_number);
int64_t Hardware_StopTSStream_Force2(int64_t a1, uint64_t a2);
char Hardware_SubmitDemod(int64_t device);
char Hardware_SubmitTuner(int64_t device);
char HwSoftReset(int64_t device, int64_t ulTime);
int64_t HwSoftReset2(int64_t a1, int64_t * a2);
int64_t i2c_1_read_mode1(int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * readData, int64_t length, char byteCnt, char retryCnt);
int64_t i2c_1_read_mode1_(int64_t a1, uint64_t a2, int64_t * a3, uint64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8);
int64_t i2c_2_read_mode1(int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * readData, int64_t length, char byteCnt, char retryCnt);
int64_t i2c_2_read_mode1_(int64_t a1, uint64_t a2, int64_t * a3, uint64_t a4, int64_t a5, int64_t a6, int64_t a7, uint64_t a8);
int64_t i2c_access(int16_t channel, char bIsRead, int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * Data, int64_t length, char byteCnt, char retryCnt);
int64_t i2c_access2(int64_t * a1, int64_t a2, int64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int64_t * a7, int64_t a8, uint64_t a9, uint32_t a10);
char I2C_PortingLayer_Read(char * pDeviceExtension, char I2CDeviceAddress, char * pWriteBuffer, int16_t WriteBufferLength, char * pReadBuffer, int16_t ReadBufferLength);
int64_t I2C_PortingLayer_Read2(int64_t a1, uint64_t a2, char * a3, int64_t * a4, char * a5, int64_t * a6);
char I2C_PortingLayer_Write(char * pDeviceExtension, char I2CDeviceAddress, char * pWriteBuffer, int16_t WriteBufferLength);
int64_t I2C_PortingLayer_Write2(int64_t a1, uint64_t a2, int64_t a3, int64_t a4);
int64_t i2c_read(int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * readData, int64_t length, char byteCnt, char retryCnt);
int64_t i2c_read2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t * a5, int64_t a6, int64_t a7, int32_t a8);
int64_t i2c_read_2(int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * readData, int64_t length, char byteCnt, char retryCnt);
int64_t i2c_read_2_(int64_t a1, int64_t a2, int64_t * a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8);
void i2c_soft_reset(int64_t pFdoData);
int64_t i2c_soft_reset2(int64_t a1);
void i2c_soft_reset_2(int64_t pFdoData);
int64_t i2c_soft_reset_2_(int64_t a1);
int64_t i2c_write(int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * writeData, int64_t length, char byteCnt, char retryCnt);
int64_t i2c_write2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t * a5, int64_t a6, int64_t a7, int32_t a8);
int64_t i2c_write_2(int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * writeData, int64_t length, char byteCnt, char retryCnt);
int64_t i2c_write_2_(int64_t a1, int64_t a2, int64_t * a3, int64_t a4, char * a5, int64_t * a6, int64_t * a7, int64_t a8);
int32_t iGetDMAStreamData(int64_t deviceExtension, char DataStream_Num, char * pu8OutPutBuf, int64_t GetLen);
int64_t iGetDMAStreamData2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t iGetStreamData(int64_t deviceExtension, char DataStream_Num, char * pu8OutPutBuf, int64_t GetLen);
int64_t iGetStreamData2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t init_b_cas_card(char * bcas);
int64_t init_b_cas_card2(int64_t a1);
int64_t init_module(void);
char Init_Tuner_S(char * DevExt, char DevCH);
int64_t Init_Tuner_S2(int64_t a1, int64_t a2);
char Init_Tuner_T(char * handle, char DevCH);
int64_t Init_Tuner_T2(int64_t a1, uint64_t a2);
char InitDemod(char * DevExt, unsigned char DevCH, char * tuner_globe_data);
int64_t InitDemod2(int64_t a1, uint64_t a2, int64_t a3);
char InitializeDeviceInformation(int64_t pDevExt);
char InitializeDeviceLNBPowerRegistry(int64_t pDevExt);
int64_t InitializeDeviceLNBPowerRegistry2(int64_t a1);
char InitializeLNASetting(int64_t pDevExt);
int64_t InitializeLNASetting2(void);
char InitializeLNAStatus(int64_t pDevExt);
int64_t InitializeLNAStatus2(void);
char InitRFDevice(char * DevExt, char DevCH, char * tuner_globe_data);
int64_t InitRFDevice2(int64_t a1, uint64_t a2, int64_t a3);
char InitSlowDownIC(int64_t pTnim);
int64_t InitSlowDownIC2(int64_t a1);
char IsBigger(int64_t ulValMSB, int64_t ulValLSB, int64_t ulWithMSB, int64_t ulWithLSB);
int64_t IsBigger2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4);
char Japan4x4Tuner_TunerCheckLockStatus(int64_t TunerDeviceID, char * pLock, char * pDeviceExtension);
int64_t Japan4x4Tuner_TunerCheckLockStatus2(unsigned char a1, int64_t a2, int64_t a3);
char Japan4x4Tuner_TunerGetCN(int64_t TunerDeviceID, int64_t * pCnValue, char * pDeviceExtension);
int64_t Japan4x4Tuner_TunerGetCN2(unsigned char a1, int64_t a2, int64_t a3);
char Japan4x4Tuner_TunerGetQuality(int64_t TunerDeviceID, char * pQuality, char * pDeviceExtension);
int64_t Japan4x4Tuner_TunerGetQuality2(unsigned char a1, int64_t a2, int64_t a3);
char Japan4x4Tuner_TunerGetStrength(int64_t TunerDeviceID, char * pStrength, char * pDeviceExtension);
int64_t Japan4x4Tuner_TunerGetStrength2(unsigned char a1, int64_t a2, int64_t a3);
char Japan4x4Tuner_TunerGetTSID(int64_t TunerDeviceID, int16_t * TSID, char * pDeviceExtension);
int64_t Japan4x4Tuner_TunerGetTSID2(unsigned char a1, int64_t * a2, int64_t a3);
char Japan4x4Tuner_TunerInitialization(int64_t TunerDeviceID, char * pDeviceExtension);
int64_t Japan4x4Tuner_TunerInitialization2(uint64_t a1, int64_t a2);
char Japan4x4Tuner_TunerSetFrequency(int64_t TunerDeviceID, int64_t RF, char * pDeviceExtension);
int64_t Japan4x4Tuner_TunerSetFrequency2(char a1, int64_t a2, int64_t a3);
char Japan4x4Tuner_TunerSetTSID(int64_t TunerDeviceID, int16_t TSID, char * pDeviceExtension);
int64_t Japan4x4Tuner_TunerSetTSID2(unsigned char a1, uint64_t a2, int64_t result);
int64_t kfree(int64_t a1);
int64_t kmem_cache_alloc_notrace(int64_t a1, int64_t * a2);
int64_t kthread_create(int64_t a1, int64_t a2, int64_t a3);
int64_t kthread_should_stop(void);
int64_t kthread_stop(int64_t a1);
void LeftShift(int64_t * ulNumMSB, int64_t * ulNumLSB);
int64_t LeftShift2(int64_t a1, uint64_t a2);
int32_t load_be_uint16(char * p);
int64_t load_be_uint16_(int64_t a1);
int32_t makeKey(int64_t key, char direction, int32_t keyLen, char * keyMaterial, int64_t pTable);
int64_t makeKey2(int64_t * a1, int64_t a2, int64_t a3, int64_t * str, int64_t a5);
int64_t mcount(void);
int64_t memcpy(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t memset(int64_t a1, int64_t a2, int64_t a3);
int64_t mpu_i2c_read(int64_t DeviceObject, char mpu_slave_address, char target_slave_address, char RegOffset, char data_length, char * pDataBuf);
int64_t mpu_i2c_read2(int64_t a1, unsigned char a2, char a3, char a4, uint32_t a5, int64_t a6);
int64_t mpu_i2c_write(int64_t DeviceObject, char mpu_slave_address, char target_slave_address, char RegOffset, char data_length, char * pDataBuf);
int64_t mpu_i2c_write2(int64_t a1, unsigned char a2, char a3, char a4, uint32_t a5, int64_t a6);
int64_t msleep_interruptible(void);
void Mult(int64_t ulOp1, int64_t ulOp2, int64_t * pulResMSB, int64_t * pulResLSB);
int64_t Mult2(int64_t a1, int64_t a2, int64_t * a3, int64_t * a4, int64_t * a5);
int64_t mutex_lock(int64_t a1);
int64_t mutex_unlock(int64_t a1);
char myAnsiToUnicodeString(char * buf, int32_t len, int16_t * wbuf, int32_t * wlen);
int64_t myAnsiToUnicodeString2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void nm120_nolock_reset(int64_t pPrivate);
int64_t nm120_nolock_reset2(int64_t a1);
void nm120_rfli_ctrl(int64_t pPrivate, char enable);
int64_t nm120_rfli_ctrl2(uint64_t a1, int64_t a2);
void nm120_rfli_track(int64_t pPrivate, int64_t p);
int64_t nm120_rfli_track2(int64_t a1, int64_t a2);
int16_t nm131_adec_get_rssi(int64_t pPrivate);
int64_t nm131_adec_get_rssi2(int64_t a1);
int32_t nm131_chip_init(int64_t pPrivate);
int64_t nm131_chip_init2(int64_t a1);
void nm131_demod_config(int64_t pPrivate, int64_t tune, int32_t clk_off_f, int32_t tuneMode);
int64_t nm131_demod_config2(int64_t a1, int64_t a2, uint32_t a3, int32_t a4);
int64_t nm131_demod_dagc_gain(int64_t pPrivate);
int64_t nm131_demod_dagc_gain2(int64_t a1);
char nm131_demod_get_agc_lock(int64_t pPrivate);
int64_t nm131_demod_get_agc_lock2(int64_t a1);
char nm131_demod_get_cpll_lock(int64_t pPrivate);
int64_t nm131_demod_get_cpll_lock2(int64_t a1);
int32_t nm131_demod_get_freq_offset(int64_t pPrivate);
int16_t nm131_demod_get_pll_level(int64_t pPrivate);
int64_t nm131_demod_get_pll_level2(int64_t a1);
int16_t nm131_demod_get_snr(int64_t pPrivate);
int64_t nm131_demod_get_snr2(int64_t a1);
void nm131_demod_get_status(int64_t pPrivate, int64_t p);
int64_t nm131_demod_get_status2(int64_t a1, int64_t a2);
void nm131_demod_soft_reset(int64_t pPrivate);
int64_t nm131_demod_soft_reset2(int64_t a1);
void nm131_fm_get_window_rssi(int32_t * orssi, int32_t len, int32_t * wrssi, int32_t * overth);
int64_t nm131_fm_get_window_rssi2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void nm131_fm_overmod(int64_t pPrivate, char fmovermod);
int64_t nm131_fm_overmod2(uint64_t a1, int64_t a2);
void nm131_fm_scan(int64_t pPrivate, int64_t p);
int64_t nm131_fm_scan2(int64_t a1, int64_t a2);
int32_t nm131_fm_seek_select(int32_t * rssi, int32_t * overth, int32_t sz);
int64_t nm131_fm_seek_select2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
void nm131_fm_select_channel_list(int64_t pPrivate, int32_t * orssi, int32_t * wrssi, int32_t * clist, int32_t * nc, int32_t cmax, int32_t clen, int32_t * overth);
int64_t nm131_fm_select_channel_list2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, uint32_t result);
void nm131_fm_set_scan_level(int64_t pPrivate, int32_t level);
int64_t nm131_fm_set_scan_level2(int64_t a1, int64_t a2);
char nm131_get_brightness(int64_t pPrivate);
int64_t nm131_get_brightness2(void);
int32_t nm131_get_chipid(int64_t pPrivate);
int64_t nm131_get_chipid2(int64_t a1);
void nm131_get_lna_gain(int64_t pPrivate, int64_t pg);
int64_t nm131_get_lna_gain2(int64_t a1, int64_t * a2);
char nm131_get_mute(int64_t pPrivate);
int64_t nm131_get_mute2(void);
int32_t nm131_get_overthcount(int64_t pPrivate);
int64_t nm131_get_overthcount2(int64_t a1);
char nm131_get_video_amplitude(int64_t pPrivate);
int64_t nm131_get_video_amplitude2(void);
char nm131_get_volume(int64_t pPrivate);
int64_t nm131_get_volume2(int64_t a1);
void nm131_invert_spectum(int64_t pPrivate, int32_t invert);
int64_t nm131_invert_spectum2(int64_t a1, int64_t a2);
void nm131_lt_ctrl(int64_t pPrivate, char enable);
int64_t nm131_lt_ctrl2(int64_t a1, int64_t a2);
void nm131_notch_ctl(int64_t pPrivate, int32_t en, int32_t width);
int64_t nm131_notch_ctl2(int64_t a1, int64_t a2, int64_t a3);
void nm131_notch_set(int64_t pPrivate, int32_t en, uint32_t frequency, int32_t width);
int64_t nm131_notch_set2(void);
void nm131_notch_spur(int64_t pPrivate);
int64_t nm131_notch_spur2(int64_t a1);
void nm131_scan(int64_t pPrivate, int64_t p);
int64_t nm131_scan2(int64_t a1, int64_t * a2);
void nm131_set_brightness(int64_t pPrivate, char brightness);
int64_t nm131_set_brightness2(int64_t a1, int64_t a2);
void nm131_set_lna_gain(int64_t pPrivate, int32_t g);
void nm131_set_lna_gain2(int64_t pPrivate, char g);
int64_t nm131_set_lna_gain2_(int64_t a1, char a2);
int64_t nm131_set_lna_gain3(int64_t a1, int64_t a2);
void nm131_set_mute(int64_t pPrivate, char mute);
int64_t nm131_set_mute2(int64_t a1, int64_t a2);
void nm131_set_scan_level(int64_t pPrivate, int32_t level);
int64_t nm131_set_scan_level2(int64_t a1, int64_t * a2);
void nm131_set_video_amplitude(int64_t pPrivate, char amp);
int64_t nm131_set_video_amplitude2(uint64_t a1, uint64_t a2);
void nm131_set_volume(int64_t pPrivate, char vol);
int64_t nm131_set_volume2(uint64_t a1, int64_t a2);
void nm131_software_sleep(int64_t pPrivate);
int64_t nm131_software_sleep2(int64_t a1);
void nm131_software_sleep_lt(int64_t pPrivate);
int64_t nm131_software_sleep_lt2(int64_t a1);
void nm131_software_wake_up_lt(int64_t pPrivate);
int64_t nm131_software_wake_up_lt2(int64_t a1);
int32_t nm131_tune(int64_t pPrivate, int64_t tune);
int64_t nm131_tune2(uint64_t a1, int64_t a2);
void nm131_tune_internal(int64_t pPrivate, int64_t tune, int32_t tuneMode);
int64_t nm131_tune_internal2(int64_t a1, int64_t a2, int64_t * a3);
void NMI131_Delay(int32_t delay_ms);
int64_t NMI131_Delay2(void);
int32_t NMI131_GetReadBlockSize(void);
int64_t NMI131_GetReadBlockSize2(void);
int64_t NMI131_GetTime(void);
int64_t NMI131_GetTime2(void);
int32_t NMI131_GetWriteBlockSize(void);
int64_t NMI131_GetWriteBlockSize2(void);
char NMI131_Initialization(char * pDeviceExtension, int64_t TunerDeviceID);
int64_t NMI131_Initialization2(int64_t a1, uint64_t a2);
void NMI131_Log(char * pString);
int64_t NMI131_Log2(void);
char NMI131_ReadRegister(char * pUserData, char i2cAdr, char * rb, int32_t sz);
int64_t NMI131_ReadRegister2(int64_t a1, int64_t a2, int64_t a3);
char NMI131_TunerSetFrequency(char * pDeviceExtension, int64_t TunerDeviceID, int64_t RF);
int64_t NMI131_TunerSetFrequency2(int64_t a1, uint64_t a2, int64_t a3);
char NMI131_WriteRegister(char * pUserData, char i2cAdr, char * wb, int32_t sz);
int64_t NMI131_WriteRegister2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void nmi_common_init(int64_t pPrivate, int64_t inp, int64_t ptv);
int64_t nmi_common_init2(int64_t a1, int64_t a2, int64_t a3);
void nmi_debug(int64_t pPrivate, int32_t zone, char * fmt, ...);
int64_t nmi_debug2(int64_t a1, int64_t * a2, int64_t format, int128_t a4, int64_t a5, int64_t a6);
void nmi_delay(int64_t pPrivate, int32_t msec);
int64_t nmi_delay2(int64_t a1, int64_t * a2);
int32_t nmi_get_tick(int64_t pPrivate);
int64_t nmi_get_tick2(int64_t a1);
int16_t nmi_log10(int64_t x);
int64_t nmi_log10_(uint64_t a1);
char NT_SUCCESS(char success_value);
int64_t NT_SUCCESS2(int64_t a1);
int64_t pci_bus_read_config_word(int64_t a1, int32_t a2, int64_t * a3, int64_t * a4);
int64_t pci_choose_state(int64_t a1, int64_t a2);
int64_t pci_disable_device(int64_t a1);
int64_t pci_enable_device(int64_t a1);
int64_t pci_iomap(int64_t a1, int64_t a2, int64_t a3);
int64_t pci_iounmap(int64_t a1, int64_t a2);
int64_t pci_release_regions(int64_t a1);
int64_t pci_request_regions(int64_t a1, int64_t a2);
int64_t pci_restore_state(int64_t a1);
int64_t pci_save_state(void);
int64_t pci_set_dma_mask(int64_t a1, int64_t a2);
int64_t pci_set_master(int64_t a1);
int64_t pci_set_power_state(int64_t a1, int64_t a2);
int64_t pci_unregister_driver(int64_t a1);
int64_t printk(int64_t a1);
int64_t private_data(char * m2);
int64_t private_data2(int64_t a1);
int64_t private_data3(char * std_b25);
int64_t private_data4(int64_t result);
int64_t private_data5(char * bcas);
int64_t private_data6(void);
int32_t proc_arib_std_b25(int64_t prv, char * std_b25);
int64_t proc_arib_std_b25_(int64_t a1);
int32_t proc_cat(int64_t prv);
int64_t proc_cat2(int64_t a1);
int32_t proc_ecm(int64_t pgrm, int64_t bcas);
int64_t proc_ecm2(int64_t a1, int64_t a2);
int32_t proc_ecm_b_cas_card(char * bcas, int64_t dst, char * src, int32_t len);
int64_t proc_ecm_b_cas_card2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t proc_eit(int64_t prv);
int64_t proc_eit2(int64_t a1, int64_t a2, int64_t a3);
int32_t proc_emm(int64_t prv);
int64_t proc_emm2(int64_t a1);
int32_t proc_emm_b_cas_card(char * bcas, char * src, int32_t len);
int64_t proc_emm_b_cas_card2(int64_t a1, int64_t a2, int64_t a3);
int32_t proc_pat(int64_t prv);
int64_t proc_pat2(int64_t a1);
int32_t proc_pmt(int64_t pgrm);
int64_t proc_pmt2(int32_t a1);
int32_t proc_sdt(int64_t prv);
int64_t proc_sdt2(int64_t a1, int64_t a2, int64_t a3);
int32_t put_arib_std_b25(char * std_b25, int64_t buf);
int64_t put_arib_std_b25_(int64_t a1, int64_t a2);
void PutTsPacketToOutputPin(int64_t Adapter);
int64_t PutTsPacketToOutputPin2(void);
char ReAcqDemod(char * DevExt, char DevCH, int32_t src);
int64_t ReAcqDemod2(int64_t a1, uint64_t a2, int64_t a3);
char ReadSlowdownICVersion(int64_t pTuner, char * SlowdownICVersion);
int64_t ReadSlowdownICVersion2(int64_t a1, int64_t a2);
char ReadWrite_Customization_Data(char * DevExt, char DevCH, char bRead, int64_t offset, char * DataBuf, int64_t bytesofpData, char * tuner_globe_data);
int64_t ReadWrite_Customization_Data2(void);
int64_t RegisterInitialize(int64_t hDEV);
int64_t RegisterInitialize2(int64_t a1);
void release_arib_std_b25(char * std_b25);
int64_t release_arib_std_b25_(void);
void release_b_cas_card(char * bcas);
int64_t release_b_cas_card2(void);
void release_multi2(char * m2);
int64_t release_multi2_(void);
void release_program(int64_t pgrm);
int64_t release_program2(int64_t a1);
void release_ts_section(int64_t sect);
int64_t release_ts_section2(int64_t a1);
void release_work_buffer(int64_t buf);
int64_t release_work_buffer2(int64_t a1);
int64_t request_threaded_irq(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int32_t reserve_work_buffer(int64_t buf, int32_t size);
int64_t reserve_work_buffer2(int64_t a1, int32_t a2);
int32_t reset_arib_std_b25(char * std_b25);
int64_t reset_arib_std_b25_(void);
void reset_ts_section(uint64_t sect);
int64_t reset_ts_section2(int64_t result);
char * resync(char * head, char * tail, int32_t unit_size);
int64_t resync2(int64_t result, int64_t a2, int32_t a3);
void rijndaelDecryptRound(int32_t * rk, int32_t Nr, char * block, int32_t rounds, int64_t pTable);
int64_t rijndaelDecryptRound2(int64_t a1, int32_t a2, int64_t * a3, int64_t a4, int64_t a5);
void rijndaelEncryptRound(int32_t * rk, int32_t Nr, char * block, int32_t rounds, int64_t pTable);
int64_t rijndaelEncryptRound2(int64_t a1, int32_t a2, int64_t * a3, int64_t a4, int64_t a5);
int32_t rijndaelKeySetupDec(int32_t * rk, char * cipherKey, int32_t keyBits, int64_t pTable);
int64_t rijndaelKeySetupDec2(int64_t a1, int64_t * a2, int64_t a3, int64_t a4);
int32_t rijndaelKeySetupEnc(int32_t * rk, char * cipherKey, int32_t keyBits, int64_t pTable);
int64_t rijndaelKeySetupEnc2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t rReg32(int64_t pPrivate, int16_t adr);
int64_t rReg32_(uint64_t a1, int64_t a2);
char rReg8(int64_t pPrivate, char adr);
int64_t rReg8_(uint64_t a1, int64_t a2);
void SAT_TUNER_InitIO(int64_t p_read_func, int64_t p_write_func);
int64_t SAT_TUNER_InitIO2(void);
char SAT_TUNER_RegRead(int64_t p_communication, int16_t address, int16_t offset, char start_bit, char num_bit, char num_bytes, int64_t * p_data);
int64_t SAT_TUNER_RegRead2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, uint64_t a5, int64_t a6, int64_t a7);
char SAT_TUNER_RegWrite(int64_t p_communication, int16_t address, int16_t offset, char start_bit, char num_bit, char num_bytes, char rmw, char access, int64_t data);
int64_t SAT_TUNER_RegWrite2(int64_t a1, int64_t a2, int64_t a3, uint64_t a4, uint64_t a5, int64_t a6, char a7, char a8, int64_t a9);
void SAT_TUNER_SetByteOrder(int64_t p_communication, char little_endian);
int64_t SAT_TUNER_SetByteOrder2(int64_t a1, int64_t a2);
void SAT_TUNER_strncpy(char * ptStrOut, char * ptStrIn, int32_t uiStrSize);
int64_t SAT_TUNER_strncpy2(int64_t a1, int64_t a2, int64_t * a3);
int32_t select_unit_size(int64_t prv);
int64_t select_unit_size2(int64_t a1);
int32_t set_b_cas_card_arib_std_b25(char * std_b25, int64_t bcas);
int64_t set_b_cas_card_arib_std_b25_(int64_t a1, int64_t a2);
int32_t set_bcas_card_exist(char * std_b25, char isExist);
int64_t set_bcas_card_exist2(int64_t a1, int64_t a2);
int32_t set_bcas_id(char * std_b25, char * card_info, int32_t info_len);
int64_t set_bcas_id2(int64_t a1, int64_t a2, int64_t a3);
int32_t set_init_cbc_multi2(char * m2, char * val);
int64_t set_init_cbc_multi2_(int64_t a1, int64_t a2);
int32_t set_is_streamscramble(char * std_b25, char isScramble);
int64_t set_is_streamscramble2(int64_t a1, int64_t a2);
void Set_Key(char * EncSeed, int64_t skeyPackage, int64_t pTable);
int64_t Set_Key2(int64_t a1, int64_t * a2, int64_t a3);
int32_t set_multi2_round_arib_std_b25(char * std_b25, int32_t round);
int64_t set_multi2_round_arib_std_b25_(int64_t a1, int64_t a2);
int32_t set_prognum(char * std_b25, int16_t prog_num);
int64_t set_prognum2(int64_t a1, int64_t a2);
int32_t set_round_multi2(char * m2, int32_t val);
int64_t set_round_multi2_(int64_t a1, int64_t a2);
int32_t set_scramble_key_multi2(char * m2, char * val);
int64_t set_scramble_key_multi2_(int64_t a1, int64_t a2);
int32_t set_system_key_multi2(char * m2, char * val);
int64_t set_system_key_multi2_(int64_t a1, int64_t a2);
int32_t set_ts_section_data(int64_t sect, int64_t hdr, char * data, int32_t size);
int64_t set_ts_section_data2(int64_t a1, int64_t * a2, int64_t a3, int32_t a4);
int32_t set_ts_section_data_for_remaining_payload_data(int64_t sect, int64_t hdr, char * data, int32_t size);
int64_t set_ts_section_data_for_remaining_payload_data2(int64_t a1, int64_t * a2, int64_t a3);
char SetSlowdownIC(int64_t pTuner, int32_t inputPin, int32_t outputPin, char bInverse, char IsAutoSyncEnable, char SyncByte);
int64_t SetSlowdownIC2(int64_t a1, int32_t a2, uint64_t a3, int64_t * a4, int64_t * a5, int64_t a6);
char SetTSMode(int64_t device, char tuner_number);
int64_t SetTSMode2(int64_t a1, int64_t a2);
char SetTsOutput(char * DevExt, char DevCH, uint32_t sig_source, int32_t ts_outputpin, char bStopOutput);
int64_t SetTsOutput2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int32_t setup_multi2(int64_t prv);
int64_t setup_multi2_(int64_t a1);
void setup_pid_map(int64_t prv);
int64_t setup_pid_map2(int64_t a1);
int64_t slab_buffer_size(int64_t a1);
char smi_cancel_dma_A(int64_t pFdoData);
int64_t smi_cancel_dma_A2(int64_t a1);
char smi_cancel_dma_B(int64_t pFdoData);
int64_t smi_cancel_dma_B2(int64_t a1);
char smi_cfg_dma_A(int64_t pFdoData);
int64_t smi_cfg_dma_A2(int64_t a1);
char smi_cfg_dma_B(int64_t pFdoData);
int64_t smi_cfg_dma_B2(int64_t a1);
char smi_clear_interrupt(int64_t pFdoData);
int64_t smi_clear_interrupt2(int64_t a1);
char smi_disable_interrupt(int64_t pFdoData, int64_t interrupt);
int64_t smi_disable_interrupt2(int64_t a1, int64_t a2);
char smi_enable_interrupt(int64_t pFdoData, int64_t interrupt);
int64_t smi_enable_interrupt2(void);
int32_t smi_interrupt_handler(int32_t irq, char * dev_instance);
int64_t smi_interrupt_handler2(int64_t a1, int64_t a2);
void smi_portA_dpc(char * pDpc, char * deferredContext, char * systemArgument1, char * systemArgument2);
int64_t smi_portA_dpc2(int64_t a1, int64_t a2);
void smi_portB_dpc(char * pDpc, char * deferredContext, char * systemArgument1, char * systemArgument2);
int64_t smi_portB_dpc2(int64_t a1, int64_t a2);
void SmiCalculateMemAddr(int64_t FdoData);
int64_t SmiCalculateMemAddr2(int64_t a1);
void SmiCalculateTotalMemSize(int64_t FdoData);
int64_t SmiCalculateTotalMemSize2(int64_t * a1);
int64_t SmiDrvDispatchPnpStartComplete(char * DeviceObject, char * Irp, char * Context);
int64_t SmiDrvStartDevice(int64_t FdoData, char * Irp);
int64_t SmiDrvStartDevice2(int64_t a1, int64_t a2);
int64_t SmiFreeDeviceResources(int64_t pFdoData);
int64_t SmiFreeDeviceResources2(void);
int64_t SmiGetDeviceInformation(int64_t FdoData);
int64_t SmiGetDeviceInformation2(void);
char SmiGetIRCode(int64_t device);
int64_t SmiGetIRCode2(void);
int64_t SmiInitializeDeviceExtension(int64_t FdoData);
int64_t SmiInitializeDeviceExtension2(void);
int64_t SmiMapHWResources(int64_t FdoData, char * Irp);
int64_t SmiMapHWResources2(int64_t a1);
char SmiReadRegister(int64_t device, char SlavAddr, char SlavMode, int32_t RegAddr, char * pData, char DataCont);
int64_t SmiReadRegister2(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char * a5, int64_t * a6, char a7);
char SmiSetIRCode(int64_t device, char IrProtocol);
int64_t SmiSetIRCode2(void);
char SmiTunerPowerDown(int64_t device);
int64_t SmiTunerPowerDown2(int64_t a1);
char SmiTunerPowerUp(int64_t device);
int64_t SmiTunerPowerUp2(int64_t a1);
int64_t SmiUnmapHWResources(int64_t FdoData);
int64_t SmiUnmapHWResources2(int64_t a1);
char SmiWriteRegister(int64_t device, char SlavAddr, char SlavMode, int32_t RegAddr, char * pData, char DataCont);
int64_t SmiWriteRegister2(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char * a5, int64_t * a6);
int64_t sprintf(int64_t a1, int64_t a2, int64_t a3, char a4, int64_t a5, int64_t a6);
char storageBufferClean(int64_t storageBuffer);
int64_t storageBufferClean2(void);
char storageBufferFlush(int64_t storageBuffer);
int64_t storageBufferFlush2(int64_t a1);
char storageBufferPrioritySet(int64_t storageBuffer, char priority);
int64_t storageBufferPrioritySet2(int64_t a1, int64_t a2);
char storageBuffInitialize(int64_t storageBuffer, int64_t initializeSize, int64_t storageBuffTag);
int64_t storageBuffInitialize2(int64_t a1, int64_t a2);
char StoreDeviceInformation(int64_t pDevExt, char * keyName, char * lpMessage);
char StoreDeviceLNBPower(int64_t pDevExt, char * keyName, int64_t * lpMessage);
int64_t StoreDeviceLNBPower2(int64_t a1, int64_t a2, int64_t * a3);
char StoreLNAStatus(int64_t pDevExt, char * keyName, int64_t * lpMessage);
int64_t strncpy(int64_t a1, int64_t a2, int64_t a3);
void swap_ts_section(int64_t curr, int64_t next);
int64_t swap_ts_section2(int64_t a1, int64_t a2);
char SWResetSlowdownIC(int64_t pTuner, int32_t outputPin);
int64_t SWResetSlowdownIC2(int64_t a1, int64_t a2);
char TC90522_ChannelSearch(char * pDeviceExtension, int64_t TunerDeviceID);
int64_t TC90522_ChannelSearch2(int64_t a1, int64_t a2);
char TC90522_CheckLock(char * pDeviceExtension, int64_t TunerDeviceID, char * pLock);
int64_t TC90522_CheckLock2(int64_t a1, uint64_t a2, int64_t a3);
char TC90522_GetCN(char * pDeviceExtension, int64_t TunerDeviceID, int64_t * pCnValue);
int64_t TC90522_GetCN2(int64_t a1, int64_t a2, int64_t a3);
char TC90522_GetQuality(char * pDeviceExtension, int64_t TunerDeviceID, char * pQuality);
int64_t TC90522_GetQuality2(int64_t a1, int64_t a2, int64_t a3);
char TC90522_GetStrength(char * pDeviceExtension, int64_t TunerDeviceID, char * pStrength);
int64_t TC90522_GetStrength2(int64_t a1, int64_t a2, int64_t a3);
char TC90522_GetTSID(char * pDeviceExtension, int64_t TunerDeviceID, int16_t * TSID);
int64_t TC90522_GetTSID2(int64_t a1, int64_t a2, int64_t a3);
char TC90522_Initialization(char * pDeviceExtension, int64_t TunerDeviceID, char ConfigureTransportStreamOutputFlag);
int64_t TC90522_Initialization2(int64_t a1, int64_t a2, int64_t * a3);
char TC90522_ResetInternal(char * pDeviceExtension, int64_t TunerDeviceID);
int64_t TC90522_ResetInternal2(int64_t a1, int64_t a2);
char TC90522_SetTSID(char * pDeviceExtension, int64_t TunerDeviceID, int16_t TSID);
int64_t TC90522_SetTSID2(int64_t a1, int64_t a2, int64_t a3);
void TC90522DemodulatorDelayMilliseconds(int64_t nMinDelayTime);
int64_t TC90522DemodulatorDelayMilliseconds2(int64_t a1);
int64_t TC90522DemodulatorGetCN(char * pDeviceExtension, int64_t TunerDeviceID);
int64_t TC90522DemodulatorGetCN2(int64_t a1, int64_t a2);
char TC90522DemodulatorGetQuality(char * pDeviceExtension, int64_t TunerDeviceID);
int64_t TC90522DemodulatorGetQuality2(int64_t a1, uint64_t a2);
char TC90522DemodulatorGetStrength(char * pDeviceExtension, int64_t TunerDeviceID);
int64_t TC90522DemodulatorGetStrength2(int64_t a1, uint64_t a2);
char TC90522DemodulatorOFDM_I2C_Read(char * pDeviceExtension, int64_t TunerDeviceID, char SubAddress, char * pData);
int64_t TC90522DemodulatorOFDM_I2C_Read2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4);
char TC90522DemodulatorOFDM_I2C_Write(char * pDeviceExtension, int64_t TunerDeviceID, char SubAddress, char Data);
int64_t TC90522DemodulatorOFDM_I2C_Write2(int64_t a1, int64_t a2, int64_t * a3, int64_t a4);
char TC90522DemodulatorPSK_I2C_Read(char * pDeviceExtension, int64_t TunerDeviceID, char SubAddress, char * pData);
int64_t TC90522DemodulatorPSK_I2C_Read2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4);
char TC90522DemodulatorPSK_I2C_Write(char * pDeviceExtension, int64_t TunerDeviceID, char SubAddress, char Data);
int64_t TC90522DemodulatorPSK_I2C_Write2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
char TC_CurrentTSIDRead(char * DevExt, char DevCH, int32_t * tsid, char * tuner_globe_data);
int64_t TC_CurrentTSIDRead2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t TC_DriverEntryFunCall(char * pDriverObject, char * pRegistryPath);
int64_t TC_DriverEntryFunCall2(void);
int64_t TC_GetAGC(char * DevExt, char DevCH, char * tuner_globe_data);
int64_t TC_GetAGC2(void);
int64_t TC_GetBER(char * DevExt, char DevCH, int64_t * BER1, int64_t * BER2, char * tuner_globe_data);
int64_t TC_GetBER2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t TC_GetCN(char * DevExt, char DevCH, char * tuner_globe_data);
int64_t TC_GetCN2(int64_t a1, uint64_t a2, int64_t a3);
int64_t TC_GetCNRegister(char * DevExt, char DevCH, char * tuner_globe_data);
int64_t TC_GetCNRegister2(int64_t a1, uint64_t a2, int64_t a3);
char TC_GetEmergencyAlarmStatus(char * DevExt, char DevCH, char * tuner_globe_data);
int64_t TC_GetEmergencyAlarmStatus2(void);
char TC_GetLNBShortDetect(char * DevExt, char DevCH, char * LNBShort, char * tuner_globe_data);
int64_t TC_GetLNBShortDetect2(int64_t a1, int64_t a2, int64_t * a3);
int64_t TC_GetSignaLevel(char * DevExt, char DevCH, char * tuner_globe_data);
int64_t TC_GetSignaLevel2(int64_t a1, uint64_t a2, int64_t a3);
char TC_Initialise(char * DevExt, char DevCH, char * FLAG, char * tuner_globe_data);
int64_t TC_Initialise2(int64_t a1, int64_t a2, char * a3, int64_t a4);
char TC_IsLocked(char * DevExt, char DevCH, char * tuner_globe_data);
int64_t TC_IsLocked2(int64_t a1, int64_t a2, int64_t a3);
char TC_MOS_POWER(char * DevExt, char DevCH, char bPower_On, char * tuner_globe_data);
int64_t TC_MOS_POWER2(int64_t a1, int64_t a2, int64_t * a3);
char TC_PollingThread(char * DevExt, char DevCH, char * tuner_globe_data);
int64_t TC_PollingThreadDelayTime(void);
char TC_PollingThreadOnlyCallOnce(char * DevExt, char * StartPolling, char total_tuner_num, char * tuner_globe_data);
void TC_PowerTunerDemod(char * DevExt, char DevCH, char bPower_On, char * tuner_globe_data);
int64_t TC_PowerTunerDemod2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
char TC_Preset(char * DevExt, char DevCH, char * tuner_globe_data);
int64_t TC_Preset2(int64_t a1);
char TC_ReadSNR(char * DevExt, char DevCH, char * tuner_globe_data);
int64_t TC_ReadSNR2(int64_t a1, uint64_t a2, int64_t a3);
char TC_RemappingTunerNumber(char * DevExt, char * DevCH);
int64_t TC_RemappingTunerNumber2(int64_t a1);
char TC_ResetTunerDemod(char * DevExt, char DevCH, char * tuner_globe_data);
char TC_SetFrequency(char * DevExt, char DevCH, int64_t dwFreqkHz, char ucBW, char * tuner_globe_data);
int64_t TC_SetFrequency2(int64_t a1, int64_t a2, uint64_t a3, int64_t a4, int64_t a5);
char TC_SetLNB(char * DevExt, char DevCH, char LNBPower, char * tuner_globe_data);
int64_t TC_SetLNB2(int64_t a1, int64_t a2);
char TC_SleepTunerDemod(char * DevExt, char DevCH, char * tuner_globe_data);
char TC_Start(char * DevExt, char DevCH, char * tuner_globe_data);
char TC_TSIDRead(char * DevExt, char DevCH, int32_t * tsidList, char listLength, char * tuner_globe_data);
int64_t TC_TSIDRead2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
char TC_TSIDWrite(char * DevExt, char DevCH, int32_t tsid, char bPreset, char * tuner_globe_data);
int64_t TC_TSIDWrite2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
char TC_WakeupTunerDemod(char * DevExt, char DevCH, char * tuner_globe_data);
char TDA2014x_I2C_Read(char * pUserData, char * p_tuner_handle, char address, int64_t * p_iostatus);
int64_t TDA2014x_I2C_Read2(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void TDA2014x_I2C_Write(char * pUserData, char * p_tuner_handle, char address, char data, int64_t * p_iostatus);
int64_t TDA2014x_I2C_Write2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
char TDA2014x_TunerCheckLockStatus(char * pDeviceExtension, int64_t TunerDeviceID, char * pLock);
int64_t TDA2014x_TunerCheckLockStatus2(int64_t a1, uint64_t a2, int64_t a3);
char TDA2014x_TunerInitialization(char * pDeviceExtension, int64_t TunerDeviceID);
int64_t TDA2014x_TunerInitialization2(int64_t a1, uint64_t a2);
char TDA2014x_TunerSetFrequency(char * pDeviceExtension, int64_t TunerDeviceID, int64_t RF);
int64_t TDA2014x_TunerSetFrequency2(int64_t a1, uint64_t a2, uint64_t a3);
void teardown(int64_t prv);
int64_t teardown2(int64_t a1);
void teardown3(int64_t prv);
int64_t teardown4(int64_t a1);
void TLIB_Delay(int64_t ms);
int64_t TLIB_Delay2(int64_t * a1);
void TLIB_Delay_Middle(int64_t dwMilliseconds);
int64_t TLIB_Delay_Middle2(void);
char TLIB_GetGPIO(char * DevExt);
int64_t TLIB_GetGPIO2(void);
char TLIB_GetGPIOEx(char * DevExt);
int64_t TLIB_GetGPIOEx2(void);
char TLIB_I2C_Read(char * DevExt, char I2C_Addr, char byReg, char * pBuffer, char byCount, char I2C_Mode);
int64_t TLIB_I2C_Read2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int64_t * a5, int64_t a6);
char TLIB_I2C_Read_Middle(char * tuner_globe_data, char I2C_Addr, char byReg, char * pBuffer, char byCount, char I2C_Mode);
int64_t TLIB_I2C_Read_Middle2(int64_t a1, uint64_t a2, uint64_t a3, int64_t a4, uint64_t a5, uint64_t a6);
char TLIB_I2C_Write(char * DevExt, char I2C_Addr, char byReg, char * pBuffer, char byCount, char I2C_Mode);
int64_t TLIB_I2C_Write2(int64_t a1, uint64_t a2, uint64_t a3, int64_t a4, uint64_t a5, uint64_t a6);
char TLIB_I2C_Write_Middle(char * tuner_globe_data, unsigned char I2C_Addr, char byReg, char * pBuffer, char byCount, char I2C_Mode);
int64_t TLIB_I2C_Write_Middle2(int64_t a1, int64_t a2, int64_t a3);
char TLIB_I2C_WriteAndRead(char * DevExt, char slave_addr, char * Write_buffer, char Write_size, char * Read_buffer, char Read_size, char mode);
int64_t TLIB_I2C_WriteAndRead2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, char a7);
void TLIB_SetGPIO(char * DevExt, unsigned char Data, char MaskData);
int64_t TLIB_SetGPIO2(int64_t a1, int64_t * a2, int64_t * a3);
char TLIB_SetGPIO_ASIE5606B5(char * DevExt, char Data, char MaskData);
int64_t TLIB_SetGPIO_ASIE5606B5_(int64_t a1, int64_t * a2, int64_t * a3);
void TLIB_SetGPIOEx(char * DevExt, unsigned char Data, char MaskData);
int64_t TLIB_SetGPIOEx2(int64_t a1, int64_t * a2, int64_t * a3);
char Tnim_AcqInit(int64_t psTnim);
int64_t Tnim_AcqInit2(int64_t a1);
char Tnim_AcquireFrequency(int64_t psTnim, int64_t dwFreqkHz, char ucBW);
int64_t Tnim_AcquireFrequency2(int64_t a1, int64_t result, int64_t a3);
char Tnim_Initialise(int64_t pTuner);
int64_t Tnim_Initialise2(int64_t a1);
char Tnim_IsLocked(int64_t psTnim);
int64_t Tnim_IsLocked2(void);
char Tnim_PollingThread(char * DevExt, char Tuner_Num);
int64_t Tnim_PollingThread2(int64_t a1, uint64_t a2);
int64_t Tnim_PollingThreadDelayTime(void);
int64_t Tnim_PollingThreadDelayTime2(void);
char Tnim_PollingThreadOnlyCallOnce(char * DevExt, char * StartPolling, char Total_Tuner_Num, char * tuner_globe_data);
int64_t Tnim_PollingThreadOnlyCallOnce2(int64_t a1, int64_t a2, int64_t * a3, int64_t a4);
char Tnim_ReadSNRx8(int64_t psTnim);
int64_t Tnim_ReadSNRx8_(void);
int64_t Tnim_SignalLevel(int64_t psTnim);
int64_t Tnim_SignalLevel2(int64_t a1);
void TS_Destroy(char * Multi2_Lib);
int64_t TS_Destroy2(int64_t a1);
void TS_EnableProcProgramID(char * Multi2_Lib, char enable);
int64_t TS_EnableProcProgramID2(int64_t result, int64_t a2);
char * TS_GetBcasPtr(char * Multi2_Lib);
int64_t TS_GetBcasPtr2(int64_t a1);
char TS_GetContentAvailabilityDescriptor(char * Multi2_Lib, int16_t pid, char * dataBuffer, int16_t * length);
int64_t TS_GetContentAvailabilityDescriptor2(int64_t result);
char TS_GetDigitalCopyControlDescriptor(char * Multi2_Lib, int16_t pid, char * dataBuffer, int16_t * length);
int64_t TS_GetDigitalCopyControlDescriptor2(int64_t result);
void TS_GetIsStreamScramble(char * Multi2_Lib, char * isStreamScramble);
int64_t TS_GetIsStreamScramble2(int64_t a1);
char TS_GetProgramNumber_ByPID(char * Multi2_Lib, int16_t pid, int32_t * program_number);
int64_t TS_GetProgramNumber_ByPID2(int64_t a1, int64_t a2, int64_t a3);
void TS_GetResetMulti2LibFlag(char * Multi2_Lib, char * isNeedResetMulti2Lib);
int64_t TS_GetResetMulti2LibFlag2(int64_t result);
void TS_GetTsProgramID(char * Multi2_Lib, char index, int16_t * program_id);
int64_t TS_GetTsProgramID2(void);
char TS_GetTsProgramID_Ex(char * Multi2_Lib, char * program_id);
int64_t TS_GetTsProgramID_Ex2(int64_t result);
char * TS_Init(char * DevExt, int32_t (*bcas_callback)(char *, char *, int32_t, char, char *), char ucTunerNum);
int64_t TS_Init2(int64_t a1, int64_t a2, int64_t a3);
int32_t TS_Process(char * Multi2_Lib, char * pbuf, int32_t size);
int64_t TS_Process2(int64_t a1, int64_t a2, int64_t a3);
void TS_Reset(char * Multi2_Lib);
int64_t TS_Reset2(int64_t a1);
void TS_SetBCASCardExist(char * Multi2_Lib, char isExist);
int64_t TS_SetBCASCardExist2(int64_t a1, int64_t a2);
void TS_SetBcasCardID(char * Multi2_Lib, char * buffer, int32_t size);
int64_t TS_SetBcasCardID2(int64_t result);
void TS_SetBCASResponse(char * buffer, int32_t size, char bInitCmd, char * bcas);
int64_t TS_SetBCASResponse2(int64_t a1, int32_t a2, char a3, int64_t a4);
void TS_SetIsStreamScramble(char * Multi2_Lib, char isStreamScramble);
int64_t TS_SetIsStreamScramble2(int64_t a1, int64_t a2);
void TS_SetProgramID(char * Multi2_Lib, int16_t program_id);
int64_t TS_SetProgramID2(int64_t result, int64_t a2);
char TunerRegRead(char * DevExt, unsigned char DevCH, char byReg, char * pBuffer, char byCount, int32_t src);
int64_t TunerRegRead2(int64_t a1, uint64_t a2, int64_t * a3, int64_t * a4, int64_t * a5, int64_t a6);
char TunerRegWrite(char * DevExt, char DevCH, char * pBuffer, char byCount, int32_t src);
int64_t TunerRegWrite2(int64_t a1, int64_t a2, int64_t * a3, int64_t * a4, int64_t a5);
int32_t TunerReset(int64_t pTnim, unsigned char bInitTuner, char bChkRstFlag);
int64_t TunerReset2(int64_t a1, int64_t a2, int64_t a3);
int64_t TVTunerInit(int64_t device);
int64_t TVTunerInit2(void);
int64_t unknown_4d8cc1e2(void);
int64_t unknown_758cbdde(void);
int64_t unknown_ba7333(void);
int64_t unknown_ffffffffc1c1dcc3(void);
int64_t unknown_fffffffff067f109(void);
int64_t unknown_fffffffff067f89f(void);
int64_t unknown_fffffffff06f75c4(void);
int64_t unknown_fffffffff077646b(void);
int64_t unknown_fffffffff07765b7(void);
int64_t unknown_fffffffff0777964(void);
int64_t unregister_chrdev_region(int32_t a1, int32_t a2);
int64_t up(int64_t a1);
int32_t USB_BulkStreamRead(int64_t deviceExtension, char Channel_Num, char * Buffer, int64_t ReadLen);
int64_t USB_BulkStreamRead2(int64_t a1, uint64_t a2);
int32_t USB_BulkStreamStart(int64_t deviceExtension, unsigned char Channel_Num, char * Contex, int64_t TransferObjBufSize, int64_t StreamBufSize);
int64_t USB_BulkStreamStart2(int64_t a1, uint64_t a2, int64_t a3, int64_t a4, int64_t a5);
int32_t USB_BulkStreamStop(int64_t deviceExtension, char Channel_Num);
int64_t USB_BulkStreamStop2(int64_t a1, int64_t a2);
char USB_CF_Read(int64_t deviceExtension, char CF_Num, char byReg, char byCount, char * pBuffer);
int64_t USB_CF_Read2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
char USB_CF_Write(int64_t deviceExtension, char CF_Num, char byReg, char * pBuffer, char byCount, char bZeroNoSend);
int64_t USB_CF_Write2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int32_t USB_CleanStreamBuffer(int64_t deviceExtension, char Channel_Num);
int64_t USB_CleanStreamBuffer2(int64_t a1, int64_t a2);
int32_t USB_FilterON_and_Start(int64_t deviceExtension, char CF_Num);
int64_t USB_FilterON_and_Start2(int64_t a1, int64_t a2);
int32_t USB_FilterONOFF(int64_t deviceExtension, char CF_Num, char ONOFF);
int64_t USB_FilterONOFF2(int64_t a1, int32_t a2);
int32_t USB_FilterReset(int64_t deviceExtension, char CF_Num, char bRestoreCFReg, char bCFSerialMode);
int64_t USB_FilterReset2(int64_t a1, uint64_t a2);
int32_t USB_FilterStart_Stop(int64_t deviceExtension, char CF_Num, char ONOFF);
int64_t USB_FilterStart_Stop2(int64_t a1, int64_t a2);
int32_t USB_GetFilterStat(int64_t deviceExtension, char CF_Num);
int64_t USB_GetFilterStat2(int64_t a1, int64_t a2);
char USB_I2C_Read(int64_t deviceExtension, char byID, char byReg, char * pBuffer, char byCount, char byI2CFlag);
int64_t USB_I2C_Read2(int64_t a1, uint64_t a2, uint64_t a3, int64_t a4, uint64_t a5, int64_t * a6);
char USB_I2C_Write(int64_t deviceExtension, char byID, char byReg, char * pBuffer, char byCount, char byI2CFlag);
int64_t USB_I2C_Write2(int64_t a1, uint64_t a2, uint64_t a3, int64_t a4, uint64_t a5, int64_t * a6);
char USB_I2C_WriteAndRead(int64_t deviceExtension, char slave_addr, char * Write_buffer, char Write_size, char * Read_buffer, char Read_size, char mode);
int64_t USB_I2C_WriteAndRead2(int64_t a1, uint64_t a2, int64_t a3, uint64_t a4, int64_t a5, uint64_t a6, unsigned char a7);
int32_t USB_IsHighSpeed(int64_t deviceExtension);
int64_t USB_IsHighSpeed2(int64_t a1);
int32_t USB_IsPidNeedToKeep(int64_t deviceExtension, char CF_Num, int32_t pid);
int64_t USB_IsPidNeedToKeep2(int64_t a1, int64_t a2, int64_t a3);
int32_t USB_SetPidTable(int64_t deviceExtension, char CF_Num, int32_t * PID_TABLE, char Num);
int64_t USB_SetPidTable2(int64_t a1, uint64_t a2, int64_t a3, int64_t * a4);
void vCleanStreamBuffer(int64_t deviceExtension, char DataStream_Num);
int64_t vCleanStreamBuffer2(int64_t a1, unsigned char a2);
int64_t vsprintf(char * a1, int64_t a2, int64_t * a3, int64_t * a4);
void vUSB_Wait(int64_t dwMilliseconds);
int64_t vUSB_Wait2(int64_t a1);
int64_t wait_for_completion(int64_t a1, int32_t a2, int32_t a3);
int64_t wake_up_process(int64_t a1);
int64_t warn_slowpath_null(int64_t a1, int64_t a2);
void wReg32(int64_t pPrivate, int16_t adr, int32_t val);
int64_t wReg32_(uint64_t a1, int64_t a2, int64_t * a3);
void wReg32Debug(int64_t pPrivate, int16_t adr, int32_t val32);
int64_t wReg32Debug2(int64_t a1, uint64_t a2, int64_t a3);
void wReg8(int64_t pPrivate, char adr, char val);
int64_t wReg8_(int64_t a1, int64_t * a2, int64_t a3);
void wReg8Debug(int64_t pPrivate, char adr, char val8);
int64_t wReg8Debug2(int64_t a1, uint64_t a2, uint64_t a3);
void wRegBurst(int64_t pPrivate, int32_t adr, char * bd, int32_t sz);
int64_t wRegBurst2(uint64_t a1, int64_t a2, int64_t a3, int64_t a4);
char writeStorageBuff(char * wtPtr, int64_t StreamObject, int64_t length);
int64_t writeStorageBuff2(int64_t a1, int64_t a2, uint64_t a3);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x14000000; // 0x1
char g2 = -9; // 0x10
char * g3 = "\xc8\xda\xb7\xe6]\xb4\x98\x18\xa7P\xae\xcf\xb9+ k\x99\xdf\xd1"; // 0x11
int32_t * g4 = (int32_t *)-0x58e7674ba2194826; // 0x12
int32_t * g5 = (int32_t *)0x50a71898b45de6b7; // 0x13
char * g6 = "%"; // 0x1338
int32_t * g7 = (int32_t *)-0x51af58e7674ba21a; // 0x14
char * g8 = "X"; // 0x148b
char * g9 = "]\xb4\x98\x18\xa7P\xae\xcf\xb9+ k\x99\xdf\xd1"; // 0x15
int32_t * g10 = (int32_t *)-0x463051af58e7674c; // 0x16
int64_t g11 = 0x65e8df894800004a; // 0x16e8
char * g12 = "\x98\x18\xa7P\xae\xcf\xb9+ k\x99\xdf\xd1"; // 0x17
int32_t * g13 = (int32_t *)0x202bb9cfae50a718; // 0x18
int64_t g14 = 328; // 0x1800
int32_t * g15 = (int32_t *)0x4de8e7894c000066; // 0x188
char * g16 = "\xa7P\xae\xcf\xb9+ k\x99\xdf\xd1"; // 0x19
char * g17 = "P\xae\xcf\xb9+ k\x99\xdf\xd1"; // 0x1a
char * g18 = "\xae\xcf\xb9+ k\x99\xdf\xd1"; // 0x1b
int32_t * g19 = (int32_t *)-0x2e206694dfd44631; // 0x1c
int64_t g20 = 0x626883c74800000b; // 0x1c48
int32_t * g21 = (int32_t *)0x4800000d04000062; // 0x1c70
int32_t * g22; // 0x1d
char * g23 = "+ k\x99\xdf\xd1"; // 0x1e
char * g24 = " k\x99\xdf\xd1"; // 0x1f
int32_t g25 = 0x140000; // 0x2
int32_t * g26; // 0x20
int64_t g27 = -0x38fffffffffff706; // 0x20c
int32_t * g28; // 0x21
int32_t g29 = -0x637c3900; // 0x21c
int64_t g30; // 0x22
int64_t g31; // 0x23
int64_t g32 = 0; // 0x2fa47
char * g33; // 0x3
int32_t g34 = 0; // 0x30000
int32_t * g35 = NULL; // 0x30d4c
int32_t * g36 = NULL; // 0x30d50
char * g37; // 0x30d54
int64_t g38 = 0; // 0x30d58
char * g39 = "\x03G6\xd3"; // 0x30d60
char * g40 = "G6\xd3"; // 0x30d61
char * g41; // 0x30d81
char * g42 = "\xb9\x02\x01"; // 0x30da1
char * g43 = "\x02\x01"; // 0x30da2
char * g44 = "\x01"; // 0x30da3
char * g45; // 0x30da4
char * g46; // 0x30dc4
char * g47; // 0x30dd4
int64_t g48 = 0x74756d0000000003; // 0x30de3
char * g49; // 0x30de4
int32_t g51 = 0; // 0x31bc0
int64_t g52 = 0xb2f278; // 0x31bc8
int32_t g53 = 0; // 0x31d60
int64_t g54 = 0x16bd7; // 0x31d68
int32_t g55 = 0xb2f278; // 0x355a0
int32_t g56 = 0xb2f278; // 0x356c0
int32_t g57 = 40; // 0x35828
int32_t g58 = 50; // 0x3582c
int32_t g59 = 32; // 0x35830
int32_t g60 = 46; // 0x35834
int32_t g61 = 32; // 0x35838
int32_t g62 = 54; // 0x3583c
int32_t g63 = 20; // 0x35840
int32_t g64 = 30; // 0x35844
int32_t g65 = 14; // 0x35848
int32_t g66 = 30; // 0x3584c
int32_t g67 = 12; // 0x35850
int32_t g68 = 34; // 0x35854
int64_t g69 = 0; // 0x36880
int64_t g70 = 0; // 0x36888
int64_t g71 = 0; // 0x36ae0
int32_t g72 = 0; // 0x36ae4
int32_t g73 = 0; // 0x36ae8
int64_t g74 = 0; // 0x36b00
int64_t g75 = 0; // 0x36b40
int64_t g76 = 0; // 0x36f40
int64_t g77 = 0; // 0x36f4c
int64_t g78 = 0; // 0x36f4d
int64_t g79 = 0; // 0x36fc0
int64_t g80 = 0; // 0x36fc8
int64_t g81 = 0; // 0x39480
bool g82 = false; // 0x3d08f
int64_t g83 = 0; // 0x3eaf8
int32_t g84 = 0; // 0x3ecb0
int64_t g85 = 0; // 0x3ecc8
int16_t g86 = 20; // 0x4
int64_t g87 = -0x173176b7fffffff8; // 0x4e0
int64_t g88 = -0x77cc88b3f7afff7; // 0x4f0
char g89 = 0; // 0x5
char * g90 = "`"; // 0x5431
char g91 = 0; // 0x6
int64_t g92 = 0x383f98100000046; // 0x6220
int64_t g93 = 0x16508e80000000a; // 0x6690
char * g94; // 0x7
char g95 = 3; // 0x8
int32_t g96 = 0x41130045; // 0x8d06
char * g97; // 0x9
char g98 = 0; // 0xa
char * g99; // 0xb
int16_t g100 = 88; // 0xc90
int64_t g101 = 0x542870f0e000058; // 0xd20
int64_t g102 = 0x58d8878948000058; // 0xd50
int16_t * g103 = (int16_t *)0x5de6b7dac8f70055; // 0xe
char g104 = 40; // 0xec
char g105 = 0; // 0xf
int32_t g106 = 0x48000058; // 0xfff
int32_t g107;
int64_t * g50 = (int64_t *)&g95; // 0x31ba0

// ------------------------ Functions -------------------------

// From module:   /root/asv5220\asv5220.c
// Address range: 0x0 - 0x1
// Line range:    1822 - 1805
void asv5220_fini(void) {
    // 0x0
    return;
}

// Address range: 0x30 - 0x54
int64_t asv5220_resume(int64_t a1) {
    // 0x30
    mcount();
    return pci_enable_device(a1);
}

// From module:   /root/asv5220\asv5220.c
// Address range: 0x56 - 0x86
int32_t asv5220_suspend(int64_t pci_dev, int64_t state) {
    // 0x56
    int64_t v1; // 0x56
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x56
    char * v3 = (char *)(v2 - 25 + v2 * (int64_t)&g86); // 0x58
    *v3 = *v3 + (char)v2;
    int32_t result = pci_set_power_state(pci_dev, state); // 0x63
    int64_t v4; // 0x56
    if (result == 0) {
        // 0x71
        pci_restore_state(v4);
    } else {
        // 0x67
        pci_disable_device(v4);
    }
    // 0x79
    return result;
}

// Address range: 0x86 - 0xa7
int64_t asv5220_suspend2(int64_t a1, int64_t a2) {
    // 0x86
    mcount();
    return dev_get_drvdata(a1 + 144);
}

// From module:   /root/asv5220\asv5220.c
// Address range: 0xa7 - 0xd7
int32_t asv5220_release(int64_t inode, int64_t file) {
    // 0xa7
    pci_save_state();
    int64_t v1; // 0xa7
    int64_t v2; // 0xa7
    if ((int32_t)pci_set_power_state(v2, pci_choose_state(v2, v1 & 0xffffffff) & 0xffffffff) != 0) {
        // 0xc5
        pci_disable_device(v2);
    }
    // 0xcd
    return 0;
}

// Address range: 0xd7 - 0x23b
int64_t asv5220_release2(int64_t a1, int64_t a2) {
    // 0xd7
    mcount();
    __readgsqword(40);
    int64_t v1 = *(int64_t *)(a2 + 160); // 0x176
    mutex_lock(*(int64_t *)(v1 + 0x1d38) + 0x6670);
    *(int32_t *)(v1 + 0x929e4) = 0;
    *(int64_t *)(v1 + (int64_t)&g45) = -83;
    *(int64_t *)(v1 + (int64_t)&g45 + 8) = -112;
    *(int64_t *)(v1 + (int64_t)&g46) = -3;
    *(int64_t *)(v1 + (int64_t)&g46 + 8) = -85;
    *(int64_t *)(v1 + (int64_t)&g47) = -3;
    *(int64_t *)(v1 + (int64_t)&g47 + 8) = -85;
    *(int32_t *)(v1 + (int64_t)&g21) = 0;
    *(char *)(v1 + (int64_t)&g39) = (char)&g1;
    *(char *)(v1 + 0x8fabc) = 0;
    int64_t * v2 = (int64_t *)(v1 + 0x8fab0); // 0x1fc
    TS_Destroy2(*v2);
    *v2 = 0;
    *(int32_t *)(v1 + 732) = 0;
    *(int32_t *)(v1 + 412) = 0;
    __asm_rep_stosq_memset((char *)(v1 + 416), 0, 39);
    return 0;
}

// From module:   /root/asv5220\asv5220.c
// Address range: 0x23b - 0x26b
int32_t asv5220_open(int64_t inode, int64_t file) {
    // 0x23b
    *(int32_t *)inode = 0;
    int64_t v1; // 0x23b
    mutex_unlock(v1);
    int32_t result = 0; // 0x25b
    int64_t v2; // 0x23b
    if (*(int64_t *)(v2 - 24) != __readgsqword(40)) {
        // 0x25d
        result = __stack_chk_fail();
    }
    // 0x262
    return result;
}

// Address range: 0x26b - 0x39c
int64_t asv5220_open2(int64_t a1, int64_t a2) {
    // 0x26b
    mcount();
    mutex_lock(g75 + 0x6670);
    int64_t v1 = *(int64_t *)-8; // 0x30b
    int64_t v2 = *(int64_t *)(v1 + (int64_t)&g87); // 0x30f
    int32_t v3 = *(int32_t *)(int64_t)(4 * *(int32_t *)(a1 + 88) & 0x3ffffc); // 0x316
    int64_t v4 = v2; // 0x320
    if (*(int32_t *)(v2 + 0x929dc) != v3) {
        // 0x322
        v4 = *(int64_t *)(v1 + 1256);
    }
    int32_t * v5 = (int32_t *)(v4 + 0x929e4); // 0x338
    if (*v5 == 1) {
        // 0x341
        mutex_unlock(v1 + 0x6670);
        return 0xfffffffb;
    }
    // 0x354
    *v5 = (int32_t)&g1;
    *(int64_t *)(a2 + 160) = v4;
    int64_t v6 = v4 + 0x929b8; // 0x369
    mutex_lock(v6);
    mutex_unlock(v6);
    abort();
    // UNREACHABLE
}

// From module:   /root/asv5220\asv5220.c
// Address range: 0x39c - 0x3cc
int32_t asv5220_ioctl(int64_t inode, int64_t file, int32_t cmd, char * arg) {
    // 0x39c
    int64_t result; // 0x39c
    return result;
}

// Address range: 0x3cc - 0x9da
int64_t asv5220_ioctl2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x3cc
    mcount();
    int64_t v1 = __readgsqword(40); // 0x3e4
    int64_t v2 = *(int64_t *)(a2 + 160); // 0x3f3
    uint32_t v3 = (int32_t)a3; // 0x404
    if (v3 == 0x40088d84) {
        // 0x7c6
        int64_t v4; // bp-72, 0x3cc
        copy_from_user(&v4, a4, (int64_t *)&g3);
        char v5; // 0x3cc
        return DTV_Muli2LibEnable2(v2, &v4, v5);
    }
    int64_t v6 = *(int64_t *)(v2 + 0x1d38); // 0x3fa
    if (v3 < 0x40088d85) {
        if (v3 == (int32_t)&g96) {
            // 0x6e5
            TC_SetLNB2(v6, 0);
            return 0;
        }
        if (v3 <= (int32_t)&g96) {
            char * v7 = (char *)(v2 + 0x1d30);
            char * v8 = (char *)(v6 + 888 + (int64_t)*v7);
            if (v3 != 0x8d02) {
                // 0x65e
                *v8 = 0;
                DTV_StreamThreadStop2(v2, 0);
                return 0;
            }
            // 0x624
            *v8 = (char)&g1;
            DTV_StreamThreadRun2(v2);
            *(int32_t *)(v2 + 0x929e8) = (int32_t)&g89;
            vCleanStreamBuffer2(v6, *v7);
            return 0;
        }
        switch (v3) {
            case 0x40088d01: {
                // 0x4d8
                int32_t v9; // bp-424, 0x3cc
                copy_from_user((int64_t *)&v9, a4, (int64_t *)&g95);
                int32_t v10 = *(int32_t *)(v2 + 0x929d8); // 0x4ec
                if (v10 == 0) {
                    // 0x52d
                    if (g52 != 0) {
                        // 0x539
                        if (g51 == v9) {
                            // 0x56c
                            DTV_SetTunerFreq2(v2, g52, (int64_t *)&g91);
                        }
                    }
                    // 0x579
                    DTV_GetTunerTSIDList2(v2);
                    int64_t v11; // bp-8, 0x3cc
                    int32_t v12; // 0x3cc
                    int32_t v13 = *(int32_t *)((int64_t)v12 * (int64_t)&g86 - 544 + (int64_t)&v11); // 0x594
                    if (v13 != 0) {
                        // 0x59f
                        DTV_SetTunerTSID2(v2, v13, 0);
                    }
                } else {
                    if (v10 == 1) {
                        // 0x4ff
                        if (g54 != 0) {
                            // 0x50f
                            if (g53 == v9) {
                                // 0x5ca
                                DTV_SetTunerFreq2(v2, g54, (int64_t *)&g91);
                            }
                        }
                    }
                }
                // break -> 0x5d7
                break;
            }
            case 0x40088d83: {
                // 0x780
                int64_t v14; // bp-488, 0x3cc
                copy_from_user(&v14, a4, (int64_t *)32);
                int64_t v15; // 0x3cc
                char v16; // 0x3cc
                char v17; // 0x3cc
                return DTV_GenEncSeed2(v2, v14, v17, v15, v16);
            }
            default: {
                // 0x6c5
                TC_SetLNB2(v6, 0);
                return 0;
            }
        }
        // 0x5d7
        *(int32_t *)(v2 + 0x929e8) = (int32_t)&g89;
        int64_t v18 = 0; // 0x5e1
        vUSB_Wait2(50);
        while ((int32_t)DTV_TunerLockCheck2(v2) == 0) {
            int64_t v19 = v18 + (int64_t)(int32_t)&g1; // 0x5e7
            v18 = v19 & 0xffffffff;
            if ((int32_t)v19 >= 50) {
                // break -> 0x607
                break;
            }
            vUSB_Wait2(50);
        }
        // 0x607
        vUSB_Wait2(300);
        return 0;
    }
    int16_t v20; // bp-412, 0x3cc
    if (v3 == -0x7ff7727f) {
        // 0x705
        v20 = 0;
        char v21 = *(char *)(v2 + 0x15ec); // 0x70f
        int16_t v22 = v21 == 0 ? (int16_t)&g25 : (int16_t)((int32_t)&g1 | (int32_t)&g25); // 0x725
        v20 = v22;
        int16_t v23 = v22; // 0x732
        if (*(char *)(v2 + 0x148d) != 0) {
            // 0x734
            v23 = v22 | (int16_t)&g86;
            v20 = v23;
        }
        // 0x73d
        v20 = v23 | 64;
        copy_to_user(a4, (int32_t *)&v20, (int64_t *)&g1);
        return 0;
    }
    int64_t v24; // bp-406, 0x3cc
    char v25; // bp-407, 0x3cc
    int64_t v26; // bp-408, 0x3cc
    if (v3 < 0x80088d82) {
        switch (v3) {
            case 0x40088d87: {
                // 0x8b2
                copy_from_user(&v26, a4, (int64_t *)322);
                int64_t v27 = *(int64_t *)(v6 + 1248); // 0x8f2
                return BCAS_CMDSet_Ext2(v27 + 8, v2, &v24, v25);
            }
            case -0x7ff772fc: {
                // 0x684
                int32_t v28; // bp-432, 0x3cc
                DTV_GetCNRegisterValue2(v2, *(char *)(v2 + 0x1d30), (int64_t *)&v28);
                v20 = v28;
                copy_to_user(a4, (int32_t *)&v20, (int64_t *)&g86);
                return 0;
            }
        }
        // 0x883
        int32_t v29; // bp-456, 0x3cc
        copy_from_user((int64_t *)&v29, a4, (int64_t *)&g2);
        return DTV_SetProgramID2(v2, (int64_t)v29);
    }
    int64_t v30; // 0x3cc
    switch (v3) {
        case -0x7ff7727b: {
            int32_t * v31 = (int32_t *)(a4 + (int64_t)&g2); // 0x81a
            int64_t v32 = __kmalloc((int64_t)(188 * *v31), (int64_t *)&g26, a3); // 0x829
            int64_t v33 = DTV_DecrypMultiTS2(v2, v32, *v31, v32); // 0x840
            if ((char)v33 != (char)&g1) {
                // 0x871
                kfree(v32);
                return 0xffffffea;
            }
            int64_t v34 = *(int64_t *)(a4 + (int64_t)&g95); // 0x852
            copy_to_user(v34, (int32_t *)v32, (int64_t *)(int64_t)(188 * *v31));
            kfree(v32);
            return 0;
        }
        case -0x7ff77278: {
            // 0x949
            if (*(char *)(v2 + 0x1d30) != 0) {
                int64_t v35 = *(int64_t *)(v6 + 1248); // 0x975
                if (v35 == 0) {
                    // 0x9c1
                    copy_to_user(a4, (int32_t *)&v26, (int64_t *)322);
                    return 0xffffffea;
                }
                int64_t v36 = BCAS_CMDGet_Ext2(v35 + 8, v2, &v26, &v25, &v24, 320, v1); // 0x99d
                v30 = v36;
            } else {
                int64_t v37 = BCAS_CMDGet_Ext2(v2 + 8, v2, &v26, &v25, &v24, 320, v1); // 0x96e
                v30 = v37;
            }
            // break -> 0x9a2
            break;
        }
        default: {
            // 0x762
            copy_to_user(a4, (int32_t *)(v2 + 0x15ed), (int64_t *)&g2);
            return 0;
        }
    }
    // 0x9a2
    if ((char)v30 != (char)&g1) {
        // 0x9c1
        copy_to_user(a4, (int32_t *)&v26, (int64_t *)322);
        return 0xffffffea;
    }
    // 0x9a6
    copy_to_user(a4, (int32_t *)&v26, (int64_t *)322);
    return 0;
}

// From module:   /root/asv5220\asv5220.c
// Address range: 0x9da - 0xa0a
int64_t asv5220_read(int64_t file, char * buf, int64_t cnt, int64_t * ppos) {
    // 0x9da
    int64_t result; // 0x9da
    int64_t v1; // 0x9da
    if (*(int64_t *)(v1 - 40) != __readgsqword(40)) {
        // 0x9f7
        result = __stack_chk_fail();
    }
    // 0x9fc
    return result;
}

// Address range: 0xa0a - 0xa9f
int64_t asv5220_read2(int64_t a1, int64_t a2, uint64_t a3) {
    // 0xa0a
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 160); // 0xa26
    int64_t v2 = (int64_t)*(char *)(v1 + 0x1d30); // 0xa34
    int64_t v3 = *(int64_t *)(*(int64_t *)(v1 + 0x1d38) + 1160 + 8 * v2); // 0xa3c
    int64_t v4 = 0; // 0xa49
    while (*(int64_t *)(v3 + 296) < a3) {
        // 0xa4b
        vUSB_Wait2((int64_t)&g1);
        if ((int32_t)v4 == 501) {
            // break -> 0xa69
            break;
        }
        v4 &= 0xffffffff;
    }
    int64_t v5 = __kmalloc(a3, (int64_t *)&g26, v2); // 0xa71
    int64_t v6 = DTV_StreamDataRead2(v1, v5, a3 & 0xffffffff); // 0xa82
    int64_t result = v6; // 0xa8e
    if ((int32_t)v6 >= 0) {
        // 0xa90
        result = copy_to_user(a2, (int32_t *)v5, (int64_t *)(v6 & 0xffffffff));
    }
    // 0xa9f
    return result;
}

// From module:   /root/asv5220\smiDrv.c
// Address range: 0xaa4 - 0xab4
// Line range:    66 - 97
int64_t SmiDrvDispatchPnpStartComplete(char * DeviceObject, char * Irp, char * Context) {
    // 0xaa4
    int64_t v1; // 0xaa4
    *(int32_t *)v1 = (int32_t)v1;
    int64_t v2 = v1 - (int64_t)(int32_t)&g1; // 0xaaa
    int64_t v3; // 0xaa4
    *(int32_t *)(v3 + 0x929e8) = (int32_t)v2;
    return v2 & 0xffffffff;
}

// From module:   /root/asv5220\smiDrv.c
// Address range: 0xab4 - 0xab9
// Line range:    560 - 647
int64_t SmiGetDeviceInformation(int64_t FdoData) {
    // 0xab4
    int64_t result; // 0xab4
    return result;
}

// From module:   /root/asv5220\smiDrv.c
// Address range: 0xac4 - 0xad2
// Line range:    659 - 723
int64_t GetPCIBusInterfaceStandard(char * DeviceObject, char * BusInterfaceStandard) {
    // 0xac4
    int64_t result; // 0xac4
    return result;
}

// From module:   /root/asv5220\smiDrv.c
// Address range: 0xad4 - 0xae4
// Line range:    737 - 846
void SmiCalculateTotalMemSize(int64_t FdoData) {
    // 0xad4
    mcount();
}

// Address range: 0xae4 - 0xaf4
int64_t SmiGetDeviceInformation2(void) {
    // 0xae4
    mcount();
    return &g1;
}

// Address range: 0xaf4 - 0xb04
int64_t GetPCIBusInterfaceStandard2(int64_t a1, int64_t a2) {
    // 0xaf4
    mcount();
    return &g1;
}

// Address range: 0xb04 - 0xb27
int64_t SmiCalculateTotalMemSize2(int64_t * a1) {
    int64_t result2 = mcount(); // 0xb08
    uint32_t result = *(int32_t *)((int64_t)a1 + 0x58e8); // 0xb0d
    if (result < 15) {
        // 0xb1a
        return result;
    }
    // 0xcdd
    return result2;
}

// Address range: 0xb27 - 0xb45
int64_t function_b27(int64_t a1) {
    // 0xb27
    *(int64_t *)(a1 + 0x58e0) = 0xe520;
    *(char *)(a1 + 0x58ec) = (char)&g1;
    *(char *)(a1 + 0x58ed) = 0;
    int64_t result; // 0xb27
    return result;
}

// Address range: 0xb45 - 0xb63
int64_t function_b45(int64_t a1) {
    // 0xb45
    *(int64_t *)(a1 + 0x58e0) = 0xe520;
    *(char *)(a1 + 0x58ec) = (char)&g25;
    *(char *)(a1 + 0x58ed) = 0;
    int64_t result; // 0xb45
    return result;
}

// Address range: 0xb63 - 0xb81
int64_t function_b63(int64_t a1) {
    // 0xb63
    *(int64_t *)(a1 + 0x58e0) = 0xe520;
    *(char *)(a1 + 0x58ec) = 0;
    *(char *)(a1 + 0x58ed) = (char)&g1;
    int64_t result; // 0xb63
    return result;
}

// Address range: 0xb81 - 0xb9f
int64_t function_b81(int64_t a1) {
    // 0xb81
    *(int64_t *)(a1 + 0x58e0) = 0xe520;
    *(char *)(a1 + 0x58ec) = 0;
    *(char *)(a1 + 0x58ed) = (char)&g25;
    int64_t result; // 0xb81
    return result;
}

// Address range: 0xb9f - 0xbbd
int64_t function_b9f(int64_t a1) {
    // 0xb9f
    *(int64_t *)(a1 + 0x58e0) = 0x1ca40;
    *(char *)(a1 + 0x58ec) = (char)&g33;
    *(char *)(a1 + 0x58ed) = 0;
    int64_t result; // 0xb9f
    return result;
}

// Address range: 0xbbd - 0xbdb
int64_t function_bbd(int64_t a1) {
    // 0xbbd
    *(int64_t *)(a1 + 0x58e0) = 0x1ca40;
    *(char *)(a1 + 0x58ec) = 0;
    *(char *)(a1 + 0x58ed) = (char)&g33;
    int64_t result; // 0xbbd
    return result;
}

// Address range: 0xbdb - 0xbf9
int64_t function_bdb(int64_t a1) {
    // 0xbdb
    *(int64_t *)(a1 + 0x58e0) = 0x1ca40;
    *(char *)(a1 + 0x58ec) = (char)&g1;
    *(char *)(a1 + 0x58ed) = (char)&g1;
    int64_t result; // 0xbdb
    return result;
}

// Address range: 0xbf9 - 0xc17
int64_t function_bf9(int64_t a1) {
    // 0xbf9
    *(int64_t *)(a1 + 0x58e0) = 0x1ca40;
    *(char *)(a1 + 0x58ec) = (char)&g1;
    *(char *)(a1 + 0x58ed) = (char)&g25;
    int64_t result; // 0xbf9
    return result;
}

// Address range: 0xc17 - 0xc35
int64_t function_c17(int64_t a1) {
    // 0xc17
    *(int64_t *)(a1 + 0x58e0) = 0x1ca40;
    *(char *)(a1 + 0x58ec) = (char)&g25;
    *(char *)(a1 + 0x58ed) = (char)&g1;
    int64_t result; // 0xc17
    return result;
}

// Address range: 0xc35 - 0xc53
int64_t function_c35(int64_t a1) {
    // 0xc35
    *(int64_t *)(a1 + 0x58e0) = 0x1ca40;
    *(char *)(a1 + 0x58ec) = (char)&g25;
    *(char *)(a1 + 0x58ed) = (char)&g25;
    int64_t result; // 0xc35
    return result;
}

// Address range: 0xc53 - 0xc71
int64_t function_c53(int64_t a1) {
    // 0xc53
    *(int64_t *)(a1 + 0x58e0) = 0x2af60;
    *(char *)(a1 + 0x58ec) = (char)&g33;
    *(char *)(a1 + 0x58ed) = (char)&g1;
    int64_t result; // 0xc53
    return result;
}

// Address range: 0xc71 - 0xc8c
int64_t function_c71(int64_t a1) {
    // 0xc71
    *(int64_t *)(a1 + 0x58e0) = 0x2af60;
    *(char *)(a1 + 0x58ec) = (char)&g33;
    *(char *)(a1 + 0x58ed) = (char)&g25;
    int64_t result; // 0xc71
    return result;
}

// Address range: 0xc8c - 0xca7
int64_t function_c8c(int64_t a1) {
    // 0xc8c
    *(int64_t *)(a1 + 0x58e0) = 0x2af60;
    *(char *)(a1 + 0x58ec) = (char)&g1;
    *(char *)(a1 + 0x58ed) = (char)&g33;
    int64_t result; // 0xc8c
    return result;
}

// Address range: 0xca7 - 0xcc2
int64_t function_ca7(int64_t a1) {
    // 0xca7
    *(int64_t *)(a1 + 0x58e0) = 0x2af60;
    *(char *)(a1 + 0x58ec) = (char)&g25;
    *(char *)(a1 + 0x58ed) = (char)&g33;
    int64_t result; // 0xca7
    return result;
}

// Address range: 0xcc2 - 0xcdd
int64_t function_cc2(int64_t a1) {
    // 0xcc2
    *(int64_t *)(a1 + 0x58e0) = (int64_t)&g81;
    *(char *)(a1 + 0x58ec) = (char)&g33;
    *(char *)(a1 + 0x58ed) = (char)&g33;
    int64_t result; // 0xcc2
    return result;
}

// From module:   /root/asv5220\smiDrv.c
// Address range: 0xce4 - 0xd14
// Line range:    862 - 1090
void SmiCalculateMemAddr(int64_t FdoData) {
    // 0xce4
    int64_t v1; // 0xce4
    *(char *)v1 = 2 * (char)v1;
    char * v2 = (char *)(FdoData + 0x58ec); // 0xce8
    *v2 = 0;
    *(char *)(FdoData + 0x58ed) = 0;
    *(int64_t *)(FdoData + 0x58f0) = (int64_t)*v2;
}

// Address range: 0xd14 - 0x1281
int64_t SmiCalculateMemAddr2(int64_t a1) {
    // 0xd14
    mcount();
    uint32_t result = *(int32_t *)(a1 + 0x58e8); // 0xd1d
    if (result < 15) {
        // 0xd2a
        return result;
    }
    int64_t result2 = *(int64_t *)(a1 + 0x5898); // 0x126c
    *(int64_t *)(a1 + 0x58c0) = result2;
    *(int64_t *)(a1 + 0x58c8) = result2;
    return result2;
}

// From module:   /root/asv5220\smiDrv.c
// Address range: 0x1284 - 0x12b4
// Line range:    471 - 547
int64_t SmiUnmapHWResources(int64_t FdoData) {
    // 0x1284
    int64_t v1; // 0x1284
    uint16_t v2 = (int16_t)v1;
    bool v3; // 0x1284
    *(char *)v1 = (char)(128 * (int16_t)v3 | v2 / 2 % 128 | v2 % 256 << (int16_t)&g95);
    char * v4 = (char *)(v1 - 119); // 0x1287
    int64_t v5; // 0x1284
    *v4 = *v4 + (char)v5;
    int64_t result = *(int64_t *)(FdoData + 0x5890); // 0x128f
    *(int64_t *)(FdoData + 0x58a0) = result;
    *(int64_t *)(FdoData + 0x58a8) = result;
    *(int64_t *)(FdoData + 0x58b0) = result;
    *(int64_t *)(FdoData + 0x58b8) = result;
    return result;
}

// Address range: 0x12b4 - 0x1353
int64_t SmiUnmapHWResources2(int64_t a1) {
    // 0x12b4
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x5818); // 0x12d8
    int64_t v2 = *(int64_t *)(a1 + 0x5808); // 0x12df
    free_irq(v2, v1);
    if (*(int64_t *)(a1 + 0x5890) == 0) {
        SmiMapHWResources(v2, (char *)v1);
    }
    int64_t v3 = *(int64_t *)(a1 + 0x57f0); // 0x1305
    int64_t result = v3; // 0x1340
    if ((v3 & 512) == 0) {
        // 0x1342
        result = warn_slowpath_null(0, 154);
    }
    // 0x1353
    return result;
}

// From module:   /root/asv5220\smiDrv.c
// Address range: 0x1355 - 0x136a
// Line range:    191 - 218
int64_t SmiFreeDeviceResources(int64_t pFdoData) {
    // 0x1355
    int64_t v1; // 0x1355
    char * v2 = (char *)(v1 - 123); // 0x1355
    int64_t v3; // 0x1355
    *v2 = *v2 | (char)v3;
    return __asm_int1();
}

// From module:   /root/asv5220\smiDrv.c
// Address range: 0x136a - 0x1385
// Line range:    227 - 417
int64_t SmiMapHWResources(int64_t FdoData, char * Irp) {
    // 0x136a
    return &g1;
}

// Address range: 0x1385 - 0x139a
int64_t SmiFreeDeviceResources2(void) {
    // 0x1385
    mcount();
    int64_t v1; // 0x1385
    SmiUnmapHWResources2(v1);
    return &g1;
}

// Address range: 0x139a - 0x14b3
int64_t SmiMapHWResources2(int64_t a1) {
    // 0x139a
    mcount();
    smi_disable_interrupt2(a1, 0xffff);
    *(int64_t *)(a1 + 0x5818) = a1;
    request_threaded_irq(*(int64_t *)(a1 + 0x5808), 0, 0, 128, 0, a1);
    int64_t v1 = *(int64_t *)(a1 + 0x57f0); // 0x13f2
    int64_t v2; // 0x139a
    switch (v1) {
        case 0: {
        }
        case -144: {
            // 0x141e
            v2 = g83;
            // break -> 0x142c
            break;
        }
        default: {
            int64_t v3 = *(int64_t *)(v1 + 592); // 0x140a
            v2 = v3 == 0 ? g83 : v3;
            // break -> 0x142c
            break;
        }
    }
    int64_t result = *(int64_t *)v2; // 0x1446
    *(int64_t *)(a1 + 0x5890) = result;
    *(char *)(a1 + 0x58f9) = (char)&g1;
    *(char *)(a1 + 0x58fb) = (char)&g1;
    return result;
}

// From module:   /root/asv5220\smiDrv.c
// Address range: 0x14bb - 0x14de
// Line range:    162 - 180
int64_t SmiInitializeDeviceExtension(int64_t FdoData) {
    // 0x14bb
    int64_t v1; // 0x14bb
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x14bb
    char * v3 = (char *)(v2 + 0x58edbb); // 0x14bd
    *v3 = *v3 + (char)v2;
    char v4 = *(char *)&v2 + (char)v2; // 0x14c3
    *(char *)v2 = v4;
    if (v4 != 0) {
        // 0x14c7
        int64_t v5; // 0x14bb
        *(int64_t *)(v5 + 0x5950) = 0;
    }
    // 0x14d2
    return &g1;
}

// From module:   /root/asv5220\smiDrv.c
// Address range: 0x14e0 - 0x14eb
// Line range:    113 - 151
int64_t SmiDrvStartDevice(int64_t FdoData, char * Irp) {
    // 0x14e0
    int64_t v1; // 0x14e0
    int32_t * v2 = (int32_t *)(v1 + 88);
    bool v3; // 0x14e0
    *v2 = *v2 + (int32_t)v3;
    int64_t result; // 0x14e0
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    return result;
}

// Address range: 0x14eb - 0x1510
int64_t SmiInitializeDeviceExtension2(void) {
    // 0x14eb
    mcount();
    NT_SUCCESS2(0);
    return 0;
}

// Address range: 0x1510 - 0x154f
int64_t SmiDrvStartDevice2(int64_t a1, int64_t a2) {
    // 0x1510
    mcount();
    uint64_t v1 = SmiGetDeviceInformation2(); // 0x152f
    int64_t result = NT_SUCCESS2(v1 % 256); // 0x153a
    *(int32_t *)(a1 + 0x58e8) = (int32_t)&g103;
    return result;
}

// From module:   /root/asv5220\smiCommon.c
// Address range: 0x1550 - 0x155d
// Line range:    49 - 52
char NT_SUCCESS(char success_value) {
    // 0x1550
    int64_t v1; // 0x1550
    return SmiCalculateTotalMemSize2(&v1);
}

// From module:   /root/asv5220\smiCommon.c
// Address range: 0x155d - 0x1570
// Line range:    145 - 176
char storageBufferPrioritySet(int64_t storageBuffer, char priority) {
    uint64_t result = SmiMapHWResources2(storageBuffer); // 0x155d
    NT_SUCCESS2(result % 256);
    return result;
}

// From module:   /root/asv5220\smiCommon.c
// Address range: 0x1571 - 0x157e
// Line range:    121 - 142
char storageBufferClean(int64_t storageBuffer) {
    // 0x1571
    int64_t result; // 0x1571
    return result;
}

// Address range: 0x1580 - 0x158d
int64_t NT_SUCCESS2(int64_t a1) {
    // 0x1580
    mcount();
    return a1 & 0xffffffff;
}

// Address range: 0x158d - 0x15a1
int64_t storageBufferPrioritySet2(int64_t a1, int64_t a2) {
    // 0x158d
    mcount();
    *(char *)(a1 + 40) = (char)a2;
    return &g1;
}

// Address range: 0x15a1 - 0x15aa
int64_t storageBufferClean2(void) {
    // 0x15a1
    int64_t result; // 0x15a1
    return result;
}

// From module:   /root/asv5220\smiCommon.c
// Address range: 0x15ad - 0x15dd
// Line range:    98 - 119
char storageBufferFlush(int64_t storageBuffer) {
    // 0x15ad
    kfree(storageBuffer);
    *(int64_t *)storageBuffer = 0;
    *(int64_t *)(storageBuffer + (int64_t)&g95) = 0;
    *(int64_t *)(storageBuffer + (int64_t)&g2) = 0;
    return &g1;
}

// Address range: 0x15dd - 0x15ee
int64_t storageBufferFlush2(int64_t a1) {
    // 0x15dd
    return mcount();
}

// From module:   /root/asv5220\smiCommon.c
// Address range: 0x15ee - 0x161e
// Line range:    55 - 96
char storageBuffInitialize(int64_t storageBuffer, int64_t initializeSize, int64_t storageBuffTag) {
    // 0x15ee
    memset(storageBuffer, 0, *(int64_t *)(storageBuffer + (int64_t)&g26));
    int64_t v1; // 0x15ee
    *(int64_t *)(v1 + (int64_t)&g13) = 0;
    return &g1;
}

// Address range: 0x161e - 0x1656
int64_t storageBuffInitialize2(int64_t a1, int64_t a2) {
    // 0x161e
    mcount();
    *(int64_t *)a1 = 0;
    *(int64_t *)(a1 + (int64_t)&g13) = 0;
    *(int64_t *)(a1 + (int64_t)&g26) = a2;
    *(char *)(a1 + 40) = 0;
    int64_t v1; // 0x161e
    return __kmalloc(a2, (int64_t *)208, v1);
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x1658 - 0x1667
// Line range:    82 - 111
int64_t FUSBDTV_ProcessSysControlIrp(char * DeviceObject, char * Irp) {
    // 0x1658
    int64_t result; // 0x1658
    return result;
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x1668 - 0x1678
// Line range:    1235 - 1349
int64_t FUSBDTV_SetPowerUSBDevice(char * Irp, char * FunctionalDeviceObject, int64_t deviceExtension) {
    // 0x1668
    int64_t v1; // 0x1668
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x1668
    int64_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    memset((int64_t)Irp, (int64_t)FunctionalDeviceObject, deviceExtension);
    int64_t result; // 0x1668
    return result;
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x1678 - 0x1688
// Line range:    1904 - 1950
int64_t FUSBDTV_Query_Capabilities(int64_t Device, char * Irp, char * Capabilities) {
    // 0x1678
    return &g1;
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x1688 - 0x1698
// Line range:    1880 - 1902
void AsicenFreeStreamBuffer(int64_t StreamObject) {
    // 0x1688
    mcount();
}

// Address range: 0x1698 - 0x16a8
int64_t FUSBDTV_SetPowerUSBDevice2(void) {
    // 0x1698
    mcount();
    return &g1;
}

// Address range: 0x16a8 - 0x16b8
int64_t FUSBDTV_Query_Capabilities2(void) {
    // 0x16a8
    mcount();
    return &g1;
}

// Address range: 0x16b8 - 0x16c9
int64_t AsicenFreeStreamBuffer2(int64_t a1) {
    // 0x16b8
    return mcount();
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x16ca - 0x16fa
// Line range:    1527 - 1602
int64_t AsicenAllocateStreamBuffer(int64_t deviceExtension, char DataStream_Num, int64_t TransferObjBufSize, int64_t StreamBufSize) {
    int64_t v1 = DataStream_Num;
    int32_t v2 = *(int32_t *)(deviceExtension + 224); // 0x16ca
    if (v2 != 0) {
        // 0x16d5
        FUSB_ExFreePool2(v2, v1);
    }
    // 0x16da
    int64_t v3; // 0x16ca
    int64_t v4 = *(int64_t *)(v3 + 304); // 0x16da
    if (v4 != 0) {
        // 0x16e6
        FUSB_ExFreePool2((int32_t)v4, v1);
    }
    // 0x16eb
    return FUSB_ExFreePool2((int32_t)v3, v1);
}

// Address range: 0x16fa - 0x18c4
int64_t AsicenAllocateStreamBuffer2(int64_t a1, int64_t a2, uint64_t a3, uint64_t a4) {
    // 0x16fa
    mcount();
    int64_t v1 = FUSB_ExAllocatePool2(0, 440); // 0x1764
    __asm_rep_stosq_memset((char *)v1, 0, 55);
    unsigned char v2 = (char)a2; // 0x1785
    char * v3; // 0x16fa
    if (v2 > (char)&g94) {
        // 0x178f
        *(int64_t *)(v1 + 232) = 0x598080;
        *(int64_t *)(v1 + 224) = FUSB_ExAllocatePool2(0, 0x598080);
        *(int64_t *)(v1 + 296) = 0;
        *(int64_t *)(v1 + 288) = 0;
        *(int64_t *)(v1 + 280) = 0;
        *(int64_t *)(v1 + 312) = (int64_t)&g81;
        *(int64_t *)(v1 + 304) = FUSB_ExAllocatePool2(0, (int64_t)&g81);
        *(int64_t *)(v1 + 336) = 0;
        *(int64_t *)(v1 + 328) = 0;
        *(int64_t *)(v1 + 320) = 0;
        v3 = (char *)(v1 + 128);
    } else {
        int64_t v4 = a4 < 0x92e1 == a3 < 513 == a4 != 0 == a3 - 1 < a4 >> (int64_t)&g1 ? 512 * a4 : 0x125c000; // 0x181b
        *(int64_t *)(v1 + 232) = v4;
        *(int64_t *)(v1 + 224) = FUSB_ExAllocatePool2(0, v4);
        *(int64_t *)(v1 + 296) = 0;
        *(int64_t *)(v1 + 288) = 0;
        *(int64_t *)(v1 + 280) = 0;
        int64_t v5 = a4 < 0x92e1 == a3 < 513 == a4 != 0 == a3 - 1 < a4 >> (int64_t)&g1 ? 2048 * a3 : 0x100000; // 0x185b
        *(int64_t *)(v1 + 312) = v5;
        *(int64_t *)(v1 + 304) = FUSB_ExAllocatePool2(0, v5);
        *(int64_t *)(v1 + 336) = 0;
        *(int64_t *)(v1 + 328) = 0;
        *(int64_t *)(v1 + 320) = 0;
        *(int64_t *)(a1 + 1160 + (8 * a2 & 2040)) = v1;
        char * v6 = (char *)(v1 + 128);
        *v6 = v2;
        v3 = v6;
    }
    // 0x18ab
    *(int64_t *)(a1 + 1224) = v1;
    *v3 = (char)&g95;
    return &g1;
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x18c5 - 0x18f5
// Line range:    1419 - 1525
int64_t FUSBDTV_GetCusGUIDInfo(int64_t deviceExtension) {
    // 0x18c5
    int64_t result; // 0x18c5
    int32_t * v1 = (int32_t *)(result + (int64_t)&g1); // 0x18c5
    bool v2; // 0x18c5
    *v1 = (int32_t)v2 - (int32_t)deviceExtension + *v1;
    int64_t v3; // 0x18c5
    if ((char)v3 == (char)&g97) {
        // 0x18d1
        int64_t v4; // 0x18c5
        *(char *)(v4 + 128) = (char)&g97;
    }
    // 0x18df
    return result;
}

// Address range: 0x18f5 - 0x1906
int64_t FUSBDTV_GetCusGUIDInfo2(int64_t a1) {
    // 0x18f5
    return mcount();
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x1908 - 0x1938
// Line range:    1961 - 2252
int64_t FUSBDTV_Start(int64_t deviceExtension) {
    // 0x1908
    int64_t v1; // 0x1908
    int64_t v2 = v1 & -0xff01 | 0x7000; // 0x1908
    int64_t v3; // 0x1908
    *(char *)v3 = 2 * (char)v3;
    int64_t v4; // 0x1908
    int64_t result = FUSBDTV_Cmd_GetCusInfo2(deviceExtension, v4); // 0x190d
    if (result != (int64_t)&g1 || *(char *)(v2 + 0x4f70) != 1) {
        // 0x1921
        *(char *)(v2 + 0x4faa) = 0;
        // 0x1931
        return result;
    }
    // 0x192a
    *(char *)(v2 + 0x4faa) = (char)&g1;
    // 0x1931
    return result;
}

// Address range: 0x1938 - 0x1d27
int64_t FUSBDTV_Start2(int64_t a1) {
    // 0x1938
    mcount();
    NT_SUCCESS2(GetPCIBusInterfaceStandard2(*(int64_t *)(a1 + 0x57a0), a1 + 0x5814) % 256);
    SmiDrvStartDevice2(a1, 0);
    *(char *)(a1 + 200) = 0;
    *(char *)(a1 + 0x590a) = 0;
    int64_t v1 = Hardware_Init2(a1); // 0x19ad
    RegisterInitialize2(a1);
    FUSBDTV_GetCusGUIDInfo2(a1);
    FUSBDTV_Cmd_Set_GPIO2(a1, (int64_t *)&g95, 255);
    FUSBDTV_Cmd_Set_GPIO_Ex2(a1, 0, (int64_t *)&g25);
    TLIB_SetGPIOEx2(a1, (int64_t *)&g1, (int64_t *)&g1);
    int64_t v2 = v1 & -256; // 0x1a12
    int64_t v3 = a1 + 0x5960; // 0x1a12
    TC_PowerTunerDemod2(a1, v2 & 0xffffffff, 0, v3);
    int64_t v4 = v2 + (int64_t)(int32_t)&g1; // 0x1a28
    v2 = v4 & 0xffffffff;
    v3 += 80;
    while ((int32_t)v4 != (int32_t)&g95) {
        // 0x1a15
        TC_PowerTunerDemod2(a1, v2 & 0xffffffff, 0, v3);
        v4 = v2 + (int64_t)(int32_t)&g1;
        v2 = v4 & 0xffffffff;
        v3 += 80;
    }
    // 0x1a36
    *(char *)(a1 + 0x3e68) = (char)&g1;
    int64_t * v5 = (int64_t *)(a1 + 0x6208); // 0x1a3d
    *v5 = 2368;
    int64_t * v6 = (int64_t *)(a1 + 0x6210); // 0x1a48
    *v6 = 2372;
    int64_t * v7 = (int64_t *)(a1 + 0x6218); // 0x1a53
    *v7 = 2376;
    int64_t * v8 = (int64_t *)(a1 + (int64_t)&g92); // 0x1a5e
    *v8 = 2380;
    int64_t * v9 = (int64_t *)(a1 + 0x6228); // 0x1a69
    *v9 = 2384;
    int64_t * v10 = (int64_t *)(a1 + 0x6230); // 0x1a74
    *v10 = 2388;
    int64_t * v11 = (int64_t *)(a1 + 0x6238); // 0x1a7f
    *v11 = 2400;
    int64_t * v12 = (int64_t *)(a1 + 0x6240); // 0x1a8a
    *v12 = 2432;
    int64_t * v13 = (int64_t *)(a1 + 0x6248); // 0x1a95
    *v13 = 2436;
    int64_t * v14 = (int64_t *)(a1 + 0x6250); // 0x1aa0
    *v14 = 2440;
    int64_t * v15 = (int64_t *)(a1 + 0x6258); // 0x1aab
    *v15 = 2444;
    int64_t * v16 = (int64_t *)(a1 + 0x6260); // 0x1ab6
    *v16 = 2448;
    int64_t * v17 = (int64_t *)(a1 + 0x6268); // 0x1ac1
    *v17 = 2452;
    int64_t * v18 = (int64_t *)(a1 + 0x6270); // 0x1acc
    *v18 = 2464;
    int64_t * v19 = (int64_t *)(a1 + 0x6278); // 0x1ad7
    *v19 = 2752;
    int64_t * v20 = (int64_t *)(a1 + 0x6280); // 0x1ae2
    *v20 = 2756;
    int64_t * v21 = (int64_t *)(a1 + 0x6288); // 0x1aed
    *v21 = 2760;
    int64_t * v22 = (int64_t *)(a1 + 0x6290); // 0x1af8
    *v22 = 2764;
    int64_t * v23 = (int64_t *)(a1 + 0x6298); // 0x1b03
    *v23 = 2768;
    int64_t * v24 = (int64_t *)(a1 + 0x62a0); // 0x1b0e
    *v24 = 2772;
    int64_t * v25 = (int64_t *)(a1 + 0x62a8); // 0x1b19
    *v25 = 2776;
    int64_t * v26 = (int64_t *)(a1 + 0x62b0); // 0x1b24
    *v26 = 2780;
    int64_t * v27 = (int64_t *)(a1 + 0x62b8); // 0x1b2f
    *v27 = 2784;
    int64_t * v28 = (int64_t *)(a1 + 0x62c0); // 0x1b3a
    *v28 = 3072;
    int64_t * v29 = (int64_t *)(a1 + 0x62c8); // 0x1b45
    *v29 = 3076;
    int64_t * v30 = (int64_t *)(a1 + 0x62d0); // 0x1b50
    *v30 = 3080;
    int64_t * v31 = (int64_t *)(a1 + 0x62d8); // 0x1b5b
    *v31 = 3084;
    int64_t * v32 = (int64_t *)(a1 + 0x62e0); // 0x1b66
    *v32 = 3088;
    int64_t * v33 = (int64_t *)(a1 + 0x62e8); // 0x1b71
    *v33 = 3092;
    int64_t * v34 = (int64_t *)(a1 + 0x62f0); // 0x1b7c
    *v34 = 3096;
    int64_t * v35 = (int64_t *)(a1 + 0x62f8); // 0x1b87
    *v35 = 3100;
    int64_t * v36 = (int64_t *)(a1 + 0x6300); // 0x1b92
    *v36 = 3104;
    int64_t v37; // bp-57, 0x1938
    int64_t result = TLIB_I2C_Read2(a1, 160, 0, &v37, (int64_t *)&g1, 0); // 0x1bba
    if ((char)result == 0) {
        // 0x1bc7
        *v5 = 2688;
        *v6 = 2692;
        *v7 = 2696;
        *v8 = 2700;
        *v9 = 2704;
        *v10 = 2708;
        *v11 = 2720;
        *v12 = 3008;
        *v13 = 3012;
        *v14 = 3016;
        *v15 = 3020;
        *v16 = 3024;
        *v17 = 3028;
        *v18 = 3040;
        *v19 = 3328;
        *v20 = 3332;
        *v21 = 3336;
        *v22 = 3340;
        *v23 = 3344;
        *v24 = 3348;
        *v25 = 3352;
        *v26 = 3356;
        *v27 = (int64_t)&g101;
        *v28 = 3392;
        *v29 = 3396;
        *v30 = 3400;
        *v31 = 3404;
        *v32 = (int64_t)&g102;
        *v33 = 3412;
        *v34 = 3416;
        *v35 = 3420;
        *v36 = 3424;
    }
    // 0x1d27
    return result;
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x1d2a - 0x1d5a
// Line range:    1198 - 1231
int64_t FUSBDTV_RemoveUSBDevice(int64_t deviceExtension) {
    // 0x1d2a
    int64_t v1; // 0x1d2a
    int64_t v2; // 0x1d2a
    *(char *)v1 = (char)v2 + (char)v1;
    int64_t v3; // 0x1d2a
    TC_Preset2(v3);
    int64_t result; // 0x1d2a
    return result;
}

// Address range: 0x1d5a - 0x1d7c
int64_t FUSBDTV_RemoveUSBDevice2(int64_t a1) {
    // 0x1d5a
    mcount();
    return FUSB_IncrementIoCount2(0);
}

// Address range: 0x1d8a - 0x1d8b
int64_t function_1d8a(void) {
    // 0x1d8a
    int64_t result; // 0x1d8a
    return result;
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x1d8c - 0x1dbc
// Line range:    2296 - 2412
void FUSBDTV_Remove(int64_t deviceExtension) {
    // 0x1d8c
    FUSB_DecrementIoCount2(0);
    int64_t v1; // 0x1d8c
    *(char *)(v1 + 200) = (char)&g1;
    FUSB_DecrementIoCount2(0);
}

// Address range: 0x1dbc - 0x1f0e
int64_t FUSBDTV_Remove2(int64_t a1) {
    // 0x1dbc
    mcount();
    Hardware_RemoveDevice2();
    FUSBDTV_RemoveUSBDevice2(a1);
    int64_t v1 = a1 + (int64_t)&g87; // 0x1de4
    int64_t v2 = 0;
    int64_t v3 = *(int64_t *)(v2 * (int64_t)&g1 + v1); // 0x1de4
    DTV_PollingThreadClose2(v3);
    DTV_PollingWDThreadClose2(v3);
    ASV5220_BcasThreadClose2(v3);
    int64_t v4 = v2 + (int64_t)&g95; // 0x1e04
    while (v2 != 64 - (int64_t)&g95) {
        // 0x1de4
        v2 = v4;
        v3 = *(int64_t *)(v2 * (int64_t)&g1 + v1);
        DTV_PollingThreadClose2(v3);
        DTV_PollingWDThreadClose2(v3);
        ASV5220_BcasThreadClose2(v3);
        v4 = v2 + (int64_t)&g95;
    }
    // 0x1e0e
    DTV_PollingDeviceThreadClose2(a1);
    int64_t v5 = 0; // bp-48, 0x1e16
    StoreDeviceLNBPower2(a1, 0, &v5);
    int64_t * v6 = (int64_t *)(a1 + 1224); // 0x1e31
    AsicenFreeStreamBuffer2(*v6);
    *v6 = 0;
    int64_t * v7 = (int64_t *)(a1 + 1232); // 0x1e48
    AsicenFreeStreamBuffer2(*v7);
    *v7 = 0;
    int64_t v8 = v4 & -256;
    int64_t * v9 = (int64_t *)(a1 + 0x59a0 + v8); // 0x1e62
    int64_t v10 = *v9; // 0x1e62
    if (v10 != 0) {
        // 0x1e6f
        FUSB_ExFreePool2((int32_t)v10, 0);
        *v9 = 0;
    }
    int64_t v11 = v8 + 80; // 0x1e80
    while (v8 != 560) {
        // 0x1e62
        v8 = v11;
        v9 = (int64_t *)(a1 + 0x59a0 + v8);
        v10 = *v9;
        if (v10 != 0) {
            // 0x1e6f
            FUSB_ExFreePool2((int32_t)v10, 0);
            *v9 = 0;
        }
        // 0x1e80
        v11 = v8 + 80;
    }
    int64_t v12 = v11 & -0x10000;
    int64_t v13 = v12 + a1;
    int64_t * v14 = (int64_t *)(v13 + 1160); // 0x1e92
    int64_t v15 = *v14; // 0x1e92
    if (v15 != 0) {
        // 0x1e9f
        AsicenFreeStreamBuffer2(v15);
        *v14 = 0;
    }
    int64_t * v16 = (int64_t *)(v13 + 0x60e8); // 0x1eb0
    int64_t v17 = *v16; // 0x1eb0
    if (v17 != 0) {
        // 0x1ebd
        FUSB_ExFreePool2((int32_t)v17, 0);
        *v16 = 0;
    }
    int64_t v18 = v12 + (int64_t)&g95; // 0x1ece
    while (v12 != 64 - (int64_t)&g95) {
        // 0x1e92
        v12 = v18;
        v13 = v12 + a1;
        v14 = (int64_t *)(v13 + 1160);
        v15 = *v14;
        if (v15 != 0) {
            // 0x1e9f
            AsicenFreeStreamBuffer2(v15);
            *v14 = 0;
        }
        // 0x1eb0
        v16 = (int64_t *)(v13 + 0x60e8);
        v17 = *v16;
        if (v17 != 0) {
            // 0x1ebd
            FUSB_ExFreePool2((int32_t)v17, 0);
            *v16 = 0;
        }
        // 0x1ece
        v18 = v12 + (int64_t)&g95;
    }
    int64_t v19 = v18 & -256; // 0x1ed8
    FUSB_ExFreePool2((int32_t)*(int64_t *)(v19 + v1), 0);
    while (v19 != 64 - (int64_t)&g95) {
        // 0x1edb
        v19 += (int64_t)&g95;
        FUSB_ExFreePool2((int32_t)*(int64_t *)(v19 + v1), 0);
    }
    int64_t result = g74 != a1 ? (int64_t)&g1 : (int64_t)&g1 & -256;
    return result;
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x1f0f - 0x1f3f
// Line range:    1167 - 1195
int64_t FUSBDTV_StopUSBDevice(int64_t deviceExtension) {
    // 0x1f0f
    int64_t v1; // 0x1f0f
    char * v2 = (char *)(v1 - 104); // 0x1f0f
    int64_t v3; // 0x1f0f
    bool v4; // 0x1f0f
    *v2 = *v2 + (char)v3 + (char)v4;
    *(int64_t *)(v1 * (int64_t)&g95) = 0;
    int64_t v5; // 0x1f0f
    int64_t v6; // 0x1f0f
    return FUSB_ExFreePool2((int32_t)v6, v5);
}

// Address range: 0x1f3f - 0x1f5e
int64_t FUSBDTV_StopUSBDevice2(int64_t a1) {
    // 0x1f3f
    mcount();
    return FUSB_IncrementIoCount2(0);
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x1f60 - 0x1f76
// Line range:    2260 - 2288
void FUSBDTV_Stop(int64_t deviceExtension) {
    // 0x1f60
    int64_t v1; // 0x1f60
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x1f60
    char * v3 = (char *)(v2 - 0x1076b322); // 0x1f62
    *v3 = *v3 + (char)v2;
    int64_t v4; // 0x1f60
    FUSBDTV_StopBulkStream2(deviceExtension, v4);
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x1f77 - 0x1f79
// Line range:    1138 - 1144
void FUSBDTV_SetFakeDeviceObj(char * FunctionalDeviceObject, int64_t deviceExtension, char * FakeDeviceObject) {
    // 0x1f77
    return;
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x1f88 - 0x1f90
// Line range:    1146 - 1164
int64_t FUSBDTV_StartUSBDevice(char * FunctionalDeviceObject, int64_t deviceExtension) {
    // 0x1f88
    int64_t v1; // 0x1f88
    char * v2 = (char *)(v1 + 65); // 0x1f88
    *v2 = *v2 | (char)v1;
    int64_t result; // 0x1f88
    return result;
}

// Address range: 0x1f90 - 0x1fa7
int64_t FUSBDTV_Stop2(int64_t a1) {
    // 0x1f90
    mcount();
    *(char *)(a1 + 0x6308) = 0;
    return FUSBDTV_StopUSBDevice2(a1);
}

// Address range: 0x1fa7 - 0x1fb8
int64_t FUSBDTV_SetFakeDeviceObj2(int64_t result, int64_t a2, int64_t a3) {
    // 0x1fa7
    mcount();
    *(int64_t *)a3 = result;
    return result;
}

// Address range: 0x1fb8 - 0x1ff2
int64_t FUSBDTV_StartUSBDevice2(int64_t a1, int64_t a2) {
    // 0x1fb8
    mcount();
    return FUSB_ExAllocatePool2(0, (int64_t)&g93);
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x1ff2 - 0x2022
// Line range:    802 - 1136
int64_t FUSBDTV_AddUSBDevice(char * FunctionalDeviceObject, char * NextDeviceObject, char * PhysicalDeviceObject, int64_t deviceExtension) {
    int64_t v1 = (int64_t)NextDeviceObject;
    FUSBDTV_SetFakeDeviceObj2((int64_t)FunctionalDeviceObject, v1, (int64_t)PhysicalDeviceObject);
    int64_t v2; // 0x1ff2
    FUSB_IncrementIoCount2(v2);
    FUSB_DecrementIoCount2(v2);
    FUSB_ExFreePool2((int32_t)v2, v1);
    return &g1;
}

// Address range: 0x2022 - 0x3010
int64_t FUSBDTV_AddUSBDevice2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x2022
    mcount();
    __readgsqword(40);
    uint64_t v1 = FUSB_CreateDeviceObject2(0, a3, 0, a4, (int64_t *)&g1); // 0x205a
    if ((char)NT_SUCCESS2(v1 % 256) != 0) {
        // 0x2072
        *(int64_t *)(a4 + 184) = 0;
        char v2 = -75; // bp-40, 0x207d
        char v3 = -85; // bp-56, 0x209d
        char v4 = -118; // bp-72, 0x20bd
        int64_t v5 = &v2; // 0x20e9
        int64_t v6 = 0;
        int64_t v7 = 0; // 0x213c
        int64_t v8 = v6; // 0x213c
        int64_t v9 = a4 + 472 + v6; // 0x213c
        char v10 = *(char *)v8; // 0x20ef
        char v11 = *(char *)(v7 * (int64_t)&g1 + v5); // 0x20f5
        *(char *)v9 = v10 - (char)v7 ^ v11;
        v7 += (int64_t)&g1;
        v8 += (int64_t)&g1;
        v9++;
        while (v7 != (int64_t)&g95) {
            // 0x20ef
            v10 = *(char *)v8;
            v11 = *(char *)(v7 * (int64_t)&g1 + v5);
            *(char *)v9 = v10 - (char)v7 ^ v11;
            v7 += (int64_t)&g1;
            v8 += (int64_t)&g1;
            v9++;
        }
        int64_t v12 = v6 + (int64_t)&g95; // 0x210e
        while (v6 != 192 - (int64_t)&g95) {
            // 0x212a
            v6 = v12;
            v7 = 0;
            v8 = v6;
            v9 = a4 + 472 + v6;
            v10 = *(char *)v8;
            v11 = *(char *)(v7 * (int64_t)&g1 + v5);
            *(char *)v9 = v10 - (char)v7 ^ v11;
            v7 += (int64_t)&g1;
            v8 += (int64_t)&g1;
            v9++;
            while (v7 != (int64_t)&g95) {
                // 0x20ef
                v10 = *(char *)v8;
                v11 = *(char *)(v7 * (int64_t)&g1 + v5);
                *(char *)v9 = v10 - (char)v7 ^ v11;
                v7 += (int64_t)&g1;
                v8 += (int64_t)&g1;
                v9++;
            }
            // 0x210e
            v12 = v6 + (int64_t)&g95;
        }
        int64_t v13 = &v3; // 0x2124
        int64_t v14 = v12 & -256; // 0x2128
        int64_t v15 = 0; // 0x2188
        int64_t v16 = v14; // 0x2188
        int64_t v17 = a4 + 664 + v14; // 0x2188
        char v18 = *(char *)v16; // 0x213e
        char v19 = *(char *)(v15 * (int64_t)&g1 + v13); // 0x2144
        *(char *)v17 = v18 - (char)v15 ^ v19;
        v15 += (int64_t)&g1;
        v16 += (int64_t)&g1;
        v17++;
        while (v15 != (int64_t)&g95) {
            // 0x213e
            v18 = *(char *)v16;
            v19 = *(char *)(v15 * (int64_t)&g1 + v13);
            *(char *)v17 = v18 - (char)v15 ^ v19;
            v15 += (int64_t)&g1;
            v16 += (int64_t)&g1;
            v17++;
        }
        int64_t v20 = v14 + (int64_t)&g95; // 0x215d
        v14 = v20;
        while (v20 != (int64_t)&g26) {
            // 0x2176
            v15 = 0;
            v16 = v14;
            v17 = a4 + 664 + v14;
            v18 = *(char *)v16;
            v19 = *(char *)(v15 * (int64_t)&g1 + v13);
            *(char *)v17 = v18 - (char)v15 ^ v19;
            v15 += (int64_t)&g1;
            v16 += (int64_t)&g1;
            v17++;
            while (v15 != (int64_t)&g95) {
                // 0x213e
                v18 = *(char *)v16;
                v19 = *(char *)(v15 * (int64_t)&g1 + v13);
                *(char *)v17 = v18 - (char)v15 ^ v19;
                v15 += (int64_t)&g1;
                v16 += (int64_t)&g1;
                v17++;
            }
            // 0x215d
            v20 = v14 + (int64_t)&g95;
            v14 = v20;
        }
        int64_t v21 = &v4; // 0x2170
        int64_t v22 = v20 & -256;
        int64_t v23 = 0; // 0x21c8
        int64_t v24 = v22; // 0x21c8
        int64_t v25 = a4 + 696 + v22; // 0x21c8
        char v26 = *(char *)v24; // 0x218a
        char v27 = *(char *)(v23 * (int64_t)&g1 + v21); // 0x2190
        *(char *)v25 = v26 - (char)v23 ^ v27;
        v23 += (int64_t)&g1;
        v24 += (int64_t)&g1;
        v25++;
        while (v23 != (int64_t)&g95) {
            // 0x218a
            v26 = *(char *)v24;
            v27 = *(char *)(v23 * (int64_t)&g1 + v21);
            *(char *)v25 = v26 - (char)v23 ^ v27;
            v23 += (int64_t)&g1;
            v24 += (int64_t)&g1;
            v25++;
        }
        int64_t v28 = v22 + (int64_t)&g95; // 0x21b4
        while (v22 != 192 - (int64_t)&g95) {
            // 0x21b6
            v22 = v28;
            v23 = 0;
            v24 = v22;
            v25 = a4 + 696 + v22;
            v26 = *(char *)v24;
            v27 = *(char *)(v23 * (int64_t)&g1 + v21);
            *(char *)v25 = v26 - (char)v23 ^ v27;
            v23 += (int64_t)&g1;
            v24 += (int64_t)&g1;
            v25++;
            while (v23 != (int64_t)&g95) {
                // 0x218a
                v26 = *(char *)v24;
                v27 = *(char *)(v23 * (int64_t)&g1 + v21);
                *(char *)v25 = v26 - (char)v23 ^ v27;
                v23 += (int64_t)&g1;
                v24 += (int64_t)&g1;
                v25++;
            }
            // 0x21a9
            v28 = v22 + (int64_t)&g95;
        }
    }
    int32_t v29 = -0x6b61a8eb; // bp-184, 0x21ca
    int32_t v30 = 0xd789920; // bp-200, 0x21f2
    int32_t v31 = -0x7e1793eb; // bp-216, 0x221a
    int32_t v32 = 0x1fe22bfc; // bp-232, 0x2242
    int32_t v33 = 0x5c1f2a50; // bp-248, 0x226a
    int32_t v34 = -0x2c2d323; // bp-264, 0x2292
    int32_t v35 = 0x65603cf9; // bp-280, 0x22ba
    int32_t v36 = 0x279c78dc; // bp-296, 0x22e2
    int32_t v37 = -0x7ad1f764; // bp-312, 0x230a
    int32_t v38 = 0x296fb2b4; // bp-328, 0x2332
    int64_t v39 = 0; // 0x2370
    int32_t * v40 = (int32_t *)(v39 * (int64_t)&g86); // 0x2377
    int32_t v41 = v39; // 0x237a
    int64_t v42 = 4 * v39 + a4;
    *(int32_t *)(v42 + 0x36e8) = *v40 - v41 ^ 0x6c0891dd;
    *(int32_t *)(v42 + 0x36ec) = *v40 - v41 ^ -0xc44b119;
    v39 += (int64_t)&g25;
    while (v39 != (int64_t)&g98) {
        // 0x2377
        v40 = (int32_t *)(v39 * (int64_t)&g86);
        v41 = v39;
        v42 = 4 * v39 + a4;
        *(int32_t *)(v42 + 0x36e8) = *v40 - v41 ^ 0x6c0891dd;
        *(int32_t *)(v42 + 0x36ec) = *v40 - v41 ^ -0xc44b119;
        v39 += (int64_t)&g25;
    }
    int64_t v43 = &v29; // 0x23af
    int64_t v44 = 0;
    int64_t v45 = 0; // 0x2407
    int64_t v46 = v44 * (int64_t)&g86; // 0x2407
    int64_t v47 = a4 + 3816 + 4 * v44; // 0x2407
    int32_t v48 = *(int32_t *)v46; // 0x23b8
    int32_t v49 = *(int32_t *)(v45 * (int64_t)&g86 + v43); // 0x23bc
    *(int32_t *)v47 = v48 - (int32_t)v44 ^ v49;
    v45 += (int64_t)&g1;
    v46 += (int64_t)&g86;
    v47 += 4;
    while (v45 != (int64_t)&g86) {
        // 0x23b8
        v48 = *(int32_t *)v46;
        v49 = *(int32_t *)(v45 * (int64_t)&g86 + v43);
        *(int32_t *)v47 = v48 - (int32_t)v44 ^ v49;
        v45 += (int64_t)&g1;
        v46 += (int64_t)&g86;
        v47 += 4;
    }
    int64_t v50 = v44 + (int64_t)&g86; // 0x23d4
    while (v44 != 256 - (int64_t)&g86) {
        // 0x23f4
        v44 = v50;
        v45 = 0;
        v46 = v44 * (int64_t)&g86;
        v47 = a4 + 3816 + 4 * v44;
        v48 = *(int32_t *)v46;
        v49 = *(int32_t *)(v45 * (int64_t)&g86 + v43);
        *(int32_t *)v47 = v48 - (int32_t)v44 ^ v49;
        v45 += (int64_t)&g1;
        v46 += (int64_t)&g86;
        v47 += 4;
        while (v45 != (int64_t)&g86) {
            // 0x23b8
            v48 = *(int32_t *)v46;
            v49 = *(int32_t *)(v45 * (int64_t)&g86 + v43);
            *(int32_t *)v47 = v48 - (int32_t)v44 ^ v49;
            v45 += (int64_t)&g1;
            v46 += (int64_t)&g86;
            v47 += 4;
        }
        // 0x23d4
        v50 = v44 + (int64_t)&g86;
    }
    int64_t v51 = &v30; // 0x23eb
    int64_t v52 = v50 & -0x10000;
    int64_t v53 = 0; // 0x2458
    int64_t v54 = v52 * (int64_t)&g86; // 0x2458
    int64_t v55 = a4 + 0x12e8 + 4 * v52; // 0x2458
    int32_t v56 = *(int32_t *)v54; // 0x2409
    int32_t v57 = *(int32_t *)(v53 * (int64_t)&g86 + v51); // 0x240d
    *(int32_t *)v55 = v56 - (int32_t)v52 ^ v57;
    v53 += (int64_t)&g1;
    v54 += (int64_t)&g86;
    v55 += 4;
    while (v53 != (int64_t)&g86) {
        // 0x2409
        v56 = *(int32_t *)v54;
        v57 = *(int32_t *)(v53 * (int64_t)&g86 + v51);
        *(int32_t *)v55 = v56 - (int32_t)v52 ^ v57;
        v53 += (int64_t)&g1;
        v54 += (int64_t)&g86;
        v55 += 4;
    }
    int64_t v58 = v52 + (int64_t)&g86; // 0x2425
    while (v52 != 256 - (int64_t)&g86) {
        // 0x2445
        v52 = v58;
        v53 = 0;
        v54 = v52 * (int64_t)&g86;
        v55 = a4 + 0x12e8 + 4 * v52;
        v56 = *(int32_t *)v54;
        v57 = *(int32_t *)(v53 * (int64_t)&g86 + v51);
        *(int32_t *)v55 = v56 - (int32_t)v52 ^ v57;
        v53 += (int64_t)&g1;
        v54 += (int64_t)&g86;
        v55 += 4;
        while (v53 != (int64_t)&g86) {
            // 0x2409
            v56 = *(int32_t *)v54;
            v57 = *(int32_t *)(v53 * (int64_t)&g86 + v51);
            *(int32_t *)v55 = v56 - (int32_t)v52 ^ v57;
            v53 += (int64_t)&g1;
            v54 += (int64_t)&g86;
            v55 += 4;
        }
        // 0x2425
        v58 = v52 + (int64_t)&g86;
    }
    int64_t v59 = &v31; // 0x243c
    int64_t v60 = v58 & -0x10000;
    int64_t v61 = v60 * (int64_t)&g86; // 0x2496
    int64_t v62 = 0; // 0x24a9
    int64_t v63 = v61; // 0x24a9
    int64_t v64 = a4 + (int64_t)&g11 + v61; // 0x24a9
    int32_t v65 = *(int32_t *)v63; // 0x245a
    int32_t v66 = *(int32_t *)(v62 * (int64_t)&g86 + v59); // 0x245e
    *(int32_t *)v64 = v65 - (int32_t)v60 ^ v66;
    v62 += (int64_t)&g1;
    v63 += (int64_t)&g86;
    v64 += (int64_t)&g86;
    while (v62 != (int64_t)&g86) {
        // 0x245a
        v65 = *(int32_t *)v63;
        v66 = *(int32_t *)(v62 * (int64_t)&g86 + v59);
        *(int32_t *)v64 = v65 - (int32_t)v60 ^ v66;
        v62 += (int64_t)&g1;
        v63 += (int64_t)&g86;
        v64 += (int64_t)&g86;
    }
    int64_t v67 = v60 + (int64_t)&g86; // 0x2476
    while (v60 != 256 - (int64_t)&g86) {
        // 0x2496
        v60 = v67;
        v61 = v60 * (int64_t)&g86;
        v62 = 0;
        v63 = v61;
        v64 = a4 + (int64_t)&g11 + v61;
        v65 = *(int32_t *)v63;
        v66 = *(int32_t *)(v62 * (int64_t)&g86 + v59);
        *(int32_t *)v64 = v65 - (int32_t)v60 ^ v66;
        v62 += (int64_t)&g1;
        v63 += (int64_t)&g86;
        v64 += (int64_t)&g86;
        while (v62 != (int64_t)&g86) {
            // 0x245a
            v65 = *(int32_t *)v63;
            v66 = *(int32_t *)(v62 * (int64_t)&g86 + v59);
            *(int32_t *)v64 = v65 - (int32_t)v60 ^ v66;
            v62 += (int64_t)&g1;
            v63 += (int64_t)&g86;
            v64 += (int64_t)&g86;
        }
        // 0x2476
        v67 = v60 + (int64_t)&g86;
    }
    int64_t v68 = &v32; // 0x248d
    int64_t v69 = v67 & -0x10000;
    int64_t v70 = 0; // 0x24fa
    int64_t v71 = v69 * (int64_t)&g86; // 0x24fa
    int64_t v72 = a4 + 0x1ae8 + 4 * v69; // 0x24fa
    int32_t v73 = *(int32_t *)v71; // 0x24ab
    int32_t v74 = *(int32_t *)(v70 * (int64_t)&g86 + v68); // 0x24af
    *(int32_t *)v72 = v73 - (int32_t)v69 ^ v74;
    v70 += (int64_t)&g1;
    v71 += (int64_t)&g86;
    v72 += 4;
    while (v70 != (int64_t)&g86) {
        // 0x24ab
        v73 = *(int32_t *)v71;
        v74 = *(int32_t *)(v70 * (int64_t)&g86 + v68);
        *(int32_t *)v72 = v73 - (int32_t)v69 ^ v74;
        v70 += (int64_t)&g1;
        v71 += (int64_t)&g86;
        v72 += 4;
    }
    int64_t v75 = v69 + (int64_t)&g86; // 0x24c7
    while (v69 != 256 - (int64_t)&g86) {
        // 0x24e7
        v69 = v75;
        v70 = 0;
        v71 = v69 * (int64_t)&g86;
        v72 = a4 + 0x1ae8 + 4 * v69;
        v73 = *(int32_t *)v71;
        v74 = *(int32_t *)(v70 * (int64_t)&g86 + v68);
        *(int32_t *)v72 = v73 - (int32_t)v69 ^ v74;
        v70 += (int64_t)&g1;
        v71 += (int64_t)&g86;
        v72 += 4;
        while (v70 != (int64_t)&g86) {
            // 0x24ab
            v73 = *(int32_t *)v71;
            v74 = *(int32_t *)(v70 * (int64_t)&g86 + v68);
            *(int32_t *)v72 = v73 - (int32_t)v69 ^ v74;
            v70 += (int64_t)&g1;
            v71 += (int64_t)&g86;
            v72 += 4;
        }
        // 0x24c7
        v75 = v69 + (int64_t)&g86;
    }
    int64_t v76 = &v33; // 0x24de
    int64_t v77 = v75 & -0x10000;
    int64_t v78 = 0; // 0x254b
    int64_t v79 = v77 * (int64_t)&g86; // 0x254b
    int64_t v80 = a4 + 0x1ee8 + 4 * v77; // 0x254b
    int32_t v81 = *(int32_t *)v79; // 0x24fc
    int32_t v82 = *(int32_t *)(v78 * (int64_t)&g86 + v76); // 0x2500
    *(int32_t *)v80 = v81 - (int32_t)v77 ^ v82;
    v78 += (int64_t)&g1;
    v79 += (int64_t)&g86;
    v80 += 4;
    while (v78 != (int64_t)&g86) {
        // 0x24fc
        v81 = *(int32_t *)v79;
        v82 = *(int32_t *)(v78 * (int64_t)&g86 + v76);
        *(int32_t *)v80 = v81 - (int32_t)v77 ^ v82;
        v78 += (int64_t)&g1;
        v79 += (int64_t)&g86;
        v80 += 4;
    }
    int64_t v83 = v77 + (int64_t)&g86; // 0x2518
    while (v77 != 256 - (int64_t)&g86) {
        // 0x2538
        v77 = v83;
        v78 = 0;
        v79 = v77 * (int64_t)&g86;
        v80 = a4 + 0x1ee8 + 4 * v77;
        v81 = *(int32_t *)v79;
        v82 = *(int32_t *)(v78 * (int64_t)&g86 + v76);
        *(int32_t *)v80 = v81 - (int32_t)v77 ^ v82;
        v78 += (int64_t)&g1;
        v79 += (int64_t)&g86;
        v80 += 4;
        while (v78 != (int64_t)&g86) {
            // 0x24fc
            v81 = *(int32_t *)v79;
            v82 = *(int32_t *)(v78 * (int64_t)&g86 + v76);
            *(int32_t *)v80 = v81 - (int32_t)v77 ^ v82;
            v78 += (int64_t)&g1;
            v79 += (int64_t)&g86;
            v80 += 4;
        }
        // 0x2518
        v83 = v77 + (int64_t)&g86;
    }
    int64_t v84 = &v34; // 0x252f
    int64_t v85 = v83 & -0x10000;
    int64_t v86 = 0; // 0x259c
    int64_t v87 = v85 * (int64_t)&g86; // 0x259c
    int64_t v88 = a4 + 0x22e8 + 4 * v85; // 0x259c
    int32_t v89 = *(int32_t *)v87; // 0x254d
    int32_t v90 = *(int32_t *)(v86 * (int64_t)&g86 + v84); // 0x2551
    *(int32_t *)v88 = v89 - (int32_t)v85 ^ v90;
    v86 += (int64_t)&g1;
    v87 += (int64_t)&g86;
    v88 += 4;
    while (v86 != (int64_t)&g86) {
        // 0x254d
        v89 = *(int32_t *)v87;
        v90 = *(int32_t *)(v86 * (int64_t)&g86 + v84);
        *(int32_t *)v88 = v89 - (int32_t)v85 ^ v90;
        v86 += (int64_t)&g1;
        v87 += (int64_t)&g86;
        v88 += 4;
    }
    int64_t v91 = v85 + (int64_t)&g86; // 0x2569
    while (v85 != 256 - (int64_t)&g86) {
        // 0x2589
        v85 = v91;
        v86 = 0;
        v87 = v85 * (int64_t)&g86;
        v88 = a4 + 0x22e8 + 4 * v85;
        v89 = *(int32_t *)v87;
        v90 = *(int32_t *)(v86 * (int64_t)&g86 + v84);
        *(int32_t *)v88 = v89 - (int32_t)v85 ^ v90;
        v86 += (int64_t)&g1;
        v87 += (int64_t)&g86;
        v88 += 4;
        while (v86 != (int64_t)&g86) {
            // 0x254d
            v89 = *(int32_t *)v87;
            v90 = *(int32_t *)(v86 * (int64_t)&g86 + v84);
            *(int32_t *)v88 = v89 - (int32_t)v85 ^ v90;
            v86 += (int64_t)&g1;
            v87 += (int64_t)&g86;
            v88 += 4;
        }
        // 0x2569
        v91 = v85 + (int64_t)&g86;
    }
    int64_t v92 = &v35; // 0x2580
    int64_t v93 = v91 & -0x10000;
    int64_t v94 = 0; // 0x25ed
    int64_t v95 = v93 * (int64_t)&g86; // 0x25ed
    int64_t v96 = a4 + 0x26e8 + 4 * v93; // 0x25ed
    int32_t v97 = *(int32_t *)v95; // 0x259e
    int32_t v98 = *(int32_t *)(v94 * (int64_t)&g86 + v92); // 0x25a2
    *(int32_t *)v96 = v97 - (int32_t)v93 ^ v98;
    v94 += (int64_t)&g1;
    v95 += (int64_t)&g86;
    v96 += 4;
    while (v94 != (int64_t)&g86) {
        // 0x259e
        v97 = *(int32_t *)v95;
        v98 = *(int32_t *)(v94 * (int64_t)&g86 + v92);
        *(int32_t *)v96 = v97 - (int32_t)v93 ^ v98;
        v94 += (int64_t)&g1;
        v95 += (int64_t)&g86;
        v96 += 4;
    }
    int64_t v99 = v93 + (int64_t)&g86; // 0x25ba
    while (v93 != 256 - (int64_t)&g86) {
        // 0x25da
        v93 = v99;
        v94 = 0;
        v95 = v93 * (int64_t)&g86;
        v96 = a4 + 0x26e8 + 4 * v93;
        v97 = *(int32_t *)v95;
        v98 = *(int32_t *)(v94 * (int64_t)&g86 + v92);
        *(int32_t *)v96 = v97 - (int32_t)v93 ^ v98;
        v94 += (int64_t)&g1;
        v95 += (int64_t)&g86;
        v96 += 4;
        while (v94 != (int64_t)&g86) {
            // 0x259e
            v97 = *(int32_t *)v95;
            v98 = *(int32_t *)(v94 * (int64_t)&g86 + v92);
            *(int32_t *)v96 = v97 - (int32_t)v93 ^ v98;
            v94 += (int64_t)&g1;
            v95 += (int64_t)&g86;
            v96 += 4;
        }
        // 0x25ba
        v99 = v93 + (int64_t)&g86;
    }
    int64_t v100 = &v36; // 0x25d1
    int64_t v101 = v99 & -0x10000;
    int64_t v102 = 0; // 0x263e
    int64_t v103 = v101 * (int64_t)&g86; // 0x263e
    int64_t v104 = a4 + 0x2ae8 + 4 * v101; // 0x263e
    int32_t v105 = *(int32_t *)v103; // 0x25ef
    int32_t v106 = *(int32_t *)(v102 * (int64_t)&g86 + v100); // 0x25f3
    *(int32_t *)v104 = v105 - (int32_t)v101 ^ v106;
    v102 += (int64_t)&g1;
    v103 += (int64_t)&g86;
    v104 += 4;
    while (v102 != (int64_t)&g86) {
        // 0x25ef
        v105 = *(int32_t *)v103;
        v106 = *(int32_t *)(v102 * (int64_t)&g86 + v100);
        *(int32_t *)v104 = v105 - (int32_t)v101 ^ v106;
        v102 += (int64_t)&g1;
        v103 += (int64_t)&g86;
        v104 += 4;
    }
    int64_t v107 = v101 + (int64_t)&g86; // 0x260b
    while (v101 != 256 - (int64_t)&g86) {
        // 0x262b
        v101 = v107;
        v102 = 0;
        v103 = v101 * (int64_t)&g86;
        v104 = a4 + 0x2ae8 + 4 * v101;
        v105 = *(int32_t *)v103;
        v106 = *(int32_t *)(v102 * (int64_t)&g86 + v100);
        *(int32_t *)v104 = v105 - (int32_t)v101 ^ v106;
        v102 += (int64_t)&g1;
        v103 += (int64_t)&g86;
        v104 += 4;
        while (v102 != (int64_t)&g86) {
            // 0x25ef
            v105 = *(int32_t *)v103;
            v106 = *(int32_t *)(v102 * (int64_t)&g86 + v100);
            *(int32_t *)v104 = v105 - (int32_t)v101 ^ v106;
            v102 += (int64_t)&g1;
            v103 += (int64_t)&g86;
            v104 += 4;
        }
        // 0x260b
        v107 = v101 + (int64_t)&g86;
    }
    int64_t v108 = &v37; // 0x2622
    int64_t v109 = v107 & -0x10000;
    int64_t v110 = 0; // 0x268f
    int64_t v111 = v109 * (int64_t)&g86; // 0x268f
    int64_t v112 = a4 + 0x2ee8 + 4 * v109; // 0x268f
    int32_t v113 = *(int32_t *)v111; // 0x2640
    int32_t v114 = *(int32_t *)(v110 * (int64_t)&g86 + v108); // 0x2644
    *(int32_t *)v112 = v113 - (int32_t)v109 ^ v114;
    v110 += (int64_t)&g1;
    v111 += (int64_t)&g86;
    v112 += 4;
    while (v110 != (int64_t)&g86) {
        // 0x2640
        v113 = *(int32_t *)v111;
        v114 = *(int32_t *)(v110 * (int64_t)&g86 + v108);
        *(int32_t *)v112 = v113 - (int32_t)v109 ^ v114;
        v110 += (int64_t)&g1;
        v111 += (int64_t)&g86;
        v112 += 4;
    }
    int64_t v115 = v109 + (int64_t)&g86; // 0x265c
    while (v109 != 256 - (int64_t)&g86) {
        // 0x267c
        v109 = v115;
        v110 = 0;
        v111 = v109 * (int64_t)&g86;
        v112 = a4 + 0x2ee8 + 4 * v109;
        v113 = *(int32_t *)v111;
        v114 = *(int32_t *)(v110 * (int64_t)&g86 + v108);
        *(int32_t *)v112 = v113 - (int32_t)v109 ^ v114;
        v110 += (int64_t)&g1;
        v111 += (int64_t)&g86;
        v112 += 4;
        while (v110 != (int64_t)&g86) {
            // 0x2640
            v113 = *(int32_t *)v111;
            v114 = *(int32_t *)(v110 * (int64_t)&g86 + v108);
            *(int32_t *)v112 = v113 - (int32_t)v109 ^ v114;
            v110 += (int64_t)&g1;
            v111 += (int64_t)&g86;
            v112 += 4;
        }
        // 0x265c
        v115 = v109 + (int64_t)&g86;
    }
    int64_t v116 = &v38; // 0x2673
    int64_t v117 = v115 & -0x10000; // 0x267a
    int64_t v118 = 0; // 0x26cd
    int64_t v119 = v117 * (int64_t)&g86; // 0x26cd
    int64_t v120 = a4 + 0x32e8 + 4 * v117; // 0x26cd
    int32_t v121 = *(int32_t *)v119; // 0x2691
    int32_t v122 = *(int32_t *)(v118 * (int64_t)&g86 + v116); // 0x2695
    *(int32_t *)v120 = v121 - (int32_t)v117 ^ v122;
    v118 += (int64_t)&g1;
    v119 += (int64_t)&g86;
    v120 += 4;
    while (v118 != (int64_t)&g86) {
        // 0x2691
        v121 = *(int32_t *)v119;
        v122 = *(int32_t *)(v118 * (int64_t)&g86 + v116);
        *(int32_t *)v120 = v121 - (int32_t)v117 ^ v122;
        v118 += (int64_t)&g1;
        v119 += (int64_t)&g86;
        v120 += 4;
    }
    while (v117 != 256 - (int64_t)&g86) {
        // 0x26ad
        v117 += (int64_t)&g86;
        v118 = 0;
        v119 = v117 * (int64_t)&g86;
        v120 = a4 + 0x32e8 + 4 * v117;
        v121 = *(int32_t *)v119;
        v122 = *(int32_t *)(v118 * (int64_t)&g86 + v116);
        *(int32_t *)v120 = v121 - (int32_t)v117 ^ v122;
        v118 += (int64_t)&g1;
        v119 += (int64_t)&g86;
        v120 += 4;
        while (v118 != (int64_t)&g86) {
            // 0x2691
            v121 = *(int32_t *)v119;
            v122 = *(int32_t *)(v118 * (int64_t)&g86 + v116);
            *(int32_t *)v120 = v121 - (int32_t)v117 ^ v122;
            v118 += (int64_t)&g1;
            v119 += (int64_t)&g86;
            v120 += 4;
        }
    }
    int64_t v123 = 0x56a0a2e; // bp-360, 0x26cf
    int64_t v124 = 0x51279570; // bp-392, 0x2716
    int64_t v125 = 0x5b4a1b99; // bp-424, 0x2754
    int64_t v126 = 0x7d71a232; // bp-456, 0x2792
    int64_t v127 = 0x18328453; // bp-488, 0x27d0
    int32_t v128 = -0x1207f9bf; // bp-520, 0x280e
    int64_t v129 = 0x6c62a522; // bp-552, 0x2855
    int64_t v130 = 0x18ad3f14; // bp-584, 0x288a
    int32_t v131 = -0x13b8e0bb; // bp-616, 0x28c8
    int64_t v132 = -0x664a914e; // bp-648, 0x290f
    char v133 = -92; // bp-88, 0x2956
    int64_t v134 = &v123; // 0x2981
    int64_t v135 = 0;
    int64_t v136 = 0; // 0x29d8
    int64_t v137 = v135 * (int64_t)&g95; // 0x29d8
    int64_t v138 = a4 + 0x3e70 + 8 * v135; // 0x29d8
    int64_t v139 = *(int64_t *)(v136 * (int64_t)&g95 + v134); // 0x2990
    *(int64_t *)v138 = *(int64_t *)v137 - v135 ^ v139;
    v136 += (int64_t)&g1;
    v137 += (int64_t)&g95;
    v138 += 8;
    while (v136 != (int64_t)&g86) {
        // 0x298a
        v139 = *(int64_t *)(v136 * (int64_t)&g95 + v134);
        *(int64_t *)v138 = *(int64_t *)v137 - v135 ^ v139;
        v136 += (int64_t)&g1;
        v137 += (int64_t)&g95;
        v138 += 8;
    }
    int64_t v140 = v135 + (int64_t)&g86; // 0x29a9
    while (v135 != 64 - (int64_t)&g86) {
        // 0x29c5
        v135 = v140;
        v136 = 0;
        v137 = v135 * (int64_t)&g95;
        v138 = a4 + 0x3e70 + 8 * v135;
        v139 = *(int64_t *)(v136 * (int64_t)&g95 + v134);
        *(int64_t *)v138 = *(int64_t *)v137 - v135 ^ v139;
        v136 += (int64_t)&g1;
        v137 += (int64_t)&g95;
        v138 += 8;
        while (v136 != (int64_t)&g86) {
            // 0x298a
            v139 = *(int64_t *)(v136 * (int64_t)&g95 + v134);
            *(int64_t *)v138 = *(int64_t *)v137 - v135 ^ v139;
            v136 += (int64_t)&g1;
            v137 += (int64_t)&g95;
            v138 += 8;
        }
        // 0x29a9
        v140 = v135 + (int64_t)&g86;
    }
    int64_t v141 = &v124; // 0x29bc
    int64_t v142 = v140 & -256;
    int64_t v143 = 0; // 0x2a28
    int64_t v144 = v142 * (int64_t)&g95; // 0x2a28
    int64_t v145 = a4 + 0x4070 + 8 * v142; // 0x2a28
    int64_t v146 = *(int64_t *)(v143 * (int64_t)&g95 + v141); // 0x29e0
    *(int64_t *)v145 = *(int64_t *)v144 - v142 ^ v146;
    v143 += (int64_t)&g1;
    v144 += (int64_t)&g95;
    v145 += 8;
    while (v143 != (int64_t)&g86) {
        // 0x29da
        v146 = *(int64_t *)(v143 * (int64_t)&g95 + v141);
        *(int64_t *)v145 = *(int64_t *)v144 - v142 ^ v146;
        v143 += (int64_t)&g1;
        v144 += (int64_t)&g95;
        v145 += 8;
    }
    int64_t v147 = v142 + (int64_t)&g86; // 0x29f9
    while (v142 != 64 - (int64_t)&g86) {
        // 0x2a15
        v142 = v147;
        v143 = 0;
        v144 = v142 * (int64_t)&g95;
        v145 = a4 + 0x4070 + 8 * v142;
        v146 = *(int64_t *)(v143 * (int64_t)&g95 + v141);
        *(int64_t *)v145 = *(int64_t *)v144 - v142 ^ v146;
        v143 += (int64_t)&g1;
        v144 += (int64_t)&g95;
        v145 += 8;
        while (v143 != (int64_t)&g86) {
            // 0x29da
            v146 = *(int64_t *)(v143 * (int64_t)&g95 + v141);
            *(int64_t *)v145 = *(int64_t *)v144 - v142 ^ v146;
            v143 += (int64_t)&g1;
            v144 += (int64_t)&g95;
            v145 += 8;
        }
        // 0x29f9
        v147 = v142 + (int64_t)&g86;
    }
    int64_t v148 = &v125; // 0x2a0c
    int64_t v149 = v147 & -256;
    int64_t v150 = 0; // 0x2a78
    int64_t v151 = v149 * (int64_t)&g95; // 0x2a78
    int64_t v152 = a4 + 0x4270 + 8 * v149; // 0x2a78
    int64_t v153 = *(int64_t *)(v150 * (int64_t)&g95 + v148); // 0x2a30
    *(int64_t *)v152 = *(int64_t *)v151 - v149 ^ v153;
    v150 += (int64_t)&g1;
    v151 += (int64_t)&g95;
    v152 += 8;
    while (v150 != (int64_t)&g86) {
        // 0x2a2a
        v153 = *(int64_t *)(v150 * (int64_t)&g95 + v148);
        *(int64_t *)v152 = *(int64_t *)v151 - v149 ^ v153;
        v150 += (int64_t)&g1;
        v151 += (int64_t)&g95;
        v152 += 8;
    }
    int64_t v154 = v149 + (int64_t)&g86; // 0x2a49
    while (v149 != 64 - (int64_t)&g86) {
        // 0x2a65
        v149 = v154;
        v150 = 0;
        v151 = v149 * (int64_t)&g95;
        v152 = a4 + 0x4270 + 8 * v149;
        v153 = *(int64_t *)(v150 * (int64_t)&g95 + v148);
        *(int64_t *)v152 = *(int64_t *)v151 - v149 ^ v153;
        v150 += (int64_t)&g1;
        v151 += (int64_t)&g95;
        v152 += 8;
        while (v150 != (int64_t)&g86) {
            // 0x2a2a
            v153 = *(int64_t *)(v150 * (int64_t)&g95 + v148);
            *(int64_t *)v152 = *(int64_t *)v151 - v149 ^ v153;
            v150 += (int64_t)&g1;
            v151 += (int64_t)&g95;
            v152 += 8;
        }
        // 0x2a49
        v154 = v149 + (int64_t)&g86;
    }
    int64_t v155 = &v126; // 0x2a5c
    int64_t v156 = v154 & -256;
    int64_t v157 = 0; // 0x2ac8
    int64_t v158 = v156 * (int64_t)&g95; // 0x2ac8
    int64_t v159 = a4 + 0x4470 + 8 * v156; // 0x2ac8
    int64_t v160 = *(int64_t *)(v157 * (int64_t)&g95 + v155); // 0x2a80
    *(int64_t *)v159 = *(int64_t *)v158 - v156 ^ v160;
    v157 += (int64_t)&g1;
    v158 += (int64_t)&g95;
    v159 += 8;
    while (v157 != (int64_t)&g86) {
        // 0x2a7a
        v160 = *(int64_t *)(v157 * (int64_t)&g95 + v155);
        *(int64_t *)v159 = *(int64_t *)v158 - v156 ^ v160;
        v157 += (int64_t)&g1;
        v158 += (int64_t)&g95;
        v159 += 8;
    }
    int64_t v161 = v156 + (int64_t)&g86; // 0x2a99
    while (v156 != 64 - (int64_t)&g86) {
        // 0x2ab5
        v156 = v161;
        v157 = 0;
        v158 = v156 * (int64_t)&g95;
        v159 = a4 + 0x4470 + 8 * v156;
        v160 = *(int64_t *)(v157 * (int64_t)&g95 + v155);
        *(int64_t *)v159 = *(int64_t *)v158 - v156 ^ v160;
        v157 += (int64_t)&g1;
        v158 += (int64_t)&g95;
        v159 += 8;
        while (v157 != (int64_t)&g86) {
            // 0x2a7a
            v160 = *(int64_t *)(v157 * (int64_t)&g95 + v155);
            *(int64_t *)v159 = *(int64_t *)v158 - v156 ^ v160;
            v157 += (int64_t)&g1;
            v158 += (int64_t)&g95;
            v159 += 8;
        }
        // 0x2a99
        v161 = v156 + (int64_t)&g86;
    }
    int64_t v162 = &v127; // 0x2aac
    int64_t v163 = v161 & -256;
    int64_t v164 = 0; // 0x2b18
    int64_t v165 = v163 * (int64_t)&g95; // 0x2b18
    int64_t v166 = a4 + 0x4670 + 8 * v163; // 0x2b18
    int64_t v167 = *(int64_t *)(v164 * (int64_t)&g95 + v162); // 0x2ad0
    *(int64_t *)v166 = *(int64_t *)v165 - v163 ^ v167;
    v164 += (int64_t)&g1;
    v165 += (int64_t)&g95;
    v166 += 8;
    while (v164 != (int64_t)&g86) {
        // 0x2aca
        v167 = *(int64_t *)(v164 * (int64_t)&g95 + v162);
        *(int64_t *)v166 = *(int64_t *)v165 - v163 ^ v167;
        v164 += (int64_t)&g1;
        v165 += (int64_t)&g95;
        v166 += 8;
    }
    int64_t v168 = v163 + (int64_t)&g86; // 0x2ae9
    while (v163 != 64 - (int64_t)&g86) {
        // 0x2b05
        v163 = v168;
        v164 = 0;
        v165 = v163 * (int64_t)&g95;
        v166 = a4 + 0x4670 + 8 * v163;
        v167 = *(int64_t *)(v164 * (int64_t)&g95 + v162);
        *(int64_t *)v166 = *(int64_t *)v165 - v163 ^ v167;
        v164 += (int64_t)&g1;
        v165 += (int64_t)&g95;
        v166 += 8;
        while (v164 != (int64_t)&g86) {
            // 0x2aca
            v167 = *(int64_t *)(v164 * (int64_t)&g95 + v162);
            *(int64_t *)v166 = *(int64_t *)v165 - v163 ^ v167;
            v164 += (int64_t)&g1;
            v165 += (int64_t)&g95;
            v166 += 8;
        }
        // 0x2ae9
        v168 = v163 + (int64_t)&g86;
    }
    int64_t v169 = &v128; // 0x2afc
    int64_t v170 = v168 & -256;
    int64_t v171 = 0; // 0x2b68
    int64_t v172 = v170 * (int64_t)&g95; // 0x2b68
    int64_t v173 = a4 + 0x4870 + 8 * v170; // 0x2b68
    int64_t v174 = *(int64_t *)(v171 * (int64_t)&g95 + v169); // 0x2b20
    *(int64_t *)v173 = *(int64_t *)v172 - v170 ^ v174;
    v171 += (int64_t)&g1;
    v172 += (int64_t)&g95;
    v173 += 8;
    while (v171 != (int64_t)&g86) {
        // 0x2b1a
        v174 = *(int64_t *)(v171 * (int64_t)&g95 + v169);
        *(int64_t *)v173 = *(int64_t *)v172 - v170 ^ v174;
        v171 += (int64_t)&g1;
        v172 += (int64_t)&g95;
        v173 += 8;
    }
    int64_t v175 = v170 + (int64_t)&g86; // 0x2b39
    while (v170 != 64 - (int64_t)&g86) {
        // 0x2b55
        v170 = v175;
        v171 = 0;
        v172 = v170 * (int64_t)&g95;
        v173 = a4 + 0x4870 + 8 * v170;
        v174 = *(int64_t *)(v171 * (int64_t)&g95 + v169);
        *(int64_t *)v173 = *(int64_t *)v172 - v170 ^ v174;
        v171 += (int64_t)&g1;
        v172 += (int64_t)&g95;
        v173 += 8;
        while (v171 != (int64_t)&g86) {
            // 0x2b1a
            v174 = *(int64_t *)(v171 * (int64_t)&g95 + v169);
            *(int64_t *)v173 = *(int64_t *)v172 - v170 ^ v174;
            v171 += (int64_t)&g1;
            v172 += (int64_t)&g95;
            v173 += 8;
        }
        // 0x2b39
        v175 = v170 + (int64_t)&g86;
    }
    int64_t v176 = &v129; // 0x2b4c
    int64_t v177 = v175 & -256;
    int64_t v178 = 0; // 0x2bb8
    int64_t v179 = v177 * (int64_t)&g95; // 0x2bb8
    int64_t v180 = a4 + 0x4a70 + 8 * v177; // 0x2bb8
    int64_t v181 = *(int64_t *)(v178 * (int64_t)&g95 + v176); // 0x2b70
    *(int64_t *)v180 = *(int64_t *)v179 - v177 ^ v181;
    v178 += (int64_t)&g1;
    v179 += (int64_t)&g95;
    v180 += 8;
    while (v178 != (int64_t)&g86) {
        // 0x2b6a
        v181 = *(int64_t *)(v178 * (int64_t)&g95 + v176);
        *(int64_t *)v180 = *(int64_t *)v179 - v177 ^ v181;
        v178 += (int64_t)&g1;
        v179 += (int64_t)&g95;
        v180 += 8;
    }
    int64_t v182 = v177 + (int64_t)&g86; // 0x2b89
    while (v177 != 64 - (int64_t)&g86) {
        // 0x2ba5
        v177 = v182;
        v178 = 0;
        v179 = v177 * (int64_t)&g95;
        v180 = a4 + 0x4a70 + 8 * v177;
        v181 = *(int64_t *)(v178 * (int64_t)&g95 + v176);
        *(int64_t *)v180 = *(int64_t *)v179 - v177 ^ v181;
        v178 += (int64_t)&g1;
        v179 += (int64_t)&g95;
        v180 += 8;
        while (v178 != (int64_t)&g86) {
            // 0x2b6a
            v181 = *(int64_t *)(v178 * (int64_t)&g95 + v176);
            *(int64_t *)v180 = *(int64_t *)v179 - v177 ^ v181;
            v178 += (int64_t)&g1;
            v179 += (int64_t)&g95;
            v180 += 8;
        }
        // 0x2b89
        v182 = v177 + (int64_t)&g86;
    }
    int64_t v183 = &v130; // 0x2b9c
    int64_t v184 = v182 & -256;
    int64_t v185 = 0; // 0x2c08
    int64_t v186 = v184 * (int64_t)&g95; // 0x2c08
    int64_t v187 = a4 + 0x4c70 + 8 * v184; // 0x2c08
    int64_t v188 = *(int64_t *)(v185 * (int64_t)&g95 + v183); // 0x2bc0
    *(int64_t *)v187 = *(int64_t *)v186 - v184 ^ v188;
    v185 += (int64_t)&g1;
    v186 += (int64_t)&g95;
    v187 += 8;
    while (v185 != (int64_t)&g86) {
        // 0x2bba
        v188 = *(int64_t *)(v185 * (int64_t)&g95 + v183);
        *(int64_t *)v187 = *(int64_t *)v186 - v184 ^ v188;
        v185 += (int64_t)&g1;
        v186 += (int64_t)&g95;
        v187 += 8;
    }
    int64_t v189 = v184 + (int64_t)&g86; // 0x2bd9
    while (v184 != 64 - (int64_t)&g86) {
        // 0x2bf5
        v184 = v189;
        v185 = 0;
        v186 = v184 * (int64_t)&g95;
        v187 = a4 + 0x4c70 + 8 * v184;
        v188 = *(int64_t *)(v185 * (int64_t)&g95 + v183);
        *(int64_t *)v187 = *(int64_t *)v186 - v184 ^ v188;
        v185 += (int64_t)&g1;
        v186 += (int64_t)&g95;
        v187 += 8;
        while (v185 != (int64_t)&g86) {
            // 0x2bba
            v188 = *(int64_t *)(v185 * (int64_t)&g95 + v183);
            *(int64_t *)v187 = *(int64_t *)v186 - v184 ^ v188;
            v185 += (int64_t)&g1;
            v186 += (int64_t)&g95;
            v187 += 8;
        }
        // 0x2bd9
        v189 = v184 + (int64_t)&g86;
    }
    int64_t v190 = &v131; // 0x2bec
    int64_t v191 = v189 & -256; // 0x2bf3
    int64_t v192 = 0; // 0x2c58
    int64_t v193 = v191 * (int64_t)&g95; // 0x2c58
    int64_t v194 = a4 + 0x4e70 + 8 * v191; // 0x2c58
    int64_t v195 = *(int64_t *)(v192 * (int64_t)&g95 + v190); // 0x2c10
    *(int64_t *)v194 = *(int64_t *)v193 - v191 ^ v195;
    v192 += (int64_t)&g1;
    v193 += (int64_t)&g95;
    v194 += 8;
    while (v192 != (int64_t)&g86) {
        // 0x2c0a
        v195 = *(int64_t *)(v192 * (int64_t)&g95 + v190);
        *(int64_t *)v194 = *(int64_t *)v193 - v191 ^ v195;
        v192 += (int64_t)&g1;
        v193 += (int64_t)&g95;
        v194 += 8;
    }
    // 0x2c29
    v191 += (int64_t)&g86;
    while (v191 != (int64_t)&g2) {
        // 0x2c45
        v192 = 0;
        v193 = v191 * (int64_t)&g95;
        v194 = a4 + 0x4e70 + 8 * v191;
        v195 = *(int64_t *)(v192 * (int64_t)&g95 + v190);
        *(int64_t *)v194 = *(int64_t *)v193 - v191 ^ v195;
        v192 += (int64_t)&g1;
        v193 += (int64_t)&g95;
        v194 += 8;
        while (v192 != (int64_t)&g86) {
            // 0x2c0a
            v195 = *(int64_t *)(v192 * (int64_t)&g95 + v190);
            *(int64_t *)v194 = *(int64_t *)v193 - v191 ^ v195;
            v192 += (int64_t)&g1;
            v193 += (int64_t)&g95;
            v194 += 8;
        }
        // 0x2c29
        v191 += (int64_t)&g86;
    }
    int64_t v196 = &v132; // 0x2c3c
    int64_t v197 = v191 & -256; // 0x2c43
    int64_t v198 = 0; // 0x2ca8
    int64_t v199 = v197 * (int64_t)&g95; // 0x2ca8
    int64_t v200 = a4 + 0x4ef0 + 8 * v197; // 0x2ca8
    int64_t v201 = *(int64_t *)(v198 * (int64_t)&g95 + v196); // 0x2c60
    *(int64_t *)v200 = *(int64_t *)v199 - v197 ^ v201;
    v198 += (int64_t)&g1;
    v199 += (int64_t)&g95;
    v200 += 8;
    while (v198 != (int64_t)&g86) {
        // 0x2c5a
        v201 = *(int64_t *)(v198 * (int64_t)&g95 + v196);
        *(int64_t *)v200 = *(int64_t *)v199 - v197 ^ v201;
        v198 += (int64_t)&g1;
        v199 += (int64_t)&g95;
        v200 += 8;
    }
    // 0x2c79
    v197 += (int64_t)&g86;
    while (v197 != (int64_t)&g2) {
        // 0x2c95
        v198 = 0;
        v199 = v197 * (int64_t)&g95;
        v200 = a4 + 0x4ef0 + 8 * v197;
        v201 = *(int64_t *)(v198 * (int64_t)&g95 + v196);
        *(int64_t *)v200 = *(int64_t *)v199 - v197 ^ v201;
        v198 += (int64_t)&g1;
        v199 += (int64_t)&g95;
        v200 += 8;
        while (v198 != (int64_t)&g86) {
            // 0x2c5a
            v201 = *(int64_t *)(v198 * (int64_t)&g95 + v196);
            *(int64_t *)v200 = *(int64_t *)v199 - v197 ^ v201;
            v198 += (int64_t)&g1;
            v199 += (int64_t)&g95;
            v200 += 8;
        }
        // 0x2c79
        v197 += (int64_t)&g86;
    }
    int64_t v202 = &v133; // 0x2c8f
    int64_t v203 = 0; // 0x2c93
    int64_t v204 = 0; // 0x2ce8
    int64_t v205 = v203; // 0x2ce8
    int64_t v206 = a4 + 0x55a8 + v203; // 0x2ce8
    char v207 = *(char *)v205; // 0x2caa
    char v208 = *(char *)(v204 * (int64_t)&g1 + v202); // 0x2cb0
    *(char *)v206 = v207 - (char)v204 ^ v208;
    v204 += (int64_t)&g1;
    v205 += (int64_t)&g1;
    v206++;
    while (v204 != (int64_t)&g95) {
        // 0x2caa
        v207 = *(char *)v205;
        v208 = *(char *)(v204 * (int64_t)&g1 + v202);
        *(char *)v206 = v207 - (char)v204 ^ v208;
        v204 += (int64_t)&g1;
        v205 += (int64_t)&g1;
        v206++;
    }
    while (v203 != 192 - (int64_t)&g95) {
        // 0x2cc9
        v203 += (int64_t)&g95;
        v204 = 0;
        v205 = v203;
        v206 = a4 + 0x55a8 + v203;
        v207 = *(char *)v205;
        v208 = *(char *)(v204 * (int64_t)&g1 + v202);
        *(char *)v206 = v207 - (char)v204 ^ v208;
        v204 += (int64_t)&g1;
        v205 += (int64_t)&g1;
        v206++;
        while (v204 != (int64_t)&g95) {
            // 0x2caa
            v207 = *(char *)v205;
            v208 = *(char *)(v204 * (int64_t)&g1 + v202);
            *(char *)v206 = v207 - (char)v204 ^ v208;
            v204 += (int64_t)&g1;
            v205 += (int64_t)&g1;
            v206++;
        }
    }
    char v209 = 65; // bp-104, 0x2cea
    char v210 = 104; // bp-120, 0x2d2a
    char v211 = 85; // bp-136, 0x2d6a
    char v212 = 96; // bp-152, 0x2daa
    int64_t v213 = &v209; // 0x2e95
    int64_t v214 = 0; // 0x2e99
    int64_t v215 = 0; // 0x2ee5
    int64_t v216 = v214; // 0x2ee5
    int64_t v217 = a4 + 0x3a28 + v214; // 0x2ee5
    char v218 = *(char *)v216; // 0x2e9b
    char v219 = *(char *)(v215 * (int64_t)&g1 + v213); // 0x2ea1
    *(char *)v217 = v218 - (char)v214 ^ v219;
    v215 += (int64_t)&g1;
    v216 += (int64_t)&g1;
    v217++;
    while (v215 != (int64_t)&g2) {
        // 0x2e9b
        v218 = *(char *)v216;
        v219 = *(char *)(v215 * (int64_t)&g1 + v213);
        *(char *)v217 = v218 - (char)v214 ^ v219;
        v215 += (int64_t)&g1;
        v216 += (int64_t)&g1;
        v217++;
    }
    // 0x2eba
    v214 += (int64_t)&g2;
    while (v214 != (int64_t)&g26) {
        // 0x2ed3
        v215 = 0;
        v216 = v214;
        v217 = a4 + 0x3a28 + v214;
        v218 = *(char *)v216;
        v219 = *(char *)(v215 * (int64_t)&g1 + v213);
        *(char *)v217 = v218 - (char)v214 ^ v219;
        v215 += (int64_t)&g1;
        v216 += (int64_t)&g1;
        v217++;
        while (v215 != (int64_t)&g2) {
            // 0x2e9b
            v218 = *(char *)v216;
            v219 = *(char *)(v215 * (int64_t)&g1 + v213);
            *(char *)v217 = v218 - (char)v214 ^ v219;
            v215 += (int64_t)&g1;
            v216 += (int64_t)&g1;
            v217++;
        }
        // 0x2eba
        v214 += (int64_t)&g2;
    }
    int64_t v220 = &v210; // 0x2ecd
    int64_t v221 = v214 & -256;
    int64_t v222 = 0; // 0x2f35
    int64_t v223 = v221; // 0x2f35
    int64_t v224 = a4 + 0x3a48 + v221; // 0x2f35
    char v225 = *(char *)v223; // 0x2ee7
    char v226 = *(char *)(v222 * (int64_t)&g1 + v220); // 0x2eed
    *(char *)v224 = v225 - (char)v221 ^ v226;
    v222 += (int64_t)&g1;
    v223 += (int64_t)&g1;
    v224++;
    while (v222 != (int64_t)&g2) {
        // 0x2ee7
        v225 = *(char *)v223;
        v226 = *(char *)(v222 * (int64_t)&g1 + v220);
        *(char *)v224 = v225 - (char)v221 ^ v226;
        v222 += (int64_t)&g1;
        v223 += (int64_t)&g1;
        v224++;
    }
    int64_t v227 = v221 + (int64_t)&g2; // 0x2f06
    while (v221 != 256 - (int64_t)&g2) {
        // 0x2f23
        v221 = v227;
        v222 = 0;
        v223 = v221;
        v224 = a4 + 0x3a48 + v221;
        v225 = *(char *)v223;
        v226 = *(char *)(v222 * (int64_t)&g1 + v220);
        *(char *)v224 = v225 - (char)v221 ^ v226;
        v222 += (int64_t)&g1;
        v223 += (int64_t)&g1;
        v224++;
        while (v222 != (int64_t)&g2) {
            // 0x2ee7
            v225 = *(char *)v223;
            v226 = *(char *)(v222 * (int64_t)&g1 + v220);
            *(char *)v224 = v225 - (char)v221 ^ v226;
            v222 += (int64_t)&g1;
            v223 += (int64_t)&g1;
            v224++;
        }
        // 0x2f06
        v227 = v221 + (int64_t)&g2;
    }
    int64_t v228 = &v211; // 0x2f1d
    int64_t v229 = v227 & -0x10000;
    int64_t v230 = 0; // 0x2f88
    int64_t v231 = v229; // 0x2f88
    int64_t v232 = a4 + 0x3b48 + v229; // 0x2f88
    char v233 = *(char *)v231; // 0x2f37
    char v234 = *(char *)(v230 * (int64_t)&g1 + v228); // 0x2f3d
    *(char *)v232 = v233 - (char)v229 ^ v234;
    v230 += (int64_t)&g1;
    v231 += (int64_t)&g1;
    v232++;
    while (v230 != (int64_t)&g2) {
        // 0x2f37
        v233 = *(char *)v231;
        v234 = *(char *)(v230 * (int64_t)&g1 + v228);
        *(char *)v232 = v233 - (char)v229 ^ v234;
        v230 += (int64_t)&g1;
        v231 += (int64_t)&g1;
        v232++;
    }
    int64_t v235 = v229 + (int64_t)&g2; // 0x2f56
    while (v229 != 256 - (int64_t)&g2) {
        // 0x2f76
        v229 = v235;
        v230 = 0;
        v231 = v229;
        v232 = a4 + 0x3b48 + v229;
        v233 = *(char *)v231;
        v234 = *(char *)(v230 * (int64_t)&g1 + v228);
        *(char *)v232 = v233 - (char)v229 ^ v234;
        v230 += (int64_t)&g1;
        v231 += (int64_t)&g1;
        v232++;
        while (v230 != (int64_t)&g2) {
            // 0x2f37
            v233 = *(char *)v231;
            v234 = *(char *)(v230 * (int64_t)&g1 + v228);
            *(char *)v232 = v233 - (char)v229 ^ v234;
            v230 += (int64_t)&g1;
            v231 += (int64_t)&g1;
            v232++;
        }
        // 0x2f56
        v235 = v229 + (int64_t)&g2;
    }
    int64_t v236 = &v212; // 0x2f6d
    int64_t v237 = v235 & -0x10000; // 0x2f74
    int64_t v238 = 0; // 0x2fdb
    int64_t v239 = v237; // 0x2fdb
    int64_t v240 = a4 + (int64_t)"pa" + v237 * (int64_t)&g1; // 0x2fdb
    char v241 = *(char *)v239; // 0x2f8a
    char v242 = *(char *)(v238 * (int64_t)&g1 + v236); // 0x2f90
    *(char *)v240 = v241 - (char)v237 ^ v242;
    int64_t result = v238 + (int64_t)&g1; // 0x2f97
    v238 = result;
    v239 += (int64_t)&g1;
    v240 += (int64_t)&g1;
    while (result != (int64_t)&g2) {
        // 0x2f8a
        v241 = *(char *)v239;
        v242 = *(char *)(v238 * (int64_t)&g1 + v236);
        *(char *)v240 = v241 - (char)v237 ^ v242;
        result = v238 + (int64_t)&g1;
        v238 = result;
        v239 += (int64_t)&g1;
        v240 += (int64_t)&g1;
    }
    while (v237 != 256 - (int64_t)&g2) {
        // 0x2fa9
        v237 += (int64_t)&g2;
        v238 = 0;
        v239 = v237;
        v240 = a4 + (int64_t)"pa" + v237 * (int64_t)&g1;
        v241 = *(char *)v239;
        v242 = *(char *)(v238 * (int64_t)&g1 + v236);
        *(char *)v240 = v241 - (char)v237 ^ v242;
        result = v238 + (int64_t)&g1;
        v238 = result;
        v239 += (int64_t)&g1;
        v240 += (int64_t)&g1;
        while (result != (int64_t)&g2) {
            // 0x2f8a
            v241 = *(char *)v239;
            v242 = *(char *)(v238 * (int64_t)&g1 + v236);
            *(char *)v240 = v241 - (char)v237 ^ v242;
            result = v238 + (int64_t)&g1;
            v238 = result;
            v239 += (int64_t)&g1;
            v240 += (int64_t)&g1;
        }
    }
    // 0x3009
    return result;
}

// From module:   /root/asv5220\AVDevice.c
// Address range: 0x3010 - 0x3040
// Line range:    1610 - 1878
int64_t FUSBDTV_Add(int64_t deviceExtension_input) {
    // 0x3010
    int64_t result; // 0x3010
    return result;
}

// Address range: 0x3040 - 0x355c
int64_t FUSBDTV_Add2(int64_t * a1) {
    // 0x3040
    mcount();
    *(int32_t *)&g77 = (int32_t)&g78;
    int64_t v1 = FUSB_ExAllocatePool2(0, (int64_t)&g93); // 0x306a
    *a1 = v1;
    memset(v1, 0, (int64_t)&g93);
    int64_t v2; // 0x3040
    FUSBDTV_AddUSBDevice2(0, 0, 0, v1, v2);
    *(char *)(v1 + 1240) = 0;
    *(char *)(v1 + 0x53d9) = 0;
    *(char *)(v1 + 0x53d8) = (char)&g1;
    int64_t v3 = v1 + (int64_t)&g95; // 0x30c5
    int64_t v4 = v1; // 0x30ca
    *(char *)(v4 + 0x53da) = 0;
    v4 += (int64_t)&g1;
    while (v4 != v3) {
        // 0x30cd
        *(char *)(v4 + 0x53da) = 0;
        v4 += (int64_t)&g1;
    }
    // 0x30dd
    *(char *)(v1 + 0x5459) = 0;
    *(char *)(v1 + 0x5458) = (char)&g1;
    int64_t v5 = v1; // 0x30ef
    *(char *)(v5 + 0x545a) = 0;
    v5 += (int64_t)&g1;
    while (v3 != v5) {
        // 0x30f2
        *(char *)(v5 + 0x545a) = 0;
        v5 += (int64_t)&g1;
    }
    // 0x3102
    *(char *)(v1 + 0x54c1) = 0;
    *(char *)(v1 + 0x54c0) = (char)&g1;
    int64_t v6 = v1; // 0x3114
    *(char *)(v6 + 0x54c2) = 0;
    v6 += (int64_t)&g1;
    while (v3 != v6) {
        // 0x3117
        *(char *)(v6 + 0x54c2) = 0;
        v6 += (int64_t)&g1;
    }
    // 0x3127
    *(char *)(v1 + 0x55a2) = 0;
    *(char *)(v1 + 0x6060) = 0;
    int64_t v7; // bp-64, 0x3040
    Get_Tuner_Extra_Data_Size2(&v7);
    int64_t v8 = v1 + 560;
    int64_t v9 = v1; // 0x3151
    if (v7 != 0) {
        int64_t v10 = FUSB_ExAllocatePool2(0, v7); // 0x3183
        *(int64_t *)(v1 + 0x59a0) = v10;
        memset(v10, 0, v7);
        *(int64_t *)(v1 + 0x5998) = v1;
        int64_t v11 = v1 + 80; // 0x31a7
        int64_t v12 = FUSB_ExAllocatePool2(0, v7); // 0x3183
        *(int64_t *)(v1 + 0x59f0) = v12;
        memset(v12, 0, v7);
        *(int64_t *)(v1 + 0x59e8) = v1;
        while (v11 != v8) {
            int64_t v13 = v11;
            v11 = v13 + 80;
            v12 = FUSB_ExAllocatePool2(0, v7);
            *(int64_t *)(v13 + 0x59f0) = v12;
            memset(v12, 0, v7);
            *(int64_t *)(v13 + 0x59e8) = v1;
        }
    } else {
        *(int64_t *)(v9 + 0x59a0) = 0;
        *(int64_t *)(v9 + 0x5998) = v1;
        while (v9 != v8) {
            // 0x315d
            v9 += 80;
            *(int64_t *)(v9 + 0x59a0) = 0;
            *(int64_t *)(v9 + 0x5998) = v1;
        }
    }
    // 0x31b0
    *(char *)(v1 + 0x5430) = 0;
    *(char *)(v1 + (int64_t)&g90) = (char)&g1;
    int64_t v14 = v1; // 0x31c2
    *(char *)(v14 + 0x5668) = 0;
    v14 += (int64_t)&g1;
    while (v3 != v14) {
        // 0x31c5
        *(char *)(v14 + 0x5668) = 0;
        v14 += (int64_t)&g1;
    }
    // 0x31d5
    *(char *)(v1 + 0x5910) = 0;
    *(char *)(v1 + 0x590f) = 0;
    if (g74 != 0) {
        while (true) {
            // continue -> 0x321d
        }
    }
    // 0x3211
    *(int64_t *)(0x100000000 * ((int64_t)&g1 & -256) / 0x100000000 * (int64_t)&g95) = v1;
    char v15 = v1; // 0x321b
    int64_t v16 = 0; // 0x321b
    int64_t v17 = FUSB_ExAllocatePool2(0, 0x929f0); // 0x3235
    memset(v17, 0, 0x929f0);
    *(int64_t *)(v17 + 0x1d38) = v1;
    *(char *)(v17 + 0x1d30) = (char)v16;
    *(int32_t *)(v17 + 0x1d40) = 0;
    *(int32_t *)(v17 + 0x1d44) = (int32_t)&g1;
    *(char *)(v17 + 0x8faad) = (char)&g1;
    *(int64_t *)(v17 + 0x1c68) = 0;
    *(int64_t *)(v17 + 0x1c60) = 0;
    *(int64_t *)(v17 + 0x1c58) = 0;
    *(int64_t *)(v17 + 0x1c50) = 0;
    *(int64_t *)(v17 + (int64_t)&g20) = 0;
    *(int64_t *)((int64_t)v15 + (int64_t)&g87) = v17;
    int64_t v18 = v16 + (int64_t)(int32_t)&g1; // 0x32ba
    v15 += (char)&g95;
    v16 = v18 & 0xffffffff;
    while ((char)v18 != (char)&g95) {
        // 0x322b
        v17 = FUSB_ExAllocatePool2(0, 0x929f0);
        memset(v17, 0, 0x929f0);
        *(int64_t *)(v17 + 0x1d38) = v1;
        *(char *)(v17 + 0x1d30) = (char)v16;
        *(int32_t *)(v17 + 0x1d40) = 0;
        *(int32_t *)(v17 + 0x1d44) = (int32_t)&g1;
        *(char *)(v17 + 0x8faad) = (char)&g1;
        *(int64_t *)(v17 + 0x1c68) = 0;
        *(int64_t *)(v17 + 0x1c60) = 0;
        *(int64_t *)(v17 + 0x1c58) = 0;
        *(int64_t *)(v17 + 0x1c50) = 0;
        *(int64_t *)(v17 + (int64_t)&g20) = 0;
        *(int64_t *)((int64_t)v15 + (int64_t)&g87) = v17;
        v18 = v16 + (int64_t)(int32_t)&g1;
        v15 += (char)&g95;
        v16 = v18 & 0xffffffff;
    }
    // 0x32d0
    *(char *)(v1 + 0x5798) = 0;
    int64_t v19 = v1; // 0x32d9
    *(char *)(v19 + 0x5958) = 0;
    v19 += (int64_t)&g1;
    while (v3 != v19) {
        // 0x32dc
        *(char *)(v19 + 0x5958) = 0;
        v19 += (int64_t)&g1;
    }
    int64_t v20 = v1; // 0x32f3
    *(char *)(v20 + 0x5698) = 0;
    v20 += (int64_t)&g1;
    int64_t v21 = 0; // 0x3304
    int64_t v22 = v1; // 0x3304
    while (v20 != v1 + 256) {
        // 0x32f6
        *(char *)(v20 + 0x5698) = 0;
        v20 += (int64_t)&g1;
        v21 = 0;
        v22 = v1;
    }
    *(int64_t *)(v22 + 1160) = 0;
    AsicenAllocateStreamBuffer2(v1, v21, 128, 0x4970);
    *(int64_t *)(v22 + 0x60e8) = FUSB_ExAllocatePool2(0, 0xe520);
    *(int64_t *)(v22 + 0x6128) = 0;
    int64_t v23 = v21 + (int64_t)(int32_t)&g1; // 0x335e
    v21 = v23 & 0xffffffff;
    v22 += (int64_t)&g95;
    while ((int32_t)v23 != (int32_t)&g95) {
        // 0x330b
        *(int64_t *)(v22 + 1160) = 0;
        AsicenAllocateStreamBuffer2(v1, v21, 128, 0x4970);
        *(int64_t *)(v22 + 0x60e8) = FUSB_ExAllocatePool2(0, 0xe520);
        *(int64_t *)(v22 + 0x6128) = 0;
        v23 = v21 + (int64_t)(int32_t)&g1;
        v21 = v23 & 0xffffffff;
        v22 += (int64_t)&g95;
    }
    // 0x336a
    AsicenAllocateStreamBuffer2(v1, (int64_t)&g95, 128, 0x4970);
    int64_t * v24 = (int64_t *)(v1 + 1224); // 0x338b
    *(int64_t *)*v24 = v1;
    *(char *)(*v24 + 184) = (char)&g1;
    AsicenAllocateStreamBuffer2(v1, (int64_t)&g97, 128, 0x4970);
    int64_t * v25 = (int64_t *)(v1 + 1232); // 0x33c6
    *(int64_t *)*v25 = v1;
    *(char *)(*v25 + 184) = (char)&g1;
    *(char *)(v1 + 0x6064) = 71;
    *(int32_t *)(v1 + 0x6068) = 0;
    *(int32_t *)(v1 + 0x606c) = 0;
    *(int32_t *)(v1 + 0x6070) = (int32_t)&g1;
    *(char *)(v1 + 0x6074) = 71;
    *(int32_t *)(v1 + 0x6078) = 0;
    *(int32_t *)(v1 + 0x607c) = 0;
    *(int32_t *)(v1 + 0x6080) = (int32_t)&g1;
    *(char *)(v1 + 0x6084) = -57;
    *(int32_t *)(v1 + 0x6088) = 0;
    *(int32_t *)(v1 + 0x608c) = 0;
    *(int32_t *)(v1 + 0x6090) = (int32_t)&g1;
    *(char *)(v1 + 0x6094) = -57;
    *(int32_t *)(v1 + 0x6098) = 0;
    *(int32_t *)(v1 + 0x609c) = 0;
    *(int32_t *)(v1 + 0x60a0) = (int32_t)&g1;
    *(char *)(v1 + 0x60a4) = -121;
    *(int32_t *)(v1 + 0x60a8) = 0;
    *(int32_t *)(v1 + 0x60ac) = 0;
    *(int32_t *)(v1 + 0x60b0) = (int32_t)&g1;
    *(char *)(v1 + 0x60b4) = -121;
    *(int32_t *)(v1 + 0x60b8) = 0;
    *(int32_t *)(v1 + 0x60bc) = 0;
    *(int32_t *)(v1 + 0x60c0) = (int32_t)&g1;
    *(char *)(v1 + 0x60c4) = (char)&g94;
    *(int32_t *)(v1 + 0x60c8) = 0;
    *(int32_t *)(v1 + 0x60cc) = 0;
    *(int32_t *)(v1 + 0x60d0) = (int32_t)&g1;
    *(char *)(v1 + 0x60d4) = (char)&g94;
    *(int32_t *)(v1 + 0x60d8) = 0;
    *(int32_t *)(v1 + 0x60dc) = 0;
    *(int32_t *)(v1 + 0x60e0) = (int32_t)&g1;
    return InitializeDeviceLNBPowerRegistry2(v1);
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3560 - 0x356b
// Line range:    129 - 134
void Hardware_Stop(int64_t device) {
    // 0x3560
    int64_t v1; // 0x3560
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x3560
    char * v3 = (char *)(v2 - 25 + v2 * (int64_t)&g86); // 0x3562
    *v3 = *v3 + (char)v2;
    int64_t v4; // 0x3560
    int64_t v5; // 0x3560
    StoreDeviceLNBPower2(device, v4, (int64_t *)v5);
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x356b - 0x357b
// Line range:    908 - 995
char Hardware_SubmitTuner(int64_t device) {
    // 0x356b
    return &g1;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x357b - 0x3586
// Line range:    997 - 1010
char Hardware_SubmitDemod(int64_t device) {
    // 0x357b
    int64_t result; // 0x357b
    return result;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x358b - 0x3590
// Line range:    1012 - 1027
int64_t Hardware_GetSignalStrength(int64_t device) {
    // 0x358b
    int64_t result; // 0x358b
    return result;
}

// Address range: 0x3590 - 0x359b
int64_t Hardware_Stop2(void) {
    // 0x3590
    return mcount();
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x359b - 0x35ab
// Line range:    1029 - 1044
int64_t Hardware_GetSignalQuality(int64_t device) {
    // 0x359b
    mcount();
    return &g1;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x35ab - 0x35bb
// Line range:    1046 - 1064
int64_t Hardware_GetSignalLock(int64_t device) {
    // 0x35ab
    mcount();
    return &g1;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x35bb - 0x35cb
// Line range:    1079 - 1107
int64_t TVTunerInit(int64_t device) {
    // 0x35bb
    mcount();
    return 0;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x35cb - 0x35d4
// Line range:    1134 - 1165
void PutTsPacketToOutputPin(int64_t Adapter) {
    // 0x35cb
    mcount();
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x35d6 - 0x35db
// Line range:    1243 - 1282
char SmiGetIRCode(int64_t device) {
    // 0x35d6
    int64_t v1; // 0x35d6
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// Address range: 0x35db - 0x35e4
int64_t Hardware_GetSignalLock2(void) {
    // 0x35db
    return mcount();
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x35e6 - 0x35eb
// Line range:    1291 - 1304
char SmiSetIRCode(int64_t device, char IrProtocol) {
    // 0x35e6
    int64_t v1; // 0x35e6
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// Address range: 0x35eb - 0x35f4
int64_t TVTunerInit2(void) {
    // 0x35eb
    return mcount();
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x35f6 - 0x35fb
// Line range:    1657 - 1700
void DelayNanoseconds(int32_t delay) {
    // 0x35f6
    int64_t v1; // 0x35f6
    *(char *)v1 = 2 * (char)v1;
}

// Address range: 0x35fb - 0x3606
int64_t PutTsPacketToOutputPin2(void) {
    // 0x35fb
    return mcount();
}

// Address range: 0x3606 - 0x3607
int64_t SmiGetIRCode2(void) {
    // 0x3606
    int64_t result; // 0x3606
    return result;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3608 - 0x3616
// Line range:    1485 - 1541
char SmiWriteRegister(int64_t device, char SlavAddr, char SlavMode, int32_t RegAddr, char * pData, char DataCont) {
    // 0x3608
    mcount();
    return 0;
}

// Address range: 0x3616 - 0x3626
int64_t SmiSetIRCode2(void) {
    // 0x3616
    mcount();
    return &g1;
}

// Address range: 0x3626 - 0x3638
int64_t DelayNanoseconds2(int64_t * a1) {
    // 0x3626
    mcount();
    return __udelay((int64_t)a1 & 0xffffffff);
}

// Address range: 0x3638 - 0x372c
int64_t SmiWriteRegister2(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char * a5, int64_t * a6) {
    uint64_t v1 = (int64_t)a6;
    mcount();
    __readgsqword(40);
    char * v2 = (char *)(a1 + 0x5908); // 0x366c
    *v2 = (char)&g1;
    int64_t v3; // bp-72, 0x3638
    int64_t v4 = &v3; // 0x3673
    v3 = 0;
    char v5 = v1; // 0x369d
    int64_t result = v4; // 0x36b3
    if (v5 != 0) {
        int64_t v6 = (int64_t)a5;
        int64_t v7 = v6 + (int64_t)&g1 + (v1 - (int64_t)(char)&g1) % 256; // 0x36c1
        int64_t v8 = v4; // 0x36c1
        int64_t v9 = v6; // 0x36c1
        *(char *)v8 = *(char *)v9;
        v9++;
        v8 += (int64_t)&g1;
        result = v8;
        while (v9 != v7) {
            // 0x36c6
            *(char *)v8 = *(char *)v9;
            v9++;
            v8 += (int64_t)&g1;
            result = v8;
        }
    }
    uint64_t v10 = (v5 & (char)&g33) == 0 ? v1 & 0xffffffff : v1 + 4 & 0xfffffffc;
    unsigned char v11 = (char)a3; // 0x36da
    if (v11 == 0) {
        // 0x36e5
        return cfg_write2(a1, a4 % 0x10000, v10 % 256, &v3);
    }
    if (v11 > (char)&g89) {
        // 0x3725
        *v2 = 0;
        return result;
    }
    int64_t result2 = i2c_write2(a1, a2 % 256, a3 % 256, a4 % 256, &v3, v10 % 256, v1 % 256, 0); // 0x371e
    return result2;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x372c - 0x375c
// Line range:    1415 - 1471
char SmiReadRegister(int64_t device, char SlavAddr, char SlavMode, int32_t RegAddr, char * pData, char DataCont) {
    char result = 68; // 0x374c
    int64_t v1; // 0x372c
    if (*(int64_t *)(v1 - 24) != __readgsqword(40)) {
        // 0x374e
        result = __stack_chk_fail();
    }
    // 0x3753
    return result;
}

// Address range: 0x375c - 0x3845
int64_t SmiReadRegister2(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char * a5, int64_t * a6, char a7) {
    uint64_t v1 = (int64_t)a6;
    mcount();
    __readgsqword(40);
    char * v2 = (char *)(a1 + 0x5908); // 0x3798
    *v2 = (char)&g1;
    int64_t v3 = 0; // bp-88, 0x37a3
    char v4 = v1; // 0x37c6
    uint64_t v5 = (v4 & (char)&g33) == 0 ? v1 : v1 + 4 & 0xfffffffc;
    unsigned char v6 = (char)a3; // 0x37d7
    int64_t result; // 0x375c
    if (v6 == 0) {
        // 0x37e2
        result = cfg_read2(a1, a4 % 0x10000, v5 % 256, &v3);
    } else {
        if (v6 > (char)&g89) {
            // 0x3826
            *v2 = 0;
            return 68;
        }
        int64_t v7 = i2c_read2(a1, a2 % 256, a3 % 256, a4 % 256, &v3, v5 % 256, v1 % 256, 0); // 0x381a
        result = v7;
    }
    if (v4 != 0) {
        // 0x3834
        return &v3;
    }
    // 0x3824
    return result;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3854 - 0x3884
// Line range:    1545 - 1634
char SetTSMode(int64_t device, char tuner_number) {
    // 0x3854
    int64_t v1; // 0x3854
    *(char *)(v1 + 0x5908) = 0;
    char result = 0; // 0x3872
    int64_t v2; // 0x3854
    if (*(int64_t *)(v2 - 40) != __readgsqword(40)) {
        // 0x3874
        result = __stack_chk_fail();
    }
    // 0x3879
    return result;
}

// Address range: 0x3884 - 0x3956
int64_t SetTSMode2(int64_t a1, int64_t a2) {
    // 0x3884
    mcount();
    int32_t v1 = 0; // bp-25, 0x3895
    char v2 = a2; // 0x3899
    if (v2 == 0) {
        // 0x38b0
        SmiReadRegister2(a1, 0, 0, 2880, (char *)&v1, (int64_t *)&g1, 0);
        v1 |= -128;
        return SmiWriteRegister2(a1, 0, 0, 2880, (char *)&v1, (int64_t *)&g1);
    }
    if (v2 != (char)&g86 == (v2 != (char)&g25) == (v2 != (char)&g91)) {
        // 0x390e
        SmiReadRegister2(a1, 0, 0, 2560, (char *)&v1, (int64_t *)&g1, 0);
        return v1 | -128;
    }
    // 0x38b0
    SmiReadRegister2(a1, 0, 0, 2880, (char *)&v1, (int64_t *)&g1, 0);
    v1 |= -128;
    return SmiWriteRegister2(a1, 0, 0, 2880, (char *)&v1, (int64_t *)&g1);
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3956 - 0x3986
// Line range:    1369 - 1398
char SmiTunerPowerUp(int64_t device) {
    // 0x3956
    int64_t v1; // 0x3956
    char * v2 = (char *)(v1 - 17); // 0x3956
    int64_t v3; // 0x3956
    *v2 = (char)v3;
    int64_t v4; // 0x3956
    SmiWriteRegister2(v4, 0, 0, 2560, v2, (int64_t *)&g1);
    return &g1;
}

// Address range: 0x3986 - 0x39d0
int64_t SmiTunerPowerUp2(int64_t a1) {
    // 0x3986
    mcount();
    *(char *)(a1 + 0x590a) = 0;
    int64_t result = *(int64_t *)(a1 + 0x57f8) + 2184; // 0x39ad
    int32_t * v1 = (int32_t *)result; // 0x39b3
    *v1 = *v1 & -2;
    return result;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x39d3 - 0x3a03
// Line range:    1200 - 1237
char Hardware_PowerUp(int64_t device) {
    // 0x39d3
    int64_t v1; // 0x39d3
    *(int32_t *)v1 = 2 * (int32_t)v1;
    int64_t v2; // 0x39d3
    int64_t v3 = *(int64_t *)(v2 + 0x57f8); // 0x39d9
    int64_t v4; // 0x39d3
    *(int32_t *)(v3 + 2184) = (int32_t)v4 | (int32_t)&g1;
    int64_t v5; // 0x39d3
    DelayMilliseconds2((int64_t *)&g7, v5);
    return &g1;
}

// Address range: 0x3a03 - 0x3a30
int64_t Hardware_PowerUp2(int64_t a1) {
    // 0x3a03
    mcount();
    SmiTunerPowerUp2(a1);
    return 0;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3a31 - 0x3a38
// Line range:    1344 - 1361
char SmiTunerPowerDown(int64_t device) {
    // 0x3a31
    int64_t result; // 0x3a31
    char * v1 = (char *)(result - 119); // 0x3a31
    int64_t v2; // 0x3a31
    *v1 = *v1 - (char)v2;
    return result;
}

// Address range: 0x3a39 - 0x3a4e
int64_t function_3a39(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x3a39
    int64_t v1; // 0x3a39
    int32_t * v2 = (int32_t *)(v1 - 125); // 0x3a39
    *v2 = *v2 - (int32_t)&g1;
    int32_t * v3 = (int32_t *)(a2 - 58 + a4 * (int64_t)&g1); // 0x3a3d
    *v3 = *v3 + (int32_t)a2;
    int64_t result; // 0x3a39
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    char v5 = *(char *)&result; // 0x3a46
    uint64_t v6; // 0x3a39
    *(char *)result = v5 + (char)(v6 >> (int64_t)&g95);
    return result;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3a52 - 0x3a61
// Line range:    1172 - 1196
char Hardware_PowerDown(int64_t device) {
    // 0x3a52
    int64_t v1; // 0x3a52
    char result = v1;
    *(char *)v1 = 2 * result;
    int32_t * v2 = (int32_t *)(v1 + (int64_t)&g1); // 0x3a54
    *v2 = *v2 + (int32_t)device;
    return result;
}

// Address range: 0x3a61 - 0x3a82
int64_t SmiTunerPowerDown2(int64_t a1) {
    // 0x3a61
    mcount();
    *(char *)(a1 + 0x590a) = 0;
    int64_t v1; // 0x3a61
    DelayMilliseconds2((int64_t *)&g7, v1);
    return &g1;
}

// Address range: 0x3a82 - 0x3a93
int64_t Hardware_PowerDown2(int64_t a1) {
    // 0x3a82
    return mcount();
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3a94 - 0x3ac4
// Line range:    1310 - 1338
char HwSoftReset(int64_t device, int64_t ulTime) {
    // 0x3a94
    int64_t v1; // 0x3a94
    *(int32_t *)v1 = 2 * (int32_t)v1;
    int64_t result; // 0x3a94
    int64_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    if (*(char *)(device + 0x57d2) == 0) {
        // 0x3abd
        return result;
    }
    // 0x3aa1
    result = 0;
    int64_t result2 = 0; // 0x3aaf
    if ((char)SmiTunerPowerDown2(device) != 0) {
        // 0x3ab1
        int64_t v3; // 0x3a94
        *(char *)(v3 + 0x57d2) = 0;
        result = &g1;
        result2 = &g1;
    }
    // 0x3abd
    return result2;
}

// Address range: 0x3ac4 - 0x3ac9
int64_t HwSoftReset2(int64_t a1, int64_t * a2) {
    // 0x3ac4
    int64_t result; // 0x3ac4
    return result;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3aca - 0x3afa
// Line range:    70 - 127
int64_t Hardware_Init(int64_t device) {
    // 0x3aca
    mcount();
    char * v1 = (char *)(device + 0x57d4); // 0x3ad5
    *v1 = (char)&g1;
    int64_t v2; // 0x3aca
    DelayMilliseconds2((int64_t *)(v2 * (int64_t)(int32_t)((int64_t)&g86 + 1) * (int64_t)(int32_t)((int64_t)&g1 + 1) & 0xffffffff), v2 * (int64_t)(int32_t)((int64_t)&g86 + 1) & 0xffffffff);
    *v1 = 0;
    return &g1;
}

// Address range: 0x3afa - 0x3ba7
int64_t Hardware_Init2(int64_t a1) {
    // 0x3afa
    mcount();
    char v1 = 0; // bp-40, 0x3b0d
    char v2 = -56; // bp-56, 0x3b21
    SmiReadRegister2(a1, 0, 0, 2176, &v1, (int64_t *)&g86, -56);
    v1 &= -64;
    SmiWriteRegister2(a1, 0, 0, 2176, &v1, (int64_t *)&g86);
    SmiWriteRegister2(a1, 0, 0, 2308, &v2, (int64_t *)&g86);
    return DelayMilliseconds2((int64_t *)&g25, 0);
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3ba8 - 0x3bb5
// Line range:    1109 - 1129
void Hardware_RemoveDevice(int64_t device) {
    // 0x3ba8
    return;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3bb8 - 0x3bd8
// Line range:    695 - 906
void Hardware_StopTSStream(int64_t device, char tuner_number) {
    // 0x3bb8
    int64_t v1; // 0x3bb8
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x3bb8
    int64_t v3; // 0x3bb8
    int64_t v4; // 0x3bb8
    int64_t v5; // 0x3bb8
    int64_t v6; // 0x3bb8
    SmiWriteRegister2(v4, (int64_t)tuner_number, v5, v6, (char *)v3, (int64_t *)v2);
    SmiTunerPowerDown2(v4);
}

// Address range: 0x3bd8 - 0x3be8
int64_t Hardware_RemoveDevice2(void) {
    // 0x3bd8
    mcount();
    return SmiFreeDeviceResources2();
}

// Address range: 0x3be8 - 0x3cc2
int64_t Hardware_StopTSStream2(int64_t a1, uint64_t a2) {
    // 0x3be8
    mcount();
    int64_t v1 = 0; // 0x3c07
    while ((int32_t)v1 != (int32_t)&g95) {
        // 0x3c0b
        v1 &= 0xffffffff;
    }
    // 0x3c39
    if (((int32_t)a2 & (int32_t)&g1) != 0) {
        // 0x3c46
        *(char *)(a1 + 0x6170) = 0;
    } else {
        // 0x3c3d
        *(char *)(a1 + 0x617a) = 0;
    }
    int64_t v2 = &g1; // 0x3c4d
    int64_t v3 = v2 & 0xffffffff; // 0x3c57
    int64_t v4 = a1 + (int64_t)&g1; // 0x3c57
    while ((char)v2 != (char)&g98) {
        int64_t v5 = v4;
        if (((int32_t)a2 & (int32_t)&g1) != 0) {
            // 0x3c46
            *(char *)(v5 + 0x6170) = 0;
        } else {
            // 0x3c3d
            *(char *)(v5 + 0x617a) = 0;
        }
        // 0x3c4d
        v2 = v3 + (int64_t)(int32_t)&g1;
        v3 = v2 & 0xffffffff;
        v4 = v5 + (int64_t)&g1;
    }
    uint64_t v6 = a2 % 64; // 0x3c67
    bool v7 = v6 == 0 ? ((int64_t)&g1 & 170) != 0 : ((int64_t)&g1 << v6 & 170) != 0; // 0x3c6c
    if (v7) {
        // 0x3cac
        *(char *)(a1 + 0x58f9) = (char)&g1;
        return smi_cancel_dma_A2(a1);
    }
    // 0x3c6e
    *(char *)(a1 + 0x58fb) = (char)&g1;
    smi_cancel_dma_B2(a1);
    storageBufferFlush2(a1 + 0x5860);
    *(char *)(a1 + 0x58fa) = 0;
    return HwSoftReset2(a1, (int64_t *)&g98);
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3cc2 - 0x3cf2
// Line range:    321 - 511
void Hardware_StopTSStream_Force(int64_t device, char tuner_number) {
    // 0x3cc2
    storageBufferFlush2(device);
    int64_t v1; // 0x3cc2
    *(char *)(v1 + 0x58f8) = 0;
    if (*(char *)(v1 + 200) == 0) {
        // 0x3cd7
        HwSoftReset2(v1, (int64_t *)&g98);
    }
    // 0x3ce4
    *(char *)(v1 + 0x57b0) = 0;
}

// Address range: 0x3cf2 - 0x3d65
int64_t Hardware_StopTSStream_Force2(int64_t a1, uint64_t a2) {
    // 0x3cf2
    mcount();
    uint64_t v1 = a2 % 64; // 0x3d10
    bool v2 = v1 == 0 ? ((int64_t)&g1 & 170) != 0 : ((int64_t)&g1 << v1 & 170) != 0; // 0x3d15
    if (v2) {
        // 0x3d52
        *(char *)(a1 + 0x58f9) = (char)&g1;
        return smi_cancel_dma_A2(a1);
    }
    // 0x3d17
    *(char *)(a1 + 0x58fb) = (char)&g1;
    smi_cancel_dma_B2(a1);
    storageBufferFlush2(a1 + 0x5860);
    *(char *)(a1 + 0x58fa) = 0;
    return HwSoftReset2(a1, (int64_t *)&g98);
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3d65 - 0x3d95
// Line range:    513 - 693
int64_t Hardware_StartTSStream(int64_t device, char tuner_number) {
    int64_t v1 = storageBufferFlush2(device); // 0x3d65
    int64_t v2; // 0x3d65
    *(char *)(v2 + 0x58f8) = 0;
    int64_t result = v1; // 0x3d78
    if (*(char *)(v2 + 200) == 0) {
        // 0x3d7a
        result = HwSoftReset2(v2, (int64_t *)&g98);
    }
    // 0x3d87
    *(char *)(v2 + 0x57b0) = 0;
    return result;
}

// Address range: 0x3d95 - 0x3ea5
int64_t Hardware_StartTSStream2(int64_t a1, unsigned char a2) {
    // 0x3d95
    mcount();
    uint64_t v1 = (int64_t)(char)a2; // 0x3da6
    int64_t v2 = 0; // 0x3db4
    int64_t v3 = a1 + 888;
    char v4 = v2; // 0x3db8
    if (v4 != a2) {
        if (((v4 ^ a2) & (char)&g1) == 0) {
            // 0x3dc4
            if (*(char *)v3 == 1) {
                // 0x3dc9
                return &g1;
            }
        }
    }
    int64_t v5 = v2 + (int64_t)(int32_t)&g1; // 0x3dd3
    v2 = v5 & 0xffffffff;
    int64_t v6 = v3 + 1; // 0x3ddd
    while ((int32_t)v5 != (int32_t)&g95) {
        // 0x3db8
        v3 = v6;
        v4 = v2;
        if (v4 != a2) {
            if (((v4 ^ a2) & (char)&g1) == 0) {
                // 0x3dc4
                if (*(char *)v3 == 1) {
                    // 0x3dc9
                    return &g1;
                }
            }
        }
        // 0x3dd3
        v5 = v2 + (int64_t)(int32_t)&g1;
        v2 = v5 & 0xffffffff;
        v6 = v3 + 1;
    }
    // 0x3ddf
    if (((int32_t)a2 & (int32_t)&g1 & 255) != 0) {
        // 0x3e01
        *(char *)(a1 + 0x6170) = 0;
    } else {
        // 0x3df8
        *(char *)(a1 + 0x617a) = 0;
    }
    int64_t v7 = &g1; // 0x3e08
    int64_t v8 = v7 & 0xffffffff; // 0x3e12
    int64_t v9 = a1 + (int64_t)&g1; // 0x3e12
    while ((char)v7 != (char)&g98) {
        int64_t v10 = v9;
        if (((int32_t)a2 & (int32_t)&g1 & 255) != 0) {
            // 0x3e01
            *(char *)(v10 + 0x6170) = 0;
        } else {
            // 0x3df8
            *(char *)(v10 + 0x617a) = 0;
        }
        // 0x3e08
        v7 = v8 + (int64_t)(int32_t)&g1;
        v8 = v7 & 0xffffffff;
        v9 = v10 + (int64_t)&g1;
    }
    uint64_t v11 = v1 % 64; // 0x3e22
    bool v12 = v11 == 0 ? ((int64_t)&g1 & 170) != 0 : ((int64_t)&g1 << v11 & 170) != 0; // 0x3e27
    int64_t v13 = SetTSMode2(a1, v1 % 256);
    if (v12) {
        // 0x3e7a
        *(char *)(a1 + 0x58f9) = 0;
        char * v14 = (char *)(a1 + 0x58f8); // 0x3e89
        int64_t result = v13; // 0x3e90
        if (*v14 == 0) {
            // 0x3e92
            *v14 = (char)&g1;
            result = smi_cfg_dma_A2(a1);
        }
        // 0x3dc9
        return result;
    }
    // 0x3e29
    *(char *)(a1 + 0x58fb) = 0;
    char * v15 = (char *)(a1 + 0x58fa); // 0x3e40
    int64_t result2 = v13; // 0x3e47
    if (*v15 == 0) {
        // 0x3e49
        *v15 = (char)&g1;
        result2 = smi_cfg_dma_B2(a1);
    }
    // 0x3e5c
    *(char *)(a1 + 0x6169) = (char)&g1;
    *(char *)(a1 + 0x616c) = 0;
    *(char *)(a1 + 0x616d) = (char)&g1;
    *(char *)(a1 + 0x616f) = 0;
    return result2;
}

// From module:   /root/asv5220\hardware.c
// Address range: 0x3eab - 0x3edb
// Line range:    136 - 319
int64_t Hardware_StartTSStream_Force(int64_t device, char tuner_number) {
    // 0x3eab
    int64_t v1; // 0x3eab
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x3eab
    *(char *)(v2 + 0x616b) = (char)&g1;
    *(char *)(v2 + 0x616e) = 0;
    *(char *)(v2 + 0x57b0) = (char)&g1;
    return &g1;
}

// Address range: 0x3edb - 0x3f4b
int64_t Hardware_StartTSStream_Force2(int64_t a1, uint64_t a2) {
    // 0x3edb
    mcount();
    uint64_t v1 = a2 % 64; // 0x3ef9
    bool v2 = v1 == 0 ? ((int64_t)&g1 & 170) != 0 : ((int64_t)&g1 << v1 & 170) != 0; // 0x3efe
    int64_t result = SetTSMode2(a1, a2 % 256);
    if (v2) {
        // 0x3f32
        *(char *)(a1 + 0x58f9) = 0;
        return result;
    }
    // 0x3f00
    *(char *)(a1 + 0x58fb) = 0;
    *(char *)(a1 + 0x58fa) = (char)&g1;
    return smi_cfg_dma_B2(a1);
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x3f50 - 0x3f5e
// Line range:    113 - 123
int64_t FUSBDTV_SendTVCmd(int64_t deviceExtension, char * pCxOut5bytes, char * pCxInData, int16_t CxInLen, int16_t TimeOUT) {
    // 0x3f50
    int64_t v1; // 0x3f50
    int64_t v2; // 0x3f50
    *(char *)(int64_t)CxInLen = (char)v2 + (char)v1;
    int64_t v3; // 0x3f50
    return smi_cfg_dma_A2(v3);
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x3f60 - 0x3f6c
// Line range:    126 - 136
int64_t FUSBDTV_SendTVCmd_Ex(int64_t deviceExtension, char * pCxOut5bytes, char * pCxInData, int16_t CxInLen, char CxDirect, int16_t TimeOUT) {
    // 0x3f60
    int64_t v1; // 0x3f60
    int64_t result = v1 & -256 | 87; // 0x3f60
    char * v2 = (char *)result; // 0x3f62
    *v2 = *v2 + 87;
    int32_t * v3 = (int32_t *)(result + 1); // 0x3f64
    *v3 = *v3 + (int32_t)deviceExtension;
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x3f70 - 0x3f78
// Line range:    138 - 161
int64_t FUSBDTV_Cmd_Get_DevRandomKey(int64_t deviceExtension) {
    // 0x3f70
    int64_t result; // 0x3f70
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x3f80 - 0x3f90
// Line range:    165 - 182
void GenEncCmd(char bIndex, char * pData, char DataLen, char * u8DevRandomKey) {
    // 0x3f80
    mcount();
}

// Address range: 0x3f90 - 0x3fa0
int64_t FUSBDTV_SendTVCmd_Ex2(void) {
    // 0x3f90
    mcount();
    return 0;
}

// Address range: 0x3fa0 - 0x3fb0
int64_t FUSBDTV_Cmd_Get_DevRandomKey2(int64_t a1) {
    // 0x3fa0
    mcount();
    return 0;
}

// Address range: 0x3fb0 - 0x3fdc
int64_t GenEncCmd2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x3fb0
    mcount();
    return a1 & 0xffffff00 | (int64_t)(unsigned char)((unsigned char)(char)a1 >> (unsigned char)(char)&g86);
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x3fe0 - 0x3ff0
// Line range:    186 - 191
int64_t FUSBDTV_Cmd_Set_RandomKey(int64_t deviceExtension, char I2C_Addr) {
    // 0x3fe0
    int64_t result; // 0x3fe0
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x3ff0 - 0x3ffe
// Line range:    195 - 200
int64_t FUSBDTV_Cmd_T_confirm(int64_t deviceExtension, char ChannelNum) {
    // 0x3ff0
    int64_t v1; // 0x3ff0
    *(char *)(int64_t)ChannelNum = (char)v1;
    int64_t v2; // 0x3ff0
    int64_t v3 = v2 + (int64_t)(int32_t)&g1; // 0x3ff3
    int64_t v4; // 0x3ff0
    return ((char)v3 >= (char)&g2 ? v4 : v3) & 0xffffffff;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4000 - 0x4010
// Line range:    204 - 209
int64_t FUSBDTV_Cmd_TimerStartStop(int64_t deviceExtension, char ChannelNum, char bStart) {
    // 0x4000
    int64_t result; // 0x4000
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4010 - 0x4020
// Line range:    258 - 262
int64_t FUSBDTV_Cmd_ReadIR(int64_t deviceExtension, char * pDataBuf) {
    // 0x4010
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4020 - 0x4030
// Line range:    264 - 268
int64_t FUSBDTV_Cmd_SetIRMode(int64_t deviceExtension, char ModeSel) {
    // 0x4020
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4030 - 0x4040
// Line range:    270 - 274
int64_t FUSBDTV_Cmd_StartDSC(int64_t deviceExtension, char DSC_Num) {
    // 0x4030
    mcount();
    return &g1;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4040 - 0x4050
// Line range:    276 - 280
int64_t FUSBDTV_Cmd_StopDSC(int64_t deviceExtension, char DSC_Num) {
    // 0x4040
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4050 - 0x4060
// Line range:    654 - 658
int64_t FUSBDTV_Cmd_Reset_Channel(int64_t deviceExtension, char Channel_Num, char bSerial) {
    // 0x4050
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4060 - 0x4070
// Line range:    660 - 664
int64_t FUSBDTV_Cmd_GetDev_Speed(int64_t deviceExtension, char * bHighSpeed) {
    // 0x4060
    mcount();
    return &g1;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4070 - 0x4080
// Line range:    667 - 672
int64_t FUSBDTV_Cmd_I2CRead_NoWt(int64_t deviceExtension, char Slave_Addr, int16_t u16ReadLen, char * pDataBuf) {
    // 0x4070
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4080 - 0x4090
// Line range:    709 - 714
int64_t FUSBDTV_Cmd_I2CRead(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16ReadLen, char * pDataBuf, char byI2CFlag) {
    // 0x4080
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4090 - 0x40a0
// Line range:    745 - 750
int64_t FUSBDTV_Cmd_I2CWrite(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16WriteLen, char * pDataBuf) {
    // 0x4090
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x40a0 - 0x40b0
// Line range:    752 - 757
int64_t FUSBDTV_Cmd_I2CWrite_noStop(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16WriteLen, char * pDataBuf) {
    // 0x40a0
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x40b0 - 0x40c0
// Line range:    758 - 763
int64_t FUSBDTV_Cmd_I2CBufFill(int64_t deviceExtension, char u8BufOffset, int16_t u16WriteLen, char * pDataBuf) {
    // 0x40b0
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x40c0 - 0x40d0
// Line range:    765 - 770
int64_t FUSBDTV_Cmd_I2CBufSend(int64_t deviceExtension, char Slave_Addr, int16_t u16WriteLen, char NoSendStopByte) {
    // 0x40c0
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x40d0 - 0x40e0
// Line range:    793 - 798
int64_t FUSBDTV_Cmd_SysCtrlWrite(int64_t deviceExtension, char RegOffset, int16_t u16WriteLen, char * pDataBuf) {
    // 0x40d0
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x40e0 - 0x40f0
// Line range:    800 - 805
int64_t FUSBDTV_Cmd_CFRead(int64_t deviceExtension, char CF_Num, char RegOffset, int16_t u16ReadLen, char * pDataBuf) {
    // 0x40e0
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x40f0 - 0x4100
// Line range:    808 - 813
int64_t FUSBDTV_Cmd_CFWrite(int64_t deviceExtension, char CF_Num, char RegOffset, int16_t u16WriteLen, char * pDataBuf) {
    // 0x40f0
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4100 - 0x4110
// Line range:    815 - 820
int64_t FUSBDTV_Cmd_EncRead(int64_t deviceExtension, char CF_Num, char RegOffset, int16_t u16ReadLen, char * pDataBuf) {
    // 0x4100
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4110 - 0x4120
// Line range:    822 - 827
int64_t FUSBDTV_Cmd_EncWrite(int64_t deviceExtension, char CF_Num, char RegOffset, int16_t u16WriteLen, char * pDataBuf) {
    // 0x4110
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4120 - 0x4130
// Line range:    830 - 834
int64_t FUSBDTV_Cmd_Simulation_Enable(int64_t deviceExtension, char u8Enable) {
    // 0x4120
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4130 - 0x4140
// Line range:    919 - 923
int64_t FUSBDTV_Cmd_Rst_Enc(int64_t deviceExtension) {
    // 0x4130
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4140 - 0x4150
// Line range:    925 - 930
int64_t FUSBDTV_Cmd_WriteEncReg(int64_t deviceExtension, char RegOffset, char RegData) {
    // 0x4140
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4150 - 0x4160
// Line range:    945 - 950
int64_t FUSBDTV_ResetParentPort(char * DeviceObject) {
    // 0x4150
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4160 - 0x4170
// Line range:    964 - 1206
int64_t FUSBDTV_ProcessTransfer(int64_t TransferObject) {
    // 0x4160
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4170 - 0x4180
// Line range:    1215 - 1259
int64_t FUSBDTV_InitializeStreamUrb_ISR(int64_t TransferObject) {
    // 0x4170
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4180 - 0x4190
// Line range:    1263 - 1327
int64_t FUSBDTV_DecrementIoCount(int64_t deviceExtension) {
    // 0x4180
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4190 - 0x4199
// Line range:    1331 - 1370
void FUSBDTV_IncrementIoCount(int64_t deviceExtension) {
    // 0x4190
    mcount();
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x419b - 0x41a0
// Line range:    1381 - 1384
void FUSB_RstBulkPipe(int64_t deviceExtension, char TunerNum) {
    // 0x419b
    int64_t v1; // 0x419b
    *(char *)v1 = 2 * (char)v1;
}

// Address range: 0x41a0 - 0x41a4
int64_t FUSBDTV_InitializeStreamUrb_ISR2(void) {
    // 0x41a0
    int64_t result; // 0x41a0
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x41a6 - 0x41b0
// Line range:    1401 - 1574
int64_t FUSBDTV_BulkIrp_Complete(char * DeviceObject, char * Irp, char * Context) {
    // 0x41a6
    int64_t v1; // 0x41a6
    *DeviceObject = (char)v1;
    return &g1;
}

// Address range: 0x41b0 - 0x41b4
int64_t FUSBDTV_DecrementIoCount2(void) {
    // 0x41b0
    int64_t result; // 0x41b0
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x41b6 - 0x41c0
// Line range:    1583 - 1661
int64_t FUSBDTV_InitializeStreamUrb(int64_t TransferObject) {
    // 0x41b6
    int64_t v1; // 0x41b6
    *(char *)TransferObject = (char)v1;
    return 0;
}

// Address range: 0x41c0 - 0x41c4
int64_t FUSBDTV_IncrementIoCount2(void) {
    // 0x41c0
    int64_t result; // 0x41c0
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x41c6 - 0x41cb
// Line range:    2625 - 2629
int64_t FUSBDTV_Cmd_RePlugInDevice(int64_t DeviceObject, char wait_time) {
    // 0x41c6
    int64_t v1; // 0x41c6
    *(char *)DeviceObject = (char)v1;
    return 2 * v1 & 0xfffffffe;
}

// Address range: 0x41cb - 0x41d6
int64_t FUSB_RstBulkPipe2(int64_t a1, int64_t a2) {
    // 0x41cb
    return mcount();
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x41d6 - 0x41e6
// Line range:    2992 - 3021
int32_t findRingbufNumToDispatchByRuleTable(char dmaCH, char * p, int64_t table, int32_t tablesize) {
    // 0x41d6
    mcount();
    return 0;
}

// Address range: 0x41e6 - 0x41f6
int64_t FUSBDTV_InitializeStreamUrb2(void) {
    // 0x41e6
    mcount();
    return &g1;
}

// Address range: 0x41f6 - 0x4206
int64_t FUSBDTV_Cmd_RePlugInDevice2(void) {
    // 0x41f6
    mcount();
    return 0;
}

// Address range: 0x4206 - 0x421d
int64_t findRingbufNumToDispatchByRuleTable2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x4206
    mcount();
    return (bool)((char)a1 != 0);
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4238 - 0x4268
// Line range:    3780 - 3795
int64_t ASV5220_GetCardInDetect(char * pCardDetect, int64_t hDEV) {
    int64_t v1 = (int64_t)pCardDetect;
    int64_t v2; // 0x4238
    char v3 = v2;
    *(char *)v2 = v3;
    int64_t result; // 0x4238
    if (v3 != 0) {
        char v4 = *(char *)(v1 + (int64_t)&g86); // 0x4241
        result = 0xffffffff;
        if ((v4 ^ *(char *)(hDEV + (int64_t)&g1)) < 0) {
            // 0x4265
            return result;
        }
    }
    // 0x424a
    *(char *)hDEV = 71;
    if (*(int32_t *)(v1 + (int64_t)&g95) != 0) {
        char * v5 = (char *)(hDEV + (int64_t)&g1); // 0x4253
        *v5 = *v5 % 128;
    }
    // 0x4265
    return result;
}

// Address range: 0x4268 - 0x4279
int64_t ASV5220_GetCardInDetect2(char * a1) {
    // 0x4268
    return mcount();
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x427a - 0x42aa
// Line range:    3732 - 3761
int64_t ASV5220_WriteCommand(char * WrData, int32_t WrLen, int64_t hDEV) {
    // 0x427a
    int64_t v1; // 0x427a
    int64_t v2 = v1 - 24; // 0x427c
    unsigned char result = bTunerReset(-112, (char)&g86, (char *)v2); // 0x428a
    uint64_t v3 = *(int64_t *)v2; // 0x428f
    int64_t v4; // 0x427a
    *(char *)v4 = ((char)(v3 >> (int64_t)&g7) ^ -4) & (char)&g1;
    return result;
}

// Address range: 0x42aa - 0x4495
int64_t ASV5220_WriteCommand2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x42aa
    mcount();
    char * v1 = (char *)((int64_t)(0x100000000000000 * a2) / 0x100000000000000); // bp-72, 0x42cd
    bReadPcieReg(3212, (int16_t)&g86, (char *)&v1, a3);
    v1 = (char *)&g33;
    bReadPcieReg(3208, (int16_t)&g86, (char *)&v1, a3);
    uint64_t v2 = a2 % 0x10000; // 0x431b
    char v3 = 0; // bp-88, 0x431f
    int64_t v4 = 0;
    bTunerReset(-108, (char)&g86, &v3);
    char v5; // 0x42aa
    while (v5 > (char)&g19) {
        // 0x4330
        bTunerReset(-108, (char)&g86, &v3);
    }
    int32_t v6 = v2 - v4; // 0x4351
    int64_t v7; // 0x42aa
    char v8; // 0x42aa
    if (v6 != (int32_t)&g1) {
        if (v6 != (int32_t)&g25) {
            if (v6 != (int32_t)&g33) {
                // 0x442f
                v8 = v5;
                v7 = v4;
                if (v6 > (int32_t)&g33) {
                    // 0x4434
                    bReadPcieReg((int16_t)&g100, (int16_t)&g86, (char *)(0x100000000 * v4 / 0x100000000 * (int64_t)&g1 + a1), a3);
                    v8 = v5;
                    v7 = v4 + (int64_t)(int32_t)&g86 & 0xffffffff;
                }
            } else {
                // 0x43eb
                v3 = (char)&g94;
                bReadPcieReg(3224, (int16_t)&g86, &v3, a3);
                bReadPcieReg((int16_t)&g100, (int16_t)&g86, (char *)(0x100000000 * v4 / 0x100000000 * (int64_t)&g1 + a1), a3);
                v8 = 0;
                v7 = v4 + (int64_t)(int32_t)&g33 & 0xffffffff;
            }
        } else {
            // 0x43a2
            v3 = (char)&g33;
            bReadPcieReg(3224, (int16_t)&g86, &v3, a3);
            bReadPcieReg((int16_t)&g100, (int16_t)&g86, (char *)(0x100000000 * v4 / 0x100000000 * (int64_t)&g1 + a1), a3);
            v8 = 0;
            v7 = v4 + (int64_t)(int32_t)&g25 & 0xffffffff;
        }
    } else {
        // 0x4356
        v3 = &g1;
        bReadPcieReg(3224, (int16_t)&g86, &v3, a3);
        bReadPcieReg((int16_t)&g100, (int16_t)&g86, (char *)(0x100000000 * v4 / 0x100000000 * (int64_t)&g1 + a1), a3);
        v8 = 0;
        v7 = v4 + (int64_t)(int32_t)&g1 & 0xffffffff;
    }
    char v9 = v8;
    while (v2 > v7) {
        // 0x4330
        v4 = v7;
        char v10 = v9;
        bTunerReset(-108, (char)&g86, &v3);
        while (v10 > (char)&g19) {
            // 0x4330
            bTunerReset(-108, (char)&g86, &v3);
        }
        // 0x434b
        v6 = v2 - v4;
        if (v6 != (int32_t)&g1) {
            if (v6 != (int32_t)&g25) {
                if (v6 != (int32_t)&g33) {
                    // 0x442f
                    v8 = v10;
                    v7 = v4;
                    if (v6 > (int32_t)&g33) {
                        // 0x4434
                        bReadPcieReg((int16_t)&g100, (int16_t)&g86, (char *)(0x100000000 * v4 / 0x100000000 * (int64_t)&g1 + a1), a3);
                        v8 = v10;
                        v7 = v4 + (int64_t)(int32_t)&g86 & 0xffffffff;
                    }
                } else {
                    // 0x43eb
                    v3 = (char)&g94;
                    bReadPcieReg(3224, (int16_t)&g86, &v3, a3);
                    bReadPcieReg((int16_t)&g100, (int16_t)&g86, (char *)(0x100000000 * v4 / 0x100000000 * (int64_t)&g1 + a1), a3);
                    v8 = 0;
                    v7 = v4 + (int64_t)(int32_t)&g33 & 0xffffffff;
                }
            } else {
                // 0x43a2
                v3 = (char)&g33;
                bReadPcieReg(3224, (int16_t)&g86, &v3, a3);
                bReadPcieReg((int16_t)&g100, (int16_t)&g86, (char *)(0x100000000 * v4 / 0x100000000 * (int64_t)&g1 + a1), a3);
                v8 = 0;
                v7 = v4 + (int64_t)(int32_t)&g25 & 0xffffffff;
            }
        } else {
            // 0x4356
            v3 = &g1;
            bReadPcieReg(3224, (int16_t)&g86, &v3, a3);
            bReadPcieReg((int16_t)&g100, (int16_t)&g86, (char *)(0x100000000 * v4 / 0x100000000 * (int64_t)&g1 + a1), a3);
            v8 = 0;
            v7 = v4 + (int64_t)(int32_t)&g1 & 0xffffffff;
        }
        // 0x4451
        v9 = v8;
    }
    char result = bTunerReset(-108, (char)&g86, &v3); // 0x446e
    while (v9 != 0) {
        // 0x445e
        result = bTunerReset(-108, (char)&g86, &v3);
    }
    // 0x4479
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4499 - 0x44c9
// Line range:    3558 - 3577
int64_t ASV5220_SetBaudrate(int64_t hDEV) {
    // 0x4499
    *(char *)((__asm_sti() + 0x8d480001 & 0xffffffff) - 119) = -1;
    int64_t v1; // 0x4499
    bTunerReset(-120, (char)&g86, (char *)v1);
    return &g1;
}

// Address range: 0x44c9 - 0x4505
int64_t ASV5220_SetBaudrate2(int64_t a1) {
    // 0x44c9
    mcount();
    char * v1 = (char *)&g99; // bp-40, 0x44e0
    char result = bReadPcieReg(3204, (int16_t)&g86, (char *)&v1, a1); // 0x4500
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4508 - 0x4538
// Line range:    2867 - 2986
int64_t RegisterInitialize(int64_t hDEV) {
    // 0x4508
    int64_t v1; // 0x4508
    *(char *)(v1 - 30) = 126;
    *(char *)(v1 - 29) = 0;
    int64_t v2; // 0x4508
    int64_t v3; // 0x4508
    bReadPcieReg(3200, (int16_t)&g86, (char *)v2, v3);
    return &g1;
}

// Address range: 0x4538 - 0x4670
int64_t RegisterInitialize2(int64_t a1) {
    // 0x4538
    mcount();
    int64_t v1 = 0x10000; // bp-32, 0x4550
    bReadPcieReg(2176, (int16_t)&g86, (char *)&v1, a1);
    v1 = 128;
    bReadPcieReg(2560, (int16_t)&g86, (char *)&v1, a1);
    v1 = 128;
    bReadPcieReg(2880, (int16_t)&g86, (char *)&v1, a1);
    v1 = 0;
    bReadPcieReg(2184, (int16_t)&g86, (char *)&v1, a1);
    v1 = 207;
    bReadPcieReg(2196, (int16_t)&g86, (char *)&v1, a1);
    v1 = 0x8000;
    bReadPcieReg(2188, (int16_t)&g86, (char *)&v1, a1);
    v1 = 0x1004;
    bReadPcieReg(2192, (int16_t)&g86, (char *)&v1, a1);
    v1 = 144;
    char result = bReadPcieReg(2304, (int16_t)&g86, (char *)&v1, a1); // 0x4667
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4676 - 0x46a6
// Line range:    3763 - 3778
int64_t ASV5220_ReadResponse(char * RdData, int32_t RdLen, int64_t TimeOut, int64_t hDEV) {
    // 0x4676
    int64_t v1; // 0x4676
    int64_t v2; // 0x4676
    char v3 = bReadPcieReg(2308, (int16_t)&g86, (char *)v1, v2); // 0x4688
    return v3 != 0;
}

// Address range: 0x46a6 - 0x4895
int64_t ASV5220_ReadResponse2(int64_t a1, char * a2, char * a3, int64_t a4) {
    // 0x46a6
    mcount();
    int32_t v1 = 0; // bp-72, 0x46f3
    int64_t v2 = 0; // 0x4700
    int64_t v3 = 0; // 0x4700
    int64_t v4; // 0x46a6
    int64_t result; // 0x46a6
    int64_t v5; // 0x46a6
    int64_t v6; // 0x46a6
    int32_t v7; // 0x46a6
    while (true) {
      lab_0x4705:
        // 0x4705
        v4 = v3;
        v5 = v2;
        bTunerReset(-108, (char)&g86, (char *)&v1);
        v7 = v5;
        if (v7 != 0) {
            goto lab_0x4770;
        } else {
            // 0x4724
            if ((char)v1 == 0) {
                goto lab_0x4770;
            } else {
                // 0x472a
                v1 = &g1;
                bReadPcieReg(3228, (int16_t)&g86, (char *)&v1, a4);
                char v8 = bTunerReset((char)&g100, (char)&g86, (char *)(0x100000000 * v5 / 0x100000000 + a1)); // 0x4763
                result = v8;
                v6 = v5 + (int64_t)(int32_t)&g1 & 0xffffffff;
                v3 = v4;
                goto lab_0x4877;
            }
        }
    }
    // 0x487f
    return result;
  lab_0x4770:;
    int32_t v9 = (int32_t)&g1 - v7; // 0x471f
    if (v9 != (int32_t)&g25) {
        goto lab_0x47c1;
    } else {
        // 0x4775
        if ((char)v1 > (char)&g1) {
            // 0x477b
            v1 = &g25;
            bReadPcieReg(3228, (int16_t)&g86, (char *)&v1, a4);
            char v10 = bTunerReset((char)&g100, (char)&g86, (char *)(0x100000000 * v5 / 0x100000000 + a1)); // 0x47b4
            result = v10;
            v6 = v5 + (int64_t)(int32_t)&g25 & 0xffffffff;
            v3 = v4;
            goto lab_0x4877;
        } else {
            goto lab_0x47c1;
        }
    }
  lab_0x47c1:
    if (v9 != (int32_t)&g33) {
        goto lab_0x480f;
    } else {
        // 0x47c6
        if ((char)v1 > (char)&g25) {
            // 0x47cc
            v1 = (int32_t)&g33;
            bReadPcieReg(3228, (int16_t)&g86, (char *)&v1, a4);
            char v11 = bTunerReset((char)&g100, (char)&g86, (char *)(0x100000000 * v5 / 0x100000000 + a1)); // 0x4805
            result = v11;
            v6 = v5 + (int64_t)(int32_t)&g33 & 0xffffffff;
            v3 = v4;
            goto lab_0x4877;
        } else {
            goto lab_0x480f;
        }
    }
  lab_0x480f:
    if (v9 > (int32_t)&g33) {
        // 0x4814
        if ((char)v1 > (char)&g33) {
            char v12 = bTunerReset((char)&g100, (char)&g86, (char *)(0x100000000 * v5 / 0x100000000 + a1)); // 0x482e
            result = v12;
            v6 = v5 + (int64_t)(int32_t)&g86 & 0xffffffff;
            v3 = v4;
            goto lab_0x4877;
        } else {
            goto lab_0x4838;
        }
    } else {
        goto lab_0x4838;
    }
  lab_0x4877:
    // 0x4877
    v2 = v6;
    if ((int32_t)v2 >= 1) {
        return result;
    }
    goto lab_0x4705;
  lab_0x4838:;
    int64_t v13 = v4 + (int64_t)&g1; // 0x4838
    if (v13 == (int64_t)a3) {
        // 0x4842
        v1 = &g86;
        bReadPcieReg(3228, (int16_t)&g86, (char *)&v1, a4);
        return 0;
    }
    int64_t v14 = DelayMilliseconds2((int64_t *)(int32_t)&g1, (int64_t)&g86); // 0x4872
    result = v14;
    v6 = v5;
    v3 = v13;
    goto lab_0x4877;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4898 - 0x48ab
// Line range:    55 - 77
int32_t FUSBDTV_Wait(int64_t dwMilliseconds) {
    // 0x4898
    int64_t v1; // 0x4898
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x4898
    int64_t v3; // 0x4898
    int64_t v4; // 0x4898
    bReadPcieReg(3228, (int16_t)v2, (char *)v3, v4);
    int64_t v5; // 0x4898
    int32_t * v6 = (int32_t *)(v5 - 80); // 0x48a4
    int32_t result = *v6 + (int32_t)&g1; // 0x48a4
    *v6 = result;
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x48ad - 0x48c8
// Line range:    3509 - 3556
int64_t ASV5220_InitUart(int64_t hDEV) {
    // 0x48ad
    return &g1;
}

// Address range: 0x48c8 - 0x48dd
int64_t FUSBDTV_Wait2(int64_t * a1) {
    // 0x48c8
    mcount();
    int64_t v1; // 0x48c8
    DelayMilliseconds2(a1, v1);
    return &g1;
}

// Address range: 0x48dd - 0x49ea
int64_t ASV5220_InitUart2(int64_t a1) {
    // 0x48dd
    mcount();
    int32_t * v1 = (int32_t *)&g12; // bp-40, 0x48f4
    bReadPcieReg(3204, (int16_t)&g86, (char *)&v1, a1);
    v1 = (int32_t *)34;
    bReadPcieReg(3200, (int16_t)&g86, (char *)&v1, a1);
    v1 = (int32_t *)&g33;
    bReadPcieReg(3208, (int16_t)&g86, (char *)&v1, a1);
    v1 = NULL;
    bReadPcieReg(3212, (int16_t)&g86, (char *)&v1, a1);
    bTunerReset(-112, (char)&g86, (char *)&v1);
    v1 = (int32_t *)(0x100000000000000 * (int64_t)v1 / 0x100000000000000 & -33);
    bReadPcieReg(2192, (int16_t)&g86, (char *)&v1, a1);
    int64_t v2 = 0; // 0x49b6
    vUSB_Wait2((int64_t)&g1);
    while ((int32_t)v2 != 50) {
        // 0x49bb
        v2 &= 0xffffffff;
        vUSB_Wait2((int64_t)&g1);
    }
    // 0x49cd
    v1 = (int32_t *)&g26;
    char result = bReadPcieReg(2192, (int16_t)&g86, (char *)&v1, a1); // 0x49e5
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x49ed - 0x4a1d
// Line range:    3489 - 3507
int64_t ASV5220_ResetUart(int64_t hDEV) {
    // 0x49ed
    int64_t v1; // 0x49ed
    int64_t v2; // 0x49ed
    uint32_t result = (int32_t)v2 + (int32_t)v1; // 0x49ed
    int64_t v3; // 0x49ed
    int64_t v4 = v3 - (int64_t)&g1; // 0x49ef
    if (v4 == (int64_t)&g1 || v4 != 0 != (result == 0)) {
        // 0x49f2
        return result;
    }
    // 0x49fa
    int64_t v5; // 0x49ed
    int64_t v6; // 0x49ed
    bReadPcieReg(3208, (int16_t)&g86, (char *)v6, v5);
    return &g1;
}

// Address range: 0x4a1d - 0x4a68
int64_t ASV5220_ResetUart2(int64_t a1) {
    // 0x4a1d
    mcount();
    int16_t v1 = 0; // bp-40, 0x4a34
    bTunerReset(-124, (char)&g86, (char *)&v1);
    v1 = &g86;
    char result = bReadPcieReg(2180, (int16_t)&g86, (char *)&v1, a1); // 0x4a63
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4a69 - 0x4a97
// Line range:    236 - 255
int64_t FUSBDTV_Cmd_I2CWriteEnc(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16WriteLen, char * pDataBuf) {
    // 0x4a69
    int64_t v1; // 0x4a69
    char * v2 = (char *)v1; // 0x4a6b
    *v2 = *v2 + (char)v1;
    vUSB_Wait2(deviceExtension);
    int64_t v3; // 0x4a69
    *(char *)(v3 - 32) = 0;
    int64_t v4; // 0x4a69
    int64_t v5; // 0x4a69
    bReadPcieReg(2180, (int16_t)&g86, (char *)v5, v4);
    return &g1;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4a97 - 0x4a99
// Line range:    3374 - 3448
int64_t mpu_i2c_write(int64_t DeviceObject, char mpu_slave_address, char target_slave_address, char RegOffset, char data_length, char * pDataBuf) {
    // 0x4a97
    int64_t result; // 0x4a97
    return result;
}

// Address range: 0x4a99 - 0x4ac7
int64_t FUSBDTV_Cmd_I2CWriteEnc2(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int64_t a5) {
    // 0x4a99
    mcount();
    return (char)TLIB_I2C_Write2(a1, a2 % 256, a3 % 256, a5, a4 % 256, 0) != 0;
}

// Address range: 0x4ac7 - 0x4b47
int64_t mpu_i2c_write2(int64_t a1, unsigned char a2, char a3, char a4, uint32_t a5, int64_t a6) {
    // 0x4ac7
    mcount();
    char v1 = a3; // bp-56, 0x4ae4
    int64_t v2 = a2; // 0x4b07
    TLIB_I2C_Write2(a1, v2, 0, (int64_t)&v1, (int64_t)&g33, (int64_t)&g25);
    int64_t v3 = (char)a5 < 0 ? (int64_t)(char)&g95 : (int64_t)(a5 % 256); // 0x4b23
    return TLIB_I2C_Write2(a1, v2, 0, a6, v3, (int64_t)&g25);
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4b70 - 0x4ba0
// Line range:    3302 - 3372
int64_t mpu_i2c_read(int64_t DeviceObject, char mpu_slave_address, char target_slave_address, char RegOffset, char data_length, char * pDataBuf) {
    // 0x4b70
    int64_t v1; // 0x4b70
    char * v2 = (char *)(v1 * (int64_t)&g1 + (int64_t)pDataBuf); // 0x4b70
    *v2 = *v2 >> (char)&g1;
    int64_t v3; // 0x4b70
    return *(char *)(v3 - 48) == (char)&g1;
}

// Address range: 0x4ba0 - 0x4ca3
int64_t mpu_i2c_read2(int64_t a1, unsigned char a2, char a3, char a4, uint32_t a5, int64_t a6) {
    // 0x4ba0
    mcount();
    __readgsqword(40);
    uint64_t v1 = (int64_t)a3 | (int64_t)(uint32_t)(int32_t)&g1; // 0x4bcb
    int64_t v2 = (char)a5 >= 0 ? (int64_t)a5 : (int64_t)(int32_t)&g95; // 0x4bd7
    int64_t v3 = a2; // 0x4bdb
    int32_t v4 = 0x1000000 * (int32_t)v1 / 0x1000000; // bp-104, 0x4bdf
    char v5 = a4; // bp-103, 0x4be2
    int64_t v6 = &v5; // 0x4be9
    TLIB_I2C_Write2(a1, v3, v1 % 256, v6, (int64_t)&g25, 0);
    int64_t v7 = 0; // 0x4c0c
    *(char *)a6 = 0;
    int64_t v8 = TLIB_I2C_Read2(a1, v3, 0, (int64_t *)a6, (int64_t *)&g1, (int64_t)&g25); // 0x4c2f
    int64_t v9; // 0x4ba0
    while ((char)v8 != 0 != (*(char *)&v9 == (char)&g1)) {
        // 0x4c43
        if ((char)v7 == 100) {
            // break -> 0x4c52
            break;
        }
        v7 &= 0xffffffff;
        *(char *)a6 = 0;
        v8 = TLIB_I2C_Read2(a1, v3, 0, (int64_t *)a6, (int64_t *)&g1, (int64_t)&g25);
    }
    // 0x4c52
    TLIB_I2C_Read2(a1, v3, 0, (int64_t *)&v4, (int64_t *)((v2 + (int64_t)(char)&g1) % 256), (int64_t)&g25);
    int64_t v10 = (v2 + 255) % 256 * (int64_t)&g1 + (int64_t)&g25 + (int64_t)&v4; // 0x4c8c
    int64_t result = v6; // 0x4c8c
    int64_t v11 = a6; // 0x4c8c
    *(char *)v11 = *(char *)result;
    result += (int64_t)&g1;
    v11 += (int64_t)&g1;
    while (result != v10) {
        // 0x4c91
        *(char *)v11 = *(char *)result;
        result += (int64_t)&g1;
        v11 += (int64_t)&g1;
    }
    // 0x4ca3
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4ca4 - 0x4cd2
// Line range:    212 - 232
int64_t FUSBDTV_Cmd_I2CReadEnc(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16ReadLen, char * pDataBuf, char byI2CFlag) {
    // 0x4ca4
    int64_t result; // 0x4ca4
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x4cd2 - 0x4cd4
// Line range:    3098 - 3243
char writeStorageBuff(char * wtPtr, int64_t StreamObject, int64_t length) {
    // 0x4cd2
    int64_t result; // 0x4cd2
    return result;
}

// Address range: 0x4cd4 - 0x4d02
int64_t FUSBDTV_Cmd_I2CReadEnc2(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int64_t a5) {
    // 0x4cd4
    mcount();
    return (char)TLIB_I2C_Read2(a1, a2 % 256, a3 % 256, (int64_t *)a5, (int64_t *)(a4 % 256), 0) != 0;
}

// Address range: 0x4d02 - 0x500c
int64_t writeStorageBuff2(int64_t a1, int64_t a2, uint64_t a3) {
    // 0x4d02
    mcount();
    if (a1 == 0 || a2 == 0) {
        // 0x4ffd
        return 0;
    }
    // 0x4d33
    if (*(char *)(a2 + 184) == 0) {
        // 0x4ffd
        return &g1;
    }
    int64_t * v1 = (int64_t *)(a2 + 200); // 0x4d48
    *v1 = *v1 + a3;
    uint64_t v2 = *(int64_t *)(a2 + 232); // 0x4d4f
    uint64_t v3 = *(int64_t *)(a2 + 312); // 0x4d56
    if (a3 > (int64_t)&g2) {
        char * v4 = (char *)(a2 + 0x4faf); // 0x4d63
        if (*v4 == 0) {
            char * v5 = (char *)(a2 + 0x4fb0); // 0x4d6c
            if (*v5 == 0) {
                // 0x4d75
                *v4 = *(char *)(a1 + (int64_t)"GNU");
                *v5 = *(char *)(a1 + (int64_t)"NU");
                *(char *)(a2 + 0x4fb1) = *(char *)(a1 + (int64_t)&g103);
                *(char *)(a2 + 0x4fb2) = *(char *)(a1 + (int64_t)&g105);
            }
        }
    }
    // 0x4d9d
    if (*(int32_t *)(a2 + 272) != 0) {
        int64_t * v6 = (int64_t *)(a2 + 328); // 0x4dc3
        int64_t v7 = *v6; // 0x4dc3
        int64_t result = v7 + a3; // 0x4dca
        if (result <= v3) {
            // 0x4ffd
            return result;
        }
        int64_t v8 = result - v3; // 0x4dd8
        int64_t v9 = a3 - v8; // 0x4de2
        int64_t * v10 = (int64_t *)(a2 + 304); // 0x4de5
        int64_t v11; // 0x4d02
        memcpy(*v10 + v7, a1, v9, v11);
        int64_t v12; // 0x4d02
        if (v8 != 0) {
            // 0x4e1a
            memcpy(*v10, v9 + a1, v8, v11);
            v12 = v8;
        } else {
            int64_t v13 = *v6 + v9; // 0x4dfe
            v12 = v3 == v13 ? 0 : v13;
        }
        // 0x4e39
        *v6 = v12;
        int64_t * v14 = (int64_t *)(a2 + 336); // 0x4e39
        int64_t v15 = *v14; // 0x4e39
        if (v15 == v3) {
            // 0x4e45
            *(int64_t *)(a2 + 320) = v12;
            // 0x4ffd
            return &g1;
        }
        uint64_t v16 = v15 + a3; // 0x4e5d
        if (v3 >= v16) {
            // 0x4e84
            *v14 = v16;
        } else {
            // 0x4e65
            *(int64_t *)(a2 + 320) = v12;
            *v14 = v3;
        }
        // 0x4ffd
        return &g1;
    }
    int64_t * v17 = (int64_t *)(a2 + 336); // 0x4db0
    int64_t * v18; // 0x4d02
    int64_t * v19; // 0x4d02
    if (*v17 != 0) {
        int64_t * v20 = (int64_t *)(a2 + 224);
        int64_t * v21 = (int64_t *)(a2 + 288);
        int64_t * v22 = (int64_t *)(a2 + 320); // 0x4eaa
        int64_t * v23 = (int64_t *)(a2 + 296); // 0x4eec
        int64_t v24 = 0; // 0x4f13
        char v25 = *(char *)(*v22 + *(int64_t *)(a2 + 304)); // 0x4eb1
        *(char *)(*v21 + *v20) = v25;
        int64_t v26 = *v22 + 1; // 0x4ec1
        *v22 = v3 == v26 ? 0 : v26;
        int64_t v27 = *v21 + 1; // 0x4eda
        int64_t v28 = v2 == v27 ? 0 : v27; // 0x4ee1
        *v21 = v28;
        uint64_t v29 = *v23; // 0x4eec
        if (v2 > v29) {
            // 0x4ef8
            *v23 = v29 + 1;
        } else {
            // 0x4f05
            *(int64_t *)(a2 + 280) = v28;
        }
        // 0x4f13
        v24 += (int64_t)&g1;
        v19 = v20;
        v18 = v21;
        while (*v17 > v24) {
            // 0x4e95
            v25 = *(char *)(*v22 + *(int64_t *)(a2 + 304));
            *(char *)(*v21 + *v20) = v25;
            v26 = *v22 + 1;
            *v22 = v3 == v26 ? 0 : v26;
            v27 = *v21 + 1;
            v28 = v2 == v27 ? 0 : v27;
            *v21 = v28;
            v29 = *v23;
            if (v2 > v29) {
                // 0x4ef8
                *v23 = v29 + 1;
            } else {
                // 0x4f05
                *(int64_t *)(a2 + 280) = v28;
            }
            // 0x4f13
            v24 += (int64_t)&g1;
            v19 = v20;
            v18 = v21;
        }
    } else {
        // 0x4da6
        v19 = (int64_t *)(a2 + 224);
        v18 = (int64_t *)(a2 + 288);
    }
    // 0x4f24
    *v17 = 0;
    int64_t v30 = *v18; // 0x4f2f
    int64_t v31 = v30 + a3 - v2; // 0x4f44
    int64_t v32 = a3 - v31; // 0x4f4e
    memcpy(*v19 + v30, a1, v32, 0);
    int64_t v33; // 0x4d02
    if (v31 != 0) {
        // 0x4f86
        memcpy(*v19, v32 + a1, v31, 0);
        v33 = v31;
    } else {
        int64_t v34 = *v18 + v32; // 0x4f6a
        v33 = v2 == v34 ? 0 : v34;
    }
    // 0x4fa5
    *v18 = v33;
    int64_t * v35 = (int64_t *)(a2 + 296); // 0x4fa5
    int64_t v36 = *v35; // 0x4fa5
    if (v36 == v2) {
        // 0x4fb1
        *(int64_t *)(a2 + 280) = v33;
        // 0x4ffd
        return &g1;
    }
    uint64_t v37 = v36 + a3; // 0x4fc6
    if (v2 >= v37) {
        // 0x4fea
        *v35 = v37;
    } else {
        // 0x4fce
        *(int64_t *)(a2 + 280) = v33;
        *v35 = v2;
    }
    // 0x4ffd
    return &g1;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x5010 - 0x5040
// Line range:    2533 - 2599
int32_t iGetDMAStreamData(int64_t deviceExtension, char DataStream_Num, char * pu8OutPutBuf, int64_t GetLen) {
    // 0x5010
    int64_t v1; // 0x5010
    *(int32_t *)v1 = 2 * (int32_t)v1;
    char * v2 = (char *)(GetLen - 22 + GetLen * (int64_t)&g86); // 0x5012
    *v2 = *v2 + (char)GetLen;
    int64_t v3; // 0x5010
    return memcpy(deviceExtension, v3, (int64_t)pu8OutPutBuf, GetLen);
}

// Address range: 0x5040 - 0x5146
int64_t iGetDMAStreamData2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x5040
    mcount();
    int64_t v1 = *(int64_t *)(((char)a2 != 0 ? 1224 : 1232) + a1);
    *(int32_t *)(v1 + 272) = (int32_t)&g25;
    int64_t * v2 = (int64_t *)(v1 + 280); // 0x50b5
    int64_t v3 = *v2; // 0x50b5
    int64_t * v4 = (int64_t *)(v1 + 232); // 0x50bc
    uint64_t v5 = *v4; // 0x50bc
    int64_t v6; // 0x5040
    int64_t v7; // 0x5040
    int64_t v8; // 0x5040
    int64_t v9; // 0x5040
    if (v3 + a4 > v5) {
        int64_t v10 = v5 - v3; // 0x50cc
        int64_t * v11 = (int64_t *)(v1 + 224); // 0x50cf
        memcpy(a3, *v11 + v3, v10, a4);
        int64_t v12 = v10 + a3; // 0x50e1
        int64_t v13 = a4 - v10; // 0x50e9
        int64_t v14 = *v11; // 0x50ec
        memcpy(v12, v14, v13, a4);
        v9 = *v2 + a4 - *v4;
        v7 = v13;
        v8 = v14;
        v6 = v12;
    } else {
        int64_t v15 = *(int64_t *)(v1 + 224) + v3; // 0x5112
        memcpy(a3, v15, a4, a4);
        v9 = *v2 + a4;
        v7 = a4;
        v8 = v15;
        v6 = a3;
    }
    // 0x512b
    *v2 = v9;
    int64_t v16 = *v4; // 0x512b
    int64_t result = v16; // 0x5139
    if (v9 != v16) {
        result = iGetStreamData(v6, (char)v8, (char *)v7, a4);
    }
    // 0x513b
    *v2 = 0;
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x5146 - 0x5176
// Line range:    2456 - 2531
int32_t iGetStreamData(int64_t deviceExtension, char DataStream_Num, char * pu8OutPutBuf, int64_t GetLen) {
    // 0x5146
    int64_t v1; // 0x5146
    int64_t * v2 = (int64_t *)(v1 + 296); // 0x5146
    int64_t result; // 0x5146
    *v2 = *v2 - result;
    *(int32_t *)(v1 + 272) = 0;
    return result;
}

// Address range: 0x5176 - 0x526a
int64_t iGetStreamData2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x5176
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 1160 + (8 * a2 & 2040)); // 0x51a0
    *(int32_t *)(v1 + 272) = (int32_t)&g25;
    int64_t * v2 = (int64_t *)(v1 + 280); // 0x51d9
    int64_t v3 = *v2; // 0x51d9
    int64_t * v4 = (int64_t *)(v1 + 232); // 0x51e0
    uint64_t v5 = *v4; // 0x51e0
    int64_t v6; // 0x5176
    int64_t v7; // 0x5176
    int64_t v8; // 0x5176
    int64_t v9; // 0x5176
    if (v3 + a4 > v5) {
        int64_t v10 = v5 - v3; // 0x51f0
        int64_t * v11 = (int64_t *)(v1 + 224); // 0x51f3
        memcpy(a3, *v11 + v3, v10, a4);
        int64_t v12 = v10 + a3; // 0x5205
        int64_t v13 = a4 - v10; // 0x520d
        int64_t v14 = *v11; // 0x5210
        memcpy(v12, v14, v13, a4);
        v9 = *v2 + a4 - *v4;
        v7 = v13;
        v8 = v14;
        v6 = v12;
    } else {
        int64_t v15 = *(int64_t *)(v1 + 224) + v3; // 0x5236
        memcpy(a3, v15, a4, a4);
        v9 = *v2 + a4;
        v7 = a4;
        v8 = v15;
        v6 = a3;
    }
    // 0x524f
    *v2 = v9;
    int64_t v16 = *v4; // 0x524f
    int64_t result = v16; // 0x525d
    if (v9 != v16) {
        result = DispatchByRuleTable((char)v6, (char *)v8, (char *)v7, a4);
    }
    // 0x525f
    *v2 = 0;
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x526a - 0x529a
// Line range:    3023 - 3096
char DispatchByRuleTable(char dmaCH, char * wtPtr, char * fp, int64_t length) {
    // 0x526a
    int64_t v1; // 0x526a
    int64_t * v2 = (int64_t *)(v1 + 296); // 0x526a
    int64_t result; // 0x526a
    *v2 = *v2 - result;
    *(int32_t *)(v1 + 272) = 0;
    return result;
}

// Address range: 0x529a - 0x5311
int64_t DispatchByRuleTable2(int32_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x529a
    mcount();
    return (uint32_t)((int32_t)((int64_t)&g86 & -256 | 188) - 1);
}

// Address range: 0x533f - 0x5349
int64_t function_533f(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    char * v1 = (char *)(a4 + (int64_t)&g105); // 0x533f
    int64_t result; // 0x533f
    *v1 = *v1 | (char)result;
    return result;
}

// Address range: 0x53b3 - 0x53c4
int64_t function_53b3(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x53b3
    int64_t v1; // 0x53b3
    *(int32_t *)(v1 + a4 * (int64_t)&g25) = -0x7cfb397d;
    unknown_ffffffffc1c1dcc3();
    return function_fffffffff3c9dcc7();
}

// Address range: 0x53e5 - 0x53e8
int64_t function_53e5(void) {
    // 0x53e5
    int64_t result; // 0x53e5
    return result;
}

// Address range: 0x53ff - 0x5405
int64_t function_53ff(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x53ff
    int64_t result; // 0x53ff
    char * v1 = (char *)(result - 127); // 0x53ff
    *v1 = *v1 | (char)a4;
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x5434 - 0x5464
// Line range:    2601 - 2623
void vCleanStreamBuffer(int64_t deviceExtension, char DataStream_Num) {
    // 0x5434
    int64_t v1; // 0x5434
    writeStorageBuff2(deviceExtension, (int64_t)DataStream_Num, v1);
}

// Address range: 0x5464 - 0x54af
int64_t vCleanStreamBuffer2(int64_t a1, unsigned char a2) {
    // 0x5464
    mcount();
    int64_t v1 = a2; // 0x547a
    int64_t result = down(a1 + 248, v1); // 0x549f
    *(int64_t *)(*(int64_t *)(a1 + 1160 + 8 * v1) + 288) = 0;
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x54b2 - 0x54e2
// Line range:    2753 - 2865
int64_t FUSBDTV_Cmd_MPU_I2CWrite(int64_t DeviceObject, char mpu_slave_address, char target_slave_address, char RegOffset, char data_length, char * pDataBuf, char withRSA) {
    // 0x54b2
    int64_t v1; // 0x54b2
    int64_t v2; // 0x54b2
    bool v3; // 0x54b2
    *(char *)(int64_t)RegOffset = (char)v1 - (char)v2 + (char)v3;
    int64_t v4; // 0x54b2
    int64_t v5 = v4;
    *(char *)v5 = *(char *)&v4 + (char)v5;
    int64_t v6 = v4;
    *(char *)v6 = *(char *)&v4 + (char)v6;
    int64_t v7 = v4;
    *(char *)v7 = *(char *)&v4 + (char)v7;
    int64_t v8; // 0x54b2
    *(int64_t *)(v8 + 296) = 0;
    *(int32_t *)(v8 + 272) = 0;
    int64_t v9; // 0x54b2
    return up(v9);
}

// Address range: 0x54e2 - 0x562c
int64_t FUSBDTV_Cmd_MPU_I2CWrite2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7) {
    // 0x54e2
    mcount();
    int64_t v1 = a1 + 344; // 0x5520
    down(v1, a2);
    int64_t * v2 = (int64_t *)(a1 + 0x5680); // 0x552f
    if (*v2 != 0) {
        up(v1);
        vUSB_Wait2((int64_t)&g1);
        down(v1, a2);
        while (*v2 != 0) {
            // 0x5568
            up(v1);
            vUSB_Wait2((int64_t)&g1);
            down(v1, a2);
        }
    }
    int64_t v3 = 0x100000000000000 * a5 / 0x100000000000000; // 0x5508
    *v2 = (int64_t)&g1;
    up(v1);
    uint64_t v4 = v3 % 256; // 0x554c
    int64_t v5 = FUSB_ExAllocatePool2(0, v4); // 0x5558
    if ((char)a7 != (char)&g1) {
        // 0x5585
        memcpy(v5, a6, v4, a4);
    } else {
        // 0x557c
        *(int64_t *)v5 = a6;
    }
    uint32_t v6 = (int32_t)v3;
    char v7 = a2;
    char v8 = a3;
    char v9 = a4;
    int64_t v10 = 0; // 0x55bf
    int64_t v11; // 0x54e2
    if ((char)a7 != (char)&g1) {
        // 0x55e5
        v11 = mpu_i2c_write2(a1, v7, v8, v9, v6 % 256, v5);
    } else {
        // 0x55c8
        v11 = mpu_i2c_write2(a1, v7, v8, v9, v6 % 128 | 128, v5);
    }
    uint64_t v12 = v11 % 256; // 0x5600
    while ((char)NT_SUCCESS2(v12) == 0) {
        // 0x560c
        FUSBDTV_Wait2((int64_t *)&g98);
        if ((int32_t)v10 == (int32_t)&g33) {
            // break -> 0x5620
            break;
        }
        v10 &= 0xffffffff;
        if ((char)a7 != (char)&g1) {
            // 0x55e5
            v11 = mpu_i2c_write2(a1, v7, v8, v9, v6 % 256, v5);
        } else {
            // 0x55c8
            v11 = mpu_i2c_write2(a1, v7, v8, v9, v6 % 128 | 128, v5);
        }
        // 0x5600
        v12 = v11 % 256;
    }
    // 0x5620
    return NT_SUCCESS2(v12);
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x5630 - 0x5660
// Line range:    2631 - 2751
int64_t FUSBDTV_Cmd_MPU_I2CRead(int64_t DeviceObject, char mpu_slave_address, char target_slave_address, char RegOffset, char data_length, char * pDataBuf, char withRSA) {
    // 0x5630
    int64_t v1; // 0x5630
    char * v2 = (char *)(v1 + 0x4800bf7d); // 0x5632
    *v2 = *v2 | (char)v1;
    int64_t v3; // 0x5630
    FUSB_ExFreePool2((int32_t)v3, (int64_t)mpu_slave_address);
    int64_t v4; // 0x5630
    *(int64_t *)(v4 + 0x5680) = 0;
    int64_t v5; // 0x5630
    return (v5 + ((int64_t)RegOffset >> (int64_t)&g95)) % 256 | v5 & 0xffffff00;
}

// Address range: 0x5660 - 0x57c3
int64_t FUSBDTV_Cmd_MPU_I2CRead2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, uint64_t a5, int64_t a6, int64_t a7) {
    // 0x5660
    mcount();
    int64_t v1 = a1 + 344; // 0x56a1
    down(v1, a2);
    int64_t * v2 = (int64_t *)(a1 + 0x5680); // 0x56b0
    if (*v2 != 0) {
        up(v1);
        vUSB_Wait2((int64_t)&g1);
        down(v1, a2);
        while (*v2 != 0) {
            // 0x5715
            up(v1);
            vUSB_Wait2((int64_t)&g1);
            down(v1, a2);
        }
    }
    // 0x56ba
    *v2 = (int64_t)&g1;
    up(v1);
    uint64_t v3 = a5 % 256; // 0x56cd
    int64_t v4 = FUSB_ExAllocatePool2(0, v3); // 0x56dd
    char v5 = a2;
    char v6 = a3;
    char v7 = a4;
    int64_t v8 = 0; // 0x5713
    int64_t v9; // 0x5660
    if ((char)a7 != (char)&g1) {
        // 0x574f
        v9 = mpu_i2c_read2(a1, v5, v6, v7, (int32_t)v3, v4);
    } else {
        // 0x5732
        v9 = mpu_i2c_read2(a1, v5, v6, v7, (int32_t)a5 % 128 | 128, v4);
    }
    uint64_t v10 = v9 % 256; // 0x576a
    while ((char)NT_SUCCESS2(v10) == 0) {
        // 0x5777
        FUSBDTV_Wait2((int64_t *)&g98);
        if ((int32_t)v8 == (int32_t)&g33) {
            // break -> 0x578b
            break;
        }
        v8 &= 0xffffffff;
        if ((char)a7 != (char)&g1) {
            // 0x574f
            v9 = mpu_i2c_read2(a1, v5, v6, v7, (int32_t)v3, v4);
        } else {
            // 0x5732
            v9 = mpu_i2c_read2(a1, v5, v6, v7, (int32_t)a5 % 128 | 128, v4);
        }
        // 0x576a
        v10 = v9 % 256;
    }
    int64_t result = NT_SUCCESS2(v10); // 0x5792
    if ((char)a7 != (char)&g1 || (char)result == 0) {
        // 0x579b
        return result;
    }
    int64_t result2 = *(int64_t *)v4; // 0x57a9
    *(int64_t *)a6 = result2;
    return result2;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x57c3 - 0x57f3
// Line range:    2063 - 2079
int32_t FUSBDTV_BDAQueueProcessThreadInit(int64_t streamObject) {
    // 0x57c3
    int64_t v1; // 0x57c3
    int64_t v2; // 0x57c3
    int64_t v3; // 0x57c3
    int64_t v4; // 0x57c3
    return memcpy(*(int64_t *)(v2 - 96), v1, v3, v4);
}

// Address range: 0x57f3 - 0x5818
int64_t FUSBDTV_BDAQueueProcessThreadInit2(int64_t a1) {
    // 0x57f3
    mcount();
    return 0xffffffff;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x581c - 0x584c
// Line range:    1991 - 2062
int32_t FUSBDTV_BDAQueueProcessThread(char * Context) {
    // 0x581c
    int64_t v1; // 0x581c
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x581c
    char v3 = *(char *)&v2; // 0x581e
    uint64_t v4; // 0x581c
    *(char *)v2 = v3 + (char)(v4 >> (int64_t)&g95);
    int64_t v5; // 0x581c
    int64_t v6; // 0x581c
    int64_t v7 = kthread_create((int64_t)Context, v5, v6); // 0x5824
    v2 = v7;
    *(int64_t *)(v4 + 432) = v7;
    int64_t result = v2; // 0x5836
    if (v7 < 0xfffffffffffff001) {
        // 0x5838
        wake_up_process(v2);
        v2 = &g1;
        result = &g1;
    }
    // 0x5845
    return result;
}

// Address range: 0x584c - 0x5940
int64_t FUSBDTV_BDAQueueProcessThread2(int64_t a1) {
    // 0x584c
    mcount();
    int64_t v1; // 0x584c
    if ((int32_t)kthread_should_stop() != 0) {
        FUSBDTV_StopBulkStream(a1, (char)v1);
    }
    // 0x5882
    down(a1 + 248, v1);
    int64_t v2 = FUSB_ExAllocatePool2(0, 0xe520); // 0x5894
    char * v3 = (char *)(a1 + 128); // 0x589c
    unsigned char v4 = *v3 % 2;
    int64_t v5; // 0x584c
    if (v4 != 0) {
        // 0x58d7
        if (*(int64_t *)(*(int64_t *)(a1 + 1224) + 296) < 0xe520) {
            // break -> 0x593d
            break;
        }
        // 0x58eb
        v5 = iGetDMAStreamData2(a1, (int64_t)v4, v2, 0xe520);
    } else {
        // 0x58aa
        if (*(int64_t *)(*(int64_t *)(a1 + 1232) + 296) < 0xe520) {
            // break -> 0x593d
            break;
        }
        // 0x58be
        v5 = iGetDMAStreamData2(a1, 0, v2, 0xe520);
    }
    int32_t v6 = v5; // 0x58fd
    int64_t result = v5; // 0x58ff
    while (v6 != 0) {
        if (-188 * (((int32_t)(-0x51b3bea3 * 0x100000000 * v5 / 0x100000000 >> (int64_t)&g26) + v6 >> (int32_t)&g94) - (v6 >> (int32_t)&g24)) == -v6) {
            // 0x591c
            DispatchByRuleTable2((int32_t)(*v3 % 2), v2, a1, 0xe520);
        }
        v4 = *v3 % 2;
        if (v4 != 0) {
            int64_t v7 = *(int64_t *)(a1 + 1224); // 0x58d7
            result = v7;
            if (*(int64_t *)(v7 + 296) < 0xe520) {
                // break -> 0x593d
                break;
            }
            // 0x58eb
            v5 = iGetDMAStreamData2(a1, (int64_t)v4, v2, 0xe520);
        } else {
            int64_t v8 = *(int64_t *)(a1 + 1232); // 0x58aa
            result = v8;
            if (*(int64_t *)(v8 + 296) < 0xe520) {
                // break -> 0x593d
                break;
            }
            // 0x58be
            v5 = iGetDMAStreamData2(a1, 0, v2, 0xe520);
        }
        // 0x58fd
        v6 = v5;
        result = v5;
    }
    // 0x593d
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x5940 - 0x595c
// Line range:    1977 - 1987
void FUSBDTV_BDAQueueProcessThreadClose(int64_t streamObject) {
    // 0x5940
    int64_t v1; // 0x5940
    FUSB_ExFreePool2((int32_t)streamObject, v1);
    int64_t v2; // 0x5940
    up(v2);
    TLIB_Delay2((int64_t *)&g1);
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x595c - 0x5970
// Line range:    2276 - 2454
int64_t FUSBDTV_StopBulkStream(int64_t deviceExtension, char DataStream_Num) {
    // 0x595c
    return 0;
}

// Address range: 0x5970 - 0x598c
int64_t FUSBDTV_BDAQueueProcessThreadClose2(int64_t a1) {
    int64_t result = mcount(); // 0x597c
    if (a1 != 0) {
        // 0x597e
        result = kthread_stop(*(int64_t *)(a1 + 432));
    }
    // 0x598a
    return result;
}

// Address range: 0x598c - 0x59eb
int64_t FUSBDTV_StopBulkStream2(int64_t a1, uint64_t a2) {
    // 0x598c
    mcount();
    uint64_t v1 = a2 % 256; // 0x59a5
    int64_t v2 = *(int64_t *)(a1 + 1160 + 8 * v1); // 0x59ac
    FUSBDTV_BDAQueueProcessThreadClose2(v2);
    *(char *)(v2 + 184) = 0;
    return Hardware_StopTSStream2(*(int64_t *)v2, v1);
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x59ed - 0x5a03
// Line range:    1671 - 1781
int64_t FUSBDTV_StartTransfer(int64_t deviceExtension, int64_t StreamObject, int64_t TransferObjBufSize, int64_t Index) {
    // 0x59ed
    int64_t v1; // 0x59ed
    int64_t v2; // 0x59ed
    *(char *)(v1 + 1152 + 0x100000000 * v2 / 0x100000000) = 0;
    int64_t * v3 = (int64_t *)(v1 + 192); // 0x59fb
    *v3 = *v3 - 1;
    int64_t result; // 0x59ed
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x5a04 - 0x5a1d
// Line range:    2093 - 2257
int64_t FUSBDTV_StartBulkStream(int64_t deviceExtension, char DataStream_Num, int64_t TransferObjBufSize, int64_t StreamBufSize, char * Contex) {
    // 0x5a04
    int64_t v1; // 0x5a04
    *(int32_t *)v1 = 2 * (int32_t)v1;
    int64_t result; // 0x5a04
    int64_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0x5a1d - 0x5a34
int64_t FUSBDTV_StartTransfer2(int64_t a1, int64_t a2) {
    // 0x5a1d
    mcount();
    return Hardware_StartTSStream2(a1, *(char *)(a2 + 128));
}

// Address range: 0x5a34 - 0x5bfc
int64_t FUSBDTV_StartBulkStream2(int64_t a1, int64_t a2, uint64_t a3, uint64_t a4, int64_t a5) {
    // 0x5a34
    mcount();
    int64_t * v1 = (int64_t *)(a1 + 1160 + (8 * a2 & 2040)); // 0x5abb
    int64_t v2 = *v1; // 0x5abb
    int64_t * v3 = (int64_t *)(v2 + 224); // 0x5ad3
    int64_t * v4 = (int64_t *)(v2 + 304); // 0x5ada
    __asm_rep_stosq_memset((char *)v2, 0, 55);
    int64_t * v5 = (int64_t *)(a1 + 192); // 0x5af1
    *v5 = *v5 + 1;
    *(int64_t *)(v2 + 352) = a5;
    *(int64_t *)v2 = a1;
    *(char *)(v2 + 184) = (char)&g1;
    *(int64_t *)(v2 + 216) = 0;
    int64_t v6 = a4 < 0x92e1 == a3 < 513 == a4 != 0 == a3 - 1 < a4 >> (int64_t)&g1 ? 512 * a4 : 0x125c000; // 0x5b16
    *(int64_t *)(v2 + 232) = v6;
    *(int32_t *)(v2 + 272) = 0;
    *(char *)(v2 + 344) = 0;
    *(char *)(v2 + 128) = (char)a2;
    *(int64_t *)(v2 + 144) = 0;
    *(int64_t *)(v2 + 296) = 0;
    *(int64_t *)(v2 + 288) = 0;
    *(int64_t *)(v2 + 280) = 0;
    int64_t v7 = a4 < 0x92e1 == a3 < 513 == a4 != 0 == a3 - 1 < a4 >> (int64_t)&g1 ? 1024 * a3 : 0x80000; // 0x5b6c
    *(int64_t *)(v2 + 312) = v7;
    *(int64_t *)(v2 + 336) = 0;
    *(int64_t *)(v2 + 328) = 0;
    *(int64_t *)(v2 + 320) = 0;
    *(int32_t *)(v2 + 152) = 0;
    __init_waitqueue_head(v2 + 160, 0, v7, 0);
    *(int32_t *)(v2 + 80) = 0;
    __init_waitqueue_head(v2 + 88, 0, v7, 0);
    int64_t result = NT_SUCCESS2(FUSBDTV_StartTransfer2(a1, v2) % 256); // 0x5bec
    *v1 = v2;
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x5bfd - 0x5c2d
// Line range:    836 - 916
int64_t FUSBDTV_Cmd_GetCusInfo(int64_t deviceExtension, char * pDataBuf) {
    // 0x5bfd
    int64_t v1; // 0x5bfd
    *(char *)((int64_t)pDataBuf + 1152 + v1) = (char)&g1;
    int64_t v2; // 0x5bfd
    FUSBDTV_BDAQueueProcessThreadInit2(v2);
    int64_t result; // 0x5bfd
    return result;
}

// Address range: 0x5c2d - 0x5c68
int64_t FUSBDTV_Cmd_GetCusInfo2(int64_t a1, int64_t a2) {
    // 0x5c2d
    mcount();
    int64_t v1 = 0; // bp-32, 0x5c41
    bReadPcieCfgReg2(44, (int64_t *)&g95, &v1, a1);
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x5c69 - 0x5c99
// Line range:    772 - 791
int64_t FUSBDTV_Cmd_SysCtrlRead(int64_t deviceExtension, char RegOffset, int16_t u16ReadLen, char * pDataBuf) {
    // 0x5c69
    int64_t v1; // 0x5c69
    uint32_t v2 = *(int32_t *)(v1 - 24); // 0x5c69
    uint64_t v3 = (int64_t)v2; // 0x5c69
    int64_t v4; // 0x5c69
    *(char *)(v4 + (int64_t)&g33) = (char)(v3 >> (int64_t)&g95);
    *(char *)(v4 + (int64_t)&g86) = (char)v2;
    *(char *)(v4 + (int64_t)&g89) = (char)(v3 >> (int64_t)&g13);
    *(char *)(v4 + (int64_t)&g91) = (char)(v3 >> (int64_t)&g2);
    *(char *)v4 = (char)&g1;
    return &g1;
}

// Address range: 0x5c99 - 0x5c9d
int64_t FUSBDTV_Cmd_SysCtrlRead2(int64_t a1, int64_t * a2, int64_t * a3, int64_t * a4) {
    // 0x5c99
    int64_t result; // 0x5c99
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x5c9e - 0x5cce
// Line range:    716 - 744
int64_t FPCIEDTV_Cmd_I2CWrite(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16WriteLen, char * pDataBuf, char slvMode) {
    // 0x5c9e
    mcount();
    int64_t v1; // 0x5c9e
    int64_t * v2 = (int64_t *)(v1 - 8); // 0x5ca9
    *v2 = 0;
    int64_t v3 = bReadPcieCfgReg2(44, (int64_t *)&g95, v2, deviceExtension); // 0x5cbf
    return (char)v3 == (char)&g1;
}

// Address range: 0x5cce - 0x5d6a
int64_t FPCIEDTV_Cmd_I2CWrite2(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int64_t a5, int64_t * a6) {
    // 0x5cce
    mcount();
    __readgsqword(40);
    int64_t v1; // bp-104, 0x5cce
    memcpy((int64_t)&v1, a5, a4 % 0x10000, a4);
    uint64_t v2 = i2c_access2((int64_t *)&g1, 0, a1, a2 % 256, (uint64_t)(int64_t)a6 % 256, a3 % 256, &v1, 0, a4 % 256, 0); // 0x5d5b
    return NT_SUCCESS2(v2 % 256);
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x5d6a - 0x5d9a
// Line range:    674 - 707
int64_t FPCIEDTV_Cmd_I2CRead(int64_t deviceExtension, char Slave_Addr, char RegOffset, int16_t u16ReadLen, char * pDataBuf, char slvMode) {
    // 0x5d6a
    bool v1; // 0x5d6a
    int64_t result = !v1; // 0x5d7d
    int64_t v2; // 0x5d6a
    if (*(int64_t *)(v2 - 56) != __readgsqword(40)) {
        // 0x5d7f
        result = __stack_chk_fail();
    }
    // 0x5d84
    return result;
}

// Address range: 0x5d9a - 0x5e3f
int64_t FPCIEDTV_Cmd_I2CRead2(int64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int64_t a5, int64_t * a6) {
    // 0x5d9a
    mcount();
    __readgsqword(40);
    int64_t v1 = 0; // bp-72, 0x5dc2
    uint64_t v2 = i2c_access2((int64_t *)&g1, (int64_t)&g1, a1, a2 % 256, (int64_t)a6 % 256, a3 % 256, &v1, a4 + (int64_t)(char)&g33 & (int64_t)(char)(-1 << (int32_t)&g25), a4 % 256, 0); // 0x5e22
    NT_SUCCESS2(v2 % 256);
    return 0;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x5e48 - 0x5e78
// Line range:    555 - 651
int64_t FUSBDTV_Cmd_Get_GPIO(int64_t deviceExtension, char * GPIO_Value) {
    // 0x5e48
    int64_t v1; // 0x5e48
    int64_t v2; // 0x5e48
    int64_t v3; // 0x5e48
    *(char *)(v2 * (int64_t)&g1 + v1) = (char)v3;
    int64_t v4 = __readgsqword(40); // 0x5e5f
    int64_t result = &g1; // 0x5e68
    int64_t v5; // 0x5e48
    if (*(int64_t *)(v5 - 24) != v4) {
        // 0x5e6a
        result = __stack_chk_fail();
    }
    // 0x5e6f
    return result;
}

// Address range: 0x5e78 - 0x5efc
int64_t FUSBDTV_Cmd_Get_GPIO2(int64_t a1, int64_t a2) {
    // 0x5e78
    mcount();
    int64_t v1 = 0; // bp-56, 0x5e9b
    uint64_t v2 = cfg_access2((int64_t *)&g1, a1, 2192, (int64_t *)&g86, &v1); // 0x5eb4
    NT_SUCCESS2(v2 % 256);
    uint64_t v3 = cfg_access2((int64_t *)&g1, a1, 2196, (int64_t *)&g86, &v1); // 0x5eef
    return NT_SUCCESS2(v3 % 256);
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x5efc - 0x5f2c
// Line range:    369 - 524
int64_t FUSBDTV_Cmd_Set_GPIO(int64_t deviceExtension, char GPIO_Value, char GPIO_Mask) {
    int64_t result = 0; // 0x5f03
    int64_t v1; // 0x5efc
    int64_t v2; // 0x5efc
    if ((char)v2 != 0) {
        // 0x5f05
        result = (int64_t)&g1 & (int64_t)(int32_t)&g1;
        int64_t v3; // 0x5efc
        int64_t v4; // 0x5efc
        v1 = v3 & 0xffffffff | (int64_t)(*(char *)(v4 - 46) & -2);
    }
    // 0x5f14
    int64_t v5; // 0x5efc
    *(char *)v5 = (char)v1;
    return result;
}

// Address range: 0x5f2c - 0x6017
int64_t FUSBDTV_Cmd_Set_GPIO2(int64_t a1, int64_t * a2, int64_t a3) {
    // 0x5f2c
    mcount();
    char v1 = 0; // bp-56, 0x5f4b
    uint64_t v2 = cfg_access2((int64_t *)&g1, a1, 2192, (int64_t *)&g86, (int64_t *)&v1); // 0x5f64
    int64_t result = 0; // 0x5f73
    if ((char)NT_SUCCESS2(v2 % 256) != 0) {
        char v3 = -(((char)a3 & (char)&g1)) & (char)&g86; // 0x5f8c
        v1 = v1 & -1 - v3 | v3 & -(((char)(int64_t)a2 & (char)&g1));
        uint64_t v4 = cfg_access2(NULL, a1, 2192, (int64_t *)&g86, (int64_t *)&v1); // 0x5fae
        int64_t v5 = NT_SUCCESS2(v4 % 256); // 0x5fb6
        result = (char)v5 != 0 ? v5 : 0;
    }
    // 0x6003
    return result;
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x601b - 0x604b
// Line range:    335 - 367
int64_t FUSBDTV_Cmd_Get_GPIO_Ex(int64_t deviceExtension, char * GPIO_Value) {
    // 0x601b
    int64_t v1; // 0x601b
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x601b
    char * v3 = (char *)(v2 + (int64_t)&g86); // 0x601d
    uint64_t v4; // 0x601b
    *v3 = *v3 + (char)(v4 >> (int64_t)&g95);
    int64_t v5; // 0x601b
    uint64_t v6 = cfg_access2((int64_t *)&g1, v4, 2196, (int64_t *)v2, (int64_t *)v5); // 0x6030
    return NT_SUCCESS2(v6 % 256);
}

// Address range: 0x604b - 0x6079
int64_t FUSBDTV_Cmd_Get_GPIO_Ex2(int64_t a1, int64_t a2) {
    // 0x604b
    return mcount();
}

// From module:   /root/asv5220\FUSBDTV.c
// Address range: 0x607d - 0x60ad
// Line range:    286 - 333
int64_t FUSBDTV_Cmd_Set_GPIO_Ex(int64_t deviceExtension, char GPIO_Value, char GPIO_Mask) {
    // 0x607d
    int64_t v1; // 0x607d
    int64_t v2; // 0x607d
    *(char *)deviceExtension = (char)v2 + (char)v1;
    int64_t result = 0; // 0x608d
    if ((char)NT_SUCCESS2(deviceExtension) != 0) {
        // 0x608f
        int64_t v3; // 0x607d
        int64_t v4; // 0x607d
        *(char *)v4 = *(char *)(v3 - 30) & (char)&g105;
        result = (int64_t)&g1 & (int64_t)(int32_t)&g1;
    }
    // 0x60a0
    return result;
}

// Address range: 0x60ad - 0x6125
int64_t FUSBDTV_Cmd_Set_GPIO_Ex2(int64_t a1, int64_t a2, int64_t * a3) {
    // 0x60ad
    mcount();
    char v1 = 0; // bp-56, 0x60d3
    uint64_t v2 = cfg_access2((int64_t *)&g1, a1, 2192, (int64_t *)&g86, (int64_t *)&v1); // 0x60ec
    NT_SUCCESS2(v2 % 256);
    int32_t v3 = -1 - ((int32_t)(int64_t)a3 << (int32_t)&g33);
    return (int64_t)(v1 & (char)v3) | (int64_t)(v3 & -256);
}

// From module:   /root/asv5220\FUSBdbg.c
// Address range: 0x6128 - 0x6137
// Line range:    173 - 182
void FUSB_ExFreePool(char * p) {
    // 0x6128
    int64_t v1; // 0x6128
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x6128
    int64_t v3; // 0x6128
    int64_t v4; // 0x6128
    int64_t v5; // 0x6128
    cfg_access2(NULL, v3, v4, (int64_t *)v5, (int64_t *)v2);
}

// From module:   /root/asv5220\FUSBdbg.c
// Address range: 0x6138 - 0x614a
// Line range:    157 - 171
char * FUSB_ExAllocatePool(char PoolType, int64_t NumberOfBytes) {
    // 0x6138
    return (char *)(int64_t)((char)NT_SUCCESS2((int64_t)PoolType) != 0);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6150 - 0x6151
// Line range:    415 - 433
char Adpater_TunerS_RegWrite(char * DevExt, char DevCH, char byReg, char * pBuffer, char cnt) {
    // 0x6150
    int64_t result; // 0x6150
    return result;
}

// Address range: 0x6152 - 0x6158
int64_t function_6152(void) {
    // 0x6152
    int64_t result; // 0x6152
    return result;
}

// Address range: 0x6158 - 0x615c
int64_t FUSB_ExFreePool2(int32_t a1, int64_t a2) {
    // 0x6158
    int64_t result; // 0x6158
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6160 - 0x6168
// Line range:    434 - 442
char Adpater_TunerS_RegRead(char * DevExt, char DevCH, char byReg, char * pBuffer, char cnt) {
    // 0x6160
    int64_t v1; // 0x6160
    return v1 + ((uint64_t)(int64_t)pBuffer >> (uint64_t)(int64_t)&g95);
}

// Address range: 0x6168 - 0x616c
int64_t FUSB_ExAllocatePool2(int64_t a1, int64_t a2) {
    // 0x6168
    int64_t result; // 0x6168
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6170 - 0x617b
// Line range:    446 - 465
char Adpater_TunerT_RegWrite(char * hExt, char DevCH, char subAddress, char * pData, char cnt) {
    // 0x6170
    int64_t v1; // 0x6170
    char * v2 = (char *)(v1 - 119); // 0x6170
    *v2 = *v2 + (char)(int64_t)pData;
    int64_t v3; // 0x6170
    return (char)*(int32_t *)&v3;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6180 - 0x6190
// Line range:    466 - 474
char Adpater_TunerT_RegRead(char * hExt, char DevCH, char subAddress, char * pData, char cnt) {
    // 0x6180
    mcount();
    return 0;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6190 - 0x61a0
// Line range:    875 - 908
char Ber_to_Signal_Quality(int32_t berdat, int32_t pecycle, char DevCH, int32_t src_select) {
    // 0x6190
    mcount();
    return 0;
}

// Address range: 0x61a0 - 0x61b0
int64_t Adpater_TunerT_RegWrite2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int64_t * a5) {
    // 0x61a0
    mcount();
    return 0;
}

// Address range: 0x61b0 - 0x61c0
int64_t Adpater_TunerT_RegRead2(void) {
    // 0x61b0
    mcount();
    return 0;
}

// Address range: 0x61c0 - 0x6270
int64_t Ber_to_Signal_Quality2(int32_t a1, int64_t a2, int64_t a3, int64_t * a4) {
    // 0x61c0
    mcount();
    return (int64_t)&g23;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6271 - 0x627e
// Line range:    910 - 1011
char Adapter_SetTsOutput(char * DevExt, char DevCH, int32_t ts_outputpin, int32_t sig_source) {
    // 0x6271
    int64_t v1; // 0x6271
    __asm_out((int16_t)ts_outputpin, (int32_t)v1);
    int64_t v2; // 0x6271
    return (char)v1 + (char)v2;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6281 - 0x6291
// Line range:    1013 - 1017
char Adapter_StopTsOutput(char * DevExt, char DevCH, int32_t ts_outputpin) {
    // 0x6281
    int64_t v1; // 0x6281
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6291 - 0x62a1
// Line range:    1447 - 1458
char SetTsOutput(char * DevExt, char DevCH, uint32_t sig_source, int32_t ts_outputpin, char bStopOutput) {
    char result = sig_source < 0x7a120 ? (char)(2 * (int64_t)(uint32_t)(int32_t)&g89 & 0xffffffff) : (char)&g89; // 0x62a0
    return result;
}

// Address range: 0x62a1 - 0x62b1
int64_t Adapter_SetTsOutput2(void) {
    // 0x62a1
    mcount();
    return 0;
}

// Address range: 0x62b1 - 0x62ba
int64_t Adapter_StopTsOutput2(void) {
    // 0x62b1
    return mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x62bb - 0x62c1
// Line range:    1597 - 1667
char TC_RemappingTunerNumber(char * DevExt, char * DevCH) {
    // 0x62bb
    int64_t v1; // 0x62bb
    *(char *)v1 = 2 * (char)v1;
    int64_t result; // 0x62bb
    int64_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0x62c1 - 0x62eb
int64_t SetTsOutput2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x62c1
    mcount();
    int64_t result; // 0x62c1
    if ((char)a5 == 0) {
        // 0x62de
        result = Adapter_SetTsOutput2();
    } else {
        // 0x62d3
        result = Adapter_StopTsOutput2();
    }
    // 0x62e9
    return result;
}

// Address range: 0x62eb - 0x6337
int64_t TC_RemappingTunerNumber2(int64_t a1) {
    // 0x62eb
    mcount();
    uint64_t v1; // 0x62eb
    return v1 % 256;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6338 - 0x6339
// Line range:    1746 - 1762
char TC_Start(char * DevExt, char DevCH, char * tuner_globe_data) {
    // 0x6338
    int64_t result; // 0x6338
    return result;
}

// Address range: 0x633a - 0x633c
int64_t function_633a(void) {
    // 0x633a
    int64_t result; // 0x633a
    return result;
}

// Address range: 0x633c - 0x6342
int64_t function_633c(int64_t a1, int64_t a2) {
    // 0x633c
    *(char *)a2 = (char)&g89;
    int64_t result; // 0x633c
    return result;
}

// Address range: 0x6342 - 0x6347
int64_t function_6342(int64_t a1, int64_t a2) {
    // 0x6342
    *(char *)a2 = 0;
    int64_t result; // 0x6342
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6348 - 0x6349
// Line range:    2373 - 2380
char TC_PollingThread(char * DevExt, char DevCH, char * tuner_globe_data) {
    // 0x6348
    int64_t result; // 0x6348
    return result;
}

// Address range: 0x634a - 0x634c
int64_t function_634a(void) {
    // 0x634a
    int64_t result; // 0x634a
    return result;
}

// Address range: 0x634c - 0x6352
int64_t function_634c(int64_t a1, int64_t a2) {
    // 0x634c
    *(char *)a2 = (char)&g33;
    int64_t result; // 0x634c
    return result;
}

// Address range: 0x6352 - 0x6357
int64_t function_6352(int64_t a1, int64_t a2) {
    // 0x6352
    *(char *)a2 = (char)&g94;
    int64_t result; // 0x6352
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6358 - 0x6368
// Line range:    2382 - 2389
char TC_PollingThreadOnlyCallOnce(char * DevExt, char * StartPolling, char total_tuner_num, char * tuner_globe_data) {
    // 0x6358
    int64_t result; // 0x6358
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6368 - 0x6378
// Line range:    2400 - 2403
int64_t TC_PollingThreadDelayTime(void) {
    // 0x6368
    mcount();
    return &g1;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6378 - 0x6388
// Line range:    2405 - 2441
char TC_CurrentTSIDRead(char * DevExt, char DevCH, int32_t * tsid, char * tuner_globe_data) {
    // 0x6378
    mcount();
    return &g1;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6388 - 0x6398
// Line range:    2457 - 2460
int64_t TC_DriverEntryFunCall(char * pDriverObject, char * pRegistryPath) {
    // 0x6388
    mcount();
    return &g1;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6398 - 0x63a1
// Line range:    2474 - 2529
void TC_PowerTunerDemod(char * DevExt, char DevCH, char bPower_On, char * tuner_globe_data) {
    // 0x6398
    mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x63a3 - 0x63a8
// Line range:    2543 - 2549
char TC_ResetTunerDemod(char * DevExt, char DevCH, char * tuner_globe_data) {
    // 0x63a3
    int64_t result; // 0x63a3
    *(int32_t *)result = 2 * (int32_t)result;
    return result;
}

// Address range: 0x63a8 - 0x63b1
int64_t TC_CurrentTSIDRead2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x63a8
    return mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x63b3 - 0x63b8
// Line range:    2665 - 2672
char TC_SleepTunerDemod(char * DevExt, char DevCH, char * tuner_globe_data) {
    // 0x63b3
    int64_t v1; // 0x63b3
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// Address range: 0x63b8 - 0x63c1
int64_t TC_DriverEntryFunCall2(void) {
    // 0x63b8
    return mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x63c3 - 0x63c8
// Line range:    2687 - 2693
char TC_WakeupTunerDemod(char * DevExt, char DevCH, char * tuner_globe_data) {
    // 0x63c3
    int64_t v1; // 0x63c3
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// Address range: 0x63c8 - 0x63d3
int64_t TC_PowerTunerDemod2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x63c8
    return mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x63d3 - 0x63e3
// Line range:    2711 - 2717
char ReadWrite_Customization_Data(char * DevExt, char DevCH, char bRead, int64_t offset, char * DataBuf, int64_t bytesofpData, char * tuner_globe_data) {
    // 0x63d3
    mcount();
    return 0;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x63e3 - 0x63f3
// Line range:    2733 - 2739
char Erase_Customization_Data(char * DevExt, char DevCH, int64_t offset, int64_t bytesofpData, char * tuner_globe_data) {
    // 0x63e3
    mcount();
    return 0;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x63f3 - 0x6403
// Line range:    2754 - 2761
char Get_Customization_Data_Size(char * DevExt, char DevCH, int64_t * customization_data_size, char * tuner_globe_data) {
    // 0x63f3
    mcount();
    return 0;
}

// Address range: 0x6403 - 0x6407
int64_t ReadWrite_Customization_Data2(void) {
    // 0x6403
    int64_t result; // 0x6403
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x640a - 0x6413
// Line range:    2773 - 2777
char Get_Tuner_Extra_Data_Size(int64_t * tuner_Extra_Data_Size) {
    // 0x640a
    return &g1;
}

// Address range: 0x6413 - 0x6421
int64_t Erase_Customization_Data2(void) {
    // 0x6413
    mcount();
    return &g1;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6421 - 0x6423
// Line range:    3006 - 3009
char GetISDBTEmergencyAlarmStatus(char * DevExt, char DevCH, int64_t ptuner_globe_data) {
    // 0x6421
    int64_t result; // 0x6421
    return result;
}

// Address range: 0x6423 - 0x642c
int64_t Get_Customization_Data_Size2(void) {
    // 0x6423
    return mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6431 - 0x643a
// Line range:    3011 - 3014
char GetSatelliteEmergencyAlarmStatus(char * DevExt, char DevCH, int64_t ptuner_globe_data) {
    // 0x6431
    int64_t v1; // 0x6431
    *(char *)v1 = 2 * (char)v1;
    return &g1;
}

// Address range: 0x643a - 0x643e
int64_t Get_Tuner_Extra_Data_Size2(int64_t * a1) {
    // 0x643a
    int64_t result; // 0x643a
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6441 - 0x6451
// Line range:    3091 - 3123
int64_t TC_GetBER(char * DevExt, char DevCH, int64_t * BER1, int64_t * BER2, char * tuner_globe_data) {
    // 0x6441
    *(int64_t *)DevExt = (int64_t)&g95;
    return &g1;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6451 - 0x6461
// Line range:    3136 - 3163
int64_t TC_GetAGC(char * DevExt, char DevCH, char * tuner_globe_data) {
    // 0x6451
    mcount();
    return 0;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6461 - 0x6471
// Line range:    3176 - 3196
char TC_GetEmergencyAlarmStatus(char * DevExt, char DevCH, char * tuner_globe_data) {
    // 0x6461
    mcount();
    return 0;
}

// Address range: 0x6471 - 0x6481
int64_t TC_GetBER2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x6471
    mcount();
    return &g1;
}

// Address range: 0x6481 - 0x6491
int64_t TC_GetAGC2(void) {
    // 0x6481
    mcount();
    return &g1;
}

// Address range: 0x6491 - 0x6495
int64_t TC_GetEmergencyAlarmStatus2(void) {
    // 0x6491
    int64_t result; // 0x6491
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6499 - 0x64c9
// Line range:    1427 - 1446
char Init_Tuner_S(char * DevExt, char DevCH) {
    int64_t v1 = (int64_t)DevExt;
    int64_t v2; // 0x6499
    char * v3 = (char *)(v2 - 128); // 0x6499
    unsigned char v4 = *v3; // 0x6499
    unsigned char v5 = v4 + (char)v2; // 0x6499
    *v3 = v5;
    char v6 = *(char *)&v1 + (char)&g1; // 0x649c
    *DevExt = v6;
    if (v5 >= v4 && v6 != 0) {
        // 0x64c7
        return 0;
    }
    // 0x64a0
    int64_t v7; // 0x6499
    int32_t v8 = *(int32_t *)(v7 + (int64_t)&g86); // 0x64a0
    if (v8 == 0) {
        // 0x64c7
        return TC_GetAGC((char *)v1, DevCH, (char *)v7);
    }
    int64_t result = 0; // 0x64b5
    if (v8 == (int32_t)&g1) {
        // 0x64b7
        result = TC_GetEmergencyAlarmStatus((char *)v1, DevCH, (char *)v7);
    }
    // 0x64c7
    return result;
}

// Address range: 0x64c9 - 0x6567
int64_t Init_Tuner_S2(int64_t a1, int64_t a2) {
    // 0x64c9
    mcount();
    __readgsqword(40);
    char * v1 = (char *)a1; // 0x650e
    char v2 = a2; // 0x650e
    char * v3; // bp-72, 0x64c9
    Adpater_TunerT_RegRead(v1, v2, 0, (char *)&v3, (char)&g25);
    v3 = (char *)&g97;
    TLIB_Delay2((int64_t *)&g1);
    // 0x655d
    return TLIB_Delay2((int64_t *)&g89);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6569 - 0x6599
// Line range:    1407 - 1426
char Init_Tuner_T(char * handle, char DevCH) {
    // 0x6569
    int64_t v1; // 0x6569
    *(char *)v1 = 2 * (char)v1;
    int64_t v2 = v1 + 184 & 0xffffffff; // 0x656d
    char * v3 = (char *)(v2 - 117); // 0x6572
    int64_t v4; // 0x6569
    *v3 = *v3 + (char)v4;
    int64_t result = v2; // 0x6580
    int64_t v5; // 0x6569
    if (*(int32_t *)40 != (int32_t)v5) {
        // 0x6582
        result = __stack_chk_fail();
    }
    // 0x6587
    return result;
}

// Address range: 0x6599 - 0x65eb
int64_t Init_Tuner_T2(int64_t a1, uint64_t a2) {
    // 0x6599
    mcount();
    int64_t v1; // bp-56, 0x6599
    Adpater_TunerT_RegWrite2(a1, a2 % 256, 0, &v1, (int64_t *)&g1);
    v1 = -1;
    return TLIB_Delay2((int64_t *)&g1);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x65fa - 0x662a
// Line range:    3274 - 3289
char TC_Preset(char * DevExt, char DevCH, char * tuner_globe_data) {
    // 0x65fa
    int64_t v1; // 0x65fa
    int64_t v2; // 0x65fa
    int64_t v3; // 0x65fa
    int64_t v4; // 0x65fa
    int64_t v5 = Adpater_TunerT_RegWrite2(v1, v3 & 0xffffffff, (int64_t)tuner_globe_data, (int64_t *)v4, (int64_t *)v2); // 0x65ff
    return (char)v5 == 0 ? 0 : (char)&g1;
}

// Address range: 0x662a - 0x6673
int64_t TC_Preset2(int64_t a1) {
    // 0x662a
    mcount();
    TLIB_Delay2((int64_t *)&g98);
    TLIB_SetGPIO2(a1, (int64_t *)&g1, (int64_t *)&g1);
    TLIB_Delay2((int64_t *)&g98);
    return TLIB_SetGPIO2(a1, NULL, (int64_t *)&g1);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6675 - 0x66a5
// Line range:    3246 - 3272
char TC_GetLNBShortDetect(char * DevExt, char DevCH, char * LNBShort, char * tuner_globe_data) {
    // 0x6675
    int64_t v1; // 0x6675
    *(char *)v1 = 2 * (char)v1;
    int64_t v2 = v1 + ((int64_t)tuner_globe_data >> (int64_t)&g95) & 101 | v1 & -256; // 0x6679
    int32_t * v3 = (int32_t *)v2; // 0x667b
    *v3 = *v3 + (int32_t)v2;
    int64_t v4; // 0x6675
    TLIB_SetGPIO2(v4, (int64_t *)&g1, (int64_t *)&g1);
    TLIB_Delay2((int64_t *)&g98);
    return &g1;
}

// Address range: 0x66a5 - 0x66d4
int64_t TC_GetLNBShortDetect2(int64_t a1, int64_t a2, int64_t * a3) {
    int64_t result = mcount(); // 0x66ae
    *(char *)a3 = 0;
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x66d8 - 0x6708
// Line range:    1108 - 1120
char DemodRegRead(char * DevExt, char DevCH, char byReg, char * pBuffer, char byCount, int32_t sig_source) {
    // 0x66d8
    int64_t v1; // 0x66d8
    return v1 + ((uint64_t)(int64_t)pBuffer >> (uint64_t)(int64_t)&g95);
}

// Address range: 0x66db - 0x66fc
int64_t function_66db(void) {
    // 0x66db
    int64_t v1; // 0x66db
    __writegsdword(v1, __readgsdword(v1) + (int32_t)v1);
    int64_t v2; // 0x66db
    char * v3 = (char *)v2;
    int64_t v4; // 0x66db
    if ((*(char *)(v4 - 17) & (char)&g1) == 0) {
        // 0x66f2
        *v3 = (char)&g1;
        return &g1;
    }
    // 0x66e8
    *v3 = 0;
    return &g1;
}

// Address range: 0x6708 - 0x672d
int64_t DemodRegRead2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t * a5, int64_t * a6) {
    // 0x6708
    return mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x672e - 0x675e
// Line range:    2996 - 3004
int64_t GetSatelliteAGC(char * DevExt, char DevCH, int64_t ptuner_globe_data) {
    // 0x672e
    int64_t v1; // 0x672e
    int64_t v2; // 0x672e
    int64_t v3; // 0x672e
    return TLIB_I2C_Read2((int64_t)DevExt, (int64_t)DevCH, ptuner_globe_data, (int64_t *)v3, (int64_t *)v2, v1);
}

// Address range: 0x675e - 0x676b
int64_t GetSatelliteAGC2(void) {
    // 0x675e
    return mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x676d - 0x679d
// Line range:    2986 - 2994
int64_t GetISDBTAGC(char * DevExt, char DevCH, int64_t ptuner_globe_data) {
    // 0x676d
    int64_t v1; // 0x676d
    int64_t * v2 = (int64_t *)(v1 + (int64_t)&g105); // 0x676d
    *v2 = *v2 + (int64_t)&g1;
    int64_t v3; // 0x676d
    int64_t v4 = DemodRegRead2((int64_t)DevExt, (int64_t)DevCH, 186, v3, (int64_t *)&g1, (int64_t *)&g1); // 0x6784
    int64_t result = 0; // 0x6792
    if ((char)v4 != 0) {
        // 0x6794
        int64_t v5; // 0x676d
        result = (int64_t)(*(char *)(v5 - 1) % 128);
    }
    // 0x679b
    return result;
}

// Address range: 0x679d - 0x67a5
int64_t GetISDBTAGC2(void) {
    // 0x679d
    int64_t result; // 0x679d
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x67a9 - 0x67d9
// Line range:    2959 - 2984
int64_t GetSatelliteBER(char * DevExt, char DevCH, int64_t * BER1, int64_t * BER2, int64_t ptuner_globe_data) {
    int64_t v1 = (int64_t)BER2;
    int64_t v2; // 0x67a9
    char * v3 = (char *)(v2 - 115); // 0x67a9
    *v3 = *v3 + (char)v1;
    int64_t * v4 = (int64_t *)(ptuner_globe_data + (int64_t)&g105); // 0x67ac
    *v4 = *v4 + (int64_t)&g1;
    int64_t v5 = DemodRegRead2((int64_t)DevExt, (int64_t)DevCH, 130, v1, (int64_t *)&g1, NULL); // 0x67c3
    int64_t result = 0; // 0x67d1
    if ((char)v5 != 0) {
        // 0x67d3
        int64_t v6; // 0x67a9
        result = (int64_t)*(char *)(v6 - 1);
    }
    // 0x67d7
    return result;
}

// Address range: 0x67d9 - 0x6887
int64_t GetSatelliteBER2(int64_t a1, uint64_t a2, int64_t a3, int64_t a4) {
    // 0x67d9
    mcount();
    int64_t * v1 = (int64_t *)a3; // 0x67ff
    *v1 = 0x5f5e100;
    *(int64_t *)a4 = 0x5f5e100;
    uint64_t v2 = a2 % 256; // 0x680d
    int32_t v3; // bp-56, 0x67d9
    int64_t v4 = &v3; // 0x6811
    DemodRegRead2(a1, v2, 240, v4, (int64_t *)&g33, (int64_t *)&g1);
    uint32_t v5; // 0x67d9
    int32_t v6 = v5 % 256 << (int32_t)&g95; // 0x683d
    uint32_t v7; // 0x67d9
    *v1 = (int64_t)((v6 | v7 % 256 | v3 % 256 << (int32_t)&g2) * ((int32_t)((int64_t)&g86 + 1) << (int32_t)&g86));
    DemodRegRead2(a1, v2, (int64_t)"%(", v4, (int64_t *)&g33, (int64_t *)&g1);
    return v3 % 256 << (int32_t)&g2 | v6;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6887 - 0x68b7
// Line range:    2911 - 2957
int64_t GetISDBTBER(char * DevExt, char DevCH, int64_t * BER1, int64_t * BER2, int64_t ptuner_globe_data) {
    // 0x6887
    int64_t v1; // 0x6887
    unsigned char v2 = *(char *)(v1 - 46); // 0x6887
    int64_t v3; // 0x6887
    int64_t v4; // 0x6887
    *(int64_t *)v3 = (v4 | (int64_t)v2) * (int64_t)((int32_t)((int64_t)&g86 + 1) << (int32_t)&g86) & 0xffffffff;
    return &g1;
}

// Address range: 0x68b7 - 0x6a0e
int64_t GetISDBTBER2(int64_t a1, uint64_t a2, int64_t a3, int64_t a4) {
    // 0x68b7
    mcount();
    int64_t * v1 = (int64_t *)a3; // 0x68e1
    *v1 = 0x5f5e100;
    *(int64_t *)a4 = 0x5f5e100;
    uint64_t v2 = a2 % 256; // 0x68ef
    int32_t v3; // bp-88, 0x68b7
    int64_t v4 = &v3; // 0x68f3
    DemodRegRead2(a1, v2, 157, v4, (int64_t *)&g33, NULL);
    int32_t v5; // bp-72, 0x68b7
    int64_t v6 = &v5; // 0x692a
    DemodRegRead2(a1, v2, 166, v6, (int64_t *)&g25, NULL);
    unsigned char v7; // 0x68b7
    int32_t v8 = v7; // 0x695c
    uint32_t v9; // 0x68b7
    uint32_t v10; // 0x68b7
    *v1 = (int64_t)((v10 % 256 << (int32_t)&g95 | v9 % 256 | v3 % 256 << (int32_t)&g2) * 0xef5a / (v5 % 256 << (int32_t)&g95 | v8));
    DemodRegRead2(a1, v2, 160, v4, (int64_t *)&g33, NULL);
    DemodRegRead2(a1, v2, 166, v6, (int64_t *)&g25, NULL);
    return 0xef5a / (v5 % 256 << (int32_t)&g95 | v8);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6a0e - 0x6a3e
// Line range:    2891 - 2908
int64_t GetSatelliteCNRegister(char * DevExt, char DevCH, int64_t ptuner_globe_data) {
    // 0x6a0e
    int64_t v1; // 0x6a0e
    unsigned char v2 = *(char *)(v1 - 81); // 0x6a0e
    int64_t v3; // 0x6a0e
    int64_t v4; // 0x6a0e
    int64_t v5; // 0x6a0e
    *(int64_t *)v3 = 0x100000000 * (v4 | (int64_t)v2) / 0x100000000 * 0x100000000 * v5 / 0x100000000 & 0xffffffff;
    return &g1;
}

// Address range: 0x6a3e - 0x6a53
int64_t GetSatelliteCNRegister2(int64_t a1, int64_t a2) {
    // 0x6a3e
    return mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6a55 - 0x6a85
// Line range:    2853 - 2889
int64_t GetSatelliteCN(char * DevExt, char DevCH, int64_t ptuner_globe_data) {
    // 0x6a55
    int64_t v1; // 0x6a55
    *(int32_t *)v1 = 2 * (int32_t)v1;
    int64_t v2; // 0x6a55
    int64_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    int64_t v4; // 0x6a55
    int64_t v5; // 0x6a55
    int64_t v6 = DemodRegRead2((int64_t)DevExt, (int64_t)DevCH, 188, v5, (int64_t *)&g25, (int64_t *)v4); // 0x6a64
    v2 = 0;
    int64_t result = 0; // 0x6a72
    if ((char)v6 != 0) {
        // 0x6a74
        int64_t v7; // 0x6a55
        unsigned char v8 = *(char *)(v7 - 16); // 0x6a74
        unsigned char v9 = *(char *)(v7 - 15); // 0x6a7b
        result = (int32_t)v8 << (int32_t)&g95 | (int32_t)v9;
        v2 = result;
    }
    // 0x6a83
    return result;
}

// Address range: 0x6a85 - 0x6b46
int64_t GetSatelliteCN2(int64_t a1, uint64_t a2) {
    // 0x6a85
    mcount();
    int32_t v1; // bp-24, 0x6a85
    DemodRegRead2(a1, a2 % 256, 188, (int64_t)&v1, (int64_t *)&g25, (int64_t *)&g1);
    unsigned char v2; // 0x6a85
    if (((uint32_t)v1 % 256 << (int32_t)&g95 || (int32_t)v2) >= 0x8bf2) {
        // 0x6aea
        return 0;
    }
    // 0x6aec
    abort();
    // UNREACHABLE
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6b48 - 0x6b78
// Line range:    2824 - 2842
int64_t GetISDBTCNRegister(char * DevExt, char DevCH, int64_t ptuner_globe_data) {
    // 0x6b48
    int64_t v1; // 0x6b48
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x6b48
    char * v3 = (char *)(v2 - 9); // 0x6b4a
    int64_t v4; // 0x6b48
    *v3 = *v3 + (char)v4;
    int64_t v5 = v2;
    *(char *)v5 = *(char *)&v2 + (char)v5;
    int64_t v6 = v2;
    *(char *)v6 = *(char *)&v2 + (char)v6;
    return (int64_t)DevCH & 0xffffffff;
}

// Address range: 0x6b78 - 0x6b93
int64_t GetISDBTCNRegister2(int64_t a1, int64_t a2) {
    // 0x6b78
    return mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6b98 - 0x6bc8
// Line range:    2788 - 2822
int64_t GetISDBTCN(char * DevExt, char DevCH, int64_t ptuner_globe_data) {
    char * v1 = (char *)(ptuner_globe_data + 139); // 0x6b98
    uint64_t v2; // 0x6b98
    *v1 = *v1 + (char)(v2 / 256);
    int64_t result = 0; // 0x6bac
    int64_t v3; // 0x6b98
    int64_t v4; // 0x6b98
    int64_t v5; // 0x6b98
    if ((char)DemodRegRead2((int64_t)DevExt, (int64_t)DevCH, ptuner_globe_data, v5, (int64_t *)v4, (int64_t *)v3) != 0) {
        // 0x6bae
        int64_t v6; // 0x6b98
        unsigned char v7 = *(char *)(v6 - 16); // 0x6bae
        unsigned char v8 = *(char *)(v6 - 15); // 0x6bb5
        unsigned char v9 = *(char *)(v6 - 14); // 0x6bbe
        result = (int32_t)v8 << (int32_t)&g95 | (int32_t)v7 << (int32_t)&g2 | (int32_t)v9;
    }
    // 0x6bc6
    return result;
}

// Address range: 0x6bc8 - 0x6c85
int64_t GetISDBTCN2(int64_t a1, uint64_t a2) {
    // 0x6bc8
    mcount();
    int32_t v1; // bp-24, 0x6bc8
    DemodRegRead2(a1, a2 % 256, 139, (int64_t)&v1, (int64_t *)&g33, NULL);
    uint32_t v2; // 0x6bc8
    uint32_t v3; // 0x6bc8
    if ((v3 % 256 << (int32_t)&g95 || v2 % 256 || (uint32_t)v1 % 256 << (int32_t)&g2) >= 0x953501) {
        // 0x6c30
        return 0;
    }
    // 0x6c32
    abort();
    // UNREACHABLE
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6c87 - 0x6cb7
// Line range:    1080 - 1093
char Adapter_ReadSNR_S(char * DevExt, char DevCH) {
    // 0x6c87
    int64_t v1; // 0x6c87
    int64_t result; // 0x6c87
    __asm_out((int16_t)v1, (int32_t)result);
    return result;
}

// Address range: 0x6cb7 - 0x6cee
int64_t Adapter_ReadSNR_S2(int64_t a1, uint64_t a2) {
    // 0x6cb7
    mcount();
    int64_t v1; // bp-40, 0x6cb7
    DemodRegRead2(a1, a2 % 256, 240, (int64_t)&v1, (int64_t *)&g33, (int64_t *)&g1);
    return 0;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6cee - 0x6d1e
// Line range:    1056 - 1079
char Adapter_ReadSNR_T(char * DevExt, char DevCH) {
    // 0x6cee
    int64_t result; // 0x6cee
    bool v1; // 0x6cee
    if (!v1) {
        // 0x6cf0
        int64_t v2; // 0x6cee
        unsigned char v3 = *(char *)(v2 - 32); // 0x6cf0
        unsigned char v4 = *(char *)(v2 - 31); // 0x6cf7
        unsigned char v5 = *(char *)(v2 - 30); // 0x6d00
        int64_t v6; // 0x6cee
        int64_t v7 = Ber_to_Signal_Quality2((int32_t)v4 << (int32_t)&g95 | (int32_t)v3 << (int32_t)&g2 | (int32_t)v5, 0, v6 & 0xffffffff, (int64_t *)&g1); // 0x6d12
        result = v7;
    }
    // 0x6d17
    return result;
}

// Address range: 0x6d1e - 0x6db7
int64_t Adapter_ReadSNR_T2(int64_t a1, uint64_t a2) {
    // 0x6d1e
    mcount();
    uint64_t v1 = a2 % 256; // 0x6d42
    int64_t v2; // bp-88, 0x6d1e
    DemodRegRead2(a1, v1, 157, (int64_t)&v2, (int64_t *)&g33, NULL);
    int64_t v3; // bp-72, 0x6d1e
    DemodRegRead2(a1, v1, 166, (int64_t)&v3, (int64_t *)&g25, NULL);
    unsigned char result; // 0x6d1e
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6db7 - 0x6de7
// Line range:    1042 - 1055
int64_t Adapter_GetSignaLevel_S(char * DevExt, char DevCH) {
    // 0x6db7
    int64_t v1; // 0x6db7
    int64_t v2; // 0x6db7
    return Ber_to_Signal_Quality2((uint32_t)(int32_t)v1 % 256 | (int32_t)(int64_t)DevExt, (int64_t)DevCH, v2 & 0xffffffff, NULL);
}

// Address range: 0x6de7 - 0x6e20
int64_t Adapter_GetSignaLevel_S2(int64_t a1, uint64_t a2) {
    // 0x6de7
    mcount();
    int64_t v1; // bp-40, 0x6de7
    DemodRegRead2(a1, a2 % 256, (int64_t)"%(", (int64_t)&v1, (int64_t *)&g33, (int64_t *)&g1);
    return 0;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6e21 - 0x6e51
// Line range:    1018 - 1041
int64_t Adapter_GetSignaLevel_T(char * DevExt, char DevCH) {
    // 0x6e21
    int64_t v1; // 0x6e21
    __asm_out_621(16, (int32_t)v1);
    int64_t v2; // 0x6e21
    unsigned char v3 = *(char *)(v2 - 31); // 0x6e27
    unsigned char v4 = *(char *)(v2 - 30); // 0x6e30
    int64_t v5; // 0x6e21
    uint64_t v6 = Ber_to_Signal_Quality2((int32_t)v3 << (int32_t)&g95 | (int32_t)(int64_t)DevExt | (int32_t)v4, 0, v5 & 0xffffffff, (int64_t *)&g1); // 0x6e42
    return v6 % 256;
}

// Address range: 0x6e51 - 0x6eea
int64_t Adapter_GetSignaLevel_T2(int64_t a1, uint64_t a2) {
    // 0x6e51
    mcount();
    uint64_t v1 = a2 % 256; // 0x6e75
    int64_t v2; // bp-88, 0x6e51
    DemodRegRead2(a1, v1, 160, (int64_t)&v2, (int64_t *)&g33, NULL);
    int64_t v3; // bp-72, 0x6e51
    DemodRegRead2(a1, v1, 166, (int64_t)&v3, (int64_t *)&g25, NULL);
    unsigned char result; // 0x6e51
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6eed - 0x6f1d
// Line range:    390 - 413
char Adapter_TSIDRead(char * DevExt, char DevCH, int32_t * tsidList, char bufferlength) {
    int64_t v1 = bufferlength;
    int32_t * v2 = (int32_t *)(v1 - 1 + v1 * (int64_t)&g1); // 0x6eed
    *v2 = *v2 + (int32_t)&g1;
    int64_t v3; // 0x6eed
    return Ber_to_Signal_Quality2((int32_t)(int64_t)DevExt, (int64_t)DevCH, v3 & 0xffffffff, NULL);
}

// Address range: 0x6f1d - 0x6fa2
int64_t Adapter_TSIDRead2(int64_t a1, uint64_t a2, int64_t a3, int64_t a4) {
    // 0x6f1d
    mcount();
    __readgsqword(40);
    int64_t v1; // bp-56, 0x6f1d
    int64_t v2 = &v1; // 0x6f4c
    DemodRegRead2(a1, a2 % 256, 206, v2, (int64_t *)&g2, (int64_t *)&g1);
    unsigned char v3 = *(char *)&v1; // 0x6f85
    unsigned char v4 = *(char *)(v2 + (int64_t)&g1); // 0x6f8c
    *(int32_t *)a3 = (int32_t)v3 << (int32_t)&g95 | (int32_t)v4;
    return &g25;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x6fa4 - 0x6fd4
// Line range:    1688 - 1729
char TC_SetFrequency(char * DevExt, char DevCH, int64_t dwFreqkHz, char ucBW, char * tuner_globe_data) {
    // 0x6fa4
    int64_t result; // 0x6fa4
    return result;
}

// Address range: 0x6fa5 - 0x6fa9
int64_t function_6fa5(void) {
    // 0x6fa5
    int64_t result; // 0x6fa5
    return result;
}

// Address range: 0x6fd4 - 0x706f
int64_t TC_SetFrequency2(int64_t a1, int64_t a2, uint64_t a3, int64_t a4, int64_t a5) {
    int64_t result = mcount(); // 0x6fdf
    if (a3 >= 0xf4240) {
        // 0x7061
        return result;
    }
    // 0x6ff7
    if (a3 < 0x28ce8) {
        // 0x7039
        *(int32_t *)(a5 + (int64_t)&g86) = 0;
        return 0x2d0e560418938124;
    }
    int64_t v1 = &g32; // 0x701a
    if (a3 >= 0x30218) {
        // 0x7023
        v1 = a3 < 0x73838 ? 0x73837 : a3;
    }
    // 0x7039
    *(int32_t *)(a5 + (int64_t)&g86) = 0;
    return 0x20c49ba5e353f7cf * v1 / 8;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x7073 - 0x70a3
// Line range:    1564 - 1576
char TLIB_SetGPIO_ASIE5606B5(char * DevExt, char Data, char MaskData) {
    // 0x7073
    int64_t v1; // 0x7073
    *(int32_t *)v1 = 2 * (int32_t)v1;
    int64_t v2; // 0x7073
    int64_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    v2 = 0;
    char result = 0; // 0x7089
    if ((char)TC_RemappingTunerNumber2((int64_t)DevExt) != 0) {
        // 0x708b
        int64_t v4; // 0x7073
        int64_t v5; // 0x7073
        int64_t v6; // 0x7073
        int64_t v7 = Japan4x4Tuner_TunerSetFrequency2(*(char *)(v5 - 20), v4, v6); // 0x7095
        v2 = v7;
        result = v7;
    }
    // 0x709a
    return result;
}

// Address range: 0x70a3 - 0x7104
int64_t TLIB_SetGPIO_ASIE5606B5_(int64_t a1, int64_t * a2, int64_t * a3) {
    // 0x70a3
    mcount();
    char v1; // bp-41, 0x70a3
    TLIB_I2C_Read2(a1, 74, (int64_t)&g99, (int64_t *)&v1, (int64_t *)&g1, 0);
    int64_t v2 = (int64_t)a3 & 0xffffffff;
    int64_t v3 = v2 ^ 0xffffffff; // 0x70f2
    return v3 & 0xffffff00 | v2 & (int64_t)a2 | (int64_t)(v1 & (char)v3);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x7105 - 0x7135
// Line range:    3209 - 3233
char TC_SetLNB(char * DevExt, char DevCH, char LNBPower, char * tuner_globe_data) {
    // 0x7105
    int64_t v1; // 0x7105
    int64_t v2; // 0x7105
    int64_t v3 = TLIB_I2C_Write2(v2, 74, (int64_t)&g99, 0, (int64_t)&g1, v1); // 0x711d
    return (char)v3 != 0;
}

// Address range: 0x7135 - 0x7149
int64_t TC_SetLNB2(int64_t a1, int64_t a2) {
    // 0x7135
    mcount();
    return 0;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x714a - 0x717a
// Line range:    2571 - 2649
char TC_MOS_POWER(char * DevExt, char DevCH, char bPower_On, char * tuner_globe_data) {
    // 0x714a
    int64_t v1; // 0x714a
    int32_t * v2 = (int32_t *)(v1 + (int64_t)&g10); // 0x714b
    *v2 = *v2 + (int32_t)DevCH;
    TLIB_SetGPIO_ASIE5606B5_((int64_t)DevExt, (int64_t *)&g26, (int64_t *)&g26);
    return &g1;
}

// Address range: 0x717a - 0x72f6
int64_t TC_MOS_POWER2(int64_t a1, int64_t a2, int64_t * a3) {
    // 0x717a
    mcount();
    if ((char)(int64_t)a3 == 0) {
        // 0x72c6
        TLIB_Delay2((int64_t *)&g98);
        TLIB_SetGPIO2(a1, NULL, (int64_t *)&g1);
        return TLIB_Delay2((int64_t *)&g98);
    }
    // 0x7193
    TLIB_SetGPIO2(a1, (int64_t *)&g1, (int64_t *)&g1);
    TLIB_Delay2((int64_t *)&g98);
    TLIB_SetGPIO2(a1, NULL, (int64_t *)&g1);
    TLIB_Delay2((int64_t *)&g98);
    TLIB_SetGPIO2(a1, (int64_t *)&g1, (int64_t *)&g1);
    TLIB_Delay2((int64_t *)&g7);
    TLIB_SetGPIOEx2(a1, (int64_t *)&g1, (int64_t *)&g1);
    TLIB_Delay2((int64_t *)&g98);
    TLIB_SetGPIOEx2(a1, NULL, (int64_t *)&g1);
    TLIB_Delay2((int64_t *)&g7);
    TLIB_SetGPIO_ASIE5606B5_(a1, (int64_t *)&g25, (int64_t *)&g25);
    TLIB_Delay2((int64_t *)&g7);
    TLIB_SetGPIO_ASIE5606B5_(a1, NULL, (int64_t *)&g25);
    TLIB_Delay2((int64_t *)&g7);
    TLIB_SetGPIO_ASIE5606B5_(a1, (int64_t *)&g25, (int64_t *)&g25);
    TLIB_Delay2((int64_t *)&g7);
    TLIB_SetGPIO_ASIE5606B5_(a1, (int64_t *)&g86, (int64_t *)&g86);
    TLIB_Delay2((int64_t *)&g7);
    TLIB_SetGPIO_ASIE5606B5_(a1, NULL, (int64_t *)&g86);
    TLIB_Delay2((int64_t *)&g7);
    TLIB_SetGPIO_ASIE5606B5_(a1, (int64_t *)&g86, (int64_t *)&g86);
    return TLIB_Delay2((int64_t *)&g7);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x72f6 - 0x7326
// Line range:    1095 - 1107
char DemodRegWrite(char * DevExt, char DevCH, char byReg, char * pBuffer, char byCount, int32_t sig_source) {
    // 0x72f6
    int64_t v1; // 0x72f6
    TLIB_SetGPIO2(v1, (int64_t *)(int64_t)DevCH, (int64_t *)(int64_t)byReg);
    TLIB_Delay2((int64_t *)&g98);
    TLIB_SetGPIOEx2(v1, (int64_t *)&g1, (int64_t *)&g1);
    return &g1;
}

// Address range: 0x7326 - 0x734c
int64_t DemodRegWrite2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int64_t * a5, int64_t a6) {
    // 0x7326
    return mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x734c - 0x737c
// Line range:    1536 - 1562
char ReAcqDemod(char * DevExt, char DevCH, int32_t src) {
    // 0x734c
    int64_t v1; // 0x734c
    int64_t v2; // 0x734c
    int64_t v3; // 0x734c
    return TLIB_I2C_Write2((int64_t)DevExt, (int64_t)DevCH, (int64_t)src, v3, v2, v1);
}

// Address range: 0x737c - 0x73b3
int64_t ReAcqDemod2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x737c
    mcount();
    if ((int32_t)a3 != 0) {
        InitDemod((char *)a1, (char)a2, (char *)a3);
    }
    int64_t v1 = 64; // bp-24, 0x738d
    int64_t v2 = DemodRegWrite2(a1, a2 % 256, a3 & -256 | (int64_t)&g1, &v1, (int64_t *)&g1, 0); // 0x73a7
    return v2 & -256 | (int64_t)((char)v2 != 0);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x73b3 - 0x73e3
// Line range:    1184 - 1259
char InitDemod(char * DevExt, unsigned char DevCH, char * tuner_globe_data) {
    int64_t v1 = (int64_t)tuner_globe_data;
    char result = &g1; // 0x73bb
    if ((int32_t)v1 == (int32_t)&g1) {
        // 0x73bd
        int64_t v2; // 0x73b3
        int64_t v3 = v2 - 16; // 0x73bd
        *(char *)v3 = (char)&g1;
        int64_t v4 = DemodRegWrite2((int64_t)DevExt, (int64_t)DevCH, v1 & -256 | (int64_t)&g33, (int64_t *)v3, (int64_t *)&g1, (int64_t)&g1); // 0x73d7
        result = (char)v4 != 0;
    }
    // 0x73e1
    return result;
}

// Address range: 0x73e3 - 0x74af
int64_t InitDemod2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x73e3
    mcount();
    int32_t v1 = *(int32_t *)(a3 + (int64_t)&g86); // 0x7414
    if (v1 != (int32_t)&g1) {
        // 0x746f
        abort();
        // UNREACHABLE
    }
    uint64_t v2 = a2 % 256; // 0x742c
    int64_t result; // 0x7453
    // 0x746d
    return result;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x74b2 - 0x74e2
// Line range:    377 - 389
char Adapter_TSIDWrite(char * DevExt, char DevCH, int32_t tsid) {
    // 0x74b2
    int64_t result; // 0x74b2
    return result;
}

// Address range: 0x74e2 - 0x74fa
int64_t Adapter_TSIDWrite2(int64_t a1, int64_t a2) {
    // 0x74e2
    mcount();
    return 0;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x74fa - 0x752a
// Line range:    515 - 554
char TunerRegRead(char * DevExt, unsigned char DevCH, char byReg, char * pBuffer, char byCount, int32_t src) {
    // 0x74fa
    int64_t v1; // 0x74fa
    int64_t v2 = v1 - 16; // 0x74ff
    *(char *)v2 = (char)((int32_t)byReg >> (int32_t)&g95);
    *(char *)(v1 - 15) = byReg;
    int64_t v3 = DemodRegWrite2((int64_t)DevExt, (int64_t)DevCH, 143, (int64_t *)v2, (int64_t *)&g25, (int64_t)&g1); // 0x751e
    return (char)v3 != 0;
}

// Address range: 0x752a - 0x763f
int64_t TunerRegRead2(int64_t a1, uint64_t a2, int64_t * a3, int64_t * a4, int64_t * a5, int64_t a6) {
    uint64_t v1 = (int64_t)a5;
    mcount();
    __readgsqword(40);
    int64_t v2; // bp-72, 0x752a
    if ((int32_t)a6 != 0) {
        // 0x75ec
        v2 = -63;
        uint64_t v3 = a2 % 256; // 0x7614
        TLIB_I2C_Write2(a1, v3, 254, (int64_t)&v2, (int64_t)&g1, a6 & -256 | (int64_t)&g86);
        int64_t result = TLIB_I2C_Read2(a1, v3, 0, a4, (int64_t *)(v1 % 256), (int64_t)&g25); // 0x7638
        return result;
    }
    // 0x756e
    v2 = -58;
    int64_t v4 = &v2; // 0x7581
    uint64_t v5 = a2 % 256; // 0x7590
    TLIB_I2C_Write2(a1, v5, 254, v4, (int64_t)&g25, a6);
    v2 = -57;
    TLIB_I2C_Write2(a1, v5, 254, v4, (int64_t)&g1, (int64_t)&g86);
    int64_t v6 = TLIB_I2C_Read2(a1, v5, 0, a4, (int64_t *)(v1 % 256), (int64_t)&g25); // 0x75e0
    return v6 & -256 | (int64_t)((char)v6 != 0);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x763f - 0x766f
// Line range:    476 - 513
char TunerRegWrite(char * DevExt, char DevCH, char * pBuffer, char byCount, int32_t src) {
    // 0x763f
    bool v1; // 0x763f
    int64_t result = !v1; // 0x7656
    int64_t v2; // 0x763f
    if (*(int64_t *)(v2 - 40) != __readgsqword(40)) {
        // 0x7658
        result = __stack_chk_fail();
    }
    // 0x765d
    return result;
}

// Address range: 0x766f - 0x7748
int64_t TunerRegWrite2(int64_t a1, int64_t a2, int64_t * a3, int64_t * a4, int64_t a5) {
    int64_t v1 = (int64_t)a4;
    int64_t v2 = (int64_t)a3;
    int64_t v3 = a2;
    mcount();
    __readgsqword(40);
    int64_t v4 = -2;
    char v5; // bp-39, 0x766f
    if ((int32_t)a5 != 0) {
        // 0x76fd
        if ((char)v1 == 0) {
            // 0x7735
            return 0;
        }
        int64_t result = &v5; // 0x771c
        int64_t v6 = v2; // 0x771c
        *(char *)result = *(char *)v6;
        v6++;
        result += (int64_t)&g1;
        while (v6 != v2 + (int64_t)&g1 + (v1 + 255) % 256) {
            // 0x7721
            *(char *)result = *(char *)v6;
            v6++;
            result += (int64_t)&g1;
        }
        // 0x7735
        return result;
    }
    // 0x769a
    v5 = -58;
    int64_t result2; // 0x76f6
    if ((char)v1 == 0) {
        // 0x76d4
        result2 = TLIB_I2C_Write2(a1, (int64_t)(char)a2, 0, (int64_t)&v4, (v1 + (int64_t)(char)&g25) % 256, (int64_t)&g25);
        return result2;
    }
    // 0x76af
    int64_t v7; // bp-38, 0x766f
    int64_t v8 = &v7; // 0x76bb
    int64_t v9 = v2; // 0x76bb
    *(char *)v8 = *(char *)v9;
    v9++;
    v8 += (int64_t)&g1;
    while (v9 != v2 + (int64_t)&g1 + (v1 + 255) % 256) {
        // 0x76c0
        *(char *)v8 = *(char *)v9;
        v9++;
        v8 += (int64_t)&g1;
    }
    char v10 = *(char *)&v3; // 0x766f
    // 0x76d4
    result2 = TLIB_I2C_Write2(a1, (int64_t)v10, 0, (int64_t)&v4, (v1 + (int64_t)(char)&g25) % 256, (int64_t)&g25);
    return result2;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x7749 - 0x7779
// Line range:    1361 - 1404
char InitRFDevice(char * DevExt, char DevCH, char * tuner_globe_data) {
    // 0x7749
    int64_t v1; // 0x7749
    uint64_t v2; // 0x7749
    int64_t v3 = TLIB_I2C_Write2((int64_t)DevExt, (int64_t)DevCH, 0, (int64_t)&g25, v2 % 256, v1); // 0x7757
    int64_t result = v3; // 0x7770
    int64_t v4; // 0x7749
    if (*(int64_t *)(v4 - 8) != __readgsqword(40)) {
        // 0x7772
        result = __stack_chk_fail();
    }
    // 0x7777
    return result;
}

// Address range: 0x7779 - 0x78e1
int64_t InitRFDevice2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x7779
    mcount();
    uint64_t v1 = a2 % 256;
    int32_t v2 = &g1; // bp-120, 0x7796
    char v3; // bp-72, 0x7779
    if (*(int32_t *)(a3 + (int64_t)&g86) != 0) {
        // branch -> 0x7887
    } else {
        int64_t v4 = &v2; // 0x7850
        v3 = *(char *)v4;
        TunerRegWrite2(a1, v1, (int64_t *)&v3, (int64_t *)&g25, 0);
        v4 += (int64_t)&g25;
        int64_t v5; // bp-78, 0x7779
        while (v4 != (int64_t)&v5) {
            // 0x7854
            v3 = *(char *)v4;
            TunerRegWrite2(a1, v1, (int64_t *)&v3, (int64_t *)&g25, 0);
            v4 += (int64_t)&g25;
        }
    }
    int64_t * v6 = (int64_t *)&v3;
    v3 = &g2;
    TunerRegWrite2(a1, v1, v6, (int64_t *)&g25, 0);
    v3 = &g2;
    return TunerRegWrite2(a1, v1, v6, (int64_t *)&g25, 0);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x78e1 - 0x7911
// Line range:    644 - 669
char FC0012_RSSI_Calibration(char * DevExt, char DevCH) {
    // 0x78e1
    int64_t v1; // 0x78e1
    int64_t v2; // 0x78e1
    int64_t v3; // 0x78e1
    int64_t v4 = TunerRegWrite2(v1, v2 & 0xffffffff, (int64_t *)v3, (int64_t *)&g25, 0); // 0x78f1
    return (char)v4 != 0;
}

// Address range: 0x7911 - 0x7a31
int64_t FC0012_RSSI_Calibration2(int64_t a1, uint64_t a2) {
    // 0x7911
    mcount();
    uint64_t v1 = a2 % 256; // 0x7924
    char v2; // bp-39, 0x7911
    TunerRegRead2(a1, v1, (int64_t *)&g97, (int64_t *)&v2, (int64_t *)&g1, 0);
    char v3 = (char)&g97; // bp-40, 0x794c
    v2 |= (char)&g2;
    TunerRegWrite2(a1, v1, (int64_t *)&v3, (int64_t *)&g25, 0);
    TunerRegRead2(a1, v1, (int64_t *)&g91, (int64_t *)&v2, (int64_t *)&g1, 0);
    v3 = &g91;
    v2 |= (char)&g1;
    TunerRegWrite2(a1, v1, (int64_t *)&v3, (int64_t *)&g25, 0);
    TLIB_Delay2((int64_t *)&g1);
    TunerRegRead2(a1, v1, (int64_t *)&g97, (int64_t *)&v2, (int64_t *)&g1, 0);
    v3 = (char)&g97;
    v2 &= -17;
    return TunerRegWrite2(a1, v1, (int64_t *)&v3, (int64_t *)&g25, 0);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x7a40 - 0x7a70
// Line range:    670 - 874
char Adpater_SetFreqISDBT(char * DevExt, char DevCH, int64_t Frequency, char ucRs) {
    // 0x7a40
    int64_t v1; // 0x7a40
    int64_t v2; // 0x7a40
    int64_t v3; // 0x7a40
    int64_t v4 = TunerRegWrite2(v1, v3 & 0xffffffff, (int64_t *)(v2 - 32), (int64_t *)&g25, 0); // 0x7a56
    return (char)v4 != 0;
}

// Address range: 0x7a70 - 0x7f23
int64_t Adpater_SetFreqISDBT2(int64_t a1, uint64_t a2, uint64_t a3) {
    // 0x7a70
    mcount();
    __readgsqword(40);
    uint64_t v1 = a2 % 256; // 0x7a9b
    FC0012_RSSI_Calibration2(a1, v1);
    char v2 = 0; // 0x7ab5
    int64_t v3 = 96; // 0x7ab5
    if (a3 * ((int64_t)&g25 + 1 << (int64_t)&g89) >= 0x365240) {
        // 0x7ac9
        v2 = &g25;
        v3 = 64;
        if (a3 << (int64_t)&g91 >= 0x365240) {
            // 0x7aea
            v2 = 0;
            v3 = 48;
            if (a3 * ((int64_t)&g25 + 1 << (int64_t)&g86) >= 0x365240) {
                // 0x7b0c
                v2 = &g25;
                v3 = (int64_t)&g26;
                if (a3 << (int64_t)&g89 >= 0x365240) {
                    // 0x7b2d
                    v2 = 0;
                    v3 = (int64_t)&g13;
                    if (a3 * ((int64_t)&g25 + 1 << (int64_t)&g33) >= 0x365240) {
                        // 0x7b4f
                        v2 = &g25;
                        v3 = &g2;
                        if (a3 << (int64_t)&g86 >= 0x365240) {
                            // 0x7b6d
                            v2 = 0;
                            v3 = (int64_t)"GNU";
                            if (a3 * ((int64_t)&g25 + 1 << (int64_t)&g25) >= 0x365240) {
                                // 0x7b8c
                                v2 = &g25;
                                v3 = &g95;
                                if (a3 * (int64_t)&g95 >= 0x365240) {
                                    char v4 = a3 * (int64_t)&g91 < 0x365240 ? 0 : (char)&g25;
                                    int64_t v5 = a3 * (int64_t)&g91 < 0x365240 ? (int64_t)&g91 : (int64_t)&g86;
                                    v2 = v4;
                                    v3 = v5;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    char v6 = v2;
    int64_t v7 = v3 % 256 * 0x100000000 * a3 / 0x100000000; // 0x7bd6
    uint32_t v8 = (int32_t)v7; // 0x7bde
    uint32_t v9 = (int32_t)(0xe90452d5 * (v7 & 0xffffffff) >> (int64_t)&g26) >> (int32_t)&g103; // 0x7bf7
    int32_t v10 = -0x4650 * (v9 % 0x10000) + v8 < 0x2328 ? v9 : v9 + (int32_t)&g1; // 0x7c0d
    unsigned char v11 = (char)v10 - (char)((int16_t)v10 >> (int16_t)&g33) * (char)&g95; // 0x7c1d
    char v12 = v11 > (char)&g1 ? v11 : v11 + (char)&g95;
    char v13 = v12;
    int64_t v14 = &v13; // 0x7c81
    int64_t v15 = &g1; // 0x7c81
    int32_t v16 = 0x1000000 * (int32_t)v15 / 0x1000000; // bp-104, 0x7c87
    char v17 = *(char *)v14; // bp-103, 0x7c8e
    TunerRegWrite2(a1, v1, (int64_t *)&v16, (int64_t *)&g25, 0);
    int64_t v18 = v15 + (int64_t)(int32_t)&g1; // 0x7cb3
    v14 += (int64_t)&g1;
    v15 = v18 & 0xffffffff;
    while ((int32_t)v18 != (int32_t)&g94) {
        // 0x7c87
        v16 = 0x1000000 * (int32_t)v15 / 0x1000000;
        v17 = *(char *)v14;
        TunerRegWrite2(a1, v1, (int64_t *)&v16, (int64_t *)&g25, 0);
        v18 = v15 + (int64_t)(int32_t)&g1;
        v14 += (int64_t)&g1;
        v15 = v18 & 0xffffffff;
    }
    char v19 = v8 < 0x2eb120 ? v6 : v6 | (char)&g95;
    v16 = (char)&g103;
    TunerRegWrite2(a1, v1, (int64_t *)&v16, (int64_t *)&g25, 0);
    TunerRegWrite2(a1, v1, (int64_t *)&v16, (int64_t *)&g25, 0);
    TLIB_Delay2((int64_t *)&g1);
    v17 = 0;
    TunerRegWrite2(a1, v1, (int64_t *)&v16, (int64_t *)&g25, 0);
    TunerRegRead2(a1, v1, (int64_t *)&g103, (int64_t *)&v17, (int64_t *)&g1, 0);
    unsigned char v20 = v17 % 64;
    if (v8 < 0x2eb120 || (char)&g1 == 0) {
        if (v20 < (char)&g1 || v20 == 1) {
            // 0x7e19
            v16 = &g91;
            v17 = v19 | (char)&g95 | -128;
            TunerRegWrite2(a1, v1, (int64_t *)&v16, (int64_t *)&g25, 0);
            v16 = (char)&g103;
            v17 = -128;
            TunerRegWrite2(a1, v1, (int64_t *)&v16, (int64_t *)&g25, 0);
            v17 = 0;
            TunerRegWrite2(a1, v1, (int64_t *)&v16, (int64_t *)&g25, 0);
            TLIB_Delay2((int64_t *)&g1);
        }
    } else {
        if (v20 >= 61) {
            // 0x7d82
            v16 = &g91;
            v17 = v19 & 119 | -128;
            TunerRegWrite2(a1, v1, (int64_t *)&v16, (int64_t *)&g25, 0);
            v16 = (char)&g103;
            v17 = -128;
            TunerRegWrite2(a1, v1, (int64_t *)&v16, (int64_t *)&g25, 0);
            v17 = 0;
            TunerRegWrite2(a1, v1, (int64_t *)&v16, (int64_t *)&g25, 0);
            TLIB_Delay2((int64_t *)&g1);
        }
    }
    int64_t result = DemodRegRead2(a1, v1, (int64_t)&g23, (int64_t)&v16, (int64_t *)&g1, NULL); // 0x7ebe
    if (a3 >= 0x3fb88) {
        // 0x7f04
        return result;
    }
    // 0x7ed0
    v16 = 0x1000000 * (v16 & 207 | (int32_t)(char)&g26) / 0x1000000;
    int64_t v21 = DemodRegWrite2(a1, v1, (int64_t)&g23, (int64_t *)&v16, (int64_t *)&g1, 0); // 0x7ef8
    return v21 & -256 | (int64_t)((char)v21 != 0);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x7f27 - 0x7f57
// Line range:    593 - 641
char Adpater_SetFreqISDBS(char * hTuner, char DevCH, int64_t freq, char ucRs) {
    // 0x7f27
    int64_t v1; // 0x7f27
    int32_t * v2 = (int32_t *)(v1 - 0x143f6af1 + v1 * (int64_t)&g95); // 0x7f27
    *v2 = *v2 + (int32_t)&g1;
    int64_t v3 = v1 + 184; // 0x7f2e
    char * v4 = (char *)((v3 & 0xffffffff) - 117); // 0x7f33
    unsigned char v5 = *v4; // 0x7f33
    unsigned char v6 = v5 + ucRs; // 0x7f33
    *v4 = v6;
    int64_t v7 = (v1 + 221 + (int64_t)(v6 < v5)) % 256 | v3 & 0xffffff00; // 0x7f3b
    int64_t result = v7; // 0x7f41
    if (*(char *)v7 != 0) {
        // 0x7f43
        result = __stack_chk_fail();
    }
    // 0x7f48
    return result;
}

// Address range: 0x7f57 - 0x811d
int64_t Adpater_SetFreqISDBS2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x7f57
    mcount();
    __readgsqword(40);
    int64_t result = 0; // 0x7f84
    int64_t v1 = &g1; // 0x7f84
    int64_t v2 = 0; // 0x7f84
    if ((int64_t)(uint32_t)g55 != a3) {
        v2 = v1;
        while ((int64_t)*(int32_t *)result != a3) {
            int64_t v3 = v1 + (int64_t)(int32_t)&g1; // 0x7f99
            result += (int64_t)"GNU";
            v1 = v3 & 0xffffffff;
            if ((int32_t)v3 == (int32_t)&g13) {
                // 0x7fa5
                return result;
            }
            v2 = v1;
        }
    }
    // 0x7faf
    int64_t v4; // bp-67, 0x7f57
    int64_t v5; // bp-71, 0x7f57
    int64_t v6; // bp-72, 0x7f57
    if (a3 != 0xb2f278 != a3 != 0xc24278) {
        if ((char)a2 == 0) {
            // 0x7fc6
            v6 = -64;
            int64_t v7 = &v5; // 0x7fe1
            int64_t v8 = 0x100000000 * v2 / 0x100000000 * ((int64_t)&g25 + 1) * (int64_t)&g86; // 0x7fe1
            *(char *)v7 = *(char *)v8;
            v7 += (int64_t)&g1;
            v8 += (int64_t)&g1;
            while (v7 != (int64_t)&v4) {
                // 0x7fe5
                *(char *)v7 = *(char *)v8;
                v7 += (int64_t)&g1;
                v8 += (int64_t)&g1;
            }
            int64_t v9 = TunerRegWrite2(a1, 0, &v6, (int64_t *)&g89, (int64_t)&g1); // 0x800e
            return v9 & -256 | (int64_t)((char)v9 != 0);
        }
    }
    // 0x801d
    v6 = -64;
    int64_t v10 = 0x100000000 * v2 / 0x100000000; // 0x8021
    int64_t v11 = v10 * ((int64_t)&g25 + 1) * (int64_t)&g86; // 0x8028
    int64_t v12 = &v5; // 0x8038
    int64_t v13 = v11; // 0x8038
    *(char *)v12 = *(char *)v13;
    v12 += (int64_t)&g1;
    v13 += (int64_t)&g1;
    while (v12 != (int64_t)&v4) {
        // 0x803c
        *(char *)v12 = *(char *)v13;
        v12 += (int64_t)&g1;
        v13 += (int64_t)&g1;
    }
    uint64_t v14 = a2 % 256; // 0x804e
    TunerRegWrite2(a1, v14, &v6, (int64_t *)&g89, (int64_t)&g1);
    char v15 = *(char *)((v10 + (int64_t)&g1 + v10 * (int64_t)&g25) * (int64_t)&g86); // 0x807c
    v5 = v15;
    TunerRegWrite2(a1, v14, &v6, (int64_t *)&g25, (int64_t)&g1);
    TLIB_Delay2((int64_t *)&g98);
    char v16 = *(char *)(v10 * ((int64_t)&g1 + 1 + (int64_t)&g1) * (int64_t)&g86); // 0x80be
    v5 = v16;
    TunerRegWrite2(a1, v14, &v6, (int64_t *)&g33, (int64_t)&g1);
    return (int64_t)*(char *)v11;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x811d - 0x814d
// Line range:    556 - 591
char Adpater_SetFreqISDBS_1(char * hTuner, char DevCH, int64_t freq, char ucRs) {
    // 0x811d
    int64_t v1; // 0x811d
    int64_t result = (char)TunerRegWrite2((int64_t)hTuner, (int64_t)DevCH, (int64_t *)freq, (int64_t *)(int64_t)ucRs, v1) != 0; // 0x813b
    int64_t v2; // 0x811d
    if (*(int64_t *)(v2 - 40) != __readgsqword(40)) {
        // 0x813d
        result = __stack_chk_fail();
    }
    // 0x8142
    return result;
}

// Address range: 0x814d - 0x82a5
int64_t Adpater_SetFreqISDBS_1_(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x814d
    mcount();
    __readgsqword(40);
    int64_t result = 0; // 0x817a
    int64_t v1 = &g1; // 0x817a
    int64_t v2 = 0; // 0x817a
    if ((int64_t)(uint32_t)g56 != a3) {
        v2 = v1;
        while ((int64_t)*(int32_t *)result != a3) {
            int64_t v3 = v1 + (int64_t)(int32_t)&g1; // 0x818f
            result += (int64_t)"GNU";
            v1 = v3 & 0xffffffff;
            if ((int32_t)v3 == (int32_t)&g13) {
                // 0x819b
                return result;
            }
            v2 = v1;
        }
    }
    int64_t v4 = -64; // bp-72, 0x81a5
    int64_t v5 = 0x100000000 * v2 / 0x100000000; // 0x81a9
    int64_t v6 = v5 * ((int64_t)&g25 + 1) * (int64_t)&g86; // 0x81b0
    int64_t v7; // bp-71, 0x814d
    int64_t v8 = &v7; // 0x81c0
    int64_t v9 = v6; // 0x81c0
    *(char *)v8 = *(char *)v9;
    v8 += (int64_t)&g1;
    v9 += (int64_t)&g1;
    int64_t v10; // bp-67, 0x814d
    while (v8 != (int64_t)&v10) {
        // 0x81c4
        *(char *)v8 = *(char *)v9;
        v8 += (int64_t)&g1;
        v9 += (int64_t)&g1;
    }
    uint64_t v11 = a2 % 256; // 0x81d6
    TunerRegWrite2(a1, v11, &v4, (int64_t *)&g89, (int64_t)&g1);
    char v12 = *(char *)((v5 + (int64_t)&g1 + v5 * (int64_t)&g25) * (int64_t)&g86); // 0x8204
    v7 = v12;
    TunerRegWrite2(a1, v11, &v4, (int64_t *)&g25, (int64_t)&g1);
    TLIB_Delay2((int64_t *)100);
    char v13 = *(char *)(v5 * ((int64_t)&g1 + 1 + (int64_t)&g1) * (int64_t)&g86); // 0x8246
    v7 = v13;
    TunerRegWrite2(a1, v11, &v4, (int64_t *)&g33, (int64_t)&g1);
    return (int64_t)*(char *)v6;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x82a5 - 0x82d5
// Line range:    1479 - 1535
char TC_Initialise(char * DevExt, char DevCH, char * FLAG, char * tuner_globe_data) {
    // 0x82a5
    int64_t v1; // 0x82a5
    int64_t result = (char)TunerRegWrite2((int64_t)DevExt, (int64_t)DevCH, (int64_t *)FLAG, (int64_t *)tuner_globe_data, v1) != 0; // 0x82c3
    int64_t v2; // 0x82a5
    if (*(int64_t *)(v2 - 40) != __readgsqword(40)) {
        // 0x82c5
        result = __stack_chk_fail();
    }
    // 0x82ca
    return result;
}

// Address range: 0x82d5 - 0x8334
int64_t TC_Initialise2(int64_t a1, int64_t a2, char * a3, int64_t a4) {
    // 0x82d5
    mcount();
    return (uint32_t)((int32_t)((int64_t)&g1 & -256) << (uint32_t)(int32_t)&g86);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x8337 - 0x8367
// Line range:    1310 - 1359
char TC_IsLocked(char * DevExt, char DevCH, char * tuner_globe_data) {
    // 0x8337
    int64_t v1; // 0x8337
    *(int32_t *)v1 = 2 * (int32_t)v1;
    if ((char)v1 == 0) {
        // 0x835e
        return 0;
    }
    char result = 0; // 0x834b
    int64_t v2; // 0x8337
    if ((char)TC_RemappingTunerNumber2(v2) != 0) {
        // 0x834d
        int64_t v3; // 0x8337
        *(char *)v3 = -23;
        result = &g1;
    }
    // 0x835e
    return result;
}

// Address range: 0x8367 - 0x8378
int64_t TC_IsLocked2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x8367
    return mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x837b - 0x83ab
// Line range:    3056 - 3078
int64_t TC_GetCNRegister(char * DevExt, char DevCH, char * tuner_globe_data) {
    int64_t result = 0; // 0x838e
    if ((char)TC_RemappingTunerNumber2((int64_t)DevExt) != 0) {
        // 0x8390
        int64_t v1; // 0x837b
        int64_t v2 = v1 - 17; // 0x8390
        int64_t v3; // 0x837b
        Japan4x4Tuner_TunerCheckLockStatus2(*(char *)(v1 - 36), v2, v3);
        result = (int64_t)*(char *)v2;
    }
    // 0x83a4
    return result;
}

// Address range: 0x83ab - 0x83f2
int64_t TC_GetCNRegister2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x83ab
    mcount();
    return TC_IsLocked2(a1, a2 % 256, a3);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x83f6 - 0x8426
// Line range:    3028 - 3054
int64_t TC_GetCN(char * DevExt, char DevCH, char * tuner_globe_data) {
    // 0x83f6
    int64_t result; // 0x83f6
    return result;
}

// Address range: 0x83f7 - 0x83f9
int64_t function_83f7(void) {
    // 0x83f7
    int64_t result; // 0x83f7
    return result;
}

// Address range: 0x8426 - 0x845c
int64_t TC_GetCN2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x8426
    mcount();
    return TC_IsLocked2(a1, a2 % 256, a3);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x845d - 0x848d
// Line range:    1843 - 2356
int32_t Fiti_LAN_Gain(char * DevExt, char * StartPolling, char total_tuner_num, char * tuner_globe_data) {
    int32_t result = 0; // 0x8466
    int64_t v1; // 0x845d
    if ((char)TC_RemappingTunerNumber2(v1 & 0xffffffff) != 0) {
        // 0x8468
        int64_t v2; // 0x845d
        int64_t v3 = v2 - 24; // 0x8468
        int64_t v4; // 0x845d
        Japan4x4Tuner_TunerGetCN2(*(char *)(v2 - 36), v3, v4);
        result = (int32_t)*(int64_t *)v3;
    }
    // 0x8483
    return result;
}

// Address range: 0x848d - 0x937a
int64_t Fiti_LAN_Gain2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x848d
    mcount();
    int64_t v1; // 0x848d
    int64_t v2; // 0x848d
    int64_t v3; // 0x848d
    int64_t v4; // 0x848d
    int64_t v5; // bp-100, 0x848d
    int32_t v6; // 0x848d
    int32_t v7; // 0x848d
    int32_t v8; // 0x848d
    int32_t v9; // 0x848d
    char v10; // 0x848d
    char v11; // 0x848d
    int64_t v12; // 0x848d
    int64_t v13; // 0x848d
    char v14; // bp-86, 0x848d
    char * v15; // 0x87ad
    int64_t v16; // 0x87b2
    char * v17; // 0x87b2
    char * v18; // 0x883a
    int64_t v19; // 0x87a7
    if (*(int64_t *)(a4 + 168) != 0) {
        // 0x870e
        int32_t v20; // bp-57, 0x848d
        TLIB_I2C_Read2(a1, 74, (int64_t)&g99, (int64_t *)&v20, (int64_t *)&g1, 0);
        v20 = 0x1000000 * (v20 & (int32_t)(char)&g1) / 0x1000000;
        int32_t v21 = a2; // 0x876c
        v6 = v21;
        v12 = a4;
        int64_t v22; // bp-70, 0x848d
        v8 = &v22;
        int64_t v23; // bp-124, 0x848d
        v10 = &v23;
        v1 = &v5;
        v3 = &v14;
        while (true) {
          lab_0x878b:
            // 0x878b
            v4 = v3;
            v2 = v1;
            v11 = v10;
            v9 = v8;
            v13 = v12;
            v7 = v6;
            char v24 = *(char *)((int64_t)v7 + (int64_t)&g25); // 0x8792
            if (v24 != 0) {
                // 0x87a1
                v19 = (int32_t)&g25 - v21 + v7;
                v15 = (char *)v2;
                *v15 = (char)&g4;
                v16 = v2 + (int64_t)&g1;
                v17 = (char *)v16;
                *v17 = 0;
                TunerRegWrite2(a1, v19, (int64_t *)v2, (int64_t *)&g25, 0);
                int64_t v25 = v9; // 0x87ee
                TunerRegRead2(a1, v19, (int64_t *)&g4, (int64_t *)v25, (int64_t *)&g1, 0);
                TunerRegRead2(a1, v19, (int64_t *)&g5, (int64_t *)v4, (int64_t *)&g1, 0);
                v18 = (char *)v4;
                *v18 = *v18 & (char)&g24;
                TunerRegRead2(a1, v19, (int64_t *)"NU", (int64_t *)v16, (int64_t *)&g1, 0);
                if ((*v17 & (char)&g2) == 0) {
                    // 0x887a
                    *v15 = (char)&g2;
                    *v17 = 0;
                    TunerRegWrite2(a1, v19, (int64_t *)(0x100000000 * v2 / 0x100000000), (int64_t *)&g25, 0);
                }
                // 0x88ac
                TunerRegRead2(a1, v19, (int64_t *)&g2, (int64_t *)(int64_t)v11, (int64_t *)&g1, 0);
                unsigned char v26 = *(char *)v25; // 0x88e1
                char v27 = *(char *)(int64_t)(v26 >> (char)&g89); // 0x88f1
                uint64_t v28 = (int64_t)(2 * (v26 & (char)&g24) + v27); // 0x88f1
                unsigned char v29 = *v18; // 0x88f9
                char * v30; // bp-58, 0x848d
                if (v29 == (char)&g98) {
                    // 0x8c67
                    *(int64_t *)(v13 + 184) = (int64_t)"NU";
                    uint32_t v31 = (char)v20 != 0 ? g66 : g60;
                    if ((int64_t)v31 < v28) {
                        // 0x8ca4
                        TunerRegRead2(a1, v19, (int64_t *)"NU", (int64_t *)(0x100000000 * v16 / 0x100000000), (int64_t *)&g1, 0);
                        *v15 = (char)"NU";
                        *v17 = *v17 & -17;
                        int64_t * v32 = (int64_t *)(0x100000000 * v2 / 0x100000000); // 0x8cf7
                        TunerRegWrite2(a1, v19, v32, (int64_t *)&g25, 0);
                        *v15 = (char)&g5;
                        *v17 = (char)&g7;
                        TunerRegWrite2(a1, v19, v32, (int64_t *)&g25, 0);
                        *v18 = (char)&g7;
                    } else {
                        uint32_t v33 = (char)v20 != 0 ? g67 : g61;
                        if ((int64_t)v33 > v28) {
                            int64_t * v34 = (int64_t *)(0x100000000 * v16 / 0x100000000); // 0x8d68
                            TunerRegRead2(a1, v19, (int64_t *)"NU", v34, (int64_t *)&g1, 0);
                            *v15 = (char)"NU";
                            *v17 = *v17 & -17;
                            int64_t * v35 = (int64_t *)(0x100000000 * v2 / 0x100000000); // 0x8d9a
                            TunerRegWrite2(a1, v19, v35, (int64_t *)&g25, 0);
                            *v15 = (char)&g2;
                            *v17 = 0;
                            TunerRegWrite2(a1, v19, v35, (int64_t *)&g25, 0);
                            TunerRegRead2(a1, v19, (int64_t *)&g2, (int64_t *)&v30, (int64_t *)&g1, 0);
                            v30 = (char *)(0x100000000000000 * ((int64_t)v30 - (int64_t)(char)&g33) / 0x100000000000000);
                            TunerRegRead2(a1, v19, (int64_t *)"NU", v34, (int64_t *)&g1, 0);
                            *v15 = (char)"NU";
                            *v17 = *v17 | (char)&g2;
                            TunerRegWrite2(a1, v19, v35, (int64_t *)&g25, 0);
                            *v15 = (char)&g2;
                            *v17 = (char)(int64_t)v30;
                            TunerRegWrite2(a1, v19, v35, (int64_t *)&g25, 0);
                            *v15 = (char)&g5;
                            *v17 = (char)&g25;
                            TunerRegWrite2(a1, v19, v35, (int64_t *)&g25, 0);
                            *v18 = (char)&g25;
                        }
                    }
                    goto lab_0x912d;
                } else {
                    if (v29 > (char)&g98) {
                        if (v29 == (char)&g2) {
                            // 0x892b
                            *(int64_t *)(v13 + 184) = (int64_t)&g12;
                            uint32_t v36 = (char)v20 != 0 ? g63 : g57; // 0x8947
                            if (v28 < (int64_t)v36) {
                                // 0x8959
                                TunerRegRead2(a1, v19, (int64_t *)"NU", (int64_t *)(0x100000000 * v16 / 0x100000000), (int64_t *)&g1, 0);
                                *v15 = (char)"NU";
                                *v17 = *v17 & -17;
                                int64_t * v37 = (int64_t *)(0x100000000 * v2 / 0x100000000); // 0x89ac
                                TunerRegWrite2(a1, v19, v37, (int64_t *)&g25, 0);
                                *v15 = (char)&g5;
                                *v17 = (char)&g7;
                                TunerRegWrite2(a1, v19, v37, (int64_t *)&g25, 0);
                                *v18 = (char)&g7;
                            }
                            goto lab_0x912d;
                        } else {
                            if (v29 != (char)&g7) {
                                goto lab_0x9097;
                            } else {
                                // 0x89f4
                                *(int64_t *)(v13 + 184) = (int64_t)&g5;
                                uint32_t v38 = (char)v20 != 0 ? g64 : g58;
                                if ((int64_t)v38 < v28) {
                                    // 0x8a31
                                    TunerRegRead2(a1, v19, (int64_t *)"NU", (int64_t *)(0x100000000 * v16 / 0x100000000), (int64_t *)&g1, 0);
                                    *v15 = (char)"NU";
                                    *v17 = *v17 & -17;
                                    int64_t * v39 = (int64_t *)(0x100000000 * v2 / 0x100000000); // 0x8a84
                                    TunerRegWrite2(a1, v19, v39, (int64_t *)&g25, 0);
                                    *v15 = (char)&g5;
                                    *v17 = (char)&g2;
                                    TunerRegWrite2(a1, v19, v39, (int64_t *)&g25, 0);
                                    *v18 = (char)&g2;
                                } else {
                                    uint32_t v40 = (char)v20 != 0 ? g65 : g59;
                                    if ((int64_t)v40 > v28) {
                                        int64_t * v41 = (int64_t *)(0x100000000 * v16 / 0x100000000); // 0x8af7
                                        TunerRegRead2(a1, v19, (int64_t *)"NU", v41, (int64_t *)&g1, 0);
                                        *v15 = (char)"NU";
                                        *v17 = *v17 & -17;
                                        int64_t * v42 = (int64_t *)(0x100000000 * v2 / 0x100000000); // 0x8b29
                                        TunerRegWrite2(a1, v19, v42, (int64_t *)&g25, 0);
                                        *v15 = (char)&g2;
                                        *v17 = 0;
                                        TunerRegWrite2(a1, v19, v42, (int64_t *)&g25, 0);
                                        TunerRegRead2(a1, v19, (int64_t *)&g2, (int64_t *)&v30, (int64_t *)&g1, 0);
                                        v30 = (char *)(0x100000000000000 * ((int64_t)v30 - (int64_t)(char)&g33) / 0x100000000000000);
                                        TunerRegRead2(a1, v19, (int64_t *)"NU", v41, (int64_t *)&g1, 0);
                                        *v15 = (char)"NU";
                                        *v17 = *v17 | (char)&g2;
                                        TunerRegWrite2(a1, v19, v42, (int64_t *)&g25, 0);
                                        *v15 = (char)&g2;
                                        *v17 = (char)(int64_t)v30;
                                        TunerRegWrite2(a1, v19, v42, (int64_t *)&g25, 0);
                                        *v15 = (char)&g5;
                                        *v17 = (char)&g98;
                                        TunerRegWrite2(a1, v19, v42, (int64_t *)&g25, 0);
                                        *v18 = (char)&g98;
                                    }
                                }
                                goto lab_0x912d;
                            }
                        }
                    } else {
                        if (v29 != (char)&g25) {
                            goto lab_0x9097;
                        } else {
                            // 0x8ed8
                            *(int64_t *)(v13 + 184) = 0;
                            uint32_t v43 = (char)v20 != 0 ? g68 : g62; // 0x8ef4
                            if (v28 > (int64_t)v43) {
                                int64_t * v44 = (int64_t *)(0x100000000 * v16 / 0x100000000); // 0x8f27
                                TunerRegRead2(a1, v19, (int64_t *)"NU", v44, (int64_t *)&g1, 0);
                                *v15 = (char)"NU";
                                *v17 = *v17 & -17;
                                int64_t * v45 = (int64_t *)(0x100000000 * v2 / 0x100000000); // 0x8f59
                                TunerRegWrite2(a1, v19, v45, (int64_t *)&g25, 0);
                                *v15 = (char)&g2;
                                *v17 = 0;
                                TunerRegWrite2(a1, v19, v45, (int64_t *)&g25, 0);
                                TunerRegRead2(a1, v19, (int64_t *)&g2, (int64_t *)&v30, (int64_t *)&g1, 0);
                                v30 = (char *)(0x100000000000000 * ((int64_t)v30 - (int64_t)(char)&g33) / 0x100000000000000);
                                TunerRegRead2(a1, v19, (int64_t *)"NU", v44, (int64_t *)&g1, 0);
                                *v15 = (char)"NU";
                                *v17 = *v17 | (char)&g2;
                                TunerRegWrite2(a1, v19, v45, (int64_t *)&g25, 0);
                                *v15 = (char)&g2;
                                *v17 = (char)(int64_t)v30;
                                TunerRegWrite2(a1, v19, v45, (int64_t *)&g25, 0);
                                *v15 = (char)&g5;
                                *v17 = (char)&g98;
                                TunerRegWrite2(a1, v19, v45, (int64_t *)&g25, 0);
                                *v18 = (char)&g98;
                            }
                            goto lab_0x912d;
                        }
                    }
                }
            } else {
                // 0x8798
                *(char *)v4 = (char)&g2;
                goto lab_0x912d;
            }
        }
      lab_0x9162:;
        unsigned char result = *(char *)(a2 + (int64_t)&g25); // 0x916c
        char v46; // 0x848d
        if (result != (char)&g1) {
            if (v46 != (char)&g2) {
                // 0x92a0
                TLIB_SetGPIO_ASIE5606B5_(a1, NULL, (int64_t *)&g1);
                *(int64_t *)(a4 + 176) = 0;
                return &g1;
            }
            int64_t v47 = TC_IsLocked2(a1, (int64_t)&g33, a4); // 0x9245
            if ((char)v47 != (char)&g1) {
                // 0x9277
                TLIB_SetGPIO_ASIE5606B5_(a1, NULL, (int64_t *)&g1);
                *(int64_t *)(a4 + 176) = 0;
                return &g1;
            }
            // 0x924e
            TLIB_SetGPIO_ASIE5606B5_(a1, (int64_t *)&g1, (int64_t *)&g1);
            *(int64_t *)(a4 + 176) = (int64_t)&g1;
            return &g1;
        }
        // 0x9179
        if (*(char *)(a2 + (int64_t)&g33) == 0) {
            if (v14 != (char)&g2) {
                // 0x91f4
                TLIB_SetGPIO_ASIE5606B5_(a1, NULL, (int64_t *)&g1);
                *(int64_t *)(a4 + 176) = 0;
                return &g1;
            }
            int64_t v48 = TC_IsLocked2(a1, (int64_t)&g25, a4); // 0x9199
            if ((char)v48 != (char)&g1) {
                // 0x91cb
                TLIB_SetGPIO_ASIE5606B5_(a1, NULL, (int64_t *)&g1);
                *(int64_t *)(a4 + 176) = 0;
                return &g1;
            }
            // 0x91a2
            TLIB_SetGPIO_ASIE5606B5_(a1, (int64_t *)&g1, (int64_t *)&g1);
            *(int64_t *)(a4 + 176) = (int64_t)&g1;
            return &g1;
        }
        // 0x92c9
        if (v46 == (char)&g2 != (v14 == (char)&g2)) {
            // 0x8709
            return result;
        }
        int64_t v49 = TC_IsLocked2(a1, (int64_t)&g25, a4); // 0x92f7
        int64_t v50 = TC_IsLocked2(a1, (int64_t)&g33, a4); // 0x930e
        if ((char)v49 == (char)&g1) {
            // 0x931d
            TLIB_SetGPIO_ASIE5606B5_(a1, (int64_t *)&g1, (int64_t *)&g1);
            *(int64_t *)(a4 + 176) = (int64_t)&g1;
            return &g1;
        }
        if ((char)v50 != (char)&g1) {
            // 0x9343
            TLIB_SetGPIO_ASIE5606B5_(a1, NULL, (int64_t *)&g1);
            *(int64_t *)(a4 + 176) = 0;
            return &g1;
        }
        // 0x931d
        TLIB_SetGPIO_ASIE5606B5_(a1, (int64_t *)&g1, (int64_t *)&g1);
        *(int64_t *)(a4 + 176) = (int64_t)&g1;
        return &g1;
    }
    // 0x861f
    if (*(int64_t *)(a4 + 176) != 0) {
        // 0x8638
        TLIB_SetGPIO_ASIE5606B5_(a1, (int64_t *)&g1, (int64_t *)&g1);
    } else {
        // 0x8627
        TLIB_SetGPIO_ASIE5606B5_(a1, NULL, (int64_t *)&g1);
    }
    // 0x864e
    int64_t v51; // bp-8, 0x848d
    int64_t v52 = &v51; // 0x848e
    int64_t v53 = (int64_t)(int32_t)&g25 - a2; // 0x8668
    int64_t v54 = v52 - 175;
    int64_t v55 = v52 - 176;
    int64_t v56 = &v14;
    int64_t v57 = &v5;
    int64_t v58 = a4;
    int64_t * v59 = (int64_t *)(v58 + 184); // 0x8670
    if (*v59 >= 24) {
        // 0x867a
        *v59 = (int64_t)&g12;
    }
    int64_t v60 = a2; // 0x868b
    int64_t v61; // 0x8699
    char v62; // 0x8699
    char v63; // 0x86a1
    int64_t v64; // 0x86de
    char v65; // 0x86e6
    if (*(char *)(a2 + (int64_t)&g25) != 0) {
        // 0x868d
        *(char *)v57 = (char)&g5;
        v61 = 2 * *v59;
        v62 = *(char *)(v61 + v54);
        v63 = *(char *)(v61 + v55);
        *(char *)(v57 + (int64_t)&g1) = v63 | v62;
        TunerRegWrite2(a1, v53 + a2 & 0xffffffff, (int64_t *)v57, (int64_t *)&g25, 0);
        v60 = *v59;
        v64 = 2 * v60;
        v65 = *(char *)(v64 + v55);
        *(char *)v56 = v65 | *(char *)(v64 + v54);
    }
    int64_t result2 = v60;
    int64_t v66 = v58 + 80; // 0x8703
    int64_t v67 = a2 + (int64_t)&g1; // 0x8703
    int64_t v68 = v57 + (int64_t)&g25; // 0x8703
    int64_t v69 = v56 + (int64_t)&g1; // 0x8703
    while (v58 != a4 + 80) {
        // 0x8670
        v56 = v69;
        v57 = v68;
        int64_t v70 = v67;
        v58 = v66;
        v59 = (int64_t *)(v58 + 184);
        if (*v59 >= 24) {
            // 0x867a
            *v59 = (int64_t)&g12;
        }
        // 0x8685
        v60 = result2;
        if (*(char *)(v70 + (int64_t)&g25) != 0) {
            // 0x868d
            *(char *)v57 = (char)&g5;
            v61 = 2 * *v59;
            v62 = *(char *)(v61 + v54);
            v63 = *(char *)(v61 + v55);
            *(char *)(v57 + (int64_t)&g1) = v63 | v62;
            TunerRegWrite2(a1, v53 + v70 & 0xffffffff, (int64_t *)v57, (int64_t *)&g25, 0);
            v60 = *v59;
            v64 = 2 * v60;
            v65 = *(char *)(v64 + v55);
            *(char *)v56 = v65 | *(char *)(v64 + v54);
        }
        // 0x86f0
        result2 = v60;
        v66 = v58 + 80;
        v67 = v70 + (int64_t)&g1;
        v68 = v57 + (int64_t)&g25;
        v69 = v56 + (int64_t)&g1;
    }
    // 0x8709
    return result2;
  lab_0x912d:;
    int64_t v71 = v4 + (int64_t)&g1; // 0x9135
    v6 = v7 + (int32_t)&g1;
    v12 = v13 + 80;
    v8 = v9 + (int32_t)&g1;
    v10 = v11 + (char)&g91;
    v1 = v2 + (int64_t)&g25;
    v3 = v71;
    int64_t v72; // bp-84, 0x848d
    if (v71 == (int64_t)&v72) {
        // break -> 0x9162
        goto lab_0x9162;
    }
    goto lab_0x878b;
  lab_0x9097:
    // 0x9097
    TunerRegRead2(a1, v19, (int64_t *)"NU", (int64_t *)(0x100000000 * v16 / 0x100000000), (int64_t *)&g1, 0);
    *v15 = (char)"NU";
    *v17 = *v17 & -17;
    int64_t * v73 = (int64_t *)(0x100000000 * v2 / 0x100000000); // 0x90ea
    TunerRegWrite2(a1, v19, v73, (int64_t *)&g25, 0);
    *v15 = (char)&g5;
    *v17 = (char)&g2;
    TunerRegWrite2(a1, v19, v73, (int64_t *)&g25, 0);
    *v18 = (char)&g2;
    goto lab_0x912d;
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x937d - 0x93ad
// Line range:    1817 - 1838
int64_t TC_GetSignaLevel(char * DevExt, char DevCH, char * tuner_globe_data) {
    // 0x937d
    int64_t result; // 0x937d
    return result;
}

// Address range: 0x93ad - 0x93dd
int64_t TC_GetSignaLevel2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x93ad
    mcount();
    return TC_IsLocked2(a1, a2 % 256, a3);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x93de - 0x940e
// Line range:    1783 - 1803
char TC_ReadSNR(char * DevExt, char DevCH, char * tuner_globe_data) {
    char result = 0; // 0x93e7
    int64_t v1; // 0x93de
    if ((char)TC_RemappingTunerNumber2(v1 & 0xffffffff) != 0) {
        // 0x93e9
        int64_t v2; // 0x93de
        int64_t v3 = v2 - 17; // 0x93e9
        int64_t v4; // 0x93de
        Japan4x4Tuner_TunerGetQuality2(*(char *)(v2 - 36), v3, v4);
        result = *(char *)v3;
    }
    // 0x9404
    return result;
}

// Address range: 0x940e - 0x943e
int64_t TC_ReadSNR2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x940e
    mcount();
    return TC_IsLocked2(a1, a2 % 256, a3);
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x943f - 0x946f
// Line range:    1145 - 1180
char TC_TSIDWrite(char * DevExt, char DevCH, int32_t tsid, char bPreset, char * tuner_globe_data) {
    char result = 0; // 0x9448
    int64_t v1; // 0x943f
    if ((char)TC_RemappingTunerNumber2(v1 & 0xffffffff) != 0) {
        // 0x944a
        int64_t v2; // 0x943f
        int64_t v3 = v2 - 17; // 0x944a
        int64_t v4; // 0x943f
        Japan4x4Tuner_TunerGetStrength2(*(char *)(v2 - 36), v3, v4);
        result = *(char *)v3;
    }
    // 0x9465
    return result;
}

// Address range: 0x946f - 0x9489
int64_t TC_TSIDWrite2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x946f
    return mcount();
}

// From module:   /root/asv5220\TunerControl.c
// Address range: 0x948a - 0x94ba
// Line range:    1123 - 1143
char TC_TSIDRead(char * DevExt, char DevCH, int32_t * tsidList, char listLength, char * tuner_globe_data) {
    // 0x948a
    int64_t v1; // 0x948a
    char * v2 = (char *)(v1 - 20); // 0x948a
    *v2 = (char)((int64_t)tsidList >> (int64_t)&g95);
    char result = 0; // 0x949f
    if ((char)TC_RemappingTunerNumber2((int64_t)DevExt) != 0) {
        // 0x94a1
        int64_t v3; // 0x948a
        uint64_t v4; // 0x948a
        result = Japan4x4Tuner_TunerSetTSID2(*v2, v4 % 0x10000, v3);
    }
    // 0x94b0
    return result;
}

// Address range: 0x94ba - 0x950e
int64_t TC_TSIDRead2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x94ba
    mcount();
    TC_RemappingTunerNumber2(a1);
    int64_t v1; // bp-56, 0x94ba
    return Japan4x4Tuner_TunerGetTSID2((char)a2, &v1, a5);
}

// From module:   /root/asv5220\smiI2cCtl.c
// Address range: 0x9510 - 0x9539
// Line range:    208 - 253
int64_t cfg_read(int64_t pFdoData, int16_t regAddr, int64_t length, char * readData) {
    // 0x9510
    int64_t v1; // 0x9510
    *(char *)v1 = 2 * (char)v1;
    int64_t result; // 0x9510
    int64_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0x9540 - 0x9589
int64_t cfg_read2(int64_t a1, uint64_t a2, int64_t a3, int64_t * a4) {
    // 0x9540
    mcount();
    uint32_t v1 = *(int32_t *)(*(int64_t *)(a1 + 0x57f8) + a2 % 0x10000); // 0x9570
    *(char *)a4 = (char)v1;
    *(char *)((int64_t)a4 + (int64_t)&g1) = (char)(v1 / 256);
    return 0;
}

// From module:   /root/asv5220\smiI2cCtl.c
// Address range: 0x958a - 0x95ba
// Line range:    256 - 302
int64_t cfg_write(int64_t pFdoData, int16_t regAddr, int64_t length, char * writeData) {
    // 0x958a
    int64_t v1; // 0x958a
    int64_t v2 = v1 + (int64_t)writeData;
    int64_t v3; // 0x958a
    *(char *)(v2 + (int64_t)&g25) = (char)v3;
    uint64_t v4; // 0x958a
    *(char *)(v2 + (int64_t)&g33) = (char)(v4 >> (int64_t)&g13);
    return &g1;
}

// Address range: 0x95ba - 0x9609
int64_t cfg_write2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4) {
    // 0x95ba
    mcount();
    return 0;
}

// From module:   /root/asv5220\smiI2cCtl.c
// Address range: 0x9609 - 0x9639
// Line range:    1526 - 1544
void i2c_soft_reset_2(int64_t pFdoData) {
    int64_t v1 = *(int64_t *)(pFdoData + 0x57f8); // 0x9610
    int64_t v2; // 0x9609
    int64_t v3; // 0x9609
    int64_t v4; // 0x9609
    *(int32_t *)(v1 + (v4 & 0xffffffff)) = (int32_t)(v3 * (int64_t)&g1 + v2);
}

// Address range: 0x9639 - 0x965d
int64_t i2c_soft_reset_2_(int64_t a1) {
    // 0x9639
    mcount();
    int32_t v1 = *(int32_t *)(*(int64_t *)(a1 + 0x6250) + *(int64_t *)(a1 + 0x57f8)); // 0x9658
    return v1 | 32;
}

// From module:   /root/asv5220\smiI2cCtl.c
// Address range: 0x9663 - 0x9668
// Line range:    1499 - 1523
void i2c_soft_reset(int64_t pFdoData) {
    // 0x9663
    int64_t v1; // 0x9663
    char * v2 = (char *)(v1 + (int64_t)&g33); // 0x9663
    int64_t v3; // 0x9663
    *v2 = *v2 + (char)v3;
}

// Address range: 0x9669 - 0x9693
int64_t function_9669(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x9669
    int64_t v1; // 0x9669
    *(char *)v1 = 2 * (char)v1;
    *(int32_t *)a3 = (int32_t)v1;
    DelayMilliseconds_i2c2((int64_t *)&g98);
    int64_t v2; // 0x9669
    *(int32_t *)(*(int64_t *)(v2 + 0x6250) + *(int64_t *)(v2 + 0x57f8)) = 0x3200;
    return 0x3200;
}

// Address range: 0x9693 - 0x96be
int64_t i2c_soft_reset2(int64_t a1) {
    // 0x9693
    mcount();
    *(char *)(a1 + 0x590a) = (char)&g1;
    int32_t v1 = *(int32_t *)(*(int64_t *)(a1 + 0x6218) + *(int64_t *)(a1 + 0x57f8)); // 0x96b9
    return v1 | 32;
}

// From module:   /root/asv5220\smiI2cCtl.c
// Address range: 0x96c4 - 0x96f4
// Line range:    1248 - 1496
int64_t i2c_write_2(int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * writeData, int64_t length, char byteCnt, char retryCnt) {
    // 0x96c4
    int64_t v1; // 0x96c4
    char * v2 = (char *)(v1 + (int64_t)&g33); // 0x96c4
    unsigned char v3 = *v2; // 0x96c4
    unsigned char v4 = v3 + regAddr; // 0x96c4
    *v2 = v4;
    uint64_t v5 = pFdoData & 0xffffffff; // 0x96c7
    int64_t v6; // 0x96c4
    char v7 = *(char *)&v6; // 0x96c8
    *(char *)(int64_t)slvMode = v7 - (char)(v5 >> (int64_t)&g95) + (char)(v4 < v3);
    char * v8 = (char *)((int64_t)regAddr + 0xabf02); // 0x96cb
    *v8 = *v8 + regAddr;
    int64_t v9; // 0x96c4
    *(char *)v5 = *(char *)&v9 + (char)pFdoData;
    DelayMilliseconds_i2c2((int64_t *)(v1 & 0xffffffff));
    int64_t v10; // 0x96c4
    *(int32_t *)(*(int64_t *)(v10 + 0x6218) + *(int64_t *)(v10 + 0x57f8)) = 0x3200;
    return 0x3200;
}

// Address range: 0x96f4 - 0x9a30
int64_t i2c_write_2_(int64_t a1, int64_t a2, int64_t * a3, int64_t a4, char * a5, int64_t * a6, int64_t * a7, int64_t a8) {
    // 0x96f4
    mcount();
    int64_t * v1 = (int64_t *)(a1 + 0x57f8); // 0x9732
    int64_t v2 = *v1; // 0x9732
    int64_t * v3 = (int64_t *)(a1 + 0x6260); // 0x9739
    int32_t v4 = *(int32_t *)(*v3 + v2); // 0x9740
    int64_t v5 = v2; // 0x974c
    if ((v4 & 0x1f00) == 0 != (((char)v4 & (char)&g24) == (char)&g2)) {
        int64_t * v6 = (int64_t *)(a1 + 0x6218); // 0x975a
        int32_t * v7 = (int32_t *)(*v6 + v2); // 0x9761
        int32_t v8 = *v7 | (int32_t)&g26; // 0x9765
        *v7 = v8;
        DelayNanoseconds2((int64_t *)&g1);
        *(int32_t *)(*v6 + *v1) = v8 & -33;
        DelayNanoseconds2((int64_t *)&g1);
        v5 = *v1;
    }
    int64_t v9 = a4 & 0xffffffff; // 0x9717
    int64_t * v10 = (int64_t *)(a1 + 0x6240); // 0x97b1
    *(int32_t *)(*v10 + v5) = 0;
    unsigned char v11 = (char)(int64_t)a3; // 0x97bf
    int32_t v12 = 196; // 0x97c3
    int64_t v13 = v9; // 0x97c3
    if (v11 <= (char)&g33) {
        // 0x97c5
        v12 = v11 >= (char)&g25 ? 192 : 128;
        v13 = v11 >= (char)&g25 ? v9 : 0;
    }
    int64_t v14 = (int64_t)a5;
    int64_t v15 = *v1; // 0x9808
    int64_t v16 = *(int64_t *)(a1 + 0x6248); // 0x980f
    *(int32_t *)(v16 + v15) = (int32_t)v13 % 256 + ((int32_t)a2 % 256 << (int32_t)&g95);
    int64_t v17 = v14 + (int64_t)&g33; // 0x9819
    unsigned char v18 = *(char *)v17; // 0x9819
    int64_t v19 = v14 + (int64_t)&g25; // 0x9823
    unsigned char v20 = *(char *)v19; // 0x9823
    int64_t v21 = v14 + (int64_t)&g1; // 0x9830
    unsigned char v22 = *(char *)v21; // 0x9830
    int64_t v23; // 0x96f4
    unsigned char v24 = *(char *)&v23; // 0x983d
    int64_t v25 = *v1; // 0x9845
    int64_t * v26 = (int64_t *)(a1 + 0x6270); // 0x984c
    int64_t v27 = *v26; // 0x984c
    *(int32_t *)(v27 + v25) = (int32_t)(((((int64_t)v18 << (int64_t)&g95) + (int64_t)v20 << (int64_t)&g95) + (int64_t)v22 << (int64_t)&g95) + (int64_t)v24 * (int64_t)&g1);
    uint32_t v28 = (int32_t)(int64_t)a7 % 256; // 0x9861
    int64_t v29 = v14; // 0x9865
    int64_t v30 = &g86; // 0x9865
    if (v28 > (int32_t)&g86) {
        unsigned char v31 = *(char *)(v29 + (int64_t)&g94); // 0x9867
        unsigned char v32 = *(char *)(v29 + (int64_t)&g91); // 0x986f
        unsigned char v33 = *(char *)(v29 + (int64_t)&g89); // 0x987a
        v29 += (int64_t)&g86;
        unsigned char v34 = *(char *)v29; // 0x9885
        int64_t v35 = *v1; // 0x988c
        int64_t v36 = *v26; // 0x9893
        *(int32_t *)(v36 + v35) = (int32_t)(((((int64_t)v31 << (int64_t)&g95) + (int64_t)v32 << (int64_t)&g95) + (int64_t)v33 << (int64_t)&g95) + (int64_t)v34 * (int64_t)&g1);
        int64_t v37 = (int64_t)&g86 + (int64_t)(int32_t)&g86; // 0x989c
        int64_t v38 = v37 & 0xffffffff; // 0x989c
        uint32_t v39 = (int32_t)v37; // 0x989f
        v30 = v38;
        while (v28 > v39 == (v39 != (int32_t)&g2)) {
            // 0x9867
            v31 = *(char *)(v29 + (int64_t)&g94);
            v32 = *(char *)(v29 + (int64_t)&g91);
            v33 = *(char *)(v29 + (int64_t)&g89);
            v29 += (int64_t)&g86;
            v34 = *(char *)v29;
            v35 = *v1;
            v36 = *v26;
            *(int32_t *)(v36 + v35) = (int32_t)(((((int64_t)v31 << (int64_t)&g95) + (int64_t)v32 << (int64_t)&g95) + (int64_t)v33 << (int64_t)&g95) + (int64_t)v34 * (int64_t)&g1);
            v37 = v38 + (int64_t)(int32_t)&g86;
            v38 = v37 & 0xffffffff;
            v39 = (int32_t)v37;
            v30 = v38;
        }
    }
    int64_t v40 = *v1; // 0x98b8
    int64_t v41 = *v10; // 0x98bf
    *(int16_t *)(v41 + v40) = (int16_t)(v12 + (v28 << (int32_t)&g95));
    int64_t v42 = v30; // 0x98c9
    int64_t v43 = 0; // 0x98c9
    int64_t v44; // 0x96f4
    while (true) {
      lab_0x98cf:;
        int64_t v45 = v42;
        uint32_t v46 = (int32_t)v45; // 0x98cf
        if (v28 <= v46) {
            // 0x999d
            v44 = v45 & 0xffffffff;
            goto lab_0x99a0;
        } else {
            int64_t v47 = *v1; // 0x98d8
            uint32_t v48 = *(int32_t *)(*v3 + v47) & (int32_t)(char)&g24;
            if (v48 == 0) {
                // 0x999d
                v44 = v45 & 0xffffffff;
                goto lab_0x99a0;
            } else {
                int64_t v49 = (v45 & 0xffffffff) * (int64_t)&g1; // 0x9903
                unsigned char v50 = *(char *)(v49 + v17); // 0x9903
                unsigned char v51 = *(char *)(v49 + v19); // 0x990d
                unsigned char v52 = *(char *)(v49 + v21); // 0x991a
                unsigned char v53 = *(char *)(v49 + v14); // 0x9927
                int64_t v54 = *v26; // 0x9936
                *(int32_t *)(v54 + v47) = (int32_t)(((((int64_t)v50 << (int64_t)&g95) + (int64_t)v51 << (int64_t)&g95) + (int64_t)v52 << (int64_t)&g95) + (int64_t)v53 * (int64_t)&g1);
                int64_t v55 = v45 + (int64_t)(int32_t)&g86; // 0x993f
                int64_t v56 = v55 & 0xffffffff; // 0x993f
                int64_t v57 = v56; // 0x9946
                v44 = v56;
                if (v28 > (int32_t)v55) {
                    int64_t v58 = v57;
                    v44 = v58;
                    while ((int32_t)v58 - v46 < v48) {
                        int64_t v59 = v58 * (int64_t)&g1; // 0x994d
                        unsigned char v60 = *(char *)(v59 + v17); // 0x994d
                        unsigned char v61 = *(char *)(v59 + v19); // 0x9957
                        unsigned char v62 = *(char *)(v59 + v21); // 0x9964
                        unsigned char v63 = *(char *)(v59 + v14); // 0x9971
                        int64_t v64 = *v1; // 0x9979
                        int64_t v65 = *v26; // 0x9980
                        *(int32_t *)(v65 + v64) = (int32_t)(((((int64_t)v60 << (int64_t)&g95) + (int64_t)v61 << (int64_t)&g95) + (int64_t)v62 << (int64_t)&g95) + (int64_t)v63 * (int64_t)&g1);
                        int64_t v66 = v58 + (int64_t)(int32_t)&g86; // 0x9989
                        int64_t v67 = v66 & 0xffffffff; // 0x9989
                        v57 = v67;
                        v44 = v67;
                        if (v28 <= (int32_t)v66) {
                            // break -> 0x99a0
                            break;
                        }
                        v58 = v57;
                        v44 = v58;
                    }
                }
                goto lab_0x99a0;
            }
        }
    }
  lab_0x99f9:;
    // 0x99f9
    int64_t v68; // 0x99ae
    int32_t * v69 = (int32_t *)(*(int64_t *)(a1 + 0x6218) + v68); // 0x9a07
    *v69 = *v69 | (int32_t)&g26;
    return DelayNanoseconds2((int64_t *)&g1);
  lab_0x99a0:;
    int64_t v70 = v43 + (int64_t)(int32_t)&g1; // 0x99a0
    DelayMilliseconds_i2c2((int64_t *)&g1);
    v68 = *v1;
    int32_t v71 = *(int32_t *)(*v10 + v68); // 0x99bc
    if ((int32_t)v70 == (int32_t)"%(" || (v71 & 0x400000) != 0) {
        // break -> 0x99f9
        goto lab_0x99f9;
    }
    // 0x99eb
    v42 = v44 & 0xffffffff;
    v43 = v70 & 0xffffffff;
    goto lab_0x98cf;
}

// From module:   /root/asv5220\smiI2cCtl.c
// Address range: 0x9a35 - 0x9a65
// Line range:    145 - 165
int64_t i2c_2_read_mode1(int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * readData, int64_t length, char byteCnt, char retryCnt) {
    // 0x9a35
    int64_t v1; // 0x9a35
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x9a35
    int64_t v3; // 0x9a35
    *(int32_t *)(*(int64_t *)(v3 + 0x6218) + v1) = (int32_t)v2;
    DelayNanoseconds2((int64_t *)&g1);
    int64_t result; // 0x9a35
    return result;
}

// Address range: 0x9a65 - 0x9ae3
int64_t i2c_2_read_mode1_(int64_t a1, uint64_t a2, int64_t * a3, uint64_t a4, int64_t a5, int64_t a6, int64_t a7, uint64_t a8) {
    // 0x9a65
    mcount();
    int64_t v1 = (int64_t)(0x100000000000000 * a4) / 0x100000000000000; // bp-72, 0x9a96
    i2c_write_2_(a1, a2 % 256, (int64_t *)&g1, a4 % 256, (char *)&v1, (int64_t *)&g86, (int64_t *)(int64_t)(int32_t)&g1, a8 % 256);
    return 0;
}

// From module:   /root/asv5220\smiI2cCtl.c
// Address range: 0x9ae4 - 0x9b14
// Line range:    1035 - 1246
int64_t i2c_read_2(int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * readData, int64_t length, char byteCnt, char retryCnt) {
    // 0x9ae4
    int64_t v1; // 0x9ae4
    int64_t v2 = *(int64_t *)(v1 - 72); // 0x9ae7
    int64_t v3; // 0x9ae4
    int64_t v4; // 0x9ae4
    int64_t v5; // 0x9ae4
    int64_t result = i2c_read_2_(v3, v4 & 0xffffffff, (int64_t *)&g1, v5 & 0xffffffff, v2, length, (int64_t)&g107, (int64_t)&g107); // 0x9af9
    return result;
}

// Address range: 0x9b14 - 0x9bbe
int64_t i2c_read_2_(int64_t a1, int64_t a2, int64_t * a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8) {
    // 0x9b14
    mcount();
    *(int32_t *)(*(int64_t *)(a1 + 0x6240) + *(int64_t *)(a1 + 0x57f8)) = 0;
    return 0;
}

// Address range: 0x9bbe - 0x9bc5
int64_t function_9bbe(void) {
    // 0x9bbe
    int64_t v1; // 0x9bbe
    int64_t v2; // 0x9bbe
    int64_t v3; // 0x9bbe
    return function_9c01(v1, v2, 0xffffffe0, v3);
}

// Address range: 0x9bc5 - 0x9bcc
int64_t function_9bc5(void) {
    // 0x9bc5
    int64_t v1; // 0x9bc5
    int64_t v2; // 0x9bc5
    int64_t v3; // 0x9bc5
    return function_9c01(v1, v2, 0xffffffe4, v3);
}

// Address range: 0x9bcc - 0x9bf7
int64_t function_9bcc(uint64_t a1, uint64_t a2, int64_t a3, uint64_t a4) {
    // 0x9bcc
    int64_t v1; // 0x9bcc
    unsigned char v2 = *(char *)(v1 - 64); // 0x9bdb
    int64_t v3; // 0x9bcc
    int64_t v4; // 0x9bcc
    int64_t v5; // 0x9bcc
    int64_t result = i2c_2_read_mode1_(v5, a2 % 256, (int64_t *)&g2, a4 % 256, v3, v4, (int64_t)v2, a1 % 256); // 0x9bed
    return result;
}

// Address range: 0x9c01 - 0x9d12
int64_t function_9c01(int64_t a1, int64_t a2, uint64_t a3, uint64_t a4) {
    // 0x9c01
    int64_t v1; // 0x9c01
    int64_t * v2 = (int64_t *)(v1 + 0x57f8); // 0x9c0e
    int64_t v3 = *v2; // 0x9c0e
    int64_t v4 = *(int64_t *)(v1 + 0x6248); // 0x9c15
    *(int32_t *)(v4 + v3) = (int32_t)((int64_t)((int32_t)a2 % 256 << (int32_t)&g95) * (int64_t)&g1 + a4 % 256);
    int64_t v5; // 0x9c01
    char * v6 = (char *)(v5 - 64); // 0x9c21
    unsigned char v7 = *v6; // 0x9c21
    int64_t v8 = *v2; // 0x9c2b
    int64_t * v9 = (int64_t *)(v1 + 0x6240); // 0x9c32
    int64_t v10 = *v9; // 0x9c32
    *(int16_t *)(v10 + v8) = (int16_t)((int64_t)((int32_t)v7 << (int32_t)&g95) * (int64_t)&g1 + a3 % 256);
    DelayMilliseconds_i2c2((int64_t *)&g25);
    int64_t v11 = *v2; // 0x9c57
    int64_t result = *(int64_t *)(v1 + 0x6260) + v11; // 0x9c5e
    uint32_t v12 = *(int32_t *)result; // 0x9c65
    if ((v12 & 768) != 0) {
        // 0x9cfb
        return result;
    }
    uint32_t v13 = v12 / 256 % 32;
    if (*v6 > (char)v13) {
        // 0x9cfb
        return result;
    }
    int64_t v14 = v11; // 0x9c8b
    if (v13 != 0) {
        int64_t v15 = 0; // 0x9c01
        uint32_t v16 = *(int32_t *)(*(int64_t *)(v1 + 0x6270) + v11); // 0x9c9e
        int64_t v17; // 0x9c01
        *(char *)(v15 * (int64_t)&g1 + v17) = (char)v16;
        int64_t v18 = v15 + v17;
        *(char *)(v18 + (int64_t)&g1) = (char)(v16 / 256);
        *(char *)(v18 + (int64_t)&g25) = (char)(v16 / 0x10000);
        *(char *)(v18 + (int64_t)&g33) = (char)(v16 / 0x1000000);
        int64_t v19 = v15 + (int64_t)(int32_t)&g86; // 0x9cc9
        while ((int32_t)v19 < (int32_t)*v6 == v13 > (int32_t)v19) {
            // 0x9cd1
            v15 = v19 & 0xffffffff;
            v16 = *(int32_t *)(*(int64_t *)(v1 + 0x6270) + *v2);
            *(char *)(v15 * (int64_t)&g1 + v17) = (char)v16;
            v18 = v15 + v17;
            *(char *)(v18 + (int64_t)&g1) = (char)(v16 / 256);
            *(char *)(v18 + (int64_t)&g25) = (char)(v16 / 0x10000);
            *(char *)(v18 + (int64_t)&g33) = (char)(v16 / 0x1000000);
            v19 = v15 + (int64_t)(int32_t)&g86;
        }
        // 0x9cdd
        v14 = *v2;
    }
    int64_t result2 = *v9 + v14; // 0x9ce4
    if ((char)(*(int32_t *)result2 / 0x10000) < 0) {
        // 0x9cfb
        return &g1;
    }
    // 0x9cfb
    return result2;
}

// From module:   /root/asv5220\smiI2cCtl.c
// Address range: 0x9d16 - 0x9d46
// Line range:    707 - 1033
int64_t i2c_write(int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * writeData, int64_t length, char byteCnt, char retryCnt) {
    // 0x9d16
    int64_t result; // 0x9d16
    return result;
}

// Address range: 0x9d46 - 0xa0d3
int64_t i2c_write2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t * a5, int64_t a6, int64_t a7, int32_t a8) {
    // 0x9d46
    mcount();
    if (((char)a6 & (char)&g33) != 0) {
        // 0x9d78
        return DelayMilliseconds_i2c2((int64_t *)&g1);
    }
    if (a5 == NULL) {
        // 0x9d92
        return DelayMilliseconds_i2c2((int64_t *)&g1);
    }
    int64_t * v1 = (int64_t *)(a1 + 0x57f8); // 0x9da7
    int64_t v2 = *v1; // 0x9da7
    int64_t * v3 = (int64_t *)(a1 + 0x6228); // 0x9dae
    int32_t v4 = *(int32_t *)(*v3 + v2); // 0x9db5
    int64_t v5 = v2; // 0x9dc1
    if ((v4 & 0x1f00) == 0 != (((char)v4 & (char)&g24) == (char)&g2)) {
        int64_t * v6 = (int64_t *)(a1 + 0x6218); // 0x9dd3
        int32_t * v7 = (int32_t *)(*v6 + v2); // 0x9dda
        int32_t v8 = *v7 | (int32_t)&g26; // 0x9dde
        *v7 = v8;
        DelayNanoseconds2((int64_t *)&g1);
        *(int32_t *)(*v6 + *v1) = v8 & -33;
        DelayNanoseconds2((int64_t *)&g1);
        v5 = *v1;
        int32_t v9 = *(int32_t *)(*v3 + v5); // 0x9e31
        if (((char)v9 & (char)&g24) != 16) {
            // 0x9e3a
            return DelayMilliseconds_i2c2((int64_t *)&g1);
        }
    }
    // 0x9e4f
    *(int32_t *)(*(int64_t *)(a1 + 0x6208) + v5) = 0;
    if ((char)a3 > (char)&g89) {
        // 0x9e8e
        return DelayMilliseconds_i2c2((int64_t *)&g1);
    }
    // 0x9e6a
    return 0;
}

// From module:   /root/asv5220\smiI2cCtl.c
// Address range: 0xa0d4 - 0xa104
// Line range:    123 - 142
int64_t i2c_1_read_mode1(int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * readData, int64_t length, char byteCnt, char retryCnt) {
    // 0xa0d4
    int64_t v1; // 0xa0d4
    int64_t v2 = *(int64_t *)(v1 + 0x6218); // 0xa0de
    int64_t v3; // 0xa0d4
    *(int32_t *)(v2 + *(int64_t *)(v1 + 0x57f8)) = (int32_t)v3;
    DelayNanoseconds2((int64_t *)&g1);
    int64_t result; // 0xa0d4
    return result;
}

// Address range: 0xa104 - 0xa182
int64_t i2c_1_read_mode1_(int64_t a1, uint64_t a2, int64_t * a3, uint64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8) {
    // 0xa104
    mcount();
    int64_t v1 = (int64_t)(0x100000000000000 * a4) / 0x100000000000000; // bp-72, 0xa135
    i2c_write2(a1, a2 % 256, (int64_t)&g1, a4 % 256, &v1, (int64_t)&g86, (int64_t)(int32_t)&g1, (int32_t)a8 % 256);
    return 0;
}

// From module:   /root/asv5220\smiI2cCtl.c
// Address range: 0xa183 - 0xa1b3
// Line range:    411 - 705
int64_t i2c_read(int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * readData, int64_t length, char byteCnt, char retryCnt) {
    // 0xa183
    int64_t v1; // 0xa183
    int64_t v2 = *(int64_t *)(v1 - 72); // 0xa186
    int64_t v3; // 0xa183
    int64_t v4; // 0xa183
    int64_t v5; // 0xa183
    int64_t result = i2c_read2(v3, v4 & 0xffffffff, (int64_t)&g1, v5 & 0xffffffff, (int64_t *)v2, length, (int64_t)&g107, (int32_t)&g107); // 0xa198
    return result;
}

// Address range: 0xa1b3 - 0xa45b
int64_t i2c_read2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t * a5, int64_t a6, int64_t a7, int32_t a8) {
    // 0xa1b3
    mcount();
    if (((char)a6 & (char)&g33) != 0) {
        // 0xa1f7
        return DelayMilliseconds_i2c2((int64_t *)&g1);
    }
    if (a5 == NULL) {
        // 0xa211
        return DelayMilliseconds_i2c2((int64_t *)&g1);
    }
    int64_t v1 = *(int64_t *)(a1 + 0x57f8); // 0xa226
    int32_t v2 = *(int32_t *)(*(int64_t *)(a1 + 0x6228) + v1); // 0xa234
    if ((v2 & 0x1f00) == 0 != (((char)v2 & (char)&g24) == (char)&g2)) {
        // 0xa24c
        return DelayMilliseconds_i2c2((int64_t *)&g1);
    }
    // 0xa261
    *(int32_t *)(*(int64_t *)(a1 + 0x6208) + v1) = 0;
    if ((char)a3 > (char)&g2) {
        // 0xa2c3
        return DelayMilliseconds_i2c2((int64_t *)&g1);
    }
    // 0xa27c
    return 0;
}

// From module:   /root/asv5220\smiI2cCtl.c
// Address range: 0xa45c - 0xa48c
// Line range:    62 - 120
int64_t i2c_access(int16_t channel, char bIsRead, int64_t pFdoData, char slvAddr, char slvMode, char regAddr, char * Data, int64_t length, char byteCnt, char retryCnt) {
    // 0xa45c
    int64_t v1; // 0xa45c
    int32_t v2 = *(int32_t *)(*(int64_t *)(v1 + 0x6228) + *(int64_t *)(v1 + 0x57f8)); // 0xa46d
    int64_t v3; // 0xa45c
    return (v2 & 0x1f00) == 0 ? v3 : 0;
}

// Address range: 0xa48c - 0xa581
int64_t i2c_access2(int64_t * a1, int64_t a2, int64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int64_t * a7, int64_t a8, uint64_t a9, uint32_t a10) {
    // 0xa48c
    mcount();
    uint64_t v1 = a9 % 256; // 0xa4b7
    uint32_t v2 = a10 % 256;
    if ((int16_t)(int64_t)a1 != (int16_t)&g1) {
        if ((char)a2 != (char)&g1) {
            // 0xa575
            return 0;
        }
        // 0xa548
        return i2c_read_2_(a3, a4 % 256, (int64_t *)(a5 % 256), a6 % 256, (int64_t)a7, a8, v1, (int64_t)v2);
    }
    uint64_t v3 = a6 % 256;
    uint64_t v4 = a5 % 256;
    uint64_t v5 = a4 % 256;
    if ((char)a2 != (char)&g1) {
        // 0xa50f
        return i2c_write2(a3, v5, v4, v3, a7, a8, v1, v2);
    }
    // 0xa4df
    return i2c_read2(a3, v5, v4, v3, a7, a8, v1, v2);
}

// From module:   /root/asv5220\smiI2cCtl.c
// Address range: 0xa582 - 0xa5b2
// Line range:    168 - 206
int64_t cfg_access(char bIsRead, int64_t pFdoData, int16_t regAddr, int64_t length, char * Data) {
    uint64_t v1 = (int64_t)regAddr;
    int64_t v2; // 0xa582
    uint64_t v3; // 0xa582
    int64_t v4; // 0xa582
    int64_t v5; // 0xa582
    int64_t v6; // 0xa582
    int64_t result = i2c_write_2_(v5, (v1 >> (int64_t)&g95) % 256, (int64_t *)v1, length, (char *)v4, (int64_t *)v6, (int64_t *)(v3 % 256), 0x100000000 * v2 / 0x100000000); // 0xa59b
    return result;
}

// Address range: 0xa5b2 - 0xa650
int64_t cfg_access2(int64_t * a1, int64_t a2, uint64_t a3, int64_t * a4, int64_t * a5) {
    // 0xa5b2
    mcount();
    int64_t v1 = a2 + 0x5918; // 0xa5d8
    down(v1, a2);
    char * v2 = (char *)(a2 + 0x5910); // 0xa5e7
    if (*v2 != 0) {
        up(v1);
        DelayMilliseconds_i2c2((int64_t *)&g1);
        down(v1, a2);
        while (*v2 != 0) {
            // 0xa607
            up(v1);
            DelayMilliseconds_i2c2((int64_t *)&g1);
            down(v1, a2);
        }
    }
    int64_t v3 = (int64_t)a4;
    *v2 = (char)&g1;
    up(v1);
    uint64_t v4 = a3 % 0x10000;
    int64_t result; // 0xa5b2
    if ((char)(int64_t)a1 != (char)&g1) {
        // 0xa633
        result = cfg_write2(a2, v4, v3, a5);
    } else {
        // 0xa61b
        result = cfg_read2(a2, v4, v3, a5);
    }
    // 0xa649
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa650 - 0xa658
// Line range:    402 - 472
void Convert_Function1_Driver(char * datain, char * dataout) {
    // 0xa650
    int64_t v1; // 0xa650
    down(v1, (int64_t)dataout);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa65b - 0xa662
// Line range:    473 - 546
void Convert_Function2_Driver(char * datain, char * dataout) {
    // 0xa65b
    char v1; // 0xa65b
    int64_t v2 = v1; // 0xa65b
    int64_t v3; // 0xa65b
    *(char *)v3 = 2 * (char)v3;
    char * v4 = (char *)(v2 - 25 + v2 * (int64_t)&g86); // 0xa65e
    *v4 = *v4 + v1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa666 - 0xa671
// Line range:    547 - 616
void Convert_Function3_Driver(char * datain, char * dataout) {
    // 0xa666
    int64_t v1; // 0xa666
    char * v2 = (char *)(v1 - 24 + v1 * (int64_t)&g86); // 0xa666
    *v2 = *v2 + (char)v1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa671 - 0xa679
// Line range:    617 - 688
void Convert_Function4_Driver(char * datain, char * dataout) {
    // 0xa671
    return;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa67c - 0xa680
// Line range:    696 - 816
int32_t GenerateCertificateKey(char * indata, char * outdata) {
    // 0xa67c
    int64_t result; // 0xa67c
    return result;
}

// Address range: 0xa680 - 0xa68b
int64_t Convert_Function1_Driver2(void) {
    // 0xa680
    return mcount();
}

// Address range: 0xa68b - 0xa68c
int64_t Convert_Function2_Driver2(void) {
    // 0xa68b
    int64_t result; // 0xa68b
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa68c - 0xa696
// Line range:    975 - 1019
int32_t DTV_SetPidFilterBoundary(int64_t pTuner, int32_t Start, int32_t End) {
    // 0xa68c
    return mcount();
}

// Address range: 0xa696 - 0xa6a1
int64_t Convert_Function3_Driver2(void) {
    // 0xa696
    return mcount();
}

// Address range: 0xa6a1 - 0xa6ac
int64_t Convert_Function4_Driver2(void) {
    // 0xa6a1
    return mcount();
}

// Address range: 0xa6ac - 0xa6bc
int64_t GenerateCertificateKey2(void) {
    // 0xa6ac
    mcount();
    return &g1;
}

// Address range: 0xa6bc - 0xa6c5
int64_t DTV_SetPidFilterBoundary2(int64_t a1, int64_t a2, int64_t a3) {
    // 0xa6bc
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa6c8 - 0xa6c9
// Line range:    1302 - 1428
char StoreDeviceInformation(int64_t pDevExt, char * keyName, char * lpMessage) {
    // 0xa6c8
    int64_t result; // 0xa6c8
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa6d8 - 0xa6e5
// Line range:    1430 - 1511
char InitializeDeviceInformation(int64_t pDevExt) {
    int64_t v1 = *(int64_t *)(pDevExt + 0x1d38); // 0xa6de
    int64_t v2; // 0xa6d8
    return (((v2 + 192) % 256 | v2 & -256) << (int64_t)&g86) + v1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa6e8 - 0xa6f8
// Line range:    1513 - 1617
char StoreLNAStatus(int64_t pDevExt, char * keyName, int64_t * lpMessage) {
    // 0xa6e8
    int64_t v1; // 0xa6e8
    *(char *)v1 = 2 * (char)v1;
    *(int32_t *)(v1 + (int64_t)&g95) = (int32_t)(int64_t)keyName;
    *(int32_t *)(v1 + (int64_t)&g86) = (int32_t)(int64_t)lpMessage;
    return &g1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa6f8 - 0xa708
// Line range:    1619 - 1701
char InitializeLNAStatus(int64_t pDevExt) {
    // 0xa6f8
    mcount();
    return &g1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa708 - 0xa718
// Line range:    1703 - 1789
char InitializeLNASetting(int64_t pDevExt) {
    // 0xa708
    mcount();
    return &g1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa718 - 0xa728
// Line range:    2662 - 2672
int32_t DTV_GetUSB_MODE(int64_t pTnim) {
    // 0xa718
    mcount();
    return &g1;
}

// Address range: 0xa728 - 0xa737
int64_t InitializeLNAStatus2(void) {
    // 0xa728
    mcount();
    return &g1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa737 - 0xa738
// Line range:    2743 - 2766
int32_t DTV_CheckSync(char * Buffer, int32_t ChkFrameNum) {
    // 0xa737
    int64_t result; // 0xa737
    return result;
}

// Address range: 0xa738 - 0xa748
int64_t InitializeLNASetting2(void) {
    // 0xa738
    mcount();
    return &g1;
}

// Address range: 0xa748 - 0xa767
int64_t DTV_GetUSB_MODE2(int64_t a1) {
    // 0xa748
    mcount();
    int64_t result = 0xfffffff6; // 0xa75d
    if (*(int32_t *)(a1 + 0x1d40) != 0) {
        // 0xa75f
        result = (int64_t)*(int32_t *)(a1 + 0x1d44);
    }
    // 0xa765
    return result;
}

// Address range: 0xa767 - 0xa779
int64_t DTV_CheckSync2(int64_t a1, int64_t * a2) {
    // 0xa767
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa77b - 0xa7ab
// Line range:    2769 - 2778
int32_t DTV_CleanEncFlag(char * Buffer, int32_t FrameNum) {
    // 0xa77b
    int64_t v1; // 0xa77b
    char v2 = v1;
    *(char *)v1 = 2 * v2;
    char * v3 = (char *)(v1 + 0x1174473f); // 0xa77d
    *v3 = *v3 + v2;
    return 0;
}

// Address range: 0xa7ab - 0xa7ac
int64_t DTV_CleanEncFlag2(int64_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xa7ab
    int64_t result; // 0xa7ab
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa7ad - 0xa7dd
// Line range:    3103 - 3115
char ChangeEndian(char Input) {
    // 0xa7ad
    mcount();
    int64_t v1; // 0xa7ad
    int32_t v2 = v1; // 0xa7b4
    int64_t v3 = 0; // 0xa7b6
    if (v2 < 1) {
        // 0xa7d6
        return &g1;
    }
    int64_t v4 = 0; // 0xa7b6
    char * v5 = (char *)(0x100000000 * v3 / 0x100000000 + (int64_t)Input); // 0xa7c5
    *v5 = *v5 % 128;
    v3 = v3 + 188 & 0xffffffff;
    while ((int32_t)v4 != v2) {
        // 0xa7c2
        v4 &= 0xffffffff;
        v5 = (char *)(0x100000000 * v3 / 0x100000000 + (int64_t)Input);
        *v5 = *v5 % 128;
        v3 = v3 + 188 & 0xffffffff;
    }
    // 0xa7d6
    return &g1;
}

// Address range: 0xa7dd - 0xa7ff
int64_t ChangeEndian2(int64_t a1) {
    // 0xa7dd
    mcount();
    uint32_t v1 = (int32_t)a1;
    return v1 % 256 << (int32_t)&g94 | v1 | v1 / 32 & 2;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa7ff - 0xa80e
// Line range:    3203 - 3310
char StoreDeviceLNBPower(int64_t pDevExt, char * keyName, int64_t * lpMessage) {
    // 0xa7ff
    int64_t v1; // 0xa7ff
    return ((int32_t)(int64_t)lpMessage & (int32_t)&g26) >> (uint32_t)(int32_t)&g33 | (int32_t)v1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa80f - 0xa81d
// Line range:    3312 - 3387
char InitializeDeviceLNBPowerRegistry(int64_t pDevExt) {
    // 0xa80f
    int64_t v1; // 0xa80f
    int64_t v2; // 0xa80f
    int64_t v3; // 0xa80f
    return 2 * ((char)v1 & (char)&g95) | (char)(v3 | v2);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa81f - 0xa828
// Line range:    4454 - 4740
void DTV_PollingWDThread(char * Context) {
    // 0xa81f
    int64_t v1; // 0xa81f
    int64_t v2 = v1 - (int64_t)&g1; // 0xa821
    int64_t v3; // 0xa81f
    if (v2 != (int64_t)&g1 && v2 != 0 == (char)v3 == 63) {
        DTV_5606B2_KeyTransfer1((int64_t)Context);
    }
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xa82a - 0xa82f
// Line range:    6323 - 6395
char DTV_5606B2_KeyTransfer1(int64_t pTuner) {
    // 0xa82a
    int64_t v1; // 0xa82a
    return (char)v1 + 9;
}

// Address range: 0xa82f - 0xa83f
int64_t StoreDeviceLNBPower2(int64_t a1, int64_t a2, int64_t * a3) {
    // 0xa82f
    mcount();
    return 0;
}

// Address range: 0xa83f - 0xa84f
int64_t InitializeDeviceLNBPowerRegistry2(int64_t a1) {
    // 0xa83f
    mcount();
    return &g1;
}

// Address range: 0xa84f - 0xa85a
int64_t DTV_PollingWDThread2(void) {
    // 0xa84f
    return mcount();
}

// Address range: 0xa85a - 0xab7d
int64_t DTV_5606B2_KeyTransfer1_(int64_t a1) {
    // 0xa85a
    mcount();
    __readgsqword(40);
    int64_t v1; // bp-8, 0xa85a
    int64_t v2 = (int64_t)&v1 - 224; // 0xa8a5
    int64_t v3 = 0; // 0xa885
    int64_t v4 = a1; // 0xa885
    unsigned char v5 = *(char *)(v4 + (int64_t)&g45); // 0xa88e
    int64_t v6 = 0; // 0xa88e
    int64_t v7 = v6 + (int64_t)(int32_t)&g1; // 0xa899
    int32_t v8 = v7; // 0xa8a0
    uint32_t v9 = v8 & (int32_t)&g24 & 255; // 0xa8a0
    char v10 = v9 == 0 ? v5 : (char)((int32_t)v5 >> v9);
    *(char *)(0x100000000 * (v6 * (int64_t)&g1 + v3) / 0x100000000 * (int64_t)&g1 + v2) = v10 & (char)&g1;
    v6 = v7 & 0xffffffff;
    while (v8 != (int32_t)&g94) {
        // 0xa896
        v7 = v6 + (int64_t)(int32_t)&g1;
        v8 = v7;
        v9 = v8 & (int32_t)&g24 & 255;
        v10 = v9 == 0 ? v5 : (char)((int32_t)v5 >> v9);
        *(char *)(0x100000000 * (v6 * (int64_t)&g1 + v3) / 0x100000000 * (int64_t)&g1 + v2) = v10 & (char)&g1;
        v6 = v7 & 0xffffffff;
    }
    int64_t v11 = v3 + (int64_t)(int32_t)&g94; // 0xa8b5
    v3 = v11 & 0xffffffff;
    v4 += (int64_t)&g1;
    while ((int32_t)v11 != 112) {
        // 0xa88b
        v5 = *(char *)(v4 + (int64_t)&g45);
        v6 = 0;
        v7 = v6 + (int64_t)(int32_t)&g1;
        v8 = v7;
        v9 = v8 & (int32_t)&g24 & 255;
        v10 = v9 == 0 ? v5 : (char)((int32_t)v5 >> v9);
        *(char *)(0x100000000 * (v6 * (int64_t)&g1 + v3) / 0x100000000 * (int64_t)&g1 + v2) = v10 & (char)&g1;
        v6 = v7 & 0xffffffff;
        while (v8 != (int32_t)&g94) {
            // 0xa896
            v7 = v6 + (int64_t)(int32_t)&g1;
            v8 = v7;
            v9 = v8 & (int32_t)&g24 & 255;
            v10 = v9 == 0 ? v5 : (char)((int32_t)v5 >> v9);
            *(char *)(0x100000000 * (v6 * (int64_t)&g1 + v3) / 0x100000000 * (int64_t)&g1 + v2) = v10 & (char)&g1;
            v6 = v7 & 0xffffffff;
        }
        // 0xa8b1
        v11 = v3 + (int64_t)(int32_t)&g94;
        v3 = v11 & 0xffffffff;
        v4 += (int64_t)&g1;
    }
    int64_t v12 = 0; // 0xa8d2
    int64_t v13; // bp-49, 0xa85a
    int64_t v14 = &v13; // 0xa8d2
    int64_t v15 = v12 * (int64_t)&g1; // 0xa8d4
    int64_t v16 = 0; // 0xa903
    unsigned char v17 = *(char *)(0x100000000 * (v16 + v15) / 0x100000000 * (int64_t)&g1 + v2); // 0xa8da
    uint32_t v18 = (int32_t)v16 & (int32_t)&g24 & 255; // 0xa8e2
    int64_t v19 = v17; // 0xa8e2
    if (v18 != 0) {
        v19 = (int32_t)v17 << v18;
    }
    int64_t v20 = v19;
    int64_t v21 = v16 + (int64_t)(int32_t)&g1; // 0xa8e6
    int64_t v22 = v20; // 0xa8ec
    v16 = v21 & 0xffffffff;
    while ((int32_t)v21 != (int32_t)&g95) {
        // 0xa8d4
        v17 = *(char *)(0x100000000 * (v16 + v15) / 0x100000000 * (int64_t)&g1 + v2);
        v18 = (int32_t)v16 & (int32_t)&g24 & 255;
        v19 = v17;
        if (v18 != 0) {
            v19 = (int32_t)v17 << v18;
        }
        v20 = v19 | v22;
        v21 = v16 + (int64_t)(int32_t)&g1;
        v22 = v20;
        v16 = v21 & 0xffffffff;
    }
    // 0xa8ee
    *(char *)v14 = (char)v20;
    int64_t v23 = v12 + (int64_t)(int32_t)&g95; // 0xa8f5
    v12 = v23 & 0xffffffff;
    v14 += (int64_t)&g1;
    while ((int32_t)v23 != 56) {
        // 0xa8fd
        v15 = v12 * (int64_t)&g1;
        v16 = 0;
        v17 = *(char *)(0x100000000 * (v16 + v15) / 0x100000000 * (int64_t)&g1 + v2);
        v18 = (int32_t)v16 & (int32_t)&g24 & 255;
        v19 = v17;
        if (v18 != 0) {
            v19 = (int32_t)v17 << v18;
        }
        v20 = v19;
        v21 = v16 + (int64_t)(int32_t)&g1;
        v22 = v20;
        v16 = v21 & 0xffffffff;
        while ((int32_t)v21 != (int32_t)&g95) {
            // 0xa8d4
            v17 = *(char *)(0x100000000 * (v16 + v15) / 0x100000000 * (int64_t)&g1 + v2);
            v18 = (int32_t)v16 & (int32_t)&g24 & 255;
            v19 = v17;
            if (v18 != 0) {
                v19 = (int32_t)v17 << v18;
            }
            v20 = v19 | v22;
            v21 = v16 + (int64_t)(int32_t)&g1;
            v22 = v20;
            v16 = v21 & 0xffffffff;
        }
        // 0xa8ee
        *(char *)v14 = (char)v20;
        v23 = v12 + (int64_t)(int32_t)&g95;
        v12 = v23 & 0xffffffff;
        v14 += (int64_t)&g1;
    }
    // 0xa905
    int64_t v24; // bp-56, 0xa85a
    int64_t v25 = &v24; // 0xa905
    int64_t v26 = 56; // 0xa91c
    int64_t v27 = v25; // 0xa91c
    int64_t v28 = 0; // 0xa94c
    unsigned char v29 = *(char *)(0x100000000 * (v28 * (int64_t)&g1 + v26) / 0x100000000 * (int64_t)&g1 + v2); // 0xa924
    uint32_t v30 = (int32_t)v28 & (int32_t)&g24 & 255; // 0xa92c
    int64_t v31 = v29; // 0xa92c
    if (v30 != 0) {
        v31 = (int32_t)v29 << v30;
    }
    int64_t v32 = v31;
    int64_t v33 = v28 + (int64_t)(int32_t)&g1; // 0xa930
    int64_t v34 = v32; // 0xa936
    v28 = v33 & 0xffffffff;
    while ((int32_t)v33 != (int32_t)&g95) {
        // 0xa91e
        v29 = *(char *)(0x100000000 * (v28 * (int64_t)&g1 + v26) / 0x100000000 * (int64_t)&g1 + v2);
        v30 = (int32_t)v28 & (int32_t)&g24 & 255;
        v31 = v29;
        if (v30 != 0) {
            v31 = (int32_t)v29 << v30;
        }
        v32 = v31 | v34;
        v33 = v28 + (int64_t)(int32_t)&g1;
        v34 = v32;
        v28 = v33 & 0xffffffff;
    }
    // 0xa938
    *(char *)v27 = (char)v32;
    int64_t v35 = v26 + 8; // 0xa93f
    v26 = v35 & 0xffffffff;
    v27 += (int64_t)&g1;
    while ((int32_t)v35 != 112) {
        // 0xa947
        v28 = 0;
        v29 = *(char *)(0x100000000 * (v28 * (int64_t)&g1 + v26) / 0x100000000 * (int64_t)&g1 + v2);
        v30 = (int32_t)v28 & (int32_t)&g24 & 255;
        v31 = v29;
        if (v30 != 0) {
            v31 = (int32_t)v29 << v30;
        }
        v32 = v31;
        v33 = v28 + (int64_t)(int32_t)&g1;
        v34 = v32;
        v28 = v33 & 0xffffffff;
        while ((int32_t)v33 != (int32_t)&g95) {
            // 0xa91e
            v29 = *(char *)(0x100000000 * (v28 * (int64_t)&g1 + v26) / 0x100000000 * (int64_t)&g1 + v2);
            v30 = (int32_t)v28 & (int32_t)&g24 & 255;
            v31 = v29;
            if (v30 != 0) {
                v31 = (int32_t)v29 << v30;
            }
            v32 = v31 | v34;
            v33 = v28 + (int64_t)(int32_t)&g1;
            v34 = v32;
            v28 = v33 & 0xffffffff;
        }
        // 0xa938
        *(char *)v27 = (char)v32;
        v35 = v26 + 8;
        v26 = v35 & 0xffffffff;
        v27 += (int64_t)&g1;
    }
    char v36 = 96; // bp-104, 0xaa2c
    int64_t v37; // bp-72, 0xa85a
    int64_t v38 = &v37; // 0xaa6a
    int64_t v39 = &v36; // 0xaa6a
    int64_t v40 = v25; // 0xaa6a
    *(char *)v38 = *(char *)v40 ^ *(char *)v39;
    v40 += (int64_t)&g1;
    v38 += (int64_t)&g1;
    v39 += (int64_t)&g1;
    int64_t v41; // bp-42, 0xa85a
    while (v40 != (int64_t)&v41) {
        // 0xaa6e
        *(char *)v38 = *(char *)v40 ^ *(char *)v39;
        v40 += (int64_t)&g1;
        v38 += (int64_t)&g1;
        v39 += (int64_t)&g1;
    }
    // 0xaa87
    char v42; // bp-88, 0xa85a
    return &v42;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xab87 - 0xabb7
// Line range:    6874 - 6885
void DTV_Software_process_5606B2(int64_t pTuner, char * Input188B, char * Output188B) {
    // 0xab87
    int64_t v1; // 0xab87
    if (*(int64_t *)(v1 - 24) != __readgsqword(40)) {
        // 0xaba8
        __stack_chk_fail();
    }
}

// Address range: 0xabb7 - 0xabeb
int64_t DTV_Software_process_5606B2_(int64_t result, int64_t a2, int64_t a3) {
    // 0xabb7
    mcount();
    int64_t v1; // 0xabb7
    *(char *)a3 = (char)v1;
    char v2 = *(char *)(a2 + (int64_t)&g1); // 0xabc5
    *(char *)(a3 + (int64_t)&g1) = v2;
    char v3 = *(char *)(a2 + (int64_t)&g25); // 0xabcc
    *(char *)(a3 + (int64_t)&g25) = v3;
    char v4 = *(char *)(a2 + (int64_t)&g33); // 0xabd3
    *(char *)(a3 + (int64_t)&g33) = v4;
    return result;
}

// Address range: 0xac03 - 0xac08
int64_t function_ac03(void) {
    // 0xac03
    return function_ffffffffc801ed24();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xac0b - 0xac3b
// Line range:    7693 - 7758
int32_t Gen_Identify_Key_01(char * OutputKey, char * InputKey, char * RandomKey) {
    // 0xac0b
    int64_t v1; // 0xac0b
    char v2 = *(char *)((int64_t)OutputKey + (int64_t)&g47 + v1 * (int64_t)&g1); // 0xac12
    int64_t v3; // 0xac0b
    *(char *)((int64_t)RandomKey + (int64_t)&g86) = v2 + 89 ^ (char)v3;
    int64_t v4; // 0xac0b
    return (int32_t)v4 + (int32_t)&g1;
}

// Address range: 0xac3b - 0xad2a
int64_t Gen_Identify_Key_01_(int64_t a1, int64_t a2, int64_t a3) {
    // 0xac3b
    mcount();
    char v1 = *(char *)(a3 + (int64_t)&g99); // 0xacea
    char v2 = *(char *)(a2 + (int64_t)&g99); // 0xacee
    char v3 = *(char *)(a3 + (int64_t)"GNU"); // 0xacf4
    char v4 = *(char *)(a2 + (int64_t)"GNU"); // 0xacf8
    char v5 = *(char *)(a3 + (int64_t)&g103); // 0xad03
    char v6 = *(char *)(a2 + (int64_t)&g103); // 0xad07
    char v7 = *(char *)(a3 + (int64_t)"NU"); // 0xad0f
    char v8 = *(char *)(a2 + (int64_t)"NU"); // 0xad13
    return (int32_t)(v4 ^ v3) << (int32_t)&g2 ^ (int32_t)(v2 ^ v1) << (int32_t)&g13 ^ (int32_t)(v6 ^ v5) ^ (int32_t)(v8 ^ v7) << (int32_t)&g95;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xad6f - 0xad9f
// Line range:    7760 - 7797
void Gen_Identify_Key(char * OutputKey, char * InputKey, char * RandomKey) {
    int64_t v1 = (int64_t)OutputKey;
    int64_t v2; // 0xad6f
    int64_t v3 = v2 ^ (int64_t)InputKey;
    int64_t v4; // 0xad6f
    int64_t v5 = v4 ^ v3;
    int64_t v6; // 0xad6f
    int32_t v7 = v6 ^ v5; // 0xad7d
    *(int32_t *)OutputKey = (int32_t)v3;
    *(int32_t *)(v1 + (int64_t)&g86) = (int32_t)v5;
    *(int32_t *)(v1 + (int64_t)&g95) = v7;
    int64_t v8; // 0xad6f
    *(int32_t *)(v1 + (int64_t)"GNU") = (int32_t)v8 ^ 178 ^ v7;
}

// Address range: 0xad9f - 0xaf06
int64_t Gen_Identify_Key2(int64_t a1, int64_t a2) {
    // 0xad9f
    mcount();
    __readgsqword(40);
    int32_t v1; // bp-40, 0xad9f
    int64_t v2 = &v1; // 0xadbf
    int64_t v3 = a2; // 0xadbf
    int64_t v4; // 0xad9f
    *(char *)v2 = *(char *)v3 ^ *(char *)v4;
    v3++;
    v2 += (int64_t)&g1;
    v4++;
    while (v3 != a2 + (int64_t)&g2) {
        // 0xadc3
        *(char *)v2 = *(char *)v3 ^ *(char *)v4;
        v3++;
        v2 += (int64_t)&g1;
        v4++;
    }
    // 0xaddb
    abort();
    // UNREACHABLE
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xaf07 - 0xaf37
// Line range:    10727 - 10741
char DTV_GetIRData(int64_t pTuner, char * pu8OutPutBuf, char * valid_cnt) {
    int64_t v1 = (int64_t)valid_cnt & 0xffffffff;
    *(int32_t *)(v1 - 16) = *(int32_t *)v1;
    int64_t result = v1 + (int64_t)&g86; // 0xaf0e
    int64_t v2; // 0xaf07
    while (result != v2) {
        // 0xaf09
        v1 = result;
        *(int32_t *)(v1 - 16) = *(int32_t *)v1;
        result = v1 + (int64_t)&g86;
    }
    // 0xaf17
    return result;
}

// Address range: 0xaf37 - 0xaf4f
int64_t DTV_GetIRData2(int64_t a1, int64_t a2) {
    // 0xaf37
    return mcount();
}

// Address range: 0xaf70 - 0xaf76
int64_t function_af70(void) {
    // 0xaf70
    int64_t result; // 0xaf70
    int32_t * v1 = (int32_t *)(result - 119); // 0xaf70
    *v1 = *v1 - (int32_t)&g1;
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xaf8a - 0xafba
// Line range:    10497 - 10504
char DTV_GetDecryptionInformation(int64_t pTuner, char * keyarray, int32_t * hw_version) {
    // 0xaf8a
    int64_t v1; // 0xaf8a
    char v2 = (char)v1 & (char)&g24; // 0xaf8a
    if (v2 != 0) {
        int64_t v3; // 0xaf8a
        char * v4 = (char *)(v3 - 115); // 0xaf8a
        char v5 = *v4; // 0xaf8a
        *v4 = v5 << (char)&g95 - v2 | v5;
    }
    int64_t v6; // 0xaf8a
    memcpy(v6, (int64_t)keyarray, (int64_t)hw_version, v1);
    int64_t v7 = __readgsqword(40); // 0xafa0
    int64_t result = &g1; // 0xafa9
    int64_t v8; // 0xaf8a
    if (*(int64_t *)(v8 - 24) != v7) {
        // 0xafab
        result = __stack_chk_fail();
    }
    // 0xafb0
    return result;
}

// Address range: 0xafba - 0xafbe
int64_t DTV_GetDecryptionInformation2(void) {
    // 0xafba
    int64_t result; // 0xafba
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xafc2 - 0xaff2
// Line range:    8753 - 8782
int32_t BCAS_CMDSet(char * PDev, char * buffer, int32_t size, char bInitCmd, char * bcas) {
    // 0xafc2
    uint64_t v1; // 0xafc2
    int64_t v2; // 0xafc2
    *(char *)v2 = (char)v2 + (char)(v1 >> (uint64_t)(int64_t)&g95);
    int64_t result; // 0xafc2
    if (PDev != NULL) {
        int64_t v3 = (int64_t)PDev;
        *(int64_t *)buffer = *(int64_t *)(v3 + (int64_t)&g45);
        int64_t v4 = *(int64_t *)(v3 + (int64_t)&g45 + (int64_t)&g95); // 0xafda
        *(int64_t *)((int64_t)buffer + (int64_t)&g95) = v4;
        *(int32_t *)(int64_t)size = (int32_t)*(char *)(v3 + 0x8f475);
        result = &g1;
    }
    // 0xaff0
    return result;
}

// Address range: 0xaff2 - 0xb033
int64_t BCAS_CMDSet2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0xaff2
    mcount();
    *(int32_t *)(a1 + 400) = (uint32_t)(int32_t)a3 % 256;
    return memcpy(a1 + 80, a2, a3 & 0xffffffff, a4);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb037 - 0xb067
// Line range:    7799 - 7815
void Get_Unique_ID(int64_t pTuner, char * ID) {
    // 0xb037
    int64_t v1; // 0xb037
    char * v2 = (char *)(v1 - 93 + v1 * (int64_t)&g86); // 0xb039
    *v2 = *v2 + (char)v1;
    int64_t v3; // 0xb037
    char * v4 = (char *)(v3 * ((int64_t)&g1 + 1)); // 0xb03d
    char v5 = v3; // 0xb03d
    *v4 = *v4 & v5;
    char * v6 = (char *)v3; // 0xb045
    *v6 = *v6 + v5;
    uint64_t v7; // 0xb037
    uint64_t v8 = (((v3 + (v7 >> (int64_t)&g95)) % 256 << (int64_t)&g95 | v7 & -0xff01) >> (int64_t)&g95) + v3; // 0xb047
    int64_t v9 = v8 % 256 | v3 & -256; // 0xb047
    char * v10 = (char *)v9; // 0xb04c
    *v10 = *v10 + (char)v8;
    char * v11 = (char *)(v9 + (int64_t)&g89); // 0xb04e
    uint64_t v12; // 0xb037
    *v11 = *v11 + (char)(v12 >> (int64_t)&g95);
}

// Address range: 0xb067 - 0xb103
int64_t Get_Unique_ID2(int64_t a1, int64_t a2) {
    // 0xb067
    mcount();
    __readgsqword(40);
    return *(int64_t *)(*(int64_t *)(a1 + 0x1d38) + 0x4fa1);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb106 - 0xb136
// Line range:    10709 - 10725
char DTV_GetEmergencyAlarmStatus(int64_t pTnim, char u8TunerNum, char * emergencyAlarmStatus) {
    int16_t v1 = (int64_t)emergencyAlarmStatus; // 0xb108
    __asm_out_622(v1, __asm_in(v1));
    int64_t v2; // 0xb106
    *(char *)(v2 - 17) = (char)&g7;
    Gen_Identify_Key2(pTnim, (int64_t)u8TunerNum);
    char result = 0; // 0xb12d
    if (*(int64_t *)(v2 - 8) != __readgsqword(40)) {
        // 0xb12f
        result = __stack_chk_fail();
    }
    // 0xb134
    return result;
}

// Address range: 0xb136 - 0xb167
int64_t DTV_GetEmergencyAlarmStatus2(int64_t a1, int64_t a2, int64_t a3) {
    // 0xb136
    mcount();
    if (a1 != 0) {
        // 0xb15b
        return &g1;
    }
    // 0xb14c
    *(char *)a3 = 0;
    return 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb167 - 0xb197
// Line range:    10691 - 10707
char DTV_GetAGCValue(int64_t pTnim, char u8TunerNum, int64_t * agcvalue) {
    // 0xb167
    int64_t result; // 0xb167
    if (agcvalue != NULL) {
        // 0xb16c
        int64_t v1; // 0xb167
        *(char *)v1 = (char)TC_GetEmergencyAlarmStatus2();
        result = &g1;
    }
    // 0xb190
    return result;
}

// Address range: 0xb197 - 0xb1cc
int64_t DTV_GetAGCValue2(int64_t a1, int64_t a2, int64_t a3) {
    // 0xb197
    mcount();
    if (a1 != 0) {
        // 0xb1c0
        return &g1;
    }
    // 0xb1ad
    *(int64_t *)a3 = 0;
    return 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb1cd - 0xb1fd
// Line range:    10671 - 10689
char DTV_GetBERValue(int64_t pTnim, char u8TunerNum, int64_t * BER1, int64_t * BER2) {
    // 0xb1cd
    int64_t result; // 0xb1cd
    if ((int32_t)(int64_t)BER1 != 0) {
        // 0xb1d1
        int64_t v1; // 0xb1cd
        *(int64_t *)v1 = TC_GetAGC2();
        result = &g1;
    }
    // 0xb1f6
    return result;
}

// Address range: 0xb1fd - 0xb236
int64_t DTV_GetBERValue2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t result = mcount(); // 0xb201
    if (a1 != 0) {
        // 0xb22a
        return result;
    }
    if (a3 != 0) {
        // 0xb210
        *(int64_t *)a3 = 0;
    }
    // 0xb217
    *(int64_t *)a4 = 0;
    return 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb236 - 0xb266
// Line range:    10653 - 10669
char DTV_GetCNRegisterValue(int64_t pTnim, unsigned char u8TunerNum, int64_t * cnvalue) {
    // 0xb236
    int64_t v1; // 0xb236
    if (v1 != 0) {
        int64_t v2 = u8TunerNum;
        TC_GetBER2(pTnim, v2, (int64_t)cnvalue, v1, pTnim + 0x5960 + v2 * ((int64_t)&g86 + 1 << (int64_t)&g86));
    }
    // 0xb264
    return &g1;
}

// Address range: 0xb266 - 0xb29b
int64_t DTV_GetCNRegisterValue2(int64_t a1, char a2, int64_t * a3) {
    // 0xb266
    mcount();
    if (a1 != 0) {
        // 0xb28f
        return &g1;
    }
    // 0xb27c
    *a3 = 0;
    return 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb29c - 0xb2cc
// Line range:    10635 - 10651
char DTV_GetCNValue(int64_t pTnim, unsigned char u8TunerNum, int64_t * cnvalue) {
    // 0xb29c
    int64_t result; // 0xb29c
    if ((int32_t)(int64_t)cnvalue != 0) {
        int64_t v1 = u8TunerNum;
        int64_t v2 = TC_GetCNRegister2(pTnim, v1, pTnim + 0x5960 + v1 * ((int64_t)&g86 + 1 << (int64_t)&g86)); // 0xb2b8
        int64_t v3; // 0xb29c
        *(int64_t *)v3 = v2;
        result = &g1;
    }
    // 0xb2c5
    return result;
}

// Address range: 0xb2cc - 0xb301
int64_t DTV_GetCNValue2(int64_t a1, int64_t a2, int64_t a3) {
    // 0xb2cc
    mcount();
    if (a1 != 0) {
        // 0xb2f5
        return &g1;
    }
    // 0xb2e2
    *(int64_t *)a3 = 0;
    return 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb302 - 0xb323
// Line range:    130 - 136
char TLIB_I2C_Write_Middle(char * tuner_globe_data, unsigned char I2C_Addr, char byReg, char * pBuffer, char byCount, char I2C_Mode) {
    int64_t v1 = (int64_t)tuner_globe_data;
    int64_t v2 = I2C_Addr; // 0xb306
    int64_t result = TC_GetCN2(v1, v2, v1 + 0x5960 + v2 * ((int64_t)&g86 + 1 << (int64_t)&g86)); // 0xb31e
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb325 - 0xb332
// Line range:    137 - 143
char TLIB_I2C_Read_Middle(char * tuner_globe_data, char I2C_Addr, char byReg, char * pBuffer, char byCount, char I2C_Mode) {
    // 0xb325
    int64_t result; // 0xb325
    return result;
}

// Address range: 0xb332 - 0xb346
int64_t TLIB_I2C_Write_Middle2(int64_t a1, int64_t a2, int64_t a3) {
    // 0xb332
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb348 - 0xb355
// Line range:    10400 - 10463
int32_t DTV_GetBCASCommand(int64_t pTuner, int64_t bcas_command, int64_t GetLen) {
    // 0xb348
    int64_t v1; // 0xb348
    uint64_t v2; // 0xb348
    int64_t v3; // 0xb348
    return TLIB_I2C_Write2(pTuner, bcas_command, GetLen & -0xff01 | 0xc900, v3, v2 % 256, v1);
}

// Address range: 0xb355 - 0xb378
int64_t TLIB_I2C_Read_Middle2(int64_t a1, uint64_t a2, uint64_t a3, int64_t a4, uint64_t a5, uint64_t a6) {
    // 0xb355
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 56); // 0xb365
    return TLIB_I2C_Read2(v1, a2 % 256, a3 % 256, (int64_t *)a4, (int64_t *)(a5 % 256), a6 % 256);
}

// Address range: 0xb378 - 0xb4f8
int64_t DTV_GetBCASCommand2(int64_t a1, int64_t a2, uint64_t a3) {
    // 0xb378
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x1d38) + 440; // 0xb3d2
    down(v1, a2);
    char * v2 = (char *)(a1 + 0x926d8); // 0xb3e1
    if (*v2 == 1) {
        // 0xb3ea
        up(v1);
        return 0xffffffff;
    }
    uint64_t v3 = *(int64_t *)(a1 + 0x926d0); // 0xb3fc
    int64_t v4 = v3 < a3 ? v3 : a3; // 0xb406
    *v2 = (char)&g1;
    int64_t * v5 = (int64_t *)(a1 + 0x926c0); // 0xb411
    int64_t v6 = *v5; // 0xb411
    int64_t result; // 0xb378
    int64_t v7; // 0xb378
    if (v4 + v6 < 17) {
        // 0xb4b6
        int64_t v8; // 0xb378
        memcpy(a2, a1 + 0x8fe40 + 648 * v6, v4 * 8 * ((int64_t)&g95 + 1 + ((int64_t)&g95 + 1) * (int64_t)&g95), v8);
        int64_t v9 = *v5 + v4; // 0xb4dd
        int64_t v10 = v9 == 16 ? 0 : v9; // 0xb4ed
        v7 = v10;
        result = v10;
    } else {
        int64_t v11 = (int64_t)&g2 - v6; // 0xb42c
        int64_t v12 = v4 - v11; // 0xb432
        int64_t v13 = a1 + 0x8fe40; // 0xb449
        memcpy(a2, 648 * v6 + v13, v11 * ((int64_t)&g95 + 1 + ((int64_t)&g95 + 1) * (int64_t)&g95 << (int64_t)&g33), v13);
        int64_t v14 = v11 - 16 + *v5; // 0xb46f
        *v5 = v14;
        memcpy(v11 * ((int64_t)&g95 + 1 + ((int64_t)&g95 + 1) * (int64_t)&g95 << (int64_t)&g33) * (int64_t)&g1 + a2, 648 * v14 + v13, v12 * ((int64_t)&g95 + 1 + ((int64_t)&g95 + 1) * (int64_t)&g95 << (int64_t)&g33), v13);
        v7 = *v5 + v12;
        result = v12;
    }
    // 0xb4f8
    *v5 = v7;
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb4fe - 0xb52e
// Line range:    10325 - 10364
char DTV_SaveBCASCommand(int64_t pTuner, int64_t bcas_command) {
    // 0xb4fe
    uint64_t v1; // 0xb4fe
    int64_t v2; // 0xb4fe
    int64_t v3 = (unsigned char)(-1 - (char)(v1 >> (uint64_t)(int64_t)&g95)) < (unsigned char)(char)v2 ? 39 : 38; // 0xb500
    int64_t v4 = v2 - v3; // 0xb500
    int32_t * v5 = (int32_t *)(v4 & 0xffffffff); // 0xb503
    *v5 = *v5 | (int32_t)v4;
    int64_t v6; // 0xb4fe
    char * v7 = (char *)(v6 - 1 + v6 * (int64_t)&g86); // 0xb505
    *v7 = *v7 + (char)v6;
    up(pTuner);
    int64_t result; // 0xb4fe
    return result;
}

// Address range: 0xb52e - 0xb70e
int64_t DTV_SaveBCASCommand2(int64_t a1, int64_t a2) {
    // 0xb52e
    mcount();
    if (a1 == 0) {
        // 0xb68c
        return 0;
    }
    int64_t v1 = *(int64_t *)(a1 + 0x1d38) + 440; // 0xb56a
    down(v1, a2);
    char * v2 = (char *)(a1 + 0x926d8); // 0xb579
    if (*v2 == 1) {
        // 0xb582
        up(v1);
        // 0xb68c
        return 0;
    }
    // 0xb594
    *v2 = (char)&g1;
    int64_t * v3 = (int64_t *)(a1 + 0x926c8); // 0xb59b
    int64_t v4 = *v3; // 0xb59b
    if (v4 >= 16) {
        int64_t v5 = v4 + 0xfffffff1; // 0xb5b0
        int64_t v6 = 0x100000000 * ((int64_t)(int32_t)&g1 - 0xfffffff1 - v4) / 0x100000000; // 0xb5bd
        int64_t v7 = a1 + 0x8fe40; // 0xb5c0
        int64_t v8; // 0xb52e
        memcpy(648 * v4 + v7, a2, v6 * ((int64_t)&g95 + 1 + ((int64_t)&g95 + 1) * (int64_t)&g95 << (int64_t)&g33), v8);
        int64_t v9; // 0xb52e
        if ((int32_t)v5 != 0) {
            int64_t v10 = 0x100000000 * v5 / 0x100000000; // 0xb60d
            memcpy(v7, a2, v10 * ((int64_t)&g95 + 1 + ((int64_t)&g95 + 1) * (int64_t)&g95 << (int64_t)&g33), v8);
            v9 = v10;
        } else {
            int64_t v11 = *v3 + v6; // 0xb5f0
            v9 = v11 == 16 ? 0 : v11;
        }
        // 0xb62f
        *v3 = v9;
        int64_t * v12 = (int64_t *)(a1 + 0x926d0); // 0xb62f
        int64_t v13 = *v12; // 0xb62f
        if (v13 == 16) {
            // 0xb63c
            *(int64_t *)(a1 + 0x926c0) = v9;
            // 0xb678
            *v2 = 0;
            up(v1);
            // 0xb68c
            return &g1;
        }
        uint64_t v14 = v13 + 1; // 0xb64c
        if (v14 < 17) {
            // 0xb671
            *v12 = v14;
        } else {
            // 0xb656
            *(int64_t *)(a1 + 0x926c0) = v9;
            *v12 = (int64_t)&g2;
        }
        // 0xb678
        *v2 = 0;
        up(v1);
        // 0xb68c
        return &g1;
    }
    int64_t v15 = a1 + 0x8fe40 + 648 * v4; // 0xb6aa
    int64_t v16 = a2; // 0xb6be
    int64_t v17 = 648; // 0xb6be
    int64_t v18 = v15; // 0xb6be
    if (v15 % 2 != 0) {
        // 0xb6c0
        *(char *)v15 = (char)a2;
        v16 = a2 + (int64_t)&g1;
        v17 = 647;
        v18 = v15 + 1;
    }
    int64_t v19 = v16; // 0xb6d5
    int64_t v20 = v17; // 0xb6d5
    int64_t v21 = v18; // 0xb6d5
    if ((v18 & 2) != 0) {
        // 0xb6d7
        *(int16_t *)v18 = *(int16_t *)v16;
        v19 = v16 + (int64_t)&g25;
        v20 = v17 + 1022 & 767;
        v21 = v18 + 2;
    }
    int64_t v22 = v19; // 0xb6ec
    int64_t result = v20; // 0xb6ec
    int64_t v23 = v21; // 0xb6ec
    if ((v21 & 4) != 0) {
        // 0xb6ee
        *(int32_t *)v21 = *(int32_t *)v19;
        v22 = v19 + (int64_t)&g86;
        result = v20 + 0xfffffffc & 0xffffffff;
        v23 = v21 + 4;
    }
    // 0xb6fd
    __asm_rep_movsq_memcpy((char *)v23, (char *)v22, (int64_t)((int32_t)result >> (int32_t)&g33));
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb70e - 0xb73e
// Line range:    10260 - 10323
int32_t DTV_GetTSReSync(int64_t pTuner, char * pu8OutPutBuf, int64_t GetLen) {
    int64_t v1 = (int64_t)pu8OutPutBuf;
    int64_t v2 = GetLen; // 0xb70e
    bool v3; // 0xb70e
    if (!v3) {
        // 0xb710
        *(int32_t *)pTuner = (int32_t)v1;
        v2 = GetLen + (int64_t)&g86;
    }
    // 0xb718
    int64_t v4; // 0xb70e
    char v5 = v4; // 0xb718
    int64_t v6 = v2; // 0xb71a
    if ((v5 & (char)&g25) != 0) {
        int64_t v7 = v2 * (int64_t)&g1; // 0xb71c
        *(int16_t *)(v7 + pTuner) = *(int16_t *)(v7 + v1);
        v6 = v2 + (int64_t)&g25;
    }
    int64_t result; // 0xb70e
    if ((v5 & (char)&g1) != 0) {
        int64_t v8 = v6 * (int64_t)&g1; // 0xb72c
        unsigned char v9 = *(char *)(v8 + v1); // 0xb72c
        *(char *)(v8 + pTuner) = v9;
        result = v9;
    }
    // 0xb733
    return result;
}

// Address range: 0xb73e - 0xb877
int64_t DTV_GetTSReSync2(int64_t a1, int64_t a2, uint64_t a3) {
    // 0xb73e
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x1d38) + 416; // 0xb798
    down(v1, a2);
    char * v2 = (char *)(a1 + 0x8fe38); // 0xb7a7
    if (*v2 == 1) {
        // 0xb7b0
        up(v1);
        return 0xffffffff;
    }
    uint64_t v3 = *(int64_t *)(a1 + 0x8fe30); // 0xb7c2
    int64_t v4 = v3 < a3 ? v3 : a3; // 0xb7cc
    *v2 = (char)&g1;
    int64_t * v5 = (int64_t *)(a1 + 0x8fe20); // 0xb7d7
    int64_t v6 = *v5; // 0xb7d7
    int64_t result; // 0xb73e
    int64_t v7; // 0xb73e
    int64_t v8; // 0xb73e
    if (v4 + v6 < 65) {
        // 0xb846
        memcpy(a2, a1 + 0x8fde0 + v6, v4, v8);
        int64_t v9 = *v5 + v4; // 0xb85c
        int64_t v10 = v9 == 64 ? 0 : v9; // 0xb86c
        v7 = v10;
        result = v10;
    } else {
        int64_t v11 = 64 - v6; // 0xb7ee
        int64_t v12 = v4 - v11; // 0xb7f4
        int64_t v13 = a1 + 0x8fde0; // 0xb7fb
        memcpy(a2, v6 + v13, v11, v8);
        int64_t v14 = v11 - 64 + *v5; // 0xb81b
        *v5 = v14;
        memcpy(v11 + a2, v14 + v13, v12, v8);
        v7 = *v5 + v12;
        result = v12;
    }
    // 0xb877
    *v5 = v7;
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb87d - 0xb8ad
// Line range:    10185 - 10224
char DTV_SaveTSReSync(int64_t pTuner, char * pReceiveDataBuf) {
    // 0xb87d
    int64_t v1; // 0xb87d
    *(char *)v1 = (char)v1;
    int64_t v2; // 0xb87d
    char * v3 = (char *)(v2 - 9 + v2 * (int64_t)&g86); // 0xb884
    *v3 = *v3 + (char)v2;
    up(pTuner);
    int64_t result; // 0xb87d
    return result;
}

// Address range: 0xb8ad - 0xb9ec
int64_t DTV_SaveTSReSync2(int64_t a1, char * a2) {
    int64_t v1 = (int64_t)a2;
    mcount();
    int64_t v2 = *(int64_t *)(a1 + 0x1d38) + 416; // 0xb8e9
    down(v2, v1);
    char * v3 = (char *)(a1 + 0x8fe38); // 0xb8f8
    if (*v3 == 1) {
        // 0xb901
        up(v2);
        return 0;
    }
    // 0xb913
    *v3 = (char)&g1;
    int64_t * v4 = (int64_t *)(a1 + 0x8fe28); // 0xb91a
    int64_t v5 = *v4; // 0xb91a
    int64_t v6 = v5 + 0xffffffc1; // 0xb92f
    int64_t v7 = 0x100000000 * ((int64_t)(int32_t)&g1 - 0xffffffc1 - v5) / 0x100000000; // 0xb93c
    int64_t v8 = a1 + 0x8fde0; // 0xb93f
    int64_t v9; // 0xb8ad
    memcpy(v5 + v8, v1, v7, v9);
    int64_t v10; // 0xb8ad
    if ((int32_t)v6 != 0) {
        int64_t v11 = 0x100000000 * v6 / 0x100000000; // 0xb97a
        memcpy(v8, v7 + v1, v11, v9);
        v10 = v11;
    } else {
        int64_t v12 = *v4 + v7; // 0xb95d
        v10 = v12 == 64 ? 0 : v12;
    }
    // 0xb994
    *v4 = v10;
    int64_t * v13 = (int64_t *)(a1 + 0x8fe30); // 0xb994
    int64_t v14 = *v13; // 0xb994
    if (v14 == 64) {
        // 0xb9a1
        *(int64_t *)(a1 + 0x8fe20) = v10;
        // 0xb9dd
        *v3 = 0;
        return up(v2);
    }
    uint64_t v15 = v14 + 1; // 0xb9b1
    if (v15 < 65) {
        // 0xb9d6
        *v13 = v15;
    } else {
        // 0xb9bb
        *(int64_t *)(a1 + 0x8fe20) = v10;
        *v13 = 64;
    }
    // 0xb9dd
    *v3 = 0;
    return up(v2);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xb9ee - 0xba1e
// Line range:    10120 - 10183
int32_t DTV_GetBcasReturnCode(int64_t pTuner, char * pu8OutPutBuf, int64_t GetLen) {
    // 0xb9ee
    int64_t result; // 0xb9ee
    *(char *)result = 2 * (char)result;
    char * v1 = (char *)(result - 117); // 0xb9f0
    int64_t v2; // 0xb9ee
    *v1 = *v1 + (char)v2;
    return result;
}

// Address range: 0xba1e - 0xbb57
int64_t DTV_GetBcasReturnCode2(int64_t a1, int64_t a2, int64_t a3) {
    // 0xba1e
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xbb5d - 0xbb8d
// Line range:    10045 - 10084
char DTV_SaveBcasReturnCode(int64_t pTuner, char * pReceiveDataBuf) {
    // 0xbb5d
    uint64_t v1; // 0xbb5d
    int64_t v2; // 0xbb5d
    int64_t v3 = (unsigned char)(-1 - (char)(v1 >> (uint64_t)(int64_t)&g95)) < (unsigned char)(char)v2 ? 0xfffffffe : 0xfffffffd; // 0xbb5f
    int64_t v4 = v2 - v3; // 0xbb5f
    char * v5 = (char *)(v4 & 0xffffffff); // 0xbb62
    *v5 = *v5 | (char)v4;
    int64_t v6; // 0xbb5d
    char * v7 = (char *)(v6 - 9 + v6 * (int64_t)&g86); // 0xbb64
    *v7 = *v7 + (char)v6;
    up(pTuner);
    int64_t result; // 0xbb5d
    return result;
}

// Address range: 0xbb8d - 0xbccc
int64_t DTV_SaveBcasReturnCode2(int64_t a1, char * a2) {
    int64_t v1 = (int64_t)a2;
    mcount();
    int64_t v2 = *(int64_t *)(a1 + 0x1d38) + 392; // 0xbbc9
    down(v2, v1);
    char * v3 = (char *)(a1 + 0x8fdd8); // 0xbbd8
    if (*v3 == 1) {
        // 0xbbe1
        up(v2);
        return 0;
    }
    // 0xbbf3
    *v3 = (char)&g1;
    int64_t * v4 = (int64_t *)(a1 + 0x8fdc8); // 0xbbfa
    int64_t v5 = *v4; // 0xbbfa
    int64_t v6 = v5 + 0xffffffc4; // 0xbc0f
    int64_t v7 = 0x100000000 * ((int64_t)(int32_t)&g86 - 0xffffffc4 - v5) / 0x100000000; // 0xbc1c
    int64_t v8 = a1 + 0x8fd80; // 0xbc1f
    int64_t v9; // 0xbb8d
    memcpy(v5 + v8, v1, v7, v9);
    int64_t v10; // 0xbb8d
    if ((int32_t)v6 != 0) {
        int64_t v11 = 0x100000000 * v6 / 0x100000000; // 0xbc5a
        memcpy(v8, v7 + v1, v11, v9);
        v10 = v11;
    } else {
        int64_t v12 = *v4 + v7; // 0xbc3d
        v10 = v12 == 64 ? 0 : v12;
    }
    // 0xbc74
    *v4 = v10;
    int64_t * v13 = (int64_t *)(a1 + 0x8fdd0); // 0xbc74
    int64_t v14 = *v13; // 0xbc74
    if (v14 == 64) {
        // 0xbc81
        *(int64_t *)(a1 + 0x8fdc0) = v10;
        // 0xbcbd
        *v3 = 0;
        return up(v2);
    }
    uint64_t v15 = v14 + 4; // 0xbc91
    if (v15 < 65) {
        // 0xbcb6
        *v13 = v15;
    } else {
        // 0xbc9b
        *(int64_t *)(a1 + 0x8fdc0) = v10;
        *v13 = 64;
    }
    // 0xbcbd
    *v3 = 0;
    return up(v2);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xbccd - 0xbcfd
// Line range:    9876 - 9910
char DTV_GetProgramNumber_ByPID(int64_t pTuner, int32_t Pid, int32_t * program_number) {
    // 0xbccd
    int64_t v1; // 0xbccd
    *(int32_t *)v1 = 2 * (int32_t)v1;
    int64_t result; // 0xbccd
    int64_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0xbcfd - 0xbd24
int64_t DTV_GetProgramNumber_ByPID2(int64_t a1, int64_t a2, int64_t a3) {
    // 0xbcfd
    mcount();
    *(int32_t *)a3 = 0;
    return 0xfffffff6;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xbd26 - 0xbd56
// Line range:    9851 - 9874
char DTV_GetResetMulti2LibFlag(int64_t pTuner, char * isNeedResetMulti2Lib) {
    // 0xbd26
    int64_t v1; // 0xbd26
    int32_t * v2 = (int32_t *)(v1 + 0x480008fa); // 0xbd26
    *v2 = (int32_t)(int64_t)isNeedResetMulti2Lib;
    if ((int32_t)v1 == 0 || *(char *)(pTuner + 0x8fabc) == 0) {
        // 0xbd54
        return &g1;
    }
    // 0xbd39
    int64_t v3; // 0xbd26
    if ((char)TS_GetProgramNumber_ByPID2(v1, (int64_t)(*v2 % 0x10000), v3) == 0) {
        // 0xbd54
        return -2;
    }
    // 0xbd54
    return &g1;
}

// Address range: 0xbd56 - 0xbd64
int64_t DTV_GetResetMulti2LibFlag2(int64_t a1) {
    // 0xbd56
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xbd69 - 0xbd99
// Line range:    9811 - 9849
char DTV_GetContentAvailabilityDescriptor(int64_t pTuner, int32_t Pid, char * Buffer, int32_t * real_length) {
    // 0xbd69
    int64_t v1; // 0xbd69
    *(char *)v1 = (char)v1;
    if (v1 == 0) {
        // 0xbd97
        return 0;
    }
    // 0xbd70
    if (*(char *)(pTuner + 0x8fabc) == 0) {
        // 0xbd88
        *(char *)(int64_t)Pid = 0;
    } else {
        // 0xbd79
        TS_GetResetMulti2LibFlag2(v1);
    }
    // 0xbd97
    return &g1;
}

// Address range: 0xbd99 - 0xbdd4
int64_t DTV_GetContentAvailabilityDescriptor2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0xbd99
    mcount();
    *(int32_t *)a4 = 0;
    return *(int64_t *)(a1 + 0x8fab0);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xbdd5 - 0xbe05
// Line range:    9772 - 9809
char DTV_GetDigitalCopyControlDescriptor(int64_t pTuner, int32_t Pid, char * Buffer, int32_t * real_length) {
    // 0xbdd5
    int64_t v1; // 0xbdd5
    int64_t v2; // 0xbdd5
    char * v3 = (char *)(v1 + 15 + v2); // 0xbdda
    *v3 = *v3 + (char)((int64_t)Buffer / 256);
    int64_t v4; // 0xbdd5
    int64_t v5 = TS_GetContentAvailabilityDescriptor2(v4); // 0xbde3
    char result = &g1; // 0xbdea
    if ((char)v5 == 0) {
        // 0xbdec
        *(int32_t *)(v2 & -0xff01 | 0xf600) = 0;
        result = -2;
    }
    // 0xbdfe
    return result;
}

// Address range: 0xbe05 - 0xbe40
int64_t DTV_GetDigitalCopyControlDescriptor2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0xbe05
    mcount();
    *(int32_t *)a4 = 0;
    return *(int64_t *)(a1 + 0x8fab0);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xbe41 - 0xbe71
// Line range:    9752 - 9770
char DTV_SetBCASCardExist(int64_t pTuner, char isExist) {
    // 0xbe41
    int64_t v1; // 0xbe41
    int64_t v2; // 0xbe41
    char * v3 = (char *)(v1 + 15 + v2); // 0xbe46
    uint64_t v4; // 0xbe41
    *v3 = *v3 + (char)(v4 / 256);
    int64_t v5; // 0xbe41
    int64_t v6 = TS_GetDigitalCopyControlDescriptor2(v5); // 0xbe4f
    char result = &g1; // 0xbe56
    if ((char)v6 == 0) {
        // 0xbe58
        *(int32_t *)(v2 & -0xff01 | 0xf600) = 0;
        result = -2;
    }
    // 0xbe6a
    return result;
}

// Address range: 0xbe71 - 0xbe7f
int64_t DTV_SetBCASCardExist2(int64_t a1) {
    // 0xbe71
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xbe83 - 0xbeb3
// Line range:    9727 - 9750
char DTV_GetIsStreamScramble(int64_t pTuner, char * isStreamScramble) {
    // 0xbe83
    int64_t v1; // 0xbe83
    *(char *)v1 = (char)v1;
    int64_t v2; // 0xbe83
    if (v2 == 0) {
        // 0xbeb1
        return 0;
    }
    // 0xbe8b
    if (*(char *)(pTuner + 0x8fabc) != 0) {
        // 0xbe99
        TS_SetBCASCardExist2(v2, (int64_t)isStreamScramble % 256);
    }
    // 0xbeb1
    return &g1;
}

// Address range: 0xbeb3 - 0xbec1
int64_t DTV_GetIsStreamScramble2(int64_t a1) {
    // 0xbeb3
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xbec6 - 0xbef6
// Line range:    9707 - 9725
char DTV_SetIsStreamScramble(int64_t pTuner, char isStreamScramble) {
    // 0xbec6
    int64_t v1; // 0xbec6
    *(char *)v1 = (char)v1;
    if (v1 == 0) {
        // 0xbef4
        return 0;
    }
    // 0xbecd
    if (*(char *)(pTuner + 0x8fabc) == 0) {
        // 0xbee5
        *(char *)(int64_t)isStreamScramble = (char)&g1;
    } else {
        // 0xbed6
        TS_GetIsStreamScramble2(v1);
    }
    // 0xbef4
    return &g1;
}

// Address range: 0xbef6 - 0xbf04
int64_t DTV_SetIsStreamScramble2(int64_t a1) {
    // 0xbef6
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xbf08 - 0xbf15
// Line range:    126 - 129
void TLIB_Delay_Middle(int64_t dwMilliseconds) {
    // 0xbf08
    int64_t v1; // 0xbf08
    *(char *)v1 = (char)v1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xbf18 - 0xbf38
// Line range:    9617 - 9704
char DTV_SetTunerTSID(int64_t pTuner, int32_t tsid, char preset) {
    uint64_t v1 = (int64_t)preset;
    int64_t v2; // 0xbf18
    *(char *)v2 = (char)v2;
    int64_t v3; // 0xbf18
    char * v4 = (char *)(v3 + 64 + v2); // 0xbf1b
    *v4 = *v4 + (preset >> 7);
    TS_SetIsStreamScramble2(v1, (v1 >> (int64_t)&g95) % 256);
    return &g1;
}

// Address range: 0xbf38 - 0xbf48
int64_t TLIB_Delay_Middle2(void) {
    // 0xbf38
    mcount();
    int64_t v1; // 0xbf38
    return TLIB_Delay2((int64_t *)v1);
}

// Address range: 0xbf48 - 0xc0cf
int64_t DTV_SetTunerTSID2(int64_t a1, uint32_t a2, uint64_t a3) {
    // 0xbf48
    mcount();
    int64_t v1 = a2; // 0xbf6c
    int64_t v2 = *(int64_t *)(a1 + 0x1d38); // 0xbf6f
    int64_t v3 = (int64_t)*(char *)(a1 + 0x1d30); // 0xbf76
    if ((char)a3 != 0) {
        // 0xbf95
        return TC_TSIDWrite2(v2, v3, v1, a3 % 256, v2 + 0x5960 + 80 * v3);
    }
    char v4 = *(char *)(a1 + (int64_t)&g39); // 0xbfcb
    if (v4 == (char)&g1) {
        // 0xbfd4
        TLIB_Delay2((int64_t *)400);
        return &g1;
    }
    // 0xbfe8
    vUSB_Wait2(50);
    TC_TSIDWrite2(v2, v3, v1, 0, v2 + 0x5960 + 80 * v3);
    vUSB_Wait2(500);
    int64_t v5 = USB_FilterReset2(v2, v3); // 0xc03f
    DTV_SetPidFilterBoundary2(a1, 0x1fff, 0x1fff);
    if ((int32_t)v5 != (int32_t)&g1) {
        // 0xc049
        return 0;
    }
    char v6 = *(char *)(v2 + 1152 + v3); // 0xc07a
    if (*(int64_t *)(v2 + 1160 + 8 * v3) != 0 && v6 == 1) {
        // 0xc08c
        FUSBDTV_StopBulkStream2(v2, v3);
        FUSBDTV_StartBulkStream2(v2, v3, 128, 0x4970, a1);
    }
    int64_t result = TS_EnableProcProgramID2(*(int64_t *)(a1 + 0x8fab0), 0); // 0xc0bb
    *(char *)(a1 + 0x8fabd) = (char)&g1;
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc0d0 - 0xc100
// Line range:    9587 - 9614
char DTV_GetTunerCurrentTSID(int64_t pTuner, int32_t * tsid) {
    // 0xc0d0
    int64_t result; // 0xc0d0
    return result;
}

// Address range: 0xc100 - 0xc12d
int64_t DTV_GetTunerCurrentTSID2(int64_t a1) {
    // 0xc100
    mcount();
    return 0xfffffff6;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc12e - 0xc15e
// Line range:    9564 - 9585
char DTV_GetProgramIDList(int64_t pTuner, int32_t * program_id_list, unsigned char list_length) {
    // 0xc12e
    int64_t v1; // 0xc12e
    int64_t v2; // 0xc12e
    int64_t v3 = TC_CurrentTSIDRead2(v1, (int64_t)list_length, (int64_t)program_id_list, v1 + 0x5960 + (80 * v2 + 0x943271b50 & 0xffffffff0)); // 0xc14d
    char result = (char)v3 < (char)&g1 ? (char)&g1 - 3 : (char)&g1; // 0xc159
    return result;
}

// Address range: 0xc15e - 0xc1a8
int64_t DTV_GetProgramIDList2(int64_t a1, int64_t a2, int64_t a3) {
    // 0xc15e
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc1b7 - 0xc1e7
// Line range:    9544 - 9563
char DTV_SetProgramID(int64_t pTuner, int32_t program_id) {
    // 0xc1b7
    return &g1;
}

// Address range: 0xc1e7 - 0xc220
int64_t DTV_SetProgramID2(int64_t a1, int64_t a2) {
    // 0xc1e7
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc224 - 0xc254
// Line range:    9514 - 9541
char DTV_GetTunerTSIDList(int64_t pTuner, int32_t * tsidList, char listLength) {
    // 0xc224
    int64_t v1; // 0xc224
    char * v2 = (char *)(v1 - 117); // 0xc224
    int64_t v3; // 0xc224
    *v2 = *v2 + (char)v3;
    TS_EnableProcProgramID2(pTuner, (int64_t)&g1);
    int64_t v4; // 0xc224
    *(int32_t *)0x122460 = (int32_t)v4;
    return &g1;
}

// Address range: 0xc254 - 0xc288
int64_t DTV_GetTunerTSIDList2(int64_t a1) {
    // 0xc254
    mcount();
    return (int64_t)*(char *)(a1 + 0x1d30);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc288 - 0xc2b8
// Line range:    9491 - 9511
void DTV_GetProgramIDList_Ex(int64_t pTuner, int64_t program_id_list, char * program_number_count) {
    // 0xc288
    int64_t v1; // 0xc288
    uint64_t v2; // 0xc288
    int64_t v3; // 0xc288
    TC_TSIDRead2(v1, v2 % 256, program_id_list, (uint64_t)(int64_t)program_number_count % 256, v1 + 0x5960 + v3 * ((int64_t)&g86 + 1 << (uint64_t)(int64_t)&g86));
}

// Address range: 0xc2b8 - 0xc2c9
int64_t DTV_GetProgramIDList_Ex2(int64_t a1, int64_t a2, int64_t a3) {
    // 0xc2b8
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc2c9 - 0xc2f9
// Line range:    8857 - 8947
char BCAS_CMDSet_Ext(char * PDev, char * PTuner, char * buffer, int32_t size) {
    // 0xc2c9
    int64_t v1; // 0xc2c9
    if (PDev == NULL) {
        // 0xc2ef
        *(char *)v1 = 0;
        // 0xc2f2
        int64_t result; // 0xc2c9
        return result;
    }
    int64_t v2 = (int64_t)PDev;
    int64_t result2 = *(int64_t *)(v2 + 0x8fab0); // 0xc2ce
    if (result2 == 0) {
        // 0xc2ef
        *(char *)v1 = 0;
        // 0xc2f2
        return 0;
    }
    // 0xc2da
    if (*(char *)(v2 + 0x8fabc) == 0) {
        // 0xc2ef
        *(char *)v1 = 0;
        // 0xc2f2
        return result2;
    }
    char result3 = TS_GetTsProgramID_Ex2(result2);
    *(char *)v1 = result3;
    // 0xc2f2
    return result3;
}

// Address range: 0xc2f9 - 0xc428
int64_t BCAS_CMDSet_Ext2(int64_t a1, int64_t a2, int64_t * a3, char a4) {
    // 0xc2f9
    mcount();
    __readgsqword(40);
    char v1 = *(char *)(a1 + (int64_t)&g6); // 0xc338
    if (v1 != (char)&g1) {
        // 0xc3da
        __readgsqword(40);
        return 0;
    }
    uint32_t v2 = (int32_t)a4; // 0xc358
    if (v1 == 0 | (*(char *)(a1 + 0x1485) == 0 ? 60 : 255) < v2) {
        // 0xc3da
        __readgsqword(40);
        return &g1;
    }
    int64_t v3 = (int64_t)a4 & 0xffffffff; // 0xc323
    char v4; // bp-392, 0xc2f9
    __asm_rep_stosq_memset(&v4, 0, 40);
    int64_t v5 = &v4; // 0xc37d
    memcpy(v5, (int64_t)a3, v3, 0);
    int32_t * v6 = (int32_t *)(a1 + (int64_t)" c"); // 0xc388
    int64_t v7; // 0xc2f9
    int64_t v8; // 0xc2f9
    if (*v6 != v2) {
        // 0xc360
        v7 = a1 + 404;
        v8 = 0;
    } else {
        // 0xc391
        if (a4 == 0) {
            // 0xc3da
            __readgsqword(40);
            return &g1;
        }
        int64_t v9 = a1 + 404;
        v7 = v9;
        v8 = 0;
        if (*(char *)v9 == v4) {
            int64_t v10 = a1; // 0xc3b4
            int64_t v11; // bp-391, 0xc2f9
            int64_t v12 = &v11; // 0xc3b4
            int64_t v13 = &g1; // 0xc3cd
            while (v2 > (int32_t)v13) {
                int64_t v14 = v10;
                char v15 = *(char *)v12; // 0xc3bd
                v10 = v14 + (int64_t)&g1;
                v12 += (int64_t)&g1;
                v7 = v9;
                v8 = v10;
                if (*(char *)(v14 + 405) != v15) {
                    goto lab_0xc3eb;
                }
                v13 = (v13 & 0xffffffff) + (int64_t)(int32_t)&g1;
            }
            // 0xc3da
            __readgsqword(40);
            return &g1;
        }
    }
  lab_0xc3eb:
    // 0xc3eb
    *(int32_t *)(a1 + 400) = v2;
    memcpy(a1 + 80, v5, v3, v8);
    *v6 = v2;
    int64_t dest_mem = memcpy(v7, v5, v3, v8); // 0xc41c
    *(char *)(a1 + 0x15cc) = (char)&g1;
    return dest_mem;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc42f - 0xc45f
// Line range:    8784 - 8854
char BCAS_CMDGet_Ext(char * PDev, char * PTuner, char * Status, char * size, char * buffer, int64_t BufferSz) {
    // 0xc42f
    int64_t v1; // 0xc42f
    char * v2 = (char *)(v1 + 0x15cd83); // 0xc42f
    *v2 = *v2 + (char)(int64_t)size;
    int64_t result; // 0xc42f
    int64_t v3 = result;
    *(char *)v3 = *(char *)&result + (char)v3;
    return result;
}

// Address range: 0xc45f - 0xc55f
int64_t BCAS_CMDGet_Ext2(int64_t a1, int64_t a2, int64_t * a3, char * a4, int64_t * a5, int64_t a6, int64_t a7) {
    // 0xc45f
    mcount();
    __readgsqword(40);
    *(char *)a3 = *(char *)(a1 + (int64_t)&g6);
    int32_t * v1 = (int32_t *)(a1 + 1064);
    uint32_t v2 = *v1;
    if (a6 != 66) {
        if (v2 >= 260) {
            // 0xc4d0
            *v1 = 259;
        }
    } else {
        if (v2 >= 69) {
            // 0xc4b8
            *v1 = 68;
        }
    }
    // 0xc4da
    int64_t v3; // bp-376, 0xc45f
    __asm_rep_stosq_memset((char *)&v3, 0, 40);
    int64_t v4 = &v3;
    int32_t * v5; // 0xc45f
    if (*(char *)(a2 + 0x1d30) != 0) {
        int32_t * v6 = (int32_t *)(a1 + 2992); // 0xc52b
        memcpy(v4, a1 + 2999, (int64_t)(*v6 - 4), 0);
        v5 = v6;
    } else {
        int32_t * v7 = (int32_t *)(a1 + 2028); // 0xc4fd
        memcpy(v4, a1 + 2035, (int64_t)(*v7 - 4), 0);
        v5 = v7;
    }
    uint32_t result = *v5 - 4;
    *a4 = (char)result;
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc560 - 0xc590
// Line range:    6858 - 6871
void DTV_HardwareDecrypt_ASV5606(int64_t pTuner, char * Input188B, char * Output188B) {
    // 0xc560
    int64_t v1; // 0xc560
    if (*(int64_t *)(v1 - 40) != __readgsqword(40)) {
        // 0xc57d
        __stack_chk_fail();
    }
}

// Address range: 0xc590 - 0xc643
int64_t DTV_HardwareDecrypt_ASV5606_(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = a2;
    mcount();
    char v1 = a3;
    char v2 = v1; // 0xc5b4
    int64_t v3 = a3; // 0xc5b4
    int64_t v4 = 188; // 0xc5b4
    if ((v1 & (char)&g1) != 0) {
        // 0xc5b6
        *(char *)a3 = 0;
        v3 = a3 + (int64_t)&g1;
        v2 = v3;
        v4 = 187;
    }
    char v5 = v2; // 0xc5c4
    int64_t v6 = v3; // 0xc5c4
    int64_t v7 = v4; // 0xc5c4
    if ((v2 & (char)&g25) != 0) {
        // 0xc5c6
        *(int16_t *)v3 = 0;
        v6 = v3 + (int64_t)&g25;
        v5 = v6;
        v7 = v4 + 254 & 191;
    }
    int64_t v8 = v6; // 0xc5d5
    int64_t v9 = v7; // 0xc5d5
    if ((v5 & (char)&g86) != 0) {
        // 0xc5d7
        *(int32_t *)v6 = 0;
        v8 = v6 + (int64_t)&g86;
        v9 = v7 + 0xfffffffc & 0xffffffff;
    }
    int64_t v10 = (int32_t)v9 >> (int32_t)&g33; // 0xc5e7
    __asm_rep_stosq_memset((char *)v8, 0, v10);
    bool v11; // 0xc590
    int64_t v12 = (v11 ? -8 : (int64_t)&g95) * v10 + v8; // 0xc5e9
    char v13 = v9; // 0xc5ec
    int64_t v14 = v12; // 0xc5f0
    if ((v13 & (char)&g86) != 0) {
        // 0xc5f2
        *(int32_t *)v12 = 0;
        v14 = v12 + (int64_t)&g86;
    }
    int64_t v15 = v14; // 0xc5fc
    if ((v13 & (char)&g25) != 0) {
        // 0xc5fe
        *(int16_t *)v14 = 0;
        v15 = v14 + (int64_t)&g25;
    }
    if ((v13 & (char)&g1) != 0) {
        // 0xc60b
        *(char *)v15 = 0;
    }
    // 0xc60d
    *(char *)a3 = *(char *)&result;
    char v16 = *(char *)(result + (int64_t)&g1); // 0xc612
    *(char *)(a3 + (int64_t)&g1) = v16;
    char v17 = *(char *)(result + (int64_t)&g25); // 0xc619
    *(char *)(a3 + (int64_t)&g25) = v17;
    char v18 = *(char *)(result + (int64_t)&g33); // 0xc620
    *(char *)(a3 + (int64_t)&g33) = v18;
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc644 - 0xc645
// Line range:    6825 - 6837
void DTV_HardwareDecrypt_5211Ver01(int64_t pTuner, char * Input188B, char * Output188B) {
    // 0xc644
    return;
}

// Address range: 0xc646 - 0xc674
int64_t function_c646(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int32_t v1 = (uint32_t)(int32_t)a4 >> (uint32_t)(int32_t)&g19; // 0xc646
    char v2 = *(char *)(a5 + (int64_t)&g46 + (int64_t)((v1 + (int32_t)a1 & (int32_t)&g105) - v1) * (int64_t)&g1); // 0xc656
    *(char *)(a3 + (int64_t)&g86) = v2 ^ (char)a6;
    int64_t v3; // 0xc646
    return v3 + (int64_t)&g1;
}

// Address range: 0xc674 - 0xc6f8
int64_t DTV_HardwareDecrypt_5211Ver01_(int64_t a1, int64_t * a2, int64_t a3) {
    int64_t v1 = (int64_t)a2;
    mcount();
    char v2 = a3;
    char v3 = v2; // 0xc696
    int64_t v4 = a3; // 0xc696
    int64_t v5 = 188; // 0xc696
    if ((v2 & (char)&g1) != 0) {
        // 0xc698
        *(char *)a3 = 0;
        v4 = a3 + (int64_t)&g1;
        v3 = v4;
        v5 = 187;
    }
    char v6 = v3; // 0xc6a6
    int64_t v7 = v4; // 0xc6a6
    int64_t v8 = v5; // 0xc6a6
    if ((v3 & (char)&g25) != 0) {
        // 0xc6a8
        *(int16_t *)v4 = 0;
        v7 = v4 + (int64_t)&g25;
        v6 = v7;
        v8 = v5 + 254 & 191;
    }
    int64_t v9 = v7; // 0xc6b7
    int64_t v10 = v8; // 0xc6b7
    if ((v6 & (char)&g86) != 0) {
        // 0xc6b9
        *(int32_t *)v7 = 0;
        v9 = v7 + (int64_t)&g86;
        v10 = v8 + 0xfffffffc & 0xffffffff;
    }
    int64_t v11 = (int32_t)v10 >> (int32_t)&g33; // 0xc6c9
    __asm_rep_stosq_memset((char *)v9, 0, v11);
    bool v12; // 0xc674
    int64_t v13 = (v12 ? -8 : (int64_t)&g95) * v11 + v9; // 0xc6cb
    char v14 = v10; // 0xc6ce
    int64_t v15 = v13; // 0xc6d2
    if ((v14 & (char)&g86) != 0) {
        // 0xc6d4
        *(int32_t *)v13 = 0;
        v15 = v13 + (int64_t)&g86;
    }
    int64_t v16 = v15; // 0xc6de
    if ((v14 & (char)&g25) != 0) {
        // 0xc6e0
        *(int16_t *)v15 = 0;
        v16 = v15 + (int64_t)&g25;
    }
    if ((v14 & (char)&g1) != 0) {
        // 0xc6ed
        *(char *)v16 = 0;
    }
    // 0xc6ef
    *(char *)a3 = *(char *)&v1;
    return (int64_t)*(char *)(v1 + (int64_t)&g1);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc6f8 - 0xc728
// Line range:    6810 - 6823
void DTV_HardwareDecrypt_Ver01(int64_t pTuner, char * Input188B, char * Output188B) {
    int64_t v1 = (int64_t)Output188B;
    int64_t v2 = (int64_t)Input188B;
    int64_t v3; // 0xc6f8
    *(char *)(v1 + (int64_t)&g1) = (char)v3;
    char v4 = *(char *)(v2 + (int64_t)&g25); // 0xc6fb
    *(char *)(v1 + (int64_t)&g25) = v4;
    char v5 = *(char *)(v2 + (int64_t)&g33); // 0xc702
    *(char *)(v1 + (int64_t)&g33) = v5;
    int64_t v6 = v1; // 0xc709
    int64_t v7 = v2; // 0xc709
    char v8 = *(char *)(v7 + 4); // 0xc713
    int64_t v9; // 0xc6f8
    *(char *)(v6 + 4) = v8 ^ (char)v9;
    v6++;
    while (v7 != v2 + 183) {
        // 0xc710
        v7++;
        v8 = *(char *)(v7 + 4);
        *(char *)(v6 + 4) = v8 ^ (char)v9;
        v6++;
    }
}

// Address range: 0xc728 - 0xc7ce
int64_t DTV_HardwareDecrypt_Ver01_(int64_t a1, int64_t * a2, int64_t a3) {
    int64_t result = (int64_t)a2;
    mcount();
    char v1 = a3;
    char v2 = v1; // 0xc751
    int64_t v3 = a3; // 0xc751
    int64_t v4 = 188; // 0xc751
    if ((v1 & (char)&g1) != 0) {
        // 0xc753
        *(char *)a3 = 0;
        v3 = a3 + (int64_t)&g1;
        v2 = v3;
        v4 = 187;
    }
    char v5 = v2; // 0xc761
    int64_t v6 = v3; // 0xc761
    int64_t v7 = v4; // 0xc761
    if ((v2 & (char)&g25) != 0) {
        // 0xc763
        *(int16_t *)v3 = 0;
        v6 = v3 + (int64_t)&g25;
        v5 = v6;
        v7 = v4 + 254 & 191;
    }
    int64_t v8 = v6; // 0xc772
    int64_t v9 = v7; // 0xc772
    if ((v5 & (char)&g86) != 0) {
        // 0xc774
        *(int32_t *)v6 = 0;
        v8 = v6 + (int64_t)&g86;
        v9 = v7 + 0xfffffffc & 0xffffffff;
    }
    int64_t v10 = (int32_t)v9 >> (int32_t)&g33; // 0xc784
    __asm_rep_stosq_memset((char *)v8, 0, v10);
    bool v11; // 0xc728
    int64_t v12 = (v11 ? -8 : (int64_t)&g95) * v10 + v8; // 0xc786
    char v13 = v9; // 0xc789
    int64_t v14 = v12; // 0xc78d
    if ((v13 & (char)&g86) != 0) {
        // 0xc78f
        *(int32_t *)v12 = 0;
        v14 = v12 + (int64_t)&g86;
    }
    int64_t v15 = v14; // 0xc799
    if ((v13 & (char)&g25) != 0) {
        // 0xc79b
        *(int16_t *)v14 = 0;
        v15 = v14 + (int64_t)&g25;
    }
    if ((v13 & (char)&g1) != 0) {
        // 0xc7a8
        *(char *)v15 = 0;
    }
    // 0xc7aa
    *(char *)a3 = *(char *)&result;
    char v16 = *(char *)(result + (int64_t)&g1); // 0xc7af
    *(char *)(a3 + (int64_t)&g1) = v16;
    char v17 = *(char *)(result + (int64_t)&g25); // 0xc7b6
    *(char *)(a3 + (int64_t)&g25) = v17;
    char v18 = *(char *)(result + (int64_t)&g33); // 0xc7bd
    *(char *)(a3 + (int64_t)&g33) = v18;
    return result;
}

// Address range: 0xc7d6 - 0xc7d9
int64_t function_c7d6(int64_t a1) {
    // 0xc7d6
    int64_t result; // 0xc7d6
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc7da - 0xc80a
// Line range:    6787 - 6800
void DTV_HardwareDecrypt(int64_t pTuner, char * Input188B, char * Output188B) {
    // 0xc7da
    __asm_iretd();
    int64_t v1; // 0xc7da
    int64_t v2; // 0xc7da
    char v3 = *(char *)(v1 + 664 + 0x100000000 * ((pTuner & (int64_t)(int32_t)&g24) - v2) / 0x100000000); // 0xc7f0
    int64_t v4; // 0xc7da
    *(char *)((int64_t)Output188B + (int64_t)&g86) = v3 ^ (char)v4;
}

// Address range: 0xc80a - 0xc8bd
int64_t DTV_HardwareDecrypt2(int64_t a1, int64_t * a2, int64_t a3) {
    int64_t result = (int64_t)a2;
    mcount();
    char v1 = a3;
    char v2 = v1; // 0xc82e
    int64_t v3 = a3; // 0xc82e
    int64_t v4 = 188; // 0xc82e
    if ((v1 & (char)&g1) != 0) {
        // 0xc830
        *(char *)a3 = 0;
        v3 = a3 + (int64_t)&g1;
        v2 = v3;
        v4 = 187;
    }
    char v5 = v2; // 0xc83e
    int64_t v6 = v3; // 0xc83e
    int64_t v7 = v4; // 0xc83e
    if ((v2 & (char)&g25) != 0) {
        // 0xc840
        *(int16_t *)v3 = 0;
        v6 = v3 + (int64_t)&g25;
        v5 = v6;
        v7 = v4 + 254 & 191;
    }
    int64_t v8 = v6; // 0xc84f
    int64_t v9 = v7; // 0xc84f
    if ((v5 & (char)&g86) != 0) {
        // 0xc851
        *(int32_t *)v6 = 0;
        v8 = v6 + (int64_t)&g86;
        v9 = v7 + 0xfffffffc & 0xffffffff;
    }
    int64_t v10 = (int32_t)v9 >> (int32_t)&g33; // 0xc861
    __asm_rep_stosq_memset((char *)v8, 0, v10);
    bool v11; // 0xc80a
    int64_t v12 = (v11 ? -8 : (int64_t)&g95) * v10 + v8; // 0xc863
    char v13 = v9; // 0xc866
    int64_t v14 = v12; // 0xc86a
    if ((v13 & (char)&g86) != 0) {
        // 0xc86c
        *(int32_t *)v12 = 0;
        v14 = v12 + (int64_t)&g86;
    }
    int64_t v15 = v14; // 0xc876
    if ((v13 & (char)&g25) != 0) {
        // 0xc878
        *(int16_t *)v14 = 0;
        v15 = v14 + (int64_t)&g25;
    }
    if ((v13 & (char)&g1) != 0) {
        // 0xc885
        *(char *)v15 = 0;
    }
    // 0xc887
    *(char *)a3 = *(char *)&result;
    char v16 = *(char *)(result + (int64_t)&g1); // 0xc88c
    *(char *)(a3 + (int64_t)&g1) = v16;
    char v17 = *(char *)(result + (int64_t)&g25); // 0xc893
    *(char *)(a3 + (int64_t)&g25) = v17;
    char v18 = *(char *)(result + (int64_t)&g33); // 0xc89a
    *(char *)(a3 + (int64_t)&g33) = v18;
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc8be - 0xc8bf
// Line range:    1049 - 1063
char myAnsiToUnicodeString(char * buf, int32_t len, int16_t * wbuf, int32_t * wlen) {
    // 0xc8be
    int64_t result; // 0xc8be
    return result;
}

// Address range: 0xc8c0 - 0xc8ee
int64_t function_c8c0(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int32_t v1 = (uint32_t)(int32_t)a4 >> (uint32_t)(int32_t)&g19; // 0xc8c0
    char v2 = *(char *)(a5 + (int64_t)&g46 + (int64_t)((v1 + (int32_t)a1 & (int32_t)&g105) - v1) * (int64_t)&g1); // 0xc8d0
    *(char *)(a3 + (int64_t)&g86) = v2 ^ (char)a6;
    int64_t v3; // 0xc8c0
    return v3 + (int64_t)&g1;
}

// Address range: 0xc8ee - 0xc98e
int64_t myAnsiToUnicodeString2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0xc8ee
    mcount();
    __readgsqword(40);
    uint32_t v1 = (int32_t)a2; // 0xc92d
    int64_t v2; // 0xc8ee
    if (v1 < 128 != (int32_t)v2 >= (int32_t)(a2 + (int64_t)&g25 + (a2 & 0xffffffff) * (int64_t)&g1)) {
        // 0xc932
        return 0;
    }
    // 0xc939
    memset(a3, 0, v2 & 0xffffffff);
    int64_t v3; // bp-328, 0xc8ee
    __asm_rep_stosq_memset((char *)&v3, 0, (int64_t)&g26);
    if (v1 == 0) {
        // 0xc932
        return 0;
    }
    int64_t v4 = a1 + (int64_t)&g1 + (a2 - (int64_t)(int32_t)&g1 & 0xffffffff) * (int64_t)&g1; // 0xc969
    int64_t result = &v3; // 0xc969
    int64_t v5 = a1; // 0xc969
    *(char *)result = *(char *)v5;
    v5 += (int64_t)&g1;
    result += (int64_t)&g25;
    while (v5 != v4) {
        // 0xc96e
        *(char *)result = *(char *)v5;
        v5 += (int64_t)&g1;
        result += (int64_t)&g25;
    }
    // 0xc932
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xc992 - 0xc9c2
// Line range:    9137 - 9165
void DriverInterfaceDec(int64_t pTuner, char * Input188B, char * Output188B) {
    // 0xc992
    int64_t v1; // 0xc992
    char * v2 = (char *)(v1 - 119); // 0xc992
    int64_t v3; // 0xc992
    *v2 = *v2 + (char)v3;
    int64_t v4 = v3 + 1; // 0xc995
    uint64_t v5; // 0xc992
    __writegsbyte(v4, __readgsbyte(v4) + (char)(v5 >> (int64_t)&g95));
    if (*(int64_t *)(v1 - 56) != __readgsqword(40)) {
        // 0xc9ab
        __stack_chk_fail();
    }
}

// Address range: 0xc9c2 - 0xcb2d
int64_t DriverInterfaceDec2(int64_t a1, int64_t a2, int64_t result) {
    // 0xc9c2
    mcount();
    __readgsqword(40);
    char v1 = result;
    char v2 = v1; // 0xc9ff
    int64_t v3 = 188; // 0xc9ff
    int64_t v4 = result; // 0xc9ff
    if ((v1 & (char)&g1) != 0) {
        // 0xca01
        *(char *)result = 0;
        v4 = result + (int64_t)&g1;
        v2 = v4;
        v3 = 187;
    }
    char v5 = v2; // 0xca0e
    int64_t v6 = v3; // 0xca0e
    int64_t v7 = v4; // 0xca0e
    if ((v2 & (char)&g25) != 0) {
        // 0xca10
        *(int16_t *)v4 = 0;
        v7 = v4 + (int64_t)&g25;
        v5 = v7;
        v6 = v3 + 254 & 191;
    }
    int64_t v8 = v6; // 0xca1e
    int64_t v9 = v7; // 0xca1e
    if ((v5 & (char)&g86) != 0) {
        // 0xca20
        *(int32_t *)v7 = 0;
        v8 = v6 + 0xfffffffc & 0xffffffff;
        v9 = v7 + (int64_t)&g86;
    }
    int64_t v10 = (int32_t)v8 >> (int32_t)&g33; // 0xca2e
    __asm_rep_stosq_memset((char *)v9, 0, v10);
    bool v11; // 0xc9c2
    int64_t v12 = (v11 ? -8 : (int64_t)&g95) * v10 + v9; // 0xca30
    char v13 = v8; // 0xca33
    int64_t v14 = v12; // 0xca36
    if ((v13 & (char)&g86) != 0) {
        // 0xca38
        *(int32_t *)v12 = 0;
        v14 = v12 + (int64_t)&g86;
    }
    int64_t v15 = v14; // 0xca41
    if ((v13 & (char)&g25) != 0) {
        // 0xca43
        *(int16_t *)v14 = 0;
        v15 = v14 + (int64_t)&g25;
    }
    if ((v13 & (char)&g1) != 0) {
        // 0xca4f
        *(char *)v15 = 0;
    }
    // 0xca51
    int64_t v16; // bp-264, 0xc9c2
    int64_t v17 = &v16; // 0xca51
    __asm_rep_stosq_memset((char *)&v16, 0, (int64_t)&g12);
    int64_t v18 = v11 ? -8 * (int64_t)&g12 : (int64_t)&g95 * (int64_t)&g12; // 0xca65
    *(int32_t *)(v18 + v17) = 0;
    int64_t v19 = a2; // 0xca7b
    int64_t v20 = result; // 0xca7b
    int64_t v21 = v17; // 0xca7b
    char v22 = *(char *)v19; // 0xca7e
    *(char *)v21 = v22;
    *(char *)v20 = v22;
    v19 += (int64_t)&g1;
    v20++;
    v21 += (int64_t)&g1;
    while (v19 != a2 + 188) {
        // 0xca7e
        v22 = *(char *)v19;
        *(char *)v21 = v22;
        *(char *)v20 = v22;
        v19 += (int64_t)&g1;
        v20++;
        v21 += (int64_t)&g1;
    }
    int64_t v23 = *(int64_t *)(a1 + 0x1d38) + 3816; // 0xca98
    int64_t v24 = a1 + 0x8fa38; // 0xcab4
    int64_t v25 = a2 + (int64_t)&g86; // 0xcadb
    int64_t v26; // bp-260, 0xc9c2
    int64_t v27 = &v26; // 0xcadb
    int32_t v28 = *(int32_t *)(a1 + 0x8f7a4); // 0xcade
    cipherUpdateRounds2(v24, a1 + 0x8f758, v25, (int64_t *)&g2, v27, v28, v23);
    v25 += (int64_t)&g26;
    v27 += (int64_t)&g26;
    while (v25 != a2 + 164) {
        // 0xcade
        v28 = *(int32_t *)(a1 + 0x8f7a4);
        cipherUpdateRounds2(v24, a1 + 0x8f758, v25, (int64_t *)&g2, v27, v28, v23);
        v25 += (int64_t)&g26;
        v27 += (int64_t)&g26;
    }
    // 0xcb1f
    return result;
}

// Address range: 0xcb2e - 0xcb36
int64_t function_cb2e(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0xcb2e
    int64_t v1; // 0xcb2e
    int32_t * v2 = (int32_t *)(a4 - 31 + v1 * (int64_t)&g1); // 0xcb2e
    uint32_t v3 = *v2; // 0xcb2e
    *v2 = v3 >> (int32_t)&g12 | v3 << (int32_t)&g97;
    int64_t result; // 0xcb2e
    return result;
}

// Address range: 0xcb49 - 0xcb50
int64_t function_cb49(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0xcb49
    int64_t result; // 0xcb49
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xcb50 - 0xcb80
// Line range:    9167 - 9172
void DriverInterfaceDec_Multi(int64_t pTuner, char * TSData_In, int32_t FrameNum, char * TSData_Out) {
    // 0xcb50
    int64_t v1; // 0xcb50
    int32_t * v2 = (int32_t *)(v1 - 125); // 0xcb50
    *v2 = *v2 + (int32_t)(int64_t)TSData_Out;
    int64_t v3; // 0xcb50
    char v4 = *(char *)&v3; // 0xcb53
    *TSData_Out = v4 << (char)&g95 | v4;
    int64_t v5; // 0xcb50
    if (*(int64_t *)(v5 - 56) != __readgsqword(40)) {
        // 0xcb69
        __stack_chk_fail();
    }
}

// Address range: 0xcb80 - 0xcbb2
int64_t DriverInterfaceDec_Multi2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0xcb80
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xcbb5 - 0xcbe5
// Line range:    9101 - 9128
void DriverInterfaceEnc(int64_t pTuner, char * Input188B, char * Output188B) {
    int64_t v1 = (int64_t)Input188B * (int64_t)&g1; // 0xcbb5
    int64_t v2; // 0xcbb5
    int64_t v3; // 0xcbb5
    int64_t v4; // 0xcbb5
    DriverInterfaceDec2(*(int64_t *)(v4 - 56), v2 + v1, v3 + v1);
}

// Address range: 0xcbe5 - 0xcd60
int64_t DriverInterfaceEnc2(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = a2;
    mcount();
    __readgsqword(40);
    int64_t v2 = *(int64_t *)(a1 + 0x1d38); // 0xcc10
    char v3 = a3;
    char v4 = v3; // 0xcc22
    int64_t v5 = 188; // 0xcc22
    int64_t v6 = a3; // 0xcc22
    if ((v3 & (char)&g1) != 0) {
        // 0xcc24
        *(char *)a3 = 0;
        v6 = a3 + (int64_t)&g1;
        v4 = v6;
        v5 = 187;
    }
    char v7 = v4; // 0xcc31
    int64_t v8 = v5; // 0xcc31
    int64_t v9 = v6; // 0xcc31
    if ((v4 & (char)&g25) != 0) {
        // 0xcc33
        *(int16_t *)v6 = 0;
        v9 = v6 + (int64_t)&g25;
        v7 = v9;
        v8 = v5 + 254 & 191;
    }
    int64_t v10 = v8; // 0xcc41
    int64_t v11 = v9; // 0xcc41
    if ((v7 & (char)&g86) != 0) {
        // 0xcc43
        *(int32_t *)v9 = 0;
        v10 = v8 + 0xfffffffc & 0xffffffff;
        v11 = v9 + (int64_t)&g86;
    }
    int64_t v12 = (int32_t)v10 >> (int32_t)&g33; // 0xcc51
    __asm_rep_stosq_memset((char *)v11, 0, v12);
    bool v13; // 0xcbe5
    int64_t v14 = (v13 ? -8 : (int64_t)&g95) * v12 + v11; // 0xcc53
    char v15 = v10; // 0xcc56
    int64_t v16 = v14; // 0xcc59
    if ((v15 & (char)&g86) != 0) {
        // 0xcc5b
        *(int32_t *)v14 = 0;
        v16 = v14 + (int64_t)&g86;
    }
    int64_t v17 = v16; // 0xcc64
    if ((v15 & (char)&g25) != 0) {
        // 0xcc66
        *(int16_t *)v16 = 0;
        v17 = v16 + (int64_t)&g25;
    }
    if ((v15 & (char)&g1) != 0) {
        // 0xcc72
        *(char *)v17 = 0;
    }
    // 0xcc74
    int64_t v18; // bp-264, 0xcbe5
    __asm_rep_stosq_memset((char *)&v18, 0, (int64_t)&g12);
    int64_t v19 = v13 ? -8 * (int64_t)&g12 : (int64_t)&g95 * (int64_t)&g12; // 0xcc88
    *(int32_t *)(v19 + (int64_t)&v18) = 0;
    *(char *)a3 = *(char *)&v1;
    char v20 = *(char *)(v1 + (int64_t)&g1); // 0xcc96
    *(char *)(a3 + (int64_t)&g1) = v20;
    char v21 = *(char *)(v1 + (int64_t)&g25); // 0xcc9d
    *(char *)(a3 + (int64_t)&g25) = v21;
    char v22 = *(char *)(v1 + (int64_t)&g33); // 0xcca4
    *(char *)(a3 + (int64_t)&g33) = v22;
    int64_t v23 = v1 + (int64_t)&g86; // 0xccab
    v1 = v23;
    int64_t v24; // bp-260, 0xcbe5
    int64_t v25 = &v24; // 0xccaf
    int64_t v26 = v25; // 0xccc3
    int64_t v27 = a3; // 0xccc3
    int32_t v28 = v27 - a3; // 0xccd0
    int32_t v29 = v28 >> (int32_t)&g24 >> (int32_t)&g18; // 0xccd6
    char v30 = *(char *)((int64_t)((v29 + v28 & (int32_t)&g24) - v29) * (int64_t)&g1); // 0xcce6
    char v31 = *(char *)v23 ^ v30; // 0xcceb
    *(char *)v26 = v31;
    *(char *)(v27 + (int64_t)&g86) = v31;
    int64_t v32 = v1 + (int64_t)&g1; // 0xccf5
    v1 = v32;
    v26 += (int64_t)&g1;
    v27 += (int64_t)&g1;
    int64_t v33; // bp-76, 0xcbe5
    while (v26 != (int64_t)&v33) {
        // 0xccca
        v28 = v27 - a3;
        v29 = v28 >> (int32_t)&g24 >> (int32_t)&g18;
        v30 = *(char *)((int64_t)((v29 + v28 & (int32_t)&g24) - v29) * (int64_t)&g1);
        v31 = *(char *)v32 ^ v30;
        *(char *)v26 = v31;
        *(char *)(v27 + (int64_t)&g86) = v31;
        v32 = v1 + (int64_t)&g1;
        v1 = v32;
        v26 += (int64_t)&g1;
        v27 += (int64_t)&g1;
    }
    int32_t v34 = *(int32_t *)(a1 + 0x8f4c4); // 0xcd36
    int64_t result = cipherUpdateRounds2(a1 + 0x8fa38, a1 + 0x8f478, v25, (int64_t *)&g2, a3 + (int64_t)&g86, v34, v2 + 3816); // 0xcd57
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xcd63 - 0xcd68
// Line range:    9130 - 9135
void DriverInterfaceEnc_Multi(int64_t pTuner, char * TSData_In, int32_t FrameNum, char * TSData_Out) {
    // 0xcd63
    int64_t v1; // 0xcd63
    char * v2 = (char *)(v1 + 59); // 0xcd63
    *v2 = *v2 & (char)(int64_t)TSData_Out;
}

// Address range: 0xcd6a - 0xcd93
int64_t function_cd6a(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t result = 0; // 0xcd7a
    int64_t v1; // 0xcd6a
    if (*(int64_t *)(v1 - 56) != __readgsqword(40)) {
        // 0xcd7c
        result = __stack_chk_fail();
    }
    // 0xcd81
    return result;
}

// Address range: 0xcd93 - 0xcdc5
int64_t DriverInterfaceEnc_Multi2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0xcd93
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xcdc8 - 0xcdf8
// Line range:    9029 - 9094
char Get_CARD_INFO(char * PDev, char * PTuner, char * Status, char * size, char * buffer, int64_t BufferSz) {
    int64_t v1 = (int64_t)PTuner * (int64_t)&g1; // 0xcdc8
    int64_t v2; // 0xcdc8
    int64_t v3; // 0xcdc8
    int64_t v4; // 0xcdc8
    return DriverInterfaceEnc2(*(int64_t *)(v4 - 56), v2 + v1, v3 + v1);
}

// Address range: 0xcdf8 - 0xd010
int64_t Get_CARD_INFO2(int64_t a1, int64_t a2, int64_t a3, int64_t result, int64_t a5) {
    // 0xcdf8
    mcount();
    __readgsqword(40);
    int64_t v1 = *(int64_t *)(a2 + 0x1d38); // 0xce38
    char * v2 = (char *)(a1 + (int64_t)&g6); // 0xce46
    char * v3 = (char *)a3; // 0xce4d
    *v3 = *v2;
    int32_t * v4 = (int32_t *)(a1 + 0x15c8); // 0xce4f
    uint32_t v5 = *v4; // 0xce4f
    if (v5 == 0) {
        // 0xce59
        *(char *)result = 0;
        return result;
    }
    // 0xce68
    if (*v2 == 0) {
        // 0xce71
        *(char *)result = 0;
        unsigned char result2 = *v2; // 0xce7b
        *v3 = result2;
        return result2;
    }
    int32_t v6 = v5; // 0xce8e
    if (v5 >= 256) {
        // 0xce90
        *v4 = 255;
        v6 = 255;
    }
    int32_t v7 = v6; // 0xce9a
    int64_t str = FUSB_ExAllocatePool2(0, (int64_t)(v7 + 1 + 2 * v7)); // 0xcead
    int32_t v8 = *v4; // 0xceb5
    memset(str, 0, (int64_t)(v8 + 1 + 2 * v8));
    int64_t v9 = a1; // 0xced8
    int64_t v10 = 0; // 0xced8
    if (*v4 >= 1) {
        int64_t v11; // 0xcdf8
        sprintf(str, 0, str, *(char *)(v9 + 0x1486), a5, v11);
        v10 = v10 + (int64_t)(int32_t)&g1 & 0xffffffff;
        v9 += (int64_t)&g1;
        while (v10 < (int64_t)*v4) {
            // 0xceea
            sprintf(str, 0, str, *(char *)(v9 + 0x1486), a5, v11);
            v10 = v10 + (int64_t)(int32_t)&g1 & 0xffffffff;
            v9 += (int64_t)&g1;
        }
    }
    // 0xcf15
    FUSB_ExFreePool2((int32_t)str, 0);
    int64_t v12; // bp-392, 0xcdf8
    __asm_rep_stosq_memset((char *)&v12, 0, 40);
    int64_t v13 = &v12; // 0xcf42
    memcpy(v13, a1 + 0x1486, (int64_t)*v4, 0);
    *(char *)result = (char)*v4;
    int32_t v14 = *(int32_t *)(a2 + 0x8f4c4); // 0xcfd6
    int64_t result3 = cipherUpdateRounds2(a2 + 0x8fa38, a2 + 0x8f478, v13 * (int64_t)&g1, (int64_t *)&g2, a5, v14, v1 + 3816); // 0xd003
    return result3;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xd014 - 0xd044
// Line range:    7269 - 7377
int32_t DTV_DecrypTS_5607(int64_t pTuner, char * Input188B, char * Output188B, int32_t buffersize) {
    // 0xd014
    int64_t result; // 0xd014
    return result;
}

// Address range: 0xd044 - 0xd877
int64_t DTV_DecrypTS_5607_(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0xd044
    mcount();
    __readgsqword(40);
    if (*(char *)(a1 + (int64_t)&g49) == 0) {
        // 0xd807
        __readgsqword(40);
        return &g1;
    }
    uint64_t v1 = 0x100000000 * a4 / 0x100000000; // 0xd067
    int64_t v2 = *(int64_t *)(a1 + 0x1d38); // 0xd079
    int64_t v3 = FUSB_ExAllocatePool2(0, v1); // 0xd098
    int64_t result = FUSB_ExAllocatePool2(0, v1); // 0xd0ac
    int32_t v4 = v1;
    int64_t v5; // 0xd044
    int64_t v6; // bp-72, 0xd044
    int64_t v7; // bp-88, 0xd044
    bool v8; // 0xd044
    if (*(char *)(a1 + (int64_t)&g42) != 0) {
        if (v4 >= 0 != v4 != 0) {
            // 0xd857
            return result;
        }
        int64_t v9 = v2 + 3816;
        int64_t v10 = a1 + 0x8f184; // 0xd47a
        int64_t v11 = a1 + 0x8f464; // 0xd485
        int64_t v12 = &v6; // 0xd4a2
        int64_t v13 = &v7; // 0xd51a
        int32_t * v14 = (int32_t *)(a1 + 0x8f1d0);
        int32_t v15 = 0; // 0xd4ae
        int64_t v16 = v15; // 0xd4b5
        *(char *)(v16 + a3) = *(char *)(v16 + a2);
        int64_t v17 = v16 | 1; // 0xd4cc
        *(char *)(v17 + a3) = *(char *)(v17 + a2);
        int64_t v18 = v16 + (int64_t)&g25; // 0xd4e0
        *(char *)(v18 + a3) = *(char *)(v18 + a2);
        int64_t v19 = v16 + (int64_t)&g33; // 0xd4f0
        *(char *)(v19 + a3) = *(char *)(v19 + a2);
        int64_t v20 = v16 + 172; // 0xd500
        v7 = *(int64_t *)(v20 + a2);
        int64_t v21 = v13; // 0xd528
        int64_t v22 = a1; // 0xd528
        char * v23 = (char *)v21; // 0xd532
        *v23 = *v23 ^ *(char *)(v22 + 0x8fc97);
        v21 += (int64_t)&g1;
        v22 -= (int64_t)&g1;
        while (v21 != v12) {
            // 0xd52b
            v23 = (char *)v21;
            *v23 = *v23 ^ *(char *)(v22 + 0x8fc97);
            v21 += (int64_t)&g1;
            v22 -= (int64_t)&g1;
        }
        // 0xd541
        cipherUpdateRounds2(v11, v10, v13, (int64_t *)&g2, v20 + a3, *v14, v9);
        int64_t v24 = v16 + 164; // 0xd578
        v7 = *(int64_t *)(v24 + a2);
        int64_t v25 = v13; // 0xd594
        int64_t v26 = a1; // 0xd594
        char * v27 = (char *)v25; // 0xd59f
        *v27 = *v27 ^ *(char *)(v26 + 0x8fc97);
        v25 += (int64_t)&g1;
        v26 -= (int64_t)&g1;
        while (v25 != v12) {
            // 0xd597
            v27 = (char *)v25;
            *v27 = *v27 ^ *(char *)(v26 + 0x8fc97);
            v25 += (int64_t)&g1;
            v26 -= (int64_t)&g1;
        }
        // 0xd5ae
        cipherUpdateRounds2(v11, v10, v13, (int64_t *)&g2, v24 + a3, *v14, v9);
        int64_t v28 = v15 + 4; // 0xd5ed
        int64_t v29 = 0; // 0xd61a
        int64_t v30 = v28; // 0xd61a
        char * v31 = (char *)(0x100000000 * v30 / 0x100000000 + a2); // 0xd5fb
        *v31 = *v31 ^ *(char *)(a1 + 0x8fc97 + v29);
        v29 -= (int64_t)&g1;
        v30 = v30 + 1 & 0xffffffff;
        while (v29 != -16) {
            // 0xd5ef
            v31 = (char *)(0x100000000 * v30 / 0x100000000 + a2);
            *v31 = *v31 ^ *(char *)(a1 + 0x8fc97 + v29);
            v29 -= (int64_t)&g1;
            v30 = v30 + 1 & 0xffffffff;
        }
        int64_t v32 = v28 + 16; // 0xd60c
        v28 = v32 & 0xffffffff;
        while (v15 + 164 != (int32_t)v32) {
            // 0xd613
            v29 = 0;
            v30 = v28;
            v31 = (char *)(0x100000000 * v30 / 0x100000000 + a2);
            *v31 = *v31 ^ *(char *)(a1 + 0x8fc97 + v29);
            v29 -= (int64_t)&g1;
            v30 = v30 + 1 & 0xffffffff;
            while (v29 != -16) {
                // 0xd5ef
                v31 = (char *)(0x100000000 * v30 / 0x100000000 + a2);
                *v31 = *v31 ^ *(char *)(a1 + 0x8fc97 + v29);
                v29 -= (int64_t)&g1;
                v30 = v30 + 1 & 0xffffffff;
            }
            // 0xd60c
            v32 = v28 + 16;
            v28 = v32 & 0xffffffff;
        }
        // 0xd61c
        v15 += 188;
        while (v1 > (int64_t)v15) {
            // 0xd4b5
            v16 = v15;
            *(char *)(v16 + a3) = *(char *)(v16 + a2);
            v17 = v16 | 1;
            *(char *)(v17 + a3) = *(char *)(v17 + a2);
            v18 = v16 + (int64_t)&g25;
            *(char *)(v18 + a3) = *(char *)(v18 + a2);
            v19 = v16 + (int64_t)&g33;
            *(char *)(v19 + a3) = *(char *)(v19 + a2);
            v20 = v16 + 172;
            v7 = *(int64_t *)(v20 + a2);
            v21 = v13;
            v22 = a1;
            v23 = (char *)v21;
            *v23 = *v23 ^ *(char *)(v22 + 0x8fc97);
            v21 += (int64_t)&g1;
            v22 -= (int64_t)&g1;
            while (v21 != v12) {
                // 0xd52b
                v23 = (char *)v21;
                *v23 = *v23 ^ *(char *)(v22 + 0x8fc97);
                v21 += (int64_t)&g1;
                v22 -= (int64_t)&g1;
            }
            // 0xd541
            cipherUpdateRounds2(v11, v10, v13, (int64_t *)&g2, v20 + a3, *v14, v9);
            v24 = v16 + 164;
            v7 = *(int64_t *)(v24 + a2);
            v25 = v13;
            v26 = a1;
            v27 = (char *)v25;
            *v27 = *v27 ^ *(char *)(v26 + 0x8fc97);
            v25 += (int64_t)&g1;
            v26 -= (int64_t)&g1;
            while (v25 != v12) {
                // 0xd597
                v27 = (char *)v25;
                *v27 = *v27 ^ *(char *)(v26 + 0x8fc97);
                v25 += (int64_t)&g1;
                v26 -= (int64_t)&g1;
            }
            // 0xd5ae
            cipherUpdateRounds2(v11, v10, v13, (int64_t *)&g2, v24 + a3, *v14, v9);
            v28 = v15 + 4;
            v29 = 0;
            v30 = v28;
            v31 = (char *)(0x100000000 * v30 / 0x100000000 + a2);
            *v31 = *v31 ^ *(char *)(a1 + 0x8fc97 + v29);
            v29 -= (int64_t)&g1;
            v30 = v30 + 1 & 0xffffffff;
            while (v29 != -16) {
                // 0xd5ef
                v31 = (char *)(0x100000000 * v30 / 0x100000000 + a2);
                *v31 = *v31 ^ *(char *)(a1 + 0x8fc97 + v29);
                v29 -= (int64_t)&g1;
                v30 = v30 + 1 & 0xffffffff;
            }
            // 0xd60c
            v32 = v28 + 16;
            v28 = v32 & 0xffffffff;
            while (v15 + 164 != (int32_t)v32) {
                // 0xd613
                v29 = 0;
                v30 = v28;
                v31 = (char *)(0x100000000 * v30 / 0x100000000 + a2);
                *v31 = *v31 ^ *(char *)(a1 + 0x8fc97 + v29);
                v29 -= (int64_t)&g1;
                v30 = v30 + 1 & 0xffffffff;
                while (v29 != -16) {
                    // 0xd5ef
                    v31 = (char *)(0x100000000 * v30 / 0x100000000 + a2);
                    *v31 = *v31 ^ *(char *)(a1 + 0x8fc97 + v29);
                    v29 -= (int64_t)&g1;
                    v30 = v30 + 1 & 0xffffffff;
                }
                // 0xd60c
                v32 = v28 + 16;
                v28 = v32 & 0xffffffff;
            }
            // 0xd61c
            v15 += 188;
        }
        int64_t v33 = 0x100000000 * v3 / 0x100000000; // 0xd64d
        int64_t v34 = 0; // 0xd64d
        int64_t v35 = 0; // 0xd64d
        int64_t v36 = 0x100000000 * v34 / 0x100000000 + v33; // 0xd65a
        int64_t v37 = a2 + 4 + 0x100000000 * v35 / 0x100000000; // 0xd65e
        int64_t v38 = 160; // 0xd66a
        int64_t v39 = v37; // 0xd66a
        int64_t v40 = v36; // 0xd66a
        if (v36 % 2 != 0) {
            // 0xd66c
            *(char *)v36 = *(char *)v37;
            v38 = 159;
            v39 = v37 + 1;
            v40 = v36 + 1;
        }
        int64_t v41 = v40;
        int64_t v42 = v39;
        int64_t v43 = v38;
        int64_t v44 = v43; // 0xd680
        int64_t v45 = v42; // 0xd680
        int64_t v46 = v41; // 0xd680
        if ((v41 & 2) != 0) {
            // 0xd682
            *(int16_t *)v41 = *(int16_t *)v42;
            v44 = (v43 + 254) % 256;
            v45 = v42 + 2;
            v46 = v41 + 2;
        }
        int64_t v47 = v46;
        int64_t v48 = v45;
        int64_t v49 = v44;
        int64_t v50 = v49; // 0xd697
        int64_t v51 = v48; // 0xd697
        int64_t v52 = v47; // 0xd697
        if ((v47 & 4) != 0) {
            // 0xd699
            *(int32_t *)v47 = *(int32_t *)v48;
            v50 = v49 + 0xfffffffc & 0xffffffff;
            v51 = v48 + 4;
            v52 = v47 + 4;
        }
        // 0xd6a8
        __asm_rep_movsq_memcpy((char *)v52, (char *)v51, (int64_t)((int32_t)v50 >> (int32_t)&g33));
        v35 = v35 + 188 & 0xffffffff;
        int64_t v53 = v34 + 160 & 0xffffffff; // 0xd6e6
        v34 = v53;
        while (v1 > v35) {
            // 0xd654
            v36 = 0x100000000 * v34 / 0x100000000 + v33;
            v37 = a2 + 4 + 0x100000000 * v35 / 0x100000000;
            v38 = 160;
            v39 = v37;
            v40 = v36;
            if (v36 % 2 != 0) {
                // 0xd66c
                *(char *)v36 = *(char *)v37;
                v38 = 159;
                v39 = v37 + 1;
                v40 = v36 + 1;
            }
            // 0xd67c
            v41 = v40;
            v42 = v39;
            v43 = v38;
            v44 = v43;
            v45 = v42;
            v46 = v41;
            if ((v41 & 2) != 0) {
                // 0xd682
                *(int16_t *)v41 = *(int16_t *)v42;
                v44 = (v43 + 254) % 256;
                v45 = v42 + 2;
                v46 = v41 + 2;
            }
            // 0xd693
            v47 = v46;
            v48 = v45;
            v49 = v44;
            v50 = v49;
            v51 = v48;
            v52 = v47;
            if ((v47 & 4) != 0) {
                // 0xd699
                *(int32_t *)v47 = *(int32_t *)v48;
                v50 = v49 + 0xfffffffc & 0xffffffff;
                v51 = v48 + 4;
                v52 = v47 + 4;
            }
            // 0xd6a8
            __asm_rep_movsq_memcpy((char *)v52, (char *)v51, (int64_t)((int32_t)v50 >> (int32_t)&g33));
            v35 = v35 + 188 & 0xffffffff;
            v53 = v34 + 160 & 0xffffffff;
            v34 = v53;
        }
        int64_t v54 = 0x100000000 * result / 0x100000000; // 0xd706
        cipherUpdateRounds2(v11, v10, v33, (int64_t *)v53, v54, *v14, v9);
        int64_t v55 = 0; // 0xd74c
        int64_t v56 = 0; // 0xd74c
        int64_t v57 = a3 + 4 + 0x100000000 * v55 / 0x100000000; // 0xd756
        int64_t v58 = 0x100000000 * v56 / 0x100000000 + v54; // 0xd75b
        int64_t v59 = 160; // 0xd767
        int64_t v60 = v58; // 0xd767
        int64_t v61 = v57; // 0xd767
        if (v57 % 2 != 0) {
            // 0xd769
            *(char *)v57 = *(char *)v58;
            v59 = 159;
            v60 = v58 + 1;
            v61 = v57 + 1;
        }
        int64_t v62 = v61;
        int64_t v63 = v60;
        int64_t v64 = v59;
        int64_t v65 = v64; // 0xd77d
        int64_t v66 = v63; // 0xd77d
        int64_t v67 = v62; // 0xd77d
        if ((v62 & 2) != 0) {
            // 0xd77f
            *(int16_t *)v62 = *(int16_t *)v63;
            v65 = (v64 + 254) % 256;
            v66 = v63 + 2;
            v67 = v62 + 2;
        }
        int64_t v68 = v67;
        int64_t v69 = v66;
        int64_t v70 = v65;
        int64_t v71 = v70; // 0xd794
        int64_t v72 = v69; // 0xd794
        int64_t v73 = v68; // 0xd794
        if ((v68 & 4) != 0) {
            // 0xd796
            *(int32_t *)v68 = *(int32_t *)v69;
            v71 = v70 + 0xfffffffc & 0xffffffff;
            v72 = v69 + 4;
            v73 = v68 + 4;
        }
        int64_t v74 = v73;
        int64_t v75 = (int32_t)v71 >> (int32_t)&g33; // 0xd7aa
        __asm_rep_movsq_memcpy((char *)v74, (char *)v72, v75);
        v55 = v55 + 188 & 0xffffffff;
        v56 = v56 + 160 & 0xffffffff;
        while ((v1 & 0xffffffff) > v55) {
            // 0xd750
            v57 = a3 + 4 + 0x100000000 * v55 / 0x100000000;
            v58 = 0x100000000 * v56 / 0x100000000 + v54;
            v59 = 160;
            v60 = v58;
            v61 = v57;
            if (v57 % 2 != 0) {
                // 0xd769
                *(char *)v57 = *(char *)v58;
                v59 = 159;
                v60 = v58 + 1;
                v61 = v57 + 1;
            }
            // 0xd779
            v62 = v61;
            v63 = v60;
            v64 = v59;
            v65 = v64;
            v66 = v63;
            v67 = v62;
            if ((v62 & 2) != 0) {
                // 0xd77f
                *(int16_t *)v62 = *(int16_t *)v63;
                v65 = (v64 + 254) % 256;
                v66 = v63 + 2;
                v67 = v62 + 2;
            }
            // 0xd790
            v68 = v67;
            v69 = v66;
            v70 = v65;
            v71 = v70;
            v72 = v69;
            v73 = v68;
            if ((v68 & 4) != 0) {
                // 0xd796
                *(int32_t *)v68 = *(int32_t *)v69;
                v71 = v70 + 0xfffffffc & 0xffffffff;
                v72 = v69 + 4;
                v73 = v68 + 4;
            }
            // 0xd7a5
            v74 = v73;
            v75 = (int32_t)v71 >> (int32_t)&g33;
            __asm_rep_movsq_memcpy((char *)v74, (char *)v72, v75);
            v55 = v55 + 188 & 0xffffffff;
            v56 = v56 + 160 & 0xffffffff;
        }
        // 0xd7ef
        v5 = (v8 ? -8 : (int64_t)&g95) * v75 + v74;
        FUSB_ExFreePool2((int32_t)v3, v5);
        FUSB_ExFreePool2((int32_t)result, v5);
        // 0xd807
        __readgsqword(40);
        return &g1;
    }
    if (v4 < 1) {
        int32_t v76 = *(int32_t *)(a1 + 0x8f1d0); // 0xd81d
        int64_t v77 = a1 + 0x8f184; // 0xd824
        cipherUpdateRounds2(a1 + 0x8f464, v77, 0x100000000 * v3 / 0x100000000, NULL, 0x100000000 * result / 0x100000000, v76, v2 + 3816);
        // 0xd7ef
        FUSB_ExFreePool2((int32_t)v3, v77);
        FUSB_ExFreePool2((int32_t)result, v77);
        // 0xd807
        __readgsqword(40);
        return &g1;
    }
    int64_t v78 = v2 + 3816; // 0xd0db
    int64_t v79 = a1 + 0x8f184; // 0xd0e6
    int64_t v80 = a1 + 0x8f464; // 0xd0f1
    int64_t v81 = &v6; // 0xd10a
    int64_t v82 = &v7;
    int32_t * v83 = (int32_t *)(a1 + 0x8f1d0);
    int32_t v84 = 0; // 0xd116
    int64_t v85 = v84; // 0xd11d
    int64_t v86 = v85 + a2; // 0xd125
    DTV_HardwareDecrypt_ASV5606_(a1, v86, v86);
    *(char *)(v85 + a3) = *(char *)v86;
    int64_t v87 = v85 + (int64_t)&g1; // 0xd148
    char v88 = *(char *)(v87 * (int64_t)&g1 + a2); // 0xd14c
    *(char *)(v87 + a3) = v88;
    int64_t v89 = v85 + (int64_t)&g25; // 0xd15c
    *(char *)(v89 + a3) = *(char *)(v89 + a2);
    int64_t v90 = v85 + (int64_t)&g33; // 0xd16c
    *(char *)(v90 + a3) = *(char *)(v90 + a2);
    int64_t v91 = v85 + 172; // 0xd17c
    v7 = *(int64_t *)(v91 + a2);
    int64_t v92 = v82; // 0xd1a0
    int64_t v93 = a1; // 0xd1a0
    char * v94 = (char *)v92; // 0xd1aa
    *v94 = *v94 ^ *(char *)(v93 + 0x8fc97);
    v92 += (int64_t)&g1;
    v93 -= (int64_t)&g1;
    while (v92 != v81) {
        // 0xd1a3
        v94 = (char *)v92;
        *v94 = *v94 ^ *(char *)(v93 + 0x8fc97);
        v92 += (int64_t)&g1;
        v93 -= (int64_t)&g1;
    }
    // 0xd1b9
    cipherUpdateRounds2(v80, v79, v82, (int64_t *)&g2, v91 + a3, *v83, v78);
    int64_t v95 = v85 + 164; // 0xd1f0
    v7 = *(int64_t *)(v95 + a2);
    int64_t v96 = v82; // 0xd20c
    int64_t v97 = a1; // 0xd20c
    char * v98 = (char *)v96; // 0xd217
    *v98 = *v98 ^ *(char *)(v97 + 0x8fc97);
    v96 += (int64_t)&g1;
    v97 -= (int64_t)&g1;
    while (v96 != v81) {
        // 0xd20f
        v98 = (char *)v96;
        *v98 = *v98 ^ *(char *)(v97 + 0x8fc97);
        v96 += (int64_t)&g1;
        v97 -= (int64_t)&g1;
    }
    // 0xd226
    cipherUpdateRounds2(v80, v79, v82, (int64_t *)&g2, v95 + a3, *v83, v78);
    int64_t v99 = v84 + 4; // 0xd265
    int64_t v100 = 0; // 0xd292
    int64_t v101 = v99; // 0xd292
    char * v102 = (char *)(0x100000000 * v101 / 0x100000000 + a2); // 0xd273
    *v102 = *v102 ^ *(char *)(a1 + 0x8fc97 + v100);
    v100 -= (int64_t)&g1;
    v101 = v101 + 1 & 0xffffffff;
    while (v100 != -16) {
        // 0xd267
        v102 = (char *)(0x100000000 * v101 / 0x100000000 + a2);
        *v102 = *v102 ^ *(char *)(a1 + 0x8fc97 + v100);
        v100 -= (int64_t)&g1;
        v101 = v101 + 1 & 0xffffffff;
    }
    int64_t v103 = v99 + 16; // 0xd284
    v99 = v103 & 0xffffffff;
    while (v84 + 164 != (int32_t)v103) {
        // 0xd28b
        v100 = 0;
        v101 = v99;
        v102 = (char *)(0x100000000 * v101 / 0x100000000 + a2);
        *v102 = *v102 ^ *(char *)(a1 + 0x8fc97 + v100);
        v100 -= (int64_t)&g1;
        v101 = v101 + 1 & 0xffffffff;
        while (v100 != -16) {
            // 0xd267
            v102 = (char *)(0x100000000 * v101 / 0x100000000 + a2);
            *v102 = *v102 ^ *(char *)(a1 + 0x8fc97 + v100);
            v100 -= (int64_t)&g1;
            v101 = v101 + 1 & 0xffffffff;
        }
        // 0xd284
        v103 = v99 + 16;
        v99 = v103 & 0xffffffff;
    }
    // 0xd294
    v84 += 188;
    while (v1 > (int64_t)v84) {
        // 0xd11d
        v85 = v84;
        v86 = v85 + a2;
        DTV_HardwareDecrypt_ASV5606_(a1, v86, v86);
        *(char *)(v85 + a3) = *(char *)v86;
        v87 = v85 + (int64_t)&g1;
        v88 = *(char *)(v87 * (int64_t)&g1 + a2);
        *(char *)(v87 + a3) = v88;
        v89 = v85 + (int64_t)&g25;
        *(char *)(v89 + a3) = *(char *)(v89 + a2);
        v90 = v85 + (int64_t)&g33;
        *(char *)(v90 + a3) = *(char *)(v90 + a2);
        v91 = v85 + 172;
        v7 = *(int64_t *)(v91 + a2);
        v92 = v82;
        v93 = a1;
        v94 = (char *)v92;
        *v94 = *v94 ^ *(char *)(v93 + 0x8fc97);
        v92 += (int64_t)&g1;
        v93 -= (int64_t)&g1;
        while (v92 != v81) {
            // 0xd1a3
            v94 = (char *)v92;
            *v94 = *v94 ^ *(char *)(v93 + 0x8fc97);
            v92 += (int64_t)&g1;
            v93 -= (int64_t)&g1;
        }
        // 0xd1b9
        cipherUpdateRounds2(v80, v79, v82, (int64_t *)&g2, v91 + a3, *v83, v78);
        v95 = v85 + 164;
        v7 = *(int64_t *)(v95 + a2);
        v96 = v82;
        v97 = a1;
        v98 = (char *)v96;
        *v98 = *v98 ^ *(char *)(v97 + 0x8fc97);
        v96 += (int64_t)&g1;
        v97 -= (int64_t)&g1;
        while (v96 != v81) {
            // 0xd20f
            v98 = (char *)v96;
            *v98 = *v98 ^ *(char *)(v97 + 0x8fc97);
            v96 += (int64_t)&g1;
            v97 -= (int64_t)&g1;
        }
        // 0xd226
        cipherUpdateRounds2(v80, v79, v82, (int64_t *)&g2, v95 + a3, *v83, v78);
        v99 = v84 + 4;
        v100 = 0;
        v101 = v99;
        v102 = (char *)(0x100000000 * v101 / 0x100000000 + a2);
        *v102 = *v102 ^ *(char *)(a1 + 0x8fc97 + v100);
        v100 -= (int64_t)&g1;
        v101 = v101 + 1 & 0xffffffff;
        while (v100 != -16) {
            // 0xd267
            v102 = (char *)(0x100000000 * v101 / 0x100000000 + a2);
            *v102 = *v102 ^ *(char *)(a1 + 0x8fc97 + v100);
            v100 -= (int64_t)&g1;
            v101 = v101 + 1 & 0xffffffff;
        }
        // 0xd284
        v103 = v99 + 16;
        v99 = v103 & 0xffffffff;
        while (v84 + 164 != (int32_t)v103) {
            // 0xd28b
            v100 = 0;
            v101 = v99;
            v102 = (char *)(0x100000000 * v101 / 0x100000000 + a2);
            *v102 = *v102 ^ *(char *)(a1 + 0x8fc97 + v100);
            v100 -= (int64_t)&g1;
            v101 = v101 + 1 & 0xffffffff;
            while (v100 != -16) {
                // 0xd267
                v102 = (char *)(0x100000000 * v101 / 0x100000000 + a2);
                *v102 = *v102 ^ *(char *)(a1 + 0x8fc97 + v100);
                v100 -= (int64_t)&g1;
                v101 = v101 + 1 & 0xffffffff;
            }
            // 0xd284
            v103 = v99 + 16;
            v99 = v103 & 0xffffffff;
        }
        // 0xd294
        v84 += 188;
    }
    int64_t v104 = 0x100000000 * v3 / 0x100000000; // 0xd2c5
    int64_t v105 = 0; // 0xd2c5
    int64_t v106 = 0; // 0xd2c5
    int64_t v107 = 0x100000000 * v105 / 0x100000000 + v104; // 0xd2d2
    int64_t v108 = a2 + 4 + 0x100000000 * v106 / 0x100000000; // 0xd2d6
    int64_t v109 = 160; // 0xd2e2
    int64_t v110 = v108; // 0xd2e2
    int64_t v111 = v107; // 0xd2e2
    if (v107 % 2 != 0) {
        // 0xd2e4
        *(char *)v107 = *(char *)v108;
        v109 = 159;
        v110 = v108 + 1;
        v111 = v107 + 1;
    }
    int64_t v112 = v111;
    int64_t v113 = v110;
    int64_t v114 = v109;
    int64_t v115 = v114; // 0xd2f8
    int64_t v116 = v113; // 0xd2f8
    int64_t v117 = v112; // 0xd2f8
    if ((v112 & 2) != 0) {
        // 0xd2fa
        *(int16_t *)v112 = *(int16_t *)v113;
        v115 = (v114 + 254) % 256;
        v116 = v113 + 2;
        v117 = v112 + 2;
    }
    int64_t v118 = v117;
    int64_t v119 = v116;
    int64_t v120 = v115;
    int64_t v121 = v120; // 0xd30f
    int64_t v122 = v119; // 0xd30f
    int64_t v123 = v118; // 0xd30f
    if ((v118 & 4) != 0) {
        // 0xd311
        *(int32_t *)v118 = *(int32_t *)v119;
        v121 = v120 + 0xfffffffc & 0xffffffff;
        v122 = v119 + 4;
        v123 = v118 + 4;
    }
    // 0xd320
    __asm_rep_movsq_memcpy((char *)v123, (char *)v122, (int64_t)((int32_t)v121 >> (int32_t)&g33));
    v106 = v106 + 188 & 0xffffffff;
    v105 = v105 + 160 & 0xffffffff;
    while (v1 > v106) {
        // 0xd2cc
        v107 = 0x100000000 * v105 / 0x100000000 + v104;
        v108 = a2 + 4 + 0x100000000 * v106 / 0x100000000;
        v109 = 160;
        v110 = v108;
        v111 = v107;
        if (v107 % 2 != 0) {
            // 0xd2e4
            *(char *)v107 = *(char *)v108;
            v109 = 159;
            v110 = v108 + 1;
            v111 = v107 + 1;
        }
        // 0xd2f4
        v112 = v111;
        v113 = v110;
        v114 = v109;
        v115 = v114;
        v116 = v113;
        v117 = v112;
        if ((v112 & 2) != 0) {
            // 0xd2fa
            *(int16_t *)v112 = *(int16_t *)v113;
            v115 = (v114 + 254) % 256;
            v116 = v113 + 2;
            v117 = v112 + 2;
        }
        // 0xd30b
        v118 = v117;
        v119 = v116;
        v120 = v115;
        v121 = v120;
        v122 = v119;
        v123 = v118;
        if ((v118 & 4) != 0) {
            // 0xd311
            *(int32_t *)v118 = *(int32_t *)v119;
            v121 = v120 + 0xfffffffc & 0xffffffff;
            v122 = v119 + 4;
            v123 = v118 + 4;
        }
        // 0xd320
        __asm_rep_movsq_memcpy((char *)v123, (char *)v122, (int64_t)((int32_t)v121 >> (int32_t)&g33));
        v106 = v106 + 188 & 0xffffffff;
        v105 = v105 + 160 & 0xffffffff;
    }
    int64_t v124 = 0x100000000 * result / 0x100000000; // 0xd37b
    cipherUpdateRounds2(v80, v79, v104, (int64_t *)v105, v124, *v83, v78);
    int64_t v125 = 0; // 0xd3c4
    int64_t v126 = 0; // 0xd3c4
    int64_t v127 = a3 + 4 + 0x100000000 * v125 / 0x100000000; // 0xd3ce
    int64_t v128 = 0x100000000 * v126 / 0x100000000 + v124; // 0xd3d3
    int64_t v129 = 160; // 0xd3df
    int64_t v130 = v128; // 0xd3df
    int64_t v131 = v127; // 0xd3df
    if (v127 % 2 != 0) {
        // 0xd3e1
        *(char *)v127 = *(char *)v128;
        v129 = 159;
        v130 = v128 + 1;
        v131 = v127 + 1;
    }
    int64_t v132 = v131;
    int64_t v133 = v130;
    int64_t v134 = v129;
    int64_t v135 = v134; // 0xd3f5
    int64_t v136 = v133; // 0xd3f5
    int64_t v137 = v132; // 0xd3f5
    if ((v132 & 2) != 0) {
        // 0xd3f7
        *(int16_t *)v132 = *(int16_t *)v133;
        v135 = (v134 + 254) % 256;
        v136 = v133 + 2;
        v137 = v132 + 2;
    }
    int64_t v138 = v137;
    int64_t v139 = v136;
    int64_t v140 = v135;
    int64_t v141 = v140; // 0xd40c
    int64_t v142 = v139; // 0xd40c
    int64_t v143 = v138; // 0xd40c
    if ((v138 & 4) != 0) {
        // 0xd40e
        *(int32_t *)v138 = *(int32_t *)v139;
        v141 = v140 + 0xfffffffc & 0xffffffff;
        v142 = v139 + 4;
        v143 = v138 + 4;
    }
    int64_t v144 = v143;
    int64_t v145 = (int32_t)v141 >> (int32_t)&g33; // 0xd422
    __asm_rep_movsq_memcpy((char *)v144, (char *)v142, v145);
    v125 = v125 + 188 & 0xffffffff;
    v126 = v126 + 160 & 0xffffffff;
    while ((v1 & 0xffffffff) > v125) {
        // 0xd3c8
        v127 = a3 + 4 + 0x100000000 * v125 / 0x100000000;
        v128 = 0x100000000 * v126 / 0x100000000 + v124;
        v129 = 160;
        v130 = v128;
        v131 = v127;
        if (v127 % 2 != 0) {
            // 0xd3e1
            *(char *)v127 = *(char *)v128;
            v129 = 159;
            v130 = v128 + 1;
            v131 = v127 + 1;
        }
        // 0xd3f1
        v132 = v131;
        v133 = v130;
        v134 = v129;
        v135 = v134;
        v136 = v133;
        v137 = v132;
        if ((v132 & 2) != 0) {
            // 0xd3f7
            *(int16_t *)v132 = *(int16_t *)v133;
            v135 = (v134 + 254) % 256;
            v136 = v133 + 2;
            v137 = v132 + 2;
        }
        // 0xd408
        v138 = v137;
        v139 = v136;
        v140 = v135;
        v141 = v140;
        v142 = v139;
        v143 = v138;
        if ((v138 & 4) != 0) {
            // 0xd40e
            *(int32_t *)v138 = *(int32_t *)v139;
            v141 = v140 + 0xfffffffc & 0xffffffff;
            v142 = v139 + 4;
            v143 = v138 + 4;
        }
        // 0xd41d
        v144 = v143;
        v145 = (int32_t)v141 >> (int32_t)&g33;
        __asm_rep_movsq_memcpy((char *)v144, (char *)v142, v145);
        v125 = v125 + 188 & 0xffffffff;
        v126 = v126 + 160 & 0xffffffff;
    }
    // 0xd7ef
    v5 = (v8 ? -8 : (int64_t)&g95) * v145 + v144;
    FUSB_ExFreePool2((int32_t)v3, v5);
    FUSB_ExFreePool2((int32_t)result, v5);
    // 0xd807
    __readgsqword(40);
    return &g1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xd87b - 0xd8ab
// Line range:    8949 - 9027
int32_t DTV_Muli2LibEnable(int64_t pTnim, char * pMulti2LibStartKey, char StartKeyLen) {
    // 0xd87b
    int64_t result; // 0xd87b
    return result;
}

// Address range: 0xd8ab - 0xda45
int64_t DTV_Muli2LibEnable2(int64_t a1, int64_t * a2, char a3) {
    // 0xd8ab
    mcount();
    __readgsqword(40);
    char v1; // bp-88, 0xd8ab
    int64_t v2 = &v1; // 0xd939
    int64_t v3 = 0x100000000 * ((int64_t)a2 + (int64_t)(int32_t)&g1) / 0x100000000;
    int64_t v4 = 0; // 0xd922
    Gen_Identify_Key2(v2, v4 % 256 << (int64_t)&g86);
    uint64_t v5; // 0xd8ab
    int64_t result = v5 % 256; // 0xd949
    int64_t v6; // 0xd8ab
    int64_t v7; // 0xd8ab
    int64_t v8; // bp-120, 0xd8ab
    int64_t v9; // bp-72, 0xd8ab
    int64_t v10; // bp-87, 0xd8ab
    unsigned char v11; // 0xd956
    int64_t v12; // 0xd961
    int64_t v13; // 0xd956
    unsigned char v14; // 0xd991
    int64_t v15; // 0xd9f5
    int32_t v16; // 0xda1f
    int64_t v17; // 0xd9ad
    int64_t * v18; // 0xd9b2
    int32_t v19; // 0xd9bd
    if (v1 == (char)v5) {
        v7 = v3;
        v6 = &v10;
        v11 = *(char *)v7;
        result = v6;
        while (v11 == *(char *)v6) {
            // 0xd95d
            v12 = v6 + (int64_t)&g1;
            if (v12 == (int64_t)&v9) {
                // 0xd97b
                v13 = v11;
                *(char *)(a1 + 0x8fabc) = (char)&g1;
                v14 = *(char *)(a1 + 0x1d30);
                if (v14 != 0) {
                    // 0xd9ee
                    v15 = *(int64_t *)(*(int64_t *)(a1 + 0x1d38) + 1248);
                    *(int64_t *)(a1 + 0x8fab0) = TS_Init2(v15 + 8, 0, (int64_t)v14);
                    v16 = *(int32_t *)(v15 + 0x15d0);
                    return memcpy((int64_t)&v8, v15 + 0x1495, (int64_t)v16, v13);
                }
                // 0xd99d
                v17 = TS_Init2(a1 + (int64_t)&g95, 0, 0);
                v18 = (int64_t *)(a1 + 0x8fab0);
                *v18 = v17;
                v19 = *(int32_t *)(a1 + 0x15d0);
                memcpy((int64_t)&v8, a1 + 0x1495, (int64_t)v19, v13);
                return TS_SetBcasCardID2(*v18);
            }
            v7 += (int64_t)&g1;
            v6 = v12;
            v11 = *(char *)v7;
            result = v6;
        }
    }
    int64_t v20 = v4 + (int64_t)(int32_t)&g1; // 0xd96c
    v4 = v20 & 0xffffffff;
    while ((char)v20 != -128) {
        // 0xd926
        Gen_Identify_Key2(v2, v4 % 256 << (int64_t)&g86);
        result = v5 % 256;
        if (v1 == (char)v5) {
            v7 = v3;
            v6 = &v10;
            v11 = *(char *)v7;
            result = v6;
            while (v11 == *(char *)v6) {
                // 0xd95d
                v12 = v6 + (int64_t)&g1;
                if (v12 == (int64_t)&v9) {
                    // 0xd97b
                    v13 = v11;
                    *(char *)(a1 + 0x8fabc) = (char)&g1;
                    v14 = *(char *)(a1 + 0x1d30);
                    if (v14 != 0) {
                        // 0xd9ee
                        v15 = *(int64_t *)(*(int64_t *)(a1 + 0x1d38) + 1248);
                        *(int64_t *)(a1 + 0x8fab0) = TS_Init2(v15 + 8, 0, (int64_t)v14);
                        v16 = *(int32_t *)(v15 + 0x15d0);
                        return memcpy((int64_t)&v8, v15 + 0x1495, (int64_t)v16, v13);
                    }
                    // 0xd99d
                    v17 = TS_Init2(a1 + (int64_t)&g95, 0, 0);
                    v18 = (int64_t *)(a1 + 0x8fab0);
                    *v18 = v17;
                    v19 = *(int32_t *)(a1 + 0x15d0);
                    memcpy((int64_t)&v8, a1 + 0x1495, (int64_t)v19, v13);
                    return TS_SetBcasCardID2(*v18);
                }
                v7 += (int64_t)&g1;
                v6 = v12;
                v11 = *(char *)v7;
                result = v6;
            }
        }
        // 0xd96c
        v20 = v4 + (int64_t)(int32_t)&g1;
        v4 = v20 & 0xffffffff;
    }
    // 0xd976
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xda45 - 0xda75
// Line range:    7505 - 7592
int32_t DTV_EncAES_TS(int64_t pTuner, char * Input188B, char * Output188B) {
    // 0xda45
    TS_SetBcasCardID2(pTuner);
    int64_t v1 = __readgsqword(40); // 0xda56
    int64_t result = &g1; // 0xda5f
    int64_t v2; // 0xda45
    if (*(int64_t *)(v2 - 56) != v1) {
        // 0xda61
        result = __stack_chk_fail();
    }
    // 0xda66
    return result;
}

// Address range: 0xda75 - 0xde5c
int64_t DTV_EncAES_TS2(int64_t a1, int64_t a2, int64_t a3) {
    // 0xda75
    mcount();
    __readgsqword(40);
    int64_t v1 = *(int64_t *)(a1 + 0x1d38); // 0xdaae
    char v2 = a3;
    char v3 = v2; // 0xdac1
    int64_t v4 = 188; // 0xdac1
    int64_t v5 = a3; // 0xdac1
    if ((v2 & (char)&g1) != 0) {
        // 0xdac3
        *(char *)a3 = 0;
        v5 = a3 + (int64_t)&g1;
        v3 = v5;
        v4 = 187;
    }
    char v6 = v3; // 0xdad0
    int64_t v7 = v4; // 0xdad0
    int64_t v8 = v5; // 0xdad0
    if ((v3 & (char)&g25) != 0) {
        // 0xdad2
        *(int16_t *)v5 = 0;
        v8 = v5 + (int64_t)&g25;
        v6 = v8;
        v7 = v4 + 254 & 191;
    }
    int64_t v9 = v7; // 0xdae0
    int64_t v10 = v8; // 0xdae0
    if ((v6 & (char)&g86) != 0) {
        // 0xdae2
        *(int32_t *)v8 = 0;
        v9 = v7 + 0xfffffffc & 0xffffffff;
        v10 = v8 + (int64_t)&g86;
    }
    int64_t v11 = (int32_t)v9 >> (int32_t)&g33; // 0xdaf0
    __asm_rep_stosq_memset((char *)v10, 0, v11);
    bool v12; // 0xda75
    int64_t v13 = v12 ? -8 : (int64_t)&g95; // 0xdaf2
    int64_t v14 = v13 * v11 + v10; // 0xdaf2
    char v15 = v9; // 0xdaf5
    int64_t v16 = v14; // 0xdaf8
    if ((v15 & (char)&g86) != 0) {
        // 0xdafa
        *(int32_t *)v14 = 0;
        v16 = v14 + (int64_t)&g86;
    }
    int64_t v17 = v16; // 0xdb03
    if ((v15 & (char)&g25) != 0) {
        // 0xdb05
        *(int16_t *)v16 = 0;
        v17 = v16 + (int64_t)&g25;
    }
    if ((v15 & (char)&g1) != 0) {
        // 0xdb11
        *(char *)v17 = 0;
    }
    // 0xdb13
    int64_t v18; // 0xda75
    if (*(char *)(a1 + 0x15d8) == 0) {
        int64_t v19 = a2 + (int64_t)&g94; // 0xdb32
        v18 = v19;
        int64_t v20 = a2; // 0xdb32
        int64_t v21 = a3; // 0xdb32
        *(char *)v21 = *(char *)v20;
        v20 += (int64_t)&g1;
        v21 += (int64_t)&g1;
        while (v20 != v18) {
            // 0xdb36
            *(char *)v21 = *(char *)v20;
            v20 += (int64_t)&g1;
            v21 += (int64_t)&g1;
        }
        int64_t v22 = v1 + 3816; // 0xdb48
        int64_t v23 = a1 + 0x8eea4; // 0xdb56
        int64_t v24 = a1 + 0x8f464; // 0xdb64
        int64_t v25; // bp-103, 0xda75
        int64_t v26 = &v25; // 0xdb86
        int32_t * v27 = (int32_t *)(a1 + 0x8eef0);
        int64_t v28; // bp-88, 0xda75
        int64_t v29 = &v28;
        int64_t v30; // bp-104, 0xda75
        int64_t v31 = &v30;
        int64_t v32 = a3 + (int64_t)&g94;
        int64_t v33 = &g1; // 0xdba3
        int64_t v34 = 0; // 0xdba3
        while (true) {
            int64_t v35 = v34;
            int32_t v36 = v33; // 0xdbad
            if (v36 != (int32_t)&g1) {
                int64_t v37 = 0x100000000 * v35 / 0x100000000 * (int64_t)&g1; // 0xdc23
                int64_t v38 = v37 + v32; // 0xdc23
                v30 = (int64_t)*(char *)v38;
                int64_t v39 = a2 + (int64_t)&g95 + v37; // 0xdc37
                v25 = *(int64_t *)v39;
                int32_t v40 = *(int32_t *)(v39 + (int64_t)&g95); // 0xdc49
                *(int32_t *)(v26 + (int64_t)&g95) = v40;
                int16_t v41 = *(int16_t *)(v39 + (int64_t)"GNU"); // 0xdc4f
                *(int16_t *)(v26 + (int64_t)"GNU") = v41;
                char v42 = *(char *)(v39 + (int64_t)&g103); // 0xdc57
                *(char *)(v26 + (int64_t)&g103) = v42;
                cipherUpdateRounds2(v24, v23, v31, (int64_t *)&g2, v29, *v27, v22);
                *(int64_t *)v38 = v28;
                if (v36 > (int32_t)&g99) {
                    // break -> 0xdca8
                    break;
                }
            } else {
                // 0xdbb3
                v30 = *(int64_t *)v19;
                cipherUpdateRounds2(v24, v23, v31, (int64_t *)&g2, v29, *v27, v22);
                int64_t v43 = 0x100000000 * v35 / 0x100000000 * (int64_t)&g1 + v32; // 0xdc04
                *(int64_t *)v43 = v28;
            }
            // 0xdba5
            v33 = v33 + (int64_t)(int32_t)&g1 & 0xffffffff;
            v34 = v35 + (int64_t)(int32_t)&g105 & 0xffffffff;
        }
        // 0xdca8
        int64_t result; // 0xda75
        return result;
    }
    char v44 = *(char *)(a1 + 0x8f475); // 0xdcad
    if (v44 == 7) {
        // 0xdcb9
        return DTV_Software_process_5606B2_(a1, a2, a3);
    }
    if (v44 != 8) {
        // 0xdd70
        *(char *)a3 = *(char *)&v18;
        char v45 = *(char *)(a2 + (int64_t)&g1); // 0xdd83
        *(char *)(a3 + (int64_t)&g1) = v45;
        char v46 = *(char *)(a2 + (int64_t)&g25); // 0xdd8a
        *(char *)(a3 + (int64_t)&g25) = v46;
        char v47 = *(char *)(a2 + (int64_t)&g33); // 0xdd91
        *(char *)(a3 + (int64_t)&g33) = v47;
        int64_t v48 = *(int64_t *)(a2 + (int64_t)&g86); // bp-296, 0xddd6
        int64_t v49 = *(int64_t *)(a2 + (int64_t)&g86 + (int64_t)&g95); // 0xddda
        uint32_t v50 = *(int32_t *)(a1 + 0x8eef0); // 0xdde2
        rijndaelEncryptRound2(a1 + 0x8eef4, v50, &v48, (int64_t)v50, v1 + 3816);
        *(int64_t *)(a3 + (int64_t)&g86) = v48;
        *(int64_t *)(a3 + (int64_t)&g86 + (int64_t)&g95) = v49;
        char v51 = *(char *)(a2 + (int64_t)&g86 + (int64_t)&g2); // 0xde12
        *(char *)(a3 + (int64_t)&g86 + (int64_t)&g2) = v51;
        char v52 = *(char *)(a2 + (int64_t)&g86 + (int64_t)&g3); // 0xde1b
        *(char *)(a3 + (int64_t)&g86 + (int64_t)&g3) = v52;
        char v53 = *(char *)(a2 + (int64_t)&g86 + (int64_t)&g4); // 0xde24
        *(char *)(a3 + (int64_t)&g86 + (int64_t)&g4) = v53;
        char v54 = *(char *)(a2 + (int64_t)&g86 + (int64_t)&g5); // 0xde2d
        *(char *)(a3 + (int64_t)&g86 + (int64_t)&g5) = v54;
        char v55 = *(char *)(a2 + (int64_t)&g86 + (int64_t)&g7); // 0xde36
        *(char *)(a3 + (int64_t)&g86 + (int64_t)&g7) = v55;
        char v56 = *(char *)(a2 + (int64_t)&g86 + (int64_t)&g9); // 0xde3f
        *(char *)(a3 + (int64_t)&g86 + (int64_t)&g9) = v56;
        unsigned char result2 = *(char *)(a2 + (int64_t)&g86 + (int64_t)&g10); // 0xde48
        *(char *)(a3 + (int64_t)&g86 + (int64_t)&g10) = result2;
        return result2;
    }
    // 0xdcdc
    v18 = a2;
    char v57 = v2; // 0xdcf3
    int64_t v58 = a2; // 0xdcf3
    int64_t v59 = 188; // 0xdcf3
    int64_t v60 = a3; // 0xdcf3
    if ((v2 & (char)&g1) != 0) {
        // 0xdcf5
        *(char *)a3 = (char)a2;
        v60 = a3 + (int64_t)&g1;
        v58 = v18 + (int64_t)&g1;
        v18 = v58;
        v57 = v60;
        v59 = 187;
    }
    char v61 = v57; // 0xdd09
    int64_t v62 = v58; // 0xdd09
    int64_t v63 = v59; // 0xdd09
    int64_t v64 = v60; // 0xdd09
    if ((v57 & (char)&g25) != 0) {
        // 0xdd0b
        *(int16_t *)v60 = *(int16_t *)v58;
        v64 = v60 + (int64_t)&g25;
        v62 = v18 + (int64_t)&g25;
        v18 = v62;
        v61 = v64;
        v63 = v59 + 254 & 191;
    }
    int64_t v65 = v62; // 0xdd20
    int64_t v66 = v63; // 0xdd20
    int64_t v67 = v64; // 0xdd20
    if ((v61 & (char)&g86) != 0) {
        // 0xdd22
        *(int32_t *)v64 = *(int32_t *)v62;
        v65 = v18 + (int64_t)&g86;
        v18 = v65;
        v66 = v63 + 0xfffffffc & 0xffffffff;
        v67 = v64 + (int64_t)&g86;
    }
    int64_t v68 = (int32_t)v66 >> (int32_t)&g33; // 0xdd36
    __asm_rep_movsq_memcpy((char *)v67, (char *)v65, v68);
    int64_t v69 = v13 * v68 + v67; // 0xdd38
    v18 = v69;
    char v70 = v66; // 0xdd40
    int64_t v71 = (v70 & (char)&g86) == 0 ? 0 : (int64_t)&g86;
    int64_t v72 = (v70 & (char)&g25) == 0 ? v71 : v71 + (int64_t)&g25;
    return (int64_t)*(char *)(v72 * (int64_t)&g1 + v69);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xde5d - 0xde8d
// Line range:    7594 - 7616
int32_t DTV_EncAES_MultiTS(int64_t pTuner, char * TSData_In, int32_t FrameNum, char * TSData_Out) {
    // 0xde5d
    int64_t result; // 0xde5d
    return result;
}

// Address range: 0xde8d - 0xdebf
int64_t DTV_EncAES_MultiTS2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0xde8d
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xdec7 - 0xdef7
// Line range:    6890 - 7267
int32_t DTV_DecrypTS(int64_t pTuner, char * Input188B, char * Output188B) {
    // 0xdec7
    int64_t v1; // 0xdec7
    int64_t v2 = *(int64_t *)(v1 - 56); // 0xdecb
    int64_t v3; // 0xdec7
    DTV_EncAES_TS2(v2, v3 + (int64_t)Input188B * (int64_t)&g1, (int64_t)Output188B);
    return &g1;
}

// Address range: 0xdef7 - 0xe479
int64_t DTV_DecrypTS2(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = a2;
    mcount();
    __readgsqword(40);
    char * v2 = (char *)(a1 + (int64_t)&g49); // 0xdf36
    char v3 = *v2; // 0xdf36
    if (v3 == 0) {
        // 0xe470
        return &g1;
    }
    int64_t v4 = *(int64_t *)(a1 + 0x1d38); // 0xdf2f
    char v5 = *(char *)(a1 + (int64_t)&g42); // 0xdf45
    char v6; // bp-248, 0xdef7
    if (v5 == 0) {
        char * v7 = (char *)(a1 + 0x8f475); // 0xdf54
        char v8 = *v7; // 0xdf54
        if (v8 != 7) {
            if (v8 == 8) {
                // 0xdf71
                __asm_rep_movsq_memcpy(&v6, (char *)v1, (int64_t)&g12);
            }
        } else {
            // 0xdf5f
            DTV_Software_process_5606B2_(a1, v1, (int64_t)&v6);
        }
        // 0xdf87
        if (*v2 != (char)&g1) {
            // 0xe470
            return &g1;
        }
        char v9 = *v7; // 0xdf94
        if (v9 == 0) {
            // 0xdf9f
            DTV_HardwareDecrypt_Ver01_(a1, (int64_t *)&v6, a3);
            // 0xe470
            return &g1;
        }
        if (v9 != 1 != v9 != 4) {
            // 0xdfc2
            DTV_HardwareDecrypt2(a1, (int64_t *)&v6, a3);
            // 0xe470
            return &g1;
        }
        if (v9 == 3) {
            // 0xdfdd
            DTV_HardwareDecrypt_5211Ver01_(a1, (int64_t *)&v6, a3);
            // 0xe470
            return &g1;
        }
        int64_t v10; // bp-237, 0xdef7
        int64_t v11; // bp-244, 0xdef7
        char v12; // bp-247, 0xdef7
        int64_t v13; // bp-53, 0xdef7
        if (v9 == 7) {
            // 0xdffc
            *(char *)a3 = v6;
            *(char *)(a3 + (int64_t)&g1) = v12;
            v1 = &v13;
            int64_t v14 = &v10; // 0xe033
            char v15 = *(char *)(a1 + 0x8fcaa); // 0xe03a
            char * v16 = (char *)v14; // 0xe041
            *v16 = *v16 ^ v15;
            char v17 = *(char *)(a1 + 0x8fca9); // 0xe043
            char * v18 = (char *)(v14 - 1); // 0xe04a
            *v18 = *v18 ^ v17;
            char * v19 = (char *)(v14 - 2); // 0xe04d
            *v19 = *v19 ^ v15;
            char v20 = *(char *)(a1 + 0x8fca8); // 0xe050
            char * v21 = (char *)(v14 - 3); // 0xe057
            *v21 = *v21 ^ v20;
            char * v22 = (char *)(v14 - 4); // 0xe05a
            *v22 = *v22 ^ v17;
            char * v23 = (char *)(v14 - 5); // 0xe064
            *v23 = *v23 ^ *(char *)(a1 + 0x8fcab);
            char * v24 = (char *)(v14 - 6); // 0xe067
            *v24 = *v24 ^ v20;
            char * v25 = (char *)(v14 - 7); // 0xe06a
            *v25 = *v25 ^ v20;
            v14 += (int64_t)&g95;
            while (v14 != v1) {
                // 0xe03a
                v15 = *(char *)(a1 + 0x8fcaa);
                v16 = (char *)v14;
                *v16 = *v16 ^ v15;
                v17 = *(char *)(a1 + 0x8fca9);
                v18 = (char *)(v14 - 1);
                *v18 = *v18 ^ v17;
                v19 = (char *)(v14 - 2);
                *v19 = *v19 ^ v15;
                v20 = *(char *)(a1 + 0x8fca8);
                v21 = (char *)(v14 - 3);
                *v21 = *v21 ^ v20;
                v22 = (char *)(v14 - 4);
                *v22 = *v22 ^ v17;
                v23 = (char *)(v14 - 5);
                *v23 = *v23 ^ *(char *)(a1 + 0x8fcab);
                v24 = (char *)(v14 - 6);
                *v24 = *v24 ^ v20;
                v25 = (char *)(v14 - 7);
                *v25 = *v25 ^ v20;
                v14 += (int64_t)&g95;
            }
            int64_t v26 = v4 + 0x3e70; // 0xe076
            int64_t v27 = *(int64_t *)(a1 + 0x8fc98); // 0xe08d
            des_crypt_ecb_Multi2(v27, &v11, a3 + (int64_t)&g86, v26, (int64_t *)&g2);
            int64_t v28 = *(int64_t *)(a1 + 0x8fca0); // 0xe0b1
            int64_t v29; // bp-116, 0xdef7
            des_crypt_ecb_Multi2(v28, &v29, a3 + 132, v26, (int64_t *)&g94);
            // 0xe470
            return &g1;
        }
        if (v9 != 8) {
            // 0xe470
            return &g1;
        }
        int64_t v30 = &v6; // 0xe0d3
        v1 = v30;
        int64_t v31 = v30; // 0xe0e0
        int64_t v32 = a3; // 0xe0e0
        *(char *)v32 = *(char *)v31;
        v31 += (int64_t)&g1;
        v32 += (int64_t)&g1;
        while (v31 != (int64_t)&v11) {
            // 0xe0e4
            *(char *)v32 = *(char *)v31;
            v31 += (int64_t)&g1;
            v32 += (int64_t)&g1;
        }
        // 0xe0f6
        v1 = &v13;
        int64_t v33 = &v10; // 0xe0fd
        char v34 = *(char *)(a1 + 0x8fcaa); // 0xe104
        char * v35 = (char *)v33; // 0xe10b
        *v35 = *v35 ^ v34;
        char v36 = *(char *)(a1 + 0x8fca9); // 0xe10d
        char * v37 = (char *)(v33 - 1); // 0xe114
        *v37 = *v37 ^ v36;
        char * v38 = (char *)(v33 - 2); // 0xe117
        *v38 = *v38 ^ v34;
        char v39 = *(char *)(a1 + 0x8fca8); // 0xe11a
        char * v40 = (char *)(v33 - 3); // 0xe121
        *v40 = *v40 ^ v39;
        char * v41 = (char *)(v33 - 4); // 0xe124
        *v41 = *v41 ^ v36;
        char * v42 = (char *)(v33 - 5); // 0xe12e
        *v42 = *v42 ^ *(char *)(a1 + 0x8fcab);
        char * v43 = (char *)(v33 - 6); // 0xe131
        *v43 = *v43 ^ v39;
        char * v44 = (char *)(v33 - 7); // 0xe134
        *v44 = *v44 ^ v39;
        v33 += (int64_t)&g95;
        while (v33 != v1) {
            // 0xe104
            v34 = *(char *)(a1 + 0x8fcaa);
            v35 = (char *)v33;
            *v35 = *v35 ^ v34;
            v36 = *(char *)(a1 + 0x8fca9);
            v37 = (char *)(v33 - 1);
            *v37 = *v37 ^ v36;
            v38 = (char *)(v33 - 2);
            *v38 = *v38 ^ v34;
            v39 = *(char *)(a1 + 0x8fca8);
            v40 = (char *)(v33 - 3);
            *v40 = *v40 ^ v39;
            v41 = (char *)(v33 - 4);
            *v41 = *v41 ^ v36;
            v42 = (char *)(v33 - 5);
            *v42 = *v42 ^ *(char *)(a1 + 0x8fcab);
            v43 = (char *)(v33 - 6);
            *v43 = *v43 ^ v39;
            v44 = (char *)(v33 - 7);
            *v44 = *v44 ^ v39;
            v33 += (int64_t)&g95;
        }
        // 0xe140
        v1 = v30;
        char v45 = a3;
        char v46 = v45; // 0xe153
        int64_t v47 = v30; // 0xe153
        int64_t v48 = 188; // 0xe153
        int64_t v49 = a3; // 0xe153
        if ((v45 & (char)&g1) != 0) {
            // 0xe155
            *(char *)a3 = v6;
            v49 = a3 + (int64_t)&g1;
            v47 = &v12;
            v1 = v47;
            v46 = v49;
            v48 = 187;
        }
        char v50 = v46; // 0xe16b
        int64_t v51 = v47; // 0xe16b
        int64_t v52 = v48; // 0xe16b
        int64_t v53 = v49; // 0xe16b
        if ((v46 & (char)&g25) != 0) {
            // 0xe16d
            *(int16_t *)v49 = *(int16_t *)v47;
            v53 = v49 + (int64_t)&g25;
            v51 = v1 + (int64_t)&g25;
            v1 = v51;
            v50 = v53;
            v52 = v48 + 254 & 191;
        }
        int64_t v54 = v51; // 0xe182
        int64_t v55 = v52; // 0xe182
        int64_t v56 = v53; // 0xe182
        if ((v50 & (char)&g86) != 0) {
            // 0xe184
            *(int32_t *)v53 = *(int32_t *)v51;
            v54 = v1 + (int64_t)&g86;
            v1 = v54;
            v55 = v52 + 0xfffffffc & 0xffffffff;
            v56 = v53 + (int64_t)&g86;
        }
        // 0xe193
        __asm_rep_movsq_memcpy((char *)v56, (char *)v54, (int64_t)((int32_t)v55 >> (int32_t)&g33));
        return &g1;
    }
    if (v3 == (char)&g1 != (v5 == (char)&g1)) {
        // 0xe470
        return &g1;
    }
    char * v57 = (char *)(a1 + 0x8f475); // 0xe1e3
    char v58 = *v57; // 0xe1e3
    char v59 = v58; // 0xe1f4
    if (v58 == 8) {
        // 0xe1f6
        __asm_rep_movsq_memcpy(&v6, (char *)v1, (int64_t)&g12);
        if (*v2 != (char)&g1) {
            // 0xe470
            return &g1;
        }
        // 0xe1f6
        v59 = *v57;
    }
    char v60 = v59; // 0xe219
    if (v60 == 0) {
        // 0xe224
        DTV_HardwareDecrypt_Ver01_(a1, (int64_t *)&v6, a3);
        // 0xe470
        return &g1;
    }
    if (v60 != 1 != v60 != 4) {
        // 0xe243
        DTV_HardwareDecrypt2(a1, (int64_t *)&v6, a3);
        // 0xe470
        return &g1;
    }
    if (v60 == 3) {
        // 0xe25e
        DTV_HardwareDecrypt_5211Ver01_(a1, (int64_t *)&v6, a3);
        // 0xe470
        return &g1;
    }
    if (v60 == 7) {
        // 0xe27d
        *(char *)a3 = *(char *)&v1;
        char v61 = *(char *)(a2 + (int64_t)&g1); // 0xe286
        *(char *)(a3 + (int64_t)&g1) = v61;
        char v62 = *(char *)(a2 + (int64_t)&g25); // 0xe290
        *(char *)(a3 + (int64_t)&g25) = v62;
        char v63 = *(char *)(a2 + (int64_t)&g33); // 0xe29a
        *(char *)(a3 + (int64_t)&g33) = v63;
        char * v64 = (char *)(a1 + 0x8fcaa); // 0xe2af
        char * v65 = (char *)(a1 + 0x8fca9); // 0xe2b9
        char * v66 = (char *)(a1 + 0x8fca8); // 0xe2cd
        char * v67 = (char *)(a2 + (int64_t)&g99); // 0xe2b6
        *v67 = *v67 ^ *v64;
        char * v68 = (char *)(a2 + (int64_t)&g98); // 0xe2c0
        *v68 = *v68 ^ *v65;
        char * v69 = (char *)(a2 + (int64_t)&g97); // 0xe2ca
        *v69 = *v69 ^ *v64;
        int64_t v70 = a2 + (int64_t)&g95; // 0xe2d4
        *(char *)v70 = *(char *)(a2 + 8) ^ *v66;
        char * v71 = (char *)(a2 + (int64_t)&g94); // 0xe2de
        *v71 = *v71 ^ *v65;
        char * v72 = (char *)(a2 + (int64_t)&g91); // 0xe2e8
        *v72 = *v72 ^ *(char *)(a1 + 0x8fcab);
        char * v73 = (char *)(a2 + (int64_t)&g89); // 0xe2f2
        *v73 = *v73 ^ *v66;
        char * v74 = (char *)(a2 + (int64_t)&g86); // 0xe2fc
        *v74 = *v74 ^ *v66;
        while (v70 != a2 + 184) {
            int64_t v75 = v70;
            v67 = (char *)(v75 + (int64_t)&g99);
            *v67 = *v67 ^ *v64;
            v68 = (char *)(v75 + (int64_t)&g98);
            *v68 = *v68 ^ *v65;
            v69 = (char *)(v75 + (int64_t)&g97);
            *v69 = *v69 ^ *v64;
            v70 = v75 + (int64_t)&g95;
            *(char *)v70 = *(char *)(v75 + 8) ^ *v66;
            v71 = (char *)(v75 + (int64_t)&g94);
            *v71 = *v71 ^ *v65;
            v72 = (char *)(v75 + (int64_t)&g91);
            *v72 = *v72 ^ *(char *)(a1 + 0x8fcab);
            v73 = (char *)(v75 + (int64_t)&g89);
            *v73 = *v73 ^ *v66;
            v74 = (char *)(v75 + (int64_t)&g86);
            *v74 = *v74 ^ *v66;
        }
        int64_t v76 = v4 + 0x3e70; // 0xe308
        int64_t v77 = *(int64_t *)(a1 + 0x8fc98); // 0xe318
        des_crypt_ecb_Multi2(v77, (int64_t *)(a2 + (int64_t)&g86), a3 + (int64_t)&g86, v76, (int64_t *)&g2);
        int64_t v78 = *(int64_t *)(a1 + 0x8fca0); // 0xe33c
        des_crypt_ecb_Multi2(v78, (int64_t *)(a2 + 132), a3 + 132, v76, (int64_t *)&g94);
        // 0xe470
        return &g1;
    }
    if (v60 != 8) {
        // 0xe470
        return &g1;
    }
    char * v79 = (char *)a3; // 0xe363
    *v79 = *(char *)&v1;
    int64_t v80 = a3 + (int64_t)&g1; // 0xe36d
    *(char *)v80 = *(char *)(a2 + (int64_t)&g1);
    char v81 = *(char *)(a2 + (int64_t)&g25); // 0xe371
    *(char *)(a3 + (int64_t)&g25) = v81;
    char v82 = *(char *)(a2 + (int64_t)&g33); // 0xe37b
    *(char *)(a3 + (int64_t)&g33) = v82;
    char * v83 = (char *)(a1 + 0x8fcaa); // 0xe390
    char * v84 = (char *)(a1 + 0x8fca9); // 0xe39a
    char * v85 = (char *)(a1 + 0x8fca8); // 0xe3ae
    char * v86 = (char *)(a2 + (int64_t)&g99); // 0xe397
    *v86 = *v86 ^ *v83;
    char * v87 = (char *)(a2 + (int64_t)&g98); // 0xe3a1
    *v87 = *v87 ^ *v84;
    char * v88 = (char *)(a2 + (int64_t)&g97); // 0xe3ab
    *v88 = *v88 ^ *v83;
    int64_t v89 = a2 + (int64_t)&g95; // 0xe3b5
    *(char *)v89 = *(char *)(a2 + 8) ^ *v85;
    char * v90 = (char *)(a2 + (int64_t)&g94); // 0xe3bf
    *v90 = *v90 ^ *v84;
    char * v91 = (char *)(a2 + (int64_t)&g91); // 0xe3c9
    *v91 = *v91 ^ *(char *)(a1 + 0x8fcab);
    char * v92 = (char *)(a2 + (int64_t)&g89); // 0xe3d3
    *v92 = *v92 ^ *v85;
    char * v93 = (char *)(a2 + (int64_t)&g86); // 0xe3dd
    *v93 = *v93 ^ *v85;
    while (v89 != a2 + 184) {
        int64_t v94 = v89;
        v86 = (char *)(v94 + (int64_t)&g99);
        *v86 = *v86 ^ *v83;
        v87 = (char *)(v94 + (int64_t)&g98);
        *v87 = *v87 ^ *v84;
        v88 = (char *)(v94 + (int64_t)&g97);
        *v88 = *v88 ^ *v83;
        v89 = v94 + (int64_t)&g95;
        *(char *)v89 = *(char *)(v94 + 8) ^ *v85;
        v90 = (char *)(v94 + (int64_t)&g94);
        *v90 = *v90 ^ *v84;
        v91 = (char *)(v94 + (int64_t)&g91);
        *v91 = *v91 ^ *(char *)(a1 + 0x8fcab);
        v92 = (char *)(v94 + (int64_t)&g89);
        *v92 = *v92 ^ *v85;
        v93 = (char *)(v94 + (int64_t)&g86);
        *v93 = *v93 ^ *v85;
    }
    // 0xe3e9
    v1 = a2;
    char v95 = a3;
    char v96 = v95; // 0xe3f8
    int64_t v97 = a2; // 0xe3f8
    int64_t v98 = 188; // 0xe3f8
    int64_t v99 = a3; // 0xe3f8
    if ((v95 & (char)&g1) != 0) {
        // 0xe3fa
        *v79 = (char)a2;
        v97 = v1 + (int64_t)&g1;
        v1 = v97;
        v96 = v80;
        v98 = 187;
        v99 = v80;
    }
    char v100 = v96; // 0xe412
    int64_t v101 = v97; // 0xe412
    int64_t v102 = v98; // 0xe412
    int64_t v103 = v99; // 0xe412
    if ((v96 & (char)&g25) != 0) {
        // 0xe414
        *(int16_t *)v99 = *(int16_t *)v97;
        v103 = v99 + (int64_t)&g25;
        v101 = v1 + (int64_t)&g25;
        v1 = v101;
        v100 = v103;
        v102 = v98 + 254 & 191;
    }
    int64_t v104 = v101; // 0xe429
    int64_t v105 = v102; // 0xe429
    int64_t v106 = v103; // 0xe429
    if ((v100 & (char)&g86) != 0) {
        // 0xe42b
        *(int32_t *)v103 = *(int32_t *)v101;
        v104 = v1 + (int64_t)&g86;
        v1 = v104;
        v105 = v102 + 0xfffffffc & 0xffffffff;
        v106 = v103 + (int64_t)&g86;
    }
    int64_t v107 = (int32_t)v105 >> (int32_t)&g33; // 0xe43f
    __asm_rep_movsq_memcpy((char *)v106, (char *)v104, v107);
    bool v108; // 0xdef7
    v1 = (v108 ? -8 : (int64_t)&g95) * v107 + v106;
    // 0xe470
    return &g1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xe479 - 0xe4a9
// Line range:    6480 - 6589
int32_t DTV_Calculate_Final_Key(int64_t pTuner, char * VID, char * PID, char * EEPROM8b, char * APEncSeed, char * PCKey) {
    // 0xe479
    int64_t result; // 0xe479
    if (__readgsqword(40) != (int64_t)PID) {
        // 0xe492
        result = __stack_chk_fail();
    }
    // 0xe497
    return result;
}

// Address range: 0xe4a9 - 0xe8df
int64_t DTV_Calculate_Final_Key2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0xe4a9
    mcount();
    __readgsqword(40);
    char v1 = (char)&g23; // bp-88, 0xe4f0
    int64_t v2; // bp-200, 0xe4a9
    __asm_rep_stosq_memset((char *)&v2, 0, (int64_t)&g95);
    int64_t str4 = &v2; // 0xe553
    int64_t v3; // bp-168, 0xe4a9
    int64_t v4 = &v3; // 0xe55d
    int64_t str = str4; // 0xe564
    int64_t v5 = a5; // 0xe564
    sprintf(str, 0, (int64_t)*(char *)v5, 0, a5, a6);
    str += (int64_t)&g25;
    v5 += (int64_t)&g1;
    while (str != v4) {
        // 0xe56b
        sprintf(str, 0, (int64_t)*(char *)v5, 0, a5, a6);
        str += (int64_t)&g25;
        v5 += (int64_t)&g1;
    }
    int64_t v6 = *(int64_t *)(a1 + 0x1d38) + 3816; // 0xe594
    int64_t v7; // bp-936, 0xe4a9
    makeKey2(&v7, 0, 128, &v2, v6);
    int64_t v8; // bp-104, 0xe4a9
    int64_t v9 = &v8; // 0xe5cd
    int64_t v10 = (int64_t)&v7 + 240; // 0xe5d1
    int64_t v11 = 0; // 0xe5cd
    uint32_t v12 = *(int32_t *)(v11 + v10); // 0xe5d1
    int64_t v13 = v11 + v9;
    *(char *)v13 = (char)(v12 / 0x1000000);
    *(char *)(v13 + (int64_t)&g1) = (char)(v12 / 0x10000);
    *(char *)(v13 + (int64_t)&g25) = (char)(v12 / 256);
    *(char *)(v13 + (int64_t)&g33) = (char)v12;
    v11 += (int64_t)&g86;
    while (v11 != (int64_t)&g2) {
        // 0xe5d1
        v12 = *(int32_t *)(v11 + v10);
        v13 = v11 + v9;
        *(char *)v13 = (char)(v12 / 0x1000000);
        *(char *)(v13 + (int64_t)&g1) = (char)(v12 / 0x10000);
        *(char *)(v13 + (int64_t)&g25) = (char)(v12 / 256);
        *(char *)(v13 + (int64_t)&g33) = (char)v12;
        v11 += (int64_t)&g86;
    }
    // 0xe600
    __asm_rep_stosq_memset((char *)&v2, v11 & -256, (int64_t)&g95);
    int64_t str2 = str4; // 0xe622
    int64_t v14 = a6; // 0xe622
    sprintf(str2, 0, (int64_t)*(char *)v14, 0, v6, a6);
    str2 += (int64_t)&g25;
    v14 += (int64_t)&g1;
    while (str2 != v4) {
        // 0xe629
        sprintf(str2, 0, (int64_t)*(char *)v14, 0, v6, a6);
        str2 += (int64_t)&g25;
        v14 += (int64_t)&g1;
    }
    // 0xe64b
    makeKey2(&v7, 0, 128, &v2, v6);
    int64_t v15; // bp-120, 0xe4a9
    int64_t v16 = &v15; // 0xe67b
    int64_t v17 = 0; // 0xe67b
    uint32_t v18 = *(int32_t *)(v17 + v10); // 0xe67f
    int64_t v19 = v17 + v16;
    *(char *)v19 = (char)(v18 / 0x1000000);
    *(char *)(v19 + (int64_t)&g1) = (char)(v18 / 0x10000);
    *(char *)(v19 + (int64_t)&g25) = (char)(v18 / 256);
    *(char *)(v19 + (int64_t)&g33) = (char)v18;
    v17 += (int64_t)&g86;
    while (v17 != (int64_t)&g2) {
        // 0xe67f
        v18 = *(int32_t *)(v17 + v10);
        v19 = v17 + v16;
        *(char *)v19 = (char)(v18 / 0x1000000);
        *(char *)(v19 + (int64_t)&g1) = (char)(v18 / 0x10000);
        *(char *)(v19 + (int64_t)&g25) = (char)(v18 / 256);
        *(char *)(v19 + (int64_t)&g33) = (char)v18;
        v17 += (int64_t)&g86;
    }
    int64_t v20 = &v1; // 0xe6ae
    v1 = v16;
    __asm_rep_stosq_memset((char *)&v2, 0, (int64_t)&g95);
    int64_t v21 = v20; // 0xe6f6
    int64_t str3 = str4; // 0xe6f6
    sprintf(str3, 0, (int64_t)*(char *)v21, 0, v6, a6);
    v21 += (int64_t)&g1;
    str3 += (int64_t)&g25;
    int64_t v22; // bp-72, 0xe4a9
    while (v21 != (int64_t)&v22) {
        // 0xe6fd
        sprintf(str3, 0, (int64_t)*(char *)v21, 0, v6, a6);
        v21 += (int64_t)&g1;
        str3 += (int64_t)&g25;
    }
    // 0xe721
    makeKey2(&v7, 0, 128, &v2, v6);
    int64_t v23; // bp-136, 0xe4a9
    int64_t v24 = &v23; // 0xe751
    int64_t v25 = 0; // 0xe751
    uint32_t v26 = *(int32_t *)(v25 + v10); // 0xe755
    int64_t v27 = v25 + v24;
    *(char *)v27 = (char)(v26 / 0x1000000);
    *(char *)(v27 + (int64_t)&g1) = (char)(v26 / 0x10000);
    *(char *)(v27 + (int64_t)&g25) = (char)(v26 / 256);
    *(char *)(v27 + (int64_t)&g33) = (char)v26;
    v25 += (int64_t)&g86;
    int64_t v28 = v9; // 0xe782
    int64_t v29 = v24; // 0xe782
    int64_t v30 = a1; // 0xe782
    int64_t v31 = v16; // 0xe782
    while (v25 != (int64_t)&g2) {
        // 0xe755
        v26 = *(int32_t *)(v25 + v10);
        v27 = v25 + v24;
        *(char *)v27 = (char)(v26 / 0x1000000);
        *(char *)(v27 + (int64_t)&g1) = (char)(v26 / 0x10000);
        *(char *)(v27 + (int64_t)&g25) = (char)(v26 / 256);
        *(char *)(v27 + (int64_t)&g33) = (char)v26;
        v25 += (int64_t)&g86;
        v28 = v9;
        v29 = v24;
        v30 = a1;
        v31 = v16;
    }
    char v32 = *(char *)v31; // 0xe79a
    char v33 = *(char *)v28; // 0xe79d
    char v34 = *(char *)v29; // 0xe7a0
    *(char *)(v30 + (int64_t)&g45) = v33 + v32 + v34;
    int64_t v35 = v28 + (int64_t)&g1; // 0xe7aa
    v28 = v35;
    v29 += (int64_t)&g1;
    v30 += (int64_t)&g1;
    v31 += (int64_t)&g1;
    while (v35 != v20) {
        // 0xe79a
        v32 = *(char *)v31;
        v33 = *(char *)v28;
        v34 = *(char *)v29;
        *(char *)(v30 + (int64_t)&g45) = v33 + v32 + v34;
        v35 = v28 + (int64_t)&g1;
        v28 = v35;
        v29 += (int64_t)&g1;
        v30 += (int64_t)&g1;
        v31 += (int64_t)&g1;
    }
    // 0xe7bf
    __asm_rep_stosq_memset((char *)&v2, 0, (int64_t)&g95);
    char v36 = *(char *)(a1 + 0x148d); // 0xe7d6
    switch (v36) {
        case 11: {
            goto lab_0xe808;
        }
        case 3: {
            // 0xe800
            DTV_5606B2_KeyTransfer1_(a1);
            goto lab_0xe808;
        }
        case 15: {
            // 0xe800
            DTV_5606B2_KeyTransfer1_(a1);
            goto lab_0xe808;
        }
        case 4: {
            // 0xe800
            DTV_5606B2_KeyTransfer1_(a1);
            goto lab_0xe808;
        }
        default: {
            int64_t v37 = a1; // 0xe7fe
            if (v36 != 17) {
                unsigned char v38 = *(char *)(v37 + (int64_t)&g45); // 0xe821
                sprintf(str4, 0, (int64_t)v38, 0, v20, a6);
                int64_t v39 = str4 + (int64_t)&g25; // 0xe83e
                int64_t str5 = v39; // 0xe845
                v37 += (int64_t)&g1;
                while (v39 != v4) {
                    // 0xe821
                    v38 = *(char *)(v37 + (int64_t)&g45);
                    sprintf(str5, 0, (int64_t)v38, 0, v20, a6);
                    v39 = str5 + (int64_t)&g25;
                    str5 = v39;
                    v37 += (int64_t)&g1;
                }
                // 0xe847
                makeKey2((int64_t *)(a1 + 0x8eea4), 0, 128, &v2, v6);
                makeKey2((int64_t *)(a1 + 0x8f184), (int64_t)&g1, 128, &v2, v6);
                cipherInit2(a1 + 0x8f464, (int64_t *)&g1, 0);
                goto lab_0xe808;
            } else {
                // 0xe800
                DTV_5606B2_KeyTransfer1_(a1);
                goto lab_0xe808;
            }
        }
    }
  lab_0xe808:;
    int64_t v40 = (int64_t)*(char *)(a1 + (int64_t)&g45); // 0xe8b9
    int64_t v41 = ChangeEndian2(v40); // 0xe8bc
    *(char *)(a1 + (int64_t)&g46) = (char)v41;
    int64_t result = ChangeEndian2(v40); // 0xe8ca
    *(char *)(a1 + (int64_t)&g48) = (char)result;
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xe8e0 - 0xe910
// Line range:    6397 - 6478
char DTV_5606B2_KeyTransfer2(int64_t pTuner) {
    int64_t v1 = __readgsqword(40); // 0xe8ee
    int64_t result = &g1; // 0xe8f7
    int64_t v2; // 0xe8e0
    if (*(int64_t *)(v2 - 56) != v1) {
        // 0xe8f9
        result = __stack_chk_fail();
    }
    // 0xe8fe
    return result;
}

// Address range: 0xe910 - 0xec4e
int64_t DTV_5606B2_KeyTransfer2_(int64_t a1) {
    // 0xe910
    mcount();
    __readgsqword(40);
    char v1 = (char)&g99; // bp-120, 0xe935
    unsigned char v2 = *(char *)(a1 + (int64_t)"_regions"); // 0xe9ec
    int32_t v3 = (int32_t)*(char *)(a1 + (int64_t)"release_regions"); // 0xe9fe
    int32_t v4 = 2 * (int32_t)*(char *)(a1 + (int64_t)"elease_regions"); // 0xea0c
    unsigned char v5 = *(char *)(a1 + (int64_t)"lease_regions"); // 0xea14
    int32_t v6 = (int32_t)v5 << (int32_t)&g25; // 0xea1b
    unsigned char v7 = *(char *)(a1 + (int64_t)"ease_regions"); // 0xea24
    int32_t v8 = (int32_t)v7 << (int32_t)&g33; // 0xea2b
    unsigned char v9 = *(char *)(a1 + (int64_t)"ase_regions"); // 0xea34
    int32_t v10 = (int32_t)v9 << (int32_t)&g86; // 0xea3b
    unsigned char v11 = *(char *)(a1 + (int64_t)"se_regions"); // 0xea44
    int32_t v12 = (int32_t)v11 << (int32_t)&g89; // 0xea4b
    unsigned char v13 = *(char *)(a1 + (int64_t)"e_regions"); // 0xea54
    int64_t v14 = a1; // 0xea6b
    int64_t v15; // bp-72, 0xe910
    int64_t v16 = &v15; // 0xea6b
    *(char *)v16 = *(char *)(v14 + (int64_t)"regions");
    v14 += (int64_t)&g1;
    v16 += (int64_t)&g1;
    while (v14 != a1 + (int64_t)&g103) {
        // 0xea6f
        *(char *)v16 = *(char *)(v14 + (int64_t)"regions");
        v14 += (int64_t)&g1;
        v16 += (int64_t)&g1;
    }
    int32_t v17 = (int32_t)v13 << (int32_t)&g91 & 64; // 0xea5e
    int64_t v18; // bp-8, 0xe910
    int64_t v19 = &v18; // 0xe911
    int32_t v20 = v3 & (int32_t)&g1 | (int32_t)v2 << (int32_t)&g94 | v4 & (int32_t)&g25 | v6 & (int32_t)&g86 | v8 & (int32_t)&g95 | v10 & (int32_t)&g2 | v12 & (int32_t)&g26; // 0xea51
    int64_t v21; // bp-88, 0xe910
    int64_t v22 = &v21; // 0xea89
    int64_t v23 = v19 - 64; // 0xea97
    int64_t v24 = v22; // 0xea91
    int64_t v25 = &v1; // 0xea91
    unsigned char v26 = *(char *)v25; // 0xea94
    char v27 = *(char *)(v23 + (int64_t)v26 * (int64_t)&g1); // 0xea97
    *(char *)v24 = v27;
    v25 += (int64_t)&g1;
    v24 += (int64_t)&g1;
    int64_t v28; // bp-106, 0xe910
    while (v25 != (int64_t)&v28) {
        // 0xea94
        v26 = *(char *)v25;
        v27 = *(char *)(v23 + (int64_t)v26 * (int64_t)&g1);
        *(char *)v24 = v27;
        v25 += (int64_t)&g1;
        v24 += (int64_t)&g1;
    }
    char v29 = v20 | v17; // bp-136, 0xeab4
    int32_t v30; // bp-104, 0xe910
    int64_t v31 = &v30; // 0xeae8
    int64_t v32 = v22; // 0xeaf0
    int64_t v33 = &v29; // 0xeaf0
    int64_t v34 = v31; // 0xeaf0
    *(char *)v34 = *(char *)v32 ^ *(char *)v33;
    v32 += (int64_t)&g1;
    v33 += (int64_t)&g1;
    v34 += (int64_t)&g1;
    int64_t v35; // bp-74, 0xe910
    while (v32 != (int64_t)&v35) {
        // 0xeaf3
        *(char *)v34 = *(char *)v32 ^ *(char *)v33;
        v32 += (int64_t)&g1;
        v33 += (int64_t)&g1;
        v34 += (int64_t)&g1;
    }
    // 0xeb0d
    uint32_t v36; // 0xe910
    uint32_t v37; // 0xe910
    *(char *)(a1 + 0x8fca8) = (char)v37 >> (char)&g86 | (char)(v36 % 256 << (int32_t)&g86);
    unsigned char v38; // 0xe910
    *(char *)(a1 + 0x8fca9) = v38 >> (char)&g86 | (char)(v37 % 256 << (int32_t)&g86);
    unsigned char v39; // 0xe910
    int32_t v40; // 0xe910
    *(char *)(a1 + 0x8fcaa) = (char)v40 & -16 | v39 >> (char)&g86;
    int32_t v41; // 0xe910
    *(char *)(a1 + 0x8fcab) = (char)(v30 & (int32_t)&g105 & 255 | v41 & 240);
    int64_t v42 = v19 - 256; // 0xeb83
    int64_t v43 = 0; // 0xeb68
    int64_t v44 = v31; // 0xeb68
    unsigned char v45 = *(char *)v44; // 0xeb71
    int64_t v46 = 0; // 0xeb71
    uint32_t v47 = (int32_t)v46 & (int32_t)&g24 & 255; // 0xeb7c
    char v48 = v47 == 0 ? v45 : (char)((int32_t)v45 >> v47);
    *(char *)(0x100000000 * (v46 * (int64_t)&g1 + v43) / 0x100000000 + v42) = v48 & (char)&g1;
    int64_t v49 = v46 + (int64_t)(int32_t)&g1; // 0xeb8b
    v46 = v49 & 0xffffffff;
    while ((int32_t)v49 != (int32_t)&g95) {
        // 0xeb74
        v47 = (int32_t)v46 & (int32_t)&g24 & 255;
        v48 = v47 == 0 ? v45 : (char)((int32_t)v45 >> v47);
        *(char *)(0x100000000 * (v46 * (int64_t)&g1 + v43) / 0x100000000 + v42) = v48 & (char)&g1;
        v49 = v46 + (int64_t)(int32_t)&g1;
        v46 = v49 & 0xffffffff;
    }
    int64_t v50 = v43 + (int64_t)(int32_t)&g95; // 0xeb97
    v43 = v50 & 0xffffffff;
    v44 += (int64_t)&g1;
    while ((int32_t)v50 != 112) {
        // 0xeb6e
        v45 = *(char *)v44;
        v46 = 0;
        v47 = (int32_t)v46 & (int32_t)&g24 & 255;
        v48 = v47 == 0 ? v45 : (char)((int32_t)v45 >> v47);
        *(char *)(0x100000000 * (v46 * (int64_t)&g1 + v43) / 0x100000000 + v42) = v48 & (char)&g1;
        v49 = v46 + (int64_t)(int32_t)&g1;
        v46 = v49 & 0xffffffff;
        while ((int32_t)v49 != (int32_t)&g95) {
            // 0xeb74
            v47 = (int32_t)v46 & (int32_t)&g24 & 255;
            v48 = v47 == 0 ? v45 : (char)((int32_t)v45 >> v47);
            *(char *)(0x100000000 * (v46 * (int64_t)&g1 + v43) / 0x100000000 + v42) = v48 & (char)&g1;
            v49 = v46 + (int64_t)(int32_t)&g1;
            v46 = v49 & 0xffffffff;
        }
        // 0xeb93
        v50 = v43 + (int64_t)(int32_t)&g95;
        v43 = v50 & 0xffffffff;
        v44 += (int64_t)&g1;
    }
    int64_t v51 = 0; // 0xebb4
    int64_t v52; // bp-33, 0xe910
    int64_t v53 = &v52; // 0xebb4
    int64_t v54 = 0; // 0xebe4
    unsigned char v55 = *(char *)(0x100000000 * (v54 * (int64_t)&g1 + v51) / 0x100000000 * (int64_t)&g1 + v42); // 0xebbc
    int64_t v56 = v54 + (int64_t)(int32_t)&g1; // 0xebc4
    int32_t v57 = v56; // 0xebc7
    uint32_t v58 = v57 & (int32_t)&g24 & 255; // 0xebc7
    int64_t v59 = v55; // 0xebc7
    if (v58 != 0) {
        v59 = (int32_t)v55 << v58;
    }
    int64_t v60 = v59;
    int64_t v61 = v60; // 0xebce
    v54 = v56 & 0xffffffff;
    while (v57 != (int32_t)&g94) {
        // 0xebb6
        v55 = *(char *)(0x100000000 * (v54 * (int64_t)&g1 + v51) / 0x100000000 * (int64_t)&g1 + v42);
        v56 = v54 + (int64_t)(int32_t)&g1;
        v57 = v56;
        v58 = v57 & (int32_t)&g24 & 255;
        v59 = v55;
        if (v58 != 0) {
            v59 = (int32_t)v55 << v58;
        }
        v60 = v59 | v61;
        v61 = v60;
        v54 = v56 & 0xffffffff;
    }
    // 0xebd0
    *(char *)v53 = (char)v60;
    int64_t v62 = v51 + (int64_t)(int32_t)&g94; // 0xebd6
    v51 = v62 & 0xffffffff;
    v53 -= (int64_t)&g1;
    while ((int32_t)v62 != 56) {
        // 0xebde
        v54 = 0;
        v55 = *(char *)(0x100000000 * (v54 * (int64_t)&g1 + v51) / 0x100000000 * (int64_t)&g1 + v42);
        v56 = v54 + (int64_t)(int32_t)&g1;
        v57 = v56;
        v58 = v57 & (int32_t)&g24 & 255;
        v59 = v55;
        if (v58 != 0) {
            v59 = (int32_t)v55 << v58;
        }
        v60 = v59;
        v61 = v60;
        v54 = v56 & 0xffffffff;
        while (v57 != (int32_t)&g94) {
            // 0xebb6
            v55 = *(char *)(0x100000000 * (v54 * (int64_t)&g1 + v51) / 0x100000000 * (int64_t)&g1 + v42);
            v56 = v54 + (int64_t)(int32_t)&g1;
            v57 = v56;
            v58 = v57 & (int32_t)&g24 & 255;
            v59 = v55;
            if (v58 != 0) {
                v59 = (int32_t)v55 << v58;
            }
            v60 = v59 | v61;
            v61 = v60;
            v54 = v56 & 0xffffffff;
        }
        // 0xebd0
        *(char *)v53 = (char)v60;
        v62 = v51 + (int64_t)(int32_t)&g94;
        v51 = v62 & 0xffffffff;
        v53 -= (int64_t)&g1;
    }
    int64_t v63 = 56; // 0xebfb
    int64_t v64; // bp-49, 0xe910
    int64_t v65 = &v64; // 0xebfb
    int64_t v66 = v63; // 0xec2e
    int64_t v67 = &g1; // 0xebfd
    unsigned char v68 = *(char *)(0x100000000 * v66 / 0x100000000 + v42); // 0xec03
    int32_t v69 = v67; // 0xec0b
    uint32_t v70 = v69 & (int32_t)&g24 & 255; // 0xec0b
    int64_t v71 = v68; // 0xec0b
    if (v70 != 0) {
        v71 = (int32_t)v68 << v70;
    }
    int64_t v72 = v71; // 0xec0d
    v66 = v66 + 1 & 0xffffffff;
    int64_t v73 = v67 & 0xffffffff; // 0xec15
    int64_t v74 = v72; // 0xec15
    while (v69 != (int32_t)&g94) {
        // 0xebfd
        v67 = v73 + (int64_t)(int32_t)&g1;
        v68 = *(char *)(0x100000000 * v66 / 0x100000000 + v42);
        v69 = v67;
        v70 = v69 & (int32_t)&g24 & 255;
        v71 = v68;
        if (v70 != 0) {
            v71 = (int32_t)v68 << v70;
        }
        v72 = v71 | v74;
        v66 = v66 + 1 & 0xffffffff;
        v73 = v67 & 0xffffffff;
        v74 = v72;
    }
    // 0xec17
    *(char *)v65 = (char)v72;
    int64_t v75 = v63 + 7; // 0xec1e
    v63 = v75 & 0xffffffff;
    v65 -= (int64_t)&g1;
    while ((int32_t)v75 != 112) {
        // 0xec26
        v66 = v63;
        v67 = &g1;
        v68 = *(char *)(0x100000000 * v66 / 0x100000000 + v42);
        v69 = v67;
        v70 = v69 & (int32_t)&g24 & 255;
        v71 = v68;
        if (v70 != 0) {
            v71 = (int32_t)v68 << v70;
        }
        v72 = v71;
        v66 = v66 + 1 & 0xffffffff;
        v73 = v67 & 0xffffffff;
        v74 = v72;
        while (v69 != (int32_t)&g94) {
            // 0xebfd
            v67 = v73 + (int64_t)(int32_t)&g1;
            v68 = *(char *)(0x100000000 * v66 / 0x100000000 + v42);
            v69 = v67;
            v70 = v69 & (int32_t)&g24 & 255;
            v71 = v68;
            if (v70 != 0) {
                v71 = (int32_t)v68 << v70;
            }
            v72 = v71 | v74;
            v66 = v66 + 1 & 0xffffffff;
            v73 = v67 & 0xffffffff;
            v74 = v72;
        }
        // 0xec17
        *(char *)v65 = (char)v72;
        v75 = v63 + 7;
        v63 = v75 & 0xffffffff;
        v65 -= (int64_t)&g1;
    }
    // 0xec30
    return des_setkey_dec2(*(int64_t *)(a1 + 0x8fc98));
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xec52 - 0xec82
// Line range:    7457 - 7503
int32_t DTV_DecrypMultiTS_no_decrypt_multi2(int64_t pTnim, char * TSData_In, int32_t FrameNum, char * TSData_Out) {
    // 0xec52
    int64_t v1; // 0xec52
    *(char *)v1 = (char)v1;
    des_setkey_dec2(pTnim);
    int64_t v2 = __readgsqword(40); // 0xec66
    int64_t result = &g1; // 0xec6f
    int64_t v3; // 0xec52
    if (*(int64_t *)(v3 - 24) != v2) {
        // 0xec71
        result = __stack_chk_fail();
    }
    // 0xec76
    return result;
}

// Address range: 0xec82 - 0xed68
int64_t DTV_DecrypMultiTS_no_decrypt_multi2_(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0xec82
    mcount();
    char * v1 = (char *)(a1 + 0x8f475); // 0xeca5
    if (*v1 < 9) {
        // 0xecb3
        DTV_5606B2_KeyTransfer2_(a1);
    }
    int64_t v2 = 0; // 0xecbb
    int64_t v3 = 0; // 0xecbb
    if ((int32_t)a3 >= 1) {
        int64_t v4 = 0x100000000 * v2 / 0x100000000; // 0xecc8
        DTV_DecrypTS2(a1, v4 + a2, v4 + a4);
        v3 = v3 + (int64_t)(int32_t)&g1 & 0xffffffff;
        v2 = v2 + 188 & 0xffffffff;
        while ((a3 & 0xffffffff) > v3) {
            // 0xecc8
            v4 = 0x100000000 * v2 / 0x100000000;
            DTV_DecrypTS2(a1, v4 + a2, v4 + a4);
            v3 = v3 + (int64_t)(int32_t)&g1 & 0xffffffff;
            v2 = v2 + 188 & 0xffffffff;
        }
    }
    // 0xecea
    if (*v1 < 9) {
        int64_t v5 = *(int64_t *)(a1 + 0x8fc98); // 0xecfa
        __asm_rep_stosq_memset((char *)v5, 0, (int64_t)&g28);
        int64_t v6 = *(int64_t *)(a1 + 0x8fca0); // 0xed11
        __asm_rep_stosq_memset((char *)v6, 0, (int64_t)&g28);
        return 0;
    }
    // 0xed22
    *(int32_t *)(a1 + 0x8eea4) = 0;
    int64_t v7 = a1 + 0x8eea8; // 0xed36
    __asm_rep_stosq_memset((char *)v7, 0, 91);
    bool v8; // 0xec82
    int64_t v9 = v8 ? -728 : 728; // 0xed42
    *(int32_t *)(v9 + v7) = 0;
    *(int32_t *)(a1 + 0x8f184) = 0;
    int64_t v10 = a1 + 0x8f188; // 0xed56
    __asm_rep_stosq_memset((char *)v10, 0, 91);
    *(int32_t *)(v9 + v10) = 0;
    return 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xed68 - 0xed98
// Line range:    7380 - 7455
int32_t DTV_DecrypMultiTS(int64_t pTnim, char * TSData_In, int32_t FrameNum, char * TSData_Out) {
    // 0xed68
    int64_t v1; // 0xed68
    *(int64_t *)(v1 + 0x8f464) = 0;
    *(int64_t *)(v1 + 0x8f46c) = 0;
    *(char *)(v1 + 0x8f474) = 0;
    return &g1;
}

// Address range: 0xed98 - 0xef17
int64_t DTV_DecrypMultiTS2(int64_t a1, int64_t a2, uint32_t a3, int64_t a4) {
    // 0xed98
    mcount();
    char * v1 = (char *)(a1 + 0x8f475); // 0xedca
    if (*v1 < 9) {
        // 0xedd8
        DTV_5606B2_KeyTransfer2_(a1);
    }
    int64_t v2 = 0; // 0xede0
    int64_t v3 = 0; // 0xede0
    if (a3 >= 1) {
        int64_t v4 = 0x100000000 * v2 / 0x100000000; // 0xeded
        DTV_DecrypTS2(a1, v4 + a2, v4 + a4);
        v3 = v3 + (int64_t)(int32_t)&g1 & 0xffffffff;
        v2 = v2 + 188 & 0xffffffff;
        while (v3 < (int64_t)a3) {
            // 0xeded
            v4 = 0x100000000 * v2 / 0x100000000;
            DTV_DecrypTS2(a1, v4 + a2, v4 + a4);
            v3 = v3 + (int64_t)(int32_t)&g1 & 0xffffffff;
            v2 = v2 + 188 & 0xffffffff;
        }
    }
    char v5 = *v1; // 0xee0f
    if (v5 < 9) {
        int64_t v6 = *(int64_t *)(a1 + 0x8fc98); // 0xee1f
        __asm_rep_stosq_memset((char *)v6, 0, (int64_t)&g28);
        int64_t v7 = *(int64_t *)(a1 + 0x8fca0); // 0xee36
        __asm_rep_stosq_memset((char *)v7, 0, (int64_t)&g28);
    } else {
        if (v5 == 6) {
            // 0xee4b
            *(int32_t *)(a1 + 0x8eea4) = 0;
            int64_t v8 = a1 + 0x8eea8; // 0xee5b
            __asm_rep_stosq_memset((char *)v8, 0, 91);
            bool v9; // 0xed98
            int64_t v10 = v9 ? -728 : 728; // 0xee67
            *(int32_t *)(v10 + v8) = 0;
            *(int32_t *)(a1 + 0x8f184) = 0;
            int64_t v11 = a1 + 0x8f188; // 0xee7b
            __asm_rep_stosq_memset((char *)v11, 0, 91);
            *(int32_t *)(v10 + v11) = 0;
            *(int64_t *)(a1 + 0x8f464) = 0;
            *(int64_t *)(a1 + 0x8f46c) = 0;
            *(char *)(a1 + 0x8f474) = 0;
        }
    }
    // 0xeea7
    DTV_GetResetMulti2LibFlag2(a1);
    char * v12 = (char *)(a1 + 0x8fabd); // 0xeec1
    if (*v12 == 1) {
        // 0xeed1
        TS_Reset2(*(int64_t *)(a1 + 0x8fab0));
        *v12 = 0;
    }
    int64_t result = *(int64_t *)(*(int64_t *)(a1 + 0x1d38) + 1248); // 0xeef3
    if (*(char *)(result + 0x1340) != 0) {
        // 0xef12
        return result;
    }
    // 0xef03
    return DTV_SetBCASCardExist2(a1);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xef19 - 0xef49
// Line range:    5948 - 5976
int32_t DTV_Set_EncSeedRegEx(int64_t pTuner, char * EncSeed_CE, char EncSeedLen) {
    // 0xef19
    int64_t v1; // 0xef19
    __asm_out((int16_t)EncSeedLen, (int32_t)v1);
    DTV_SetBCASCardExist2(pTuner);
    int64_t v2; // 0xef19
    int64_t v3; // 0xef19
    int64_t v4; // 0xef19
    TS_Process2(*(int64_t *)(v4 + 0x8fab0), v3, 188 * v2 & 0xfffffffc);
    return &g1;
}

// Address range: 0xef49 - 0xefb8
int64_t DTV_Set_EncSeedRegEx2(int64_t a1, int64_t a2, int64_t * a3) {
    // 0xef49
    mcount();
    return 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xefbb - 0xefeb
// Line range:    5924 - 5945
int32_t DTV_Reset_EncChipEx(int64_t pTuner) {
    // 0xefbb
    int64_t result; // 0xefbb
    return result;
}

// Address range: 0xefbc - 0xefd0
int64_t function_efbc(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0xefbc
    int64_t v1; // 0xefbc
    int32_t * v2 = (int32_t *)(a4 - 29 + v1 * (int64_t)&g1); // 0xefbc
    *v2 = *v2 + (int32_t)&g1;
    return (char)v1 == (char)&g1 ? v1 : 0xfffffffe;
}

// Address range: 0xefeb - 0xf014
int64_t DTV_Reset_EncChipEx2(int64_t a1, int64_t a2, int64_t a3) {
    // 0xefeb
    mcount();
    return *(int64_t *)(a1 + 0x1d38);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf014 - 0xf044
// Line range:    5902 - 5922
int32_t DTV_Set_EncSeedReg(int64_t pTnim, char * EncSeed_CE, char EncSeedLen) {
    // 0xf014
    int64_t v1; // 0xf014
    *(char *)(v1 - 1) = EncSeedLen - 96;
    int64_t v2; // 0xf014
    int64_t v3; // 0xf014
    int64_t v4 = FUSBDTV_Cmd_EncRead(v3, (char)&g98, (char)&g1, (int16_t)v1 - 1, (char *)v2); // 0xf02b
    int32_t result = (char)v4 != (char)&g1 ? -2 : (int32_t)&g1; // 0xf043
    return result;
}

// Address range: 0xf044 - 0xf07c
int64_t DTV_Set_EncSeedReg2(int64_t a1, int64_t a2, int64_t * a3) {
    // 0xf044
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf091 - 0xf0c1
// Line range:    5879 - 5900
int32_t DTV_StartStop_Enc(int64_t pTnim, char bStart) {
    // 0xf091
    int64_t v1; // 0xf091
    int64_t v2 = FUSBDTV_InitializeStreamUrb_ISR(v1); // 0xf097
    int32_t result = (char)v2 == (char)&g1 ? (int32_t)&g1 : -2;
    return result;
}

// Address range: 0xf0c1 - 0xf0f0
int64_t DTV_StartStop_Enc2(int64_t a1, int64_t a2) {
    // 0xf0c1
    mcount();
    return *(int64_t *)(a1 + 0x1d38);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf0f0 - 0xf120
// Line range:    5859 - 5876
int32_t DTV_Reset_EncChip(int64_t pTnim) {
    int64_t v1 = FUSBDTV_InitializeStreamUrb_ISR(pTnim); // 0xf0f5
    int32_t result = (char)v1 != (char)&g1 ? -2 : (int32_t)&g1; // 0xf11f
    return result;
}

// Address range: 0xf120 - 0xf129
int64_t DTV_Reset_EncChip2(int64_t a1) {
    // 0xf120
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf12e - 0xf15e
// Line range:    5782 - 5855
char ASV5220_bReadBCAS_Data(int64_t pTuner, char * DataBuf, int32_t * GetLen, char bRdATR, char bRdEcm, int32_t BufferSz) {
    // 0xf12e
    int64_t v1; // 0xf12e
    *(char *)v1 = 2 * (char)v1;
    if (*(char *)(pTuner + 0x15eb) != 17 || *(char *)(pTuner + 0x15d8) == 1) {
        // 0xf15c
        return &g1;
    }
    int64_t v2 = FUSBDTV_ProcessTransfer(v1); // 0xf145
    if ((char)v2 != (char)&g1) {
        // 0xf15c
        return -2;
    }
    // 0xf15c
    return &g1;
}

// Address range: 0xf15e - 0xf2c9
int64_t ASV5220_bReadBCAS_Data2(int64_t a1, int64_t * a2, int64_t * a3, int64_t a4, int64_t a5, int64_t a6) {
    int64_t v1 = (int64_t)a2;
    mcount();
    __readgsqword(40);
    int64_t v2 = *(int64_t *)(a1 + 0x1d38); // 0xf1a2
    if ((char)a4 == (char)&g1) {
        int64_t result = ASV5220_ReadResponse2(v1, "NU", "%(", v2); // 0xf1d2
        if (result != (int64_t)&g1) {
            // 0xf1f5
            *(int32_t *)a3 = 0;
            return (int64_t)a3;
        }
        // 0xf1dd
        *(int32_t *)a3 = (int32_t)"NU";
        return result;
    }
    // 0xf20d
    int64_t v3; // bp-584, 0xf15e
    int64_t v4 = &v3; // 0xf221
    char * v5 = (char)a5 < (char)&g1 ? (char *)1000 : (char *)600; // 0xf230
    int64_t v6 = ASV5220_ReadResponse2(v4, (char *)&g33, v5, v2); // 0xf230
    int64_t v7 = 0; // 0xf244
    if (v6 == (int64_t)&g1) {
        // 0xf246
        uint32_t v8; // 0xf15e
        uint32_t v9 = v8 % 256 + (int32_t)&g1; // 0xf24d
        v7 = (int64_t)&g33;
        if (v9 >= 1) {
            int64_t v10 = (int64_t)&g33; // 0xf269
            int64_t v11; // bp-581, 0xf15e
            int64_t v12 = &v11; // 0xf269
            int64_t v13 = 0; // 0xf269
            int64_t v14 = ASV5220_ReadResponse2(v12, (char *)&g1, &g89, v2); // 0xf27f
            v7 = v10;
            while (v14 == (int64_t)&g1) {
                // 0xf292
                v10 = v10 + (int64_t)(int32_t)&g1 & 0xffffffff;
                int64_t v15 = v13 + (int64_t)(int32_t)&g1; // 0xf295
                v12 += (int64_t)&g1;
                v13 = v15 & 0xffffffff;
                v7 = v10;
                if (v9 <= (int32_t)v15) {
                    // break -> 0xf2ac
                    break;
                }
                v14 = ASV5220_ReadResponse2(v12, (char *)&g1, &g89, v2);
                v7 = v10;
            }
        }
    }
    int64_t v16 = v7;
    int32_t v17 = v16; // 0xf2ac
    int32_t v18 = v17 - (int32_t)a6; // 0xf2ac
    int64_t v19 = v18 < 0 == ((v18 ^ v17) & (int32_t)(v16 ^ a6)) < 0 == (v18 != 0) ? a6 : v16;
    return memcpy(v1, v4, 0x100000000 * v19 / 0x100000000, v2);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf2cf - 0xf2f5
// Line range:    5760 - 5775
char ASV5220_bWtBCAS_Data(int64_t pTuner, char * DataBuf, int32_t WtLen) {
    // 0xf2cf
    int64_t v1; // 0xf2cf
    int32_t * v2 = (int32_t *)(v1 - 0x1f76bbe6); // 0xf2cf
    *v2 = *v2 - (int32_t)&g1;
    int64_t result; // 0xf2cf
    int64_t v3; // 0xf2cf
    if (*(int64_t *)(v3 - 56) != __readgsqword(40)) {
        // 0xf2e4
        result = __stack_chk_fail();
    }
    // 0xf2e9
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf2f5 - 0xf2ff
// Line range:    4745 - 4835
char ASV5220_Get_BCAS_INFO(int64_t BCAS_Dev) {
    // 0xf2f5
    int64_t result; // 0xf2f5
    return result;
}

// Address range: 0xf2ff - 0xf325
int64_t ASV5220_bWtBCAS_Data2(int64_t a1, char * a2, int64_t * a3) {
    // 0xf2ff
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x1d38); // 0xf310
    int64_t v2 = ASV5220_WriteCommand2((int64_t)a2, (int64_t)a3 & 0xffffffff, v1); // 0xf317
    return v2 & -256 | (int64_t)(v2 == (int64_t)&g1);
}

// Address range: 0xf325 - 0xf46f
int64_t ASV5220_Get_BCAS_INFO2(int64_t a1) {
    // 0xf325
    mcount();
    __readgsqword(40);
    char v1 = 0; // bp-104, 0xf36b
    char * v2 = (char *)(a1 + 0x1482); // 0xf36f
    char v3 = *v2 == 0 ? 0 : 64; // bp-103, 0xf37d
    char v4 = 0; // bp-96, 0xf3a3
    int64_t v5 = &v4; // 0xf3aa
    char v6 = 0; // 0xf3aa
    int64_t v7 = &v3; // 0xf3aa
    v6 ^= *(char *)v7;
    v4 = v6;
    v7 += (int64_t)&g1;
    while (v7 != v5) {
        // 0xf3ae
        v6 ^= *(char *)v7;
        v4 = v6;
        v7 += (int64_t)&g1;
    }
    int64_t * v8 = (int64_t *)(a1 + 72); // 0xf3c1
    ASV5220_bWtBCAS_Data2(*v8, &v1, (int64_t *)&g97);
    int64_t v9; // bp-424, 0xf325
    int32_t v10; // bp-428, 0xf325
    ASV5220_bReadBCAS_Data2(*v8, &v9, (int64_t *)&v10, 0, 0, 320);
    if (v10 > (int32_t)&g86) {
        // 0xf40e
        *(int32_t *)(a1 + 0x15c8) = v10 - (int32_t)&g86;
    } else {
        // 0xf419
        *(int32_t *)(a1 + 0x15c8) = 0;
    }
    // 0xf423
    if (v10 - (int32_t)&g1 <= (int32_t)&g33) {
        // 0xf462
        return (int64_t)(*v2 % 2 ^ 1);
    }
    int64_t v11 = (int64_t)&g33; // 0xf43b
    int64_t v12; // bp-421, 0xf325
    int64_t v13 = &v12; // 0xf43b
    int64_t v14 = a1; // 0xf43b
    *(char *)(v14 + 0x1486) = *(char *)v13;
    v11 = v11 + (int64_t)(int32_t)&g1 & 0xffffffff;
    v13 += (int64_t)&g1;
    v14 += (int64_t)&g1;
    while (v11 < (int64_t)(v10 - (int32_t)&g1)) {
        // 0xf440
        *(char *)(v14 + 0x1486) = *(char *)v13;
        v11 = v11 + (int64_t)(int32_t)&g1 & 0xffffffff;
        v13 += (int64_t)&g1;
        v14 += (int64_t)&g1;
    }
    // 0xf462
    return (int64_t)(*v2 % 2 ^ 1);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf46f - 0xf49f
// Line range:    5734 - 5756
void DTV_PollingDeviceThreadClose(int64_t deviceExtension) {
    // 0xf46f
    int64_t v1; // 0xf46f
    int64_t v2; // 0xf46f
    *(char *)(v1 + 0x1482) = (char)v2;
    int64_t v3; // 0xf46f
    if (*(int64_t *)(v3 - 24) != __readgsqword(40)) {
        // 0xf490
        __stack_chk_fail();
    }
}

// Address range: 0xf49f - 0xf4b9
int64_t DTV_PollingDeviceThreadClose2(int64_t a1) {
    // 0xf49f
    return mcount();
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf4bf - 0xf4ef
// Line range:    5670 - 5732
void ASV5220_BcasThreadClose(int64_t pTnim) {
    // 0xf4bf
    int64_t v1; // 0xf4bf
    int32_t * v2 = (int32_t *)(v1 + 0x1000054); // 0xf4c1
    int64_t v3; // 0xf4bf
    *v2 = (int32_t)v3;
    int64_t v4; // 0xf4bf
    wait_for_completion(pTnim + 0x5470, (int32_t)v1 + (int32_t)v4, *v2);
    int64_t v5; // 0xf4bf
    int64_t * v6 = (int64_t *)(v5 + 0x5498); // 0xf4d3
    if (*v6 != 0) {
        // 0xf4dd
        *v6 = 0;
    }
}

// Address range: 0xf4ef - 0xf560
int64_t ASV5220_BcasThreadClose2(int64_t a1) {
    // 0xf4ef
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x1d38); // 0xf4fd
    unsigned char v2 = *(char *)(a1 + 0x1d30); // 0xf504
    int64_t v3 = v2; // 0xf504
    if (*(char *)(v1 + 0x54f9) == 0) {
        // 0xf51c
        *(char *)(v1 + 0x54fa + v3) = 0;
        return 0;
    }
    int64_t result = 0;
    if (v2 != (char)result) {
        // 0xf52d
        if (*(char *)(v1 + 0x54fa) == 1) {
            // 0xf543
            *(char *)(v1 + 0x54fa + v3) = 0;
            return result;
        }
    }
    int64_t v4 = result + (int64_t)(int32_t)&g1; // 0xf536
    int64_t result2 = v4 & 0xffffffff; // 0xf536
    int64_t v5 = v1 + 1; // 0xf53f
    while ((char)v4 != (char)&g95) {
        int64_t v6 = v5;
        result = result2;
        if (v2 != (char)result) {
            // 0xf52d
            if (*(char *)(v6 + 0x54fa) == 1) {
                // 0xf543
                *(char *)(v1 + 0x54fa + v3) = 0;
                return result;
            }
        }
        // 0xf536
        v4 = result + (int64_t)(int32_t)&g1;
        result2 = v4 & 0xffffffff;
        v5 = v6 + 1;
    }
    // 0xf55d
    return result2;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf563 - 0xf593
// Line range:    5607 - 5667
void DTV_PollingWDThreadClose(int64_t pTnim) {
    // 0xf563
    uint64_t v1; // 0xf563
    int64_t v2; // 0xf563
    uint64_t v3 = (v2 + (v1 >> (uint64_t)(int64_t)&g95)) % 256 << (uint64_t)(int64_t)&g95 | v1 & -0xff01; // 0xf567
    *(char *)v2 = 2 * (char)v2;
    int32_t * v4 = (int32_t *)(v2 - 115); // 0xf575
    int64_t v5; // 0xf563
    *v4 = *v4 + (int32_t)v5;
    int64_t v6; // 0xf563
    wait_for_completion(pTnim, (int32_t)v6, (int32_t)(((v3 >> (int64_t)&g95) + v2) % 256 << (int64_t)&g95 | v3 & 0xffff00ff));
}

// Address range: 0xf593 - 0xf604
int64_t DTV_PollingWDThreadClose2(int64_t a1) {
    // 0xf593
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x1d38); // 0xf5a1
    unsigned char v2 = *(char *)(a1 + 0x1d30); // 0xf5a8
    int64_t v3 = v2; // 0xf5a8
    if (*(char *)(v1 + 0x5459) == 0) {
        // 0xf5c0
        *(char *)(v1 + 0x545a + v3) = 0;
        return 0;
    }
    int64_t result = 0;
    if (v2 != (char)result) {
        // 0xf5d1
        if (*(char *)(v1 + 0x545a) == 1) {
            // 0xf5e7
            *(char *)(v1 + 0x545a + v3) = 0;
            return result;
        }
    }
    int64_t v4 = result + (int64_t)(int32_t)&g1; // 0xf5da
    int64_t result2 = v4 & 0xffffffff; // 0xf5da
    int64_t v5 = v1 + 1; // 0xf5e3
    while ((char)v4 != (char)&g95) {
        int64_t v6 = v5;
        result = result2;
        if (v2 != (char)result) {
            // 0xf5d1
            if (*(char *)(v6 + 0x545a) == 1) {
                // 0xf5e7
                *(char *)(v1 + 0x545a + v3) = 0;
                return result;
            }
        }
        // 0xf5da
        v4 = result + (int64_t)(int32_t)&g1;
        result2 = v4 & 0xffffffff;
        v5 = v6 + 1;
    }
    // 0xf601
    return result2;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf607 - 0xf637
// Line range:    5541 - 5605
void DTV_PollingThreadClose(int64_t pTnim) {
    // 0xf607
    int64_t v1; // 0xf607
    *(char *)v1 = 2 * (char)v1;
    uint64_t v2; // 0xf607
    unsigned char v3 = (char)(v2 >> (int64_t)&g95); // 0xf60b
    int64_t v4; // 0xf607
    unsigned char v5 = (char)v4 + v3; // 0xf60b
    int64_t v6; // 0xf607
    int32_t * v7 = (int32_t *)(v6 + 84); // 0xf60d
    *v7 = *v7 - (int32_t)(v5 < v3);
    int64_t v8 = v4;
    *(char *)v8 = *(char *)&v4 + (char)v8;
    int64_t v9; // 0xf607
    *(char *)(v9 + 0x5458) = (char)&g1;
    int64_t v10; // 0xf607
    wait_for_completion(v9 + 0x5438, (int32_t)v10, (int32_t)((int64_t)v5 << (int64_t)&g95 | v2 & 0xffff00ff));
}

// Address range: 0xf637 - 0xf6b7
int64_t DTV_PollingThreadClose2(int64_t a1) {
    // 0xf637
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x1d38); // 0xf645
    unsigned char v2 = *(char *)(a1 + 0x1d30); // 0xf64c
    int64_t v3 = v2; // 0xf64c
    char * v4 = (char *)(v1 + 0x53d9); // 0xf65b
    if (*v4 == 0) {
        // 0xf664
        *(char *)(v1 + 0x53da + v3) = 0;
        return 0;
    }
    int64_t result = 0;
    if (v2 != (char)result) {
        // 0xf675
        if (*(char *)(v1 + 0x53da) == 1) {
            // 0xf68b
            *(char *)(v1 + 0x53da + v3) = 0;
            return result;
        }
    }
    int64_t v5 = result + (int64_t)(int32_t)&g1; // 0xf67e
    int64_t result2 = v5 & 0xffffffff; // 0xf67e
    int64_t v6 = v1 + 1; // 0xf687
    while ((char)v5 != (char)&g95) {
        int64_t v7 = v6;
        result = result2;
        if (v2 != (char)result) {
            // 0xf675
            if (*(char *)(v7 + 0x53da) == 1) {
                // 0xf68b
                *(char *)(v1 + 0x53da + v3) = 0;
                return result;
            }
        }
        // 0xf67e
        v5 = result + (int64_t)(int32_t)&g1;
        result2 = v5 & 0xffffffff;
        v6 = v7 + 1;
    }
    // 0xf6a5
    *(char *)(v1 + 0x53da + v3) = 0;
    *v4 = 0;
    return result2;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf6b9 - 0xf6e9
// Line range:    5490 - 5539
int32_t DTV_PollingDeviceThreadInit(int64_t deviceExtension) {
    // 0xf6b9
    int64_t v1; // 0xf6b9
    int64_t v2; // 0xf6b9
    *(char *)v1 = (char)v2 + (char)v1;
    int64_t v3; // 0xf6b9
    *(char *)(v3 + 0x5430) = 0;
    *(char *)(v3 + (int64_t)&g90) = (char)&g1;
    int64_t v4; // 0xf6b9
    int64_t v5; // 0xf6b9
    return wait_for_completion(v3 + 0x53b8, (int32_t)v4, (int32_t)v5);
}

// Address range: 0xf6e9 - 0xf719
int64_t DTV_PollingDeviceThreadInit2(int64_t a1) {
    // 0xf6e9
    mcount();
    *(char *)(a1 + 0x5490) = 0;
    return &g1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf719 - 0xf749
// Line range:    5429 - 5488
int32_t ASV5220_BcasThreadInit(int64_t pTnim) {
    // 0xf719
    *(int32_t *)(pTnim + 0x5470) = 0;
    int64_t v1; // 0xf719
    int64_t v2; // 0xf719
    __init_waitqueue_head(pTnim + 0x5478, 0, v1, v2);
    int64_t v3; // 0xf719
    *(char *)(v3 + 0x5491) = (char)&g1;
    return &g1;
}

// Address range: 0xf749 - 0xf7df
int64_t ASV5220_BcasThreadInit2(int64_t a1) {
    // 0xf749
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x1d38); // 0xf75f
    if (*(char *)(v1 + 0x54f9) != 0) {
        unsigned char v2 = *(char *)(a1 + 0x1d30); // 0xf766
        *(char *)(v1 + 0x54fa + (int64_t)v2) = (char)&g1;
        return &g1;
    }
    // 0xf799
    *(char *)(v1 + 0x54f8) = 0;
    *(int32_t *)(v1 + 0x54d8) = 0;
    int64_t v3; // 0xf749
    int64_t v4; // 0xf749
    __init_waitqueue_head(v1 + 0x54e0, 0, v3, v4);
    int64_t result = kthread_create(0, v1, 0); // 0xf7d3
    *(int64_t *)(v1 + 0x6318) = result;
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf7e3 - 0xf813
// Line range:    5307 - 5370
int32_t DTV_PollingThreadInit(int64_t pTnim) {
    // 0xf7e3
    int64_t result; // 0xf7e3
    return result;
}

// Address range: 0xf813 - 0xf8b0
int64_t DTV_PollingThreadInit2(int64_t a1) {
    // 0xf813
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x1d38); // 0xf829
    if (*(char *)(v1 + 0x53d9) != 0) {
        unsigned char v2 = *(char *)(a1 + 0x1d30); // 0xf830
        *(char *)(v1 + 0x53da + (int64_t)v2) = (char)&g1;
        return &g1;
    }
    // 0xf863
    *(char *)(v1 + (int64_t)&g90) = 0;
    *(char *)(v1 + 0x53d8) = 0;
    *(int32_t *)(v1 + 0x53b8) = 0;
    int64_t v3; // 0xf813
    int64_t v4; // 0xf813
    __init_waitqueue_head(v1 + 0x53c0, 0, v3, v4);
    int64_t result = kthread_create(0, v1, 0); // 0xf8a4
    *(int64_t *)(v1 + 0x6310) = result;
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf8b4 - 0xf8e4
// Line range:    5372 - 5425
int32_t DTV_PollingWDThreadInit(int64_t pTnim) {
    // 0xf8b4
    int64_t result; // 0xf8b4
    return result;
}

// Address range: 0xf8e4 - 0xf954
int64_t DTV_PollingWDThreadInit2(int64_t a1) {
    // 0xf8e4
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x1d38); // 0xf8fa
    if (*(char *)(v1 + 0x5459) == 0) {
        // 0xf92b
        *(char *)(v1 + 0x5458) = 0;
        *(int32_t *)(v1 + 0x5438) = 0;
        int64_t v2; // 0xf8e4
        int64_t v3; // 0xf8e4
        return __init_waitqueue_head(v1 + 0x5440, 0, v2, v3);
    }
    unsigned char v4 = *(char *)(a1 + 0x1d30); // 0xf901
    *(char *)(v1 + 0x545a + (int64_t)v4) = (char)&g1;
    return &g1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xf958 - 0xf988
// Line range:    5239 - 5304
void DTV_PollingDeviceThread(char * Context) {
    // 0xf958
    int64_t v1; // 0xf958
    int32_t * v2 = (int32_t *)(v1 - 0x7c39e48c + v1 * (int64_t)&g95);
    *v2 = *v2 + (int32_t)&g1;
    int64_t v3; // 0xf958
    int64_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    int64_t v5; // 0xf958
    int32_t * v6 = (int32_t *)(v5 + (int64_t)&g105); // 0xf963
    *v6 = *v6 + (int32_t)v3;
    int64_t v7; // 0xf958
    int64_t v8; // 0xf958
    *(char *)(v7 + 0x545a + v8) = (char)&g1;
}

// Address range: 0xf988 - 0xfa24
int64_t DTV_PollingDeviceThread2(int64_t a1) {
    // 0xf988
    mcount();
    int64_t v1; // 0xf988
    if (v1 == (int64_t)&g1 != (*(char *)(a1 + 0x6308) == 1)) {
        // 0xfa13
        return vUSB_Wait2(100);
    }
    char v2 = 0; // bp-57, 0xf9db
    int64_t v3 = TC_GetLNBShortDetect2(a1, 0, (int64_t *)&v2); // 0xf9eb
    if ((char)v3 != (char)&g1) {
        // 0xfa13
        return vUSB_Wait2(100);
    }
    // 0xf9f4
    if (v2 == 1) {
        // 0xf9fa
        TC_SetLNB2(a1, 0);
    }
    // 0xfa13
    return vUSB_Wait2(100);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0xfa25 - 0xfa26
// Line range:    4838 - 5236
void ASV5220_BcasThread(char * Context) {
    // 0xfa25
    return;
}

// Address range: 0xfa26 - 0xfa2c
int64_t function_fa26(void) {
    // 0xfa26
    int64_t result; // 0xfa26
    return result;
}

// Address range: 0xfa2c - 0xfa55
int64_t function_fa2c(void) {
    // 0xfa2c
    int64_t v1; // 0xfa2c
    *(char *)(v1 + 0x5491) = 0;
    return complete(v1 + 0x5470);
}

// Address range: 0xfa55 - 0x10282
int64_t ASV5220_BcasThread2(int64_t a1) {
    // 0xfa55
    mcount();
    __readgsqword(40);
    char v1 = 0; // bp-137, 0xfa80
    ASV5220_ResetUart2(a1);
    int64_t v2 = a1 + (int64_t)&g87; // 0xfa9d
    int64_t * v3 = (int64_t *)v2; // 0xfa9d
    char * v4 = (char *)(a1 + 0x54f8);
    char v5; // bp-136, 0xfa55
    int64_t v6 = &v5;
    int32_t v7 = 0; // 0xfa96
    int32_t v8 = 0; // 0xfa96
    int64_t v9; // 0xfa55
    int64_t v10; // 0xfa55
    int64_t v11; // 0xfa55
    int64_t v12; // 0xfa55
    int64_t v13; // 0xfa55
    int64_t v14; // 0xfa55
    int64_t v15; // 0xfa55
    int64_t v16; // 0xfa55
    int64_t v17; // 0xfa55
    char v18; // 0xfa55
    char v19; // 0xfa55
    int32_t v20; // 0xfa55
    char * v21; // 0xfa55
    char v22; // 0xfab2
    char * v23; // 0xfdc1
    int64_t v24; // 0xff51
    while (true) {
      lab_0xfa9d_3:;
        int32_t v25 = v7;
        int64_t v26 = *v3; // 0xfa9d
        int64_t v27 = v26; // 0xfaa8
        int64_t v28 = v13; // 0xfaa8
        int64_t v29 = v10; // 0xfaa8
        int64_t v30 = v15; // 0xfaa8
        v7 = v25;
        v19 = v18;
        v16 = v15;
        v12 = v10;
        v14 = v13;
        if (v26 == 0) {
            goto lab_0x101da;
        } else {
            int64_t v31; // 0xfa55
            int64_t v32; // 0xfa55
            int64_t v33; // 0xfa55
            char v34; // 0xfac8
            while (true) {
                // 0xfaae
                v33 = v30;
                v31 = v29;
                v32 = v28;
                v9 = v27;
                v21 = (char *)(v9 + 0x1340);
                v34 = *v21;
                if (v34 != 0) {
                    // break (via goto) -> 0xfcfa
                    goto lab_0xfcfa;
                }
                // 0xfad7
                *(int64_t *)(v9 + 0x8fdd0) = 0;
                *(int64_t *)(v9 + 0x8fdc0) = 0;
                *(int64_t *)(v9 + 0x8fdc8) = 0;
                *(char *)(v9 + 0x8fdd8) = 0;
                char * v35 = (char *)(v9 + 0x15d6);
                vUSB_Wait2(200);
                ASV5220_GetCardInDetect2(&v1);
                while (v1 != 1) {
                    // 0xfb21
                    *v35 = 0;
                    if (*v4 == 1) {
                        // break (via goto) -> 0x10263
                        goto lab_0x10263_3;
                    }
                    vUSB_Wait2(200);
                    ASV5220_GetCardInDetect2(&v1);
                }
                // 0xfb38
                if (*v4 == 1) {
                    // break (via goto) -> 0x10263
                    goto lab_0x10263_3;
                }
                while (*(char *)(a1 + 0x5798) == 1) {
                    // 0xfb52
                    *(char *)(v9 + 0x148a) = 0;
                    *v35 = 0;
                    ASV5220_ResetUart2(a1);
                    *v21 = 0;
                    int64_t v36 = *v3; // 0xfa9d
                    if (v36 == 0) {
                        // 0xfa9d
                        v7 = v25;
                        v19 = (char)v9 + (char)&g95;
                        v16 = v33;
                        v12 = v31;
                        v14 = v32;
                        goto lab_0x101da;
                    }
                    v9 = v36;
                    v21 = (char *)(v9 + 0x1340);
                    v34 = *v21;
                    if (v34 != 0) {
                        // break (via goto) -> 0xfcfa
                        goto lab_0xfcfa;
                    }
                    // 0xfad7
                    *(int64_t *)(v9 + 0x8fdd0) = 0;
                    *(int64_t *)(v9 + 0x8fdc0) = 0;
                    *(int64_t *)(v9 + 0x8fdc8) = 0;
                    *(char *)(v9 + 0x8fdd8) = 0;
                    v35 = (char *)(v9 + 0x15d6);
                    vUSB_Wait2(200);
                    ASV5220_GetCardInDetect2(&v1);
                    while (v1 != 1) {
                        // 0xfb21
                        *v35 = 0;
                        if (*v4 == 1) {
                            // break (via goto) -> 0x10263
                            goto lab_0x10263_3;
                        }
                        vUSB_Wait2(200);
                        ASV5220_GetCardInDetect2(&v1);
                    }
                    // 0xfb38
                    if (*v4 == 1) {
                        // break (via goto) -> 0x10263
                        goto lab_0x10263_3;
                    }
                }
                // 0xfb74
                ASV5220_InitUart2(a1);
                int64_t v37 = ASV5220_bReadBCAS_Data2(v9, (int64_t *)(v9 + 0x1348), (int64_t *)(v9 + 0x1344), (int64_t)&g1, 0, 320); // 0xfb9e
                int64_t v38; // 0xfa55
                if ((char)v37 != 0) {
                    // 0xfbc9
                    ASV5220_SetBaudrate2(a1);
                    v5 = 0;
                    vUSB_Wait2(50);
                    ASV5220_bWtBCAS_Data2(v9, &v5, (int64_t *)&g89);
                    ASV5220_ReadResponse2(v6, &g89, (char *)200, a1);
                    if (*v35 != 1) {
                        char v39 = (char)v9 + (char)&g95; // 0xfab2
                        vUSB_Wait2(50);
                        int64_t v40 = v39; // 0xfc3c
                        if ((char)ASV5220_Get_BCAS_INFO2(v40) == 0) {
                            // 0xfcd8
                            *(char *)(v9 + 0x148a) = 0;
                            *v35 = 0;
                            ASV5220_ResetUart2(a1);
                            *v21 = 0;
                            v7 = v25;
                            v19 = v39;
                            v16 = a1;
                            v12 = 0;
                            v14 = 320;
                            goto lab_0x101da;
                        } else {
                            int32_t * v41 = (int32_t *)(v9 + 0x15d0); // 0xfc50
                            if (*v41 != 0) {
                                // 0xfccc
                                *v21 = (char)&g1;
                                v7 = v25;
                                v19 = v39;
                                v16 = a1;
                                v12 = 0;
                                v14 = 320;
                                goto lab_0x101da;
                            } else {
                                // 0xfc59
                                vUSB_Wait2(50);
                                if ((char)ASV5220_Get_BCAS_INFO2(v40) == 0) {
                                    // 0xfcaa
                                    *(char *)(v9 + 0x148a) = 0;
                                    *v35 = 0;
                                    ASV5220_ResetUart2(a1);
                                    *v21 = 0;
                                    v7 = v25;
                                    v19 = v39;
                                    v16 = a1;
                                    v12 = 0;
                                    v14 = 320;
                                    goto lab_0x101da;
                                } else {
                                    // 0xfc73
                                    if (*v41 != 0) {
                                        // 0xfc9e
                                        *v21 = (char)&g1;
                                        v7 = v25;
                                        v19 = v39;
                                        v16 = a1;
                                        v12 = 0;
                                        v14 = 320;
                                        goto lab_0x101da;
                                    } else {
                                        // 0xfc7c
                                        *(char *)(v9 + 0x148a) = 0;
                                        *v35 = 0;
                                        ASV5220_ResetUart2(a1);
                                        *v21 = 0;
                                        v7 = v25;
                                        v19 = v39;
                                        v16 = a1;
                                        v12 = 0;
                                        v14 = 320;
                                        goto lab_0x101da;
                                    }
                                }
                            }
                        }
                    }
                    // 0xfc1f
                    *v21 = (char)&g25;
                    *v35 = 0;
                    v38 = a1;
                } else {
                    // 0xfba7
                    *(char *)(v9 + 0x148a) = 0;
                    *v35 = 0;
                    ASV5220_ResetUart2(a1);
                    *v21 = 0;
                    v38 = &g1;
                }
                int64_t v42 = v38;
                int64_t v43 = *v3; // 0xfa9d
                v27 = v43;
                v28 = 320;
                v29 = 0;
                v30 = v42;
                if (v43 == 0) {
                    // 0xfa9d
                    v7 = v25;
                    v19 = (char)v9 + (char)&g95;
                    v16 = v42;
                    v12 = 0;
                    v14 = 320;
                    goto lab_0x101da;
                }
            }
          lab_0xfcfa:
            // 0xfcfa
            v22 = (char)v9 + (char)&g95;
            v7 = v25;
            v19 = v22;
            v16 = v33;
            v12 = v31;
            v14 = v32;
            if (v34 != 2) {
                goto lab_0x101da;
            } else {
                int32_t * v44 = (int32_t *)(v9 + 408); // 0xfd02
                int32_t v45 = *v44; // 0xfd02
                int64_t v46 = v9 + 88; // 0xfd09
                uint32_t v47 = v45 + 1; // 0xfd22
                int64_t str = FUSB_ExAllocatePool2(0, (int64_t)(v47 + 2 * v45)); // 0xfd2f
                int32_t v48 = *v44; // 0xfd37
                memset(str, 0, (int64_t)(v48 + 1 + 2 * v48));
                int64_t v49 = 0; // 0xfd58
                int64_t v50 = v33; // 0xfd58
                if (*v44 >= 1) {
                    unsigned char v51 = *(char *)(0x100000000 * v49 / 0x100000000 + v46); // 0xfd63
                    sprintf(str, 0, str, v51, v31, v32);
                    int64_t v52 = v49 + (int64_t)(int32_t)&g1 & 0xffffffff; // 0xfd7f
                    v49 = v52;
                    while (v52 < (int64_t)*v44) {
                        // 0xfd60
                        v51 = *(char *)(0x100000000 * v49 / 0x100000000 + v46);
                        sprintf(str, 0, str, v51, v31, v32);
                        v52 = v49 + (int64_t)(int32_t)&g1 & 0xffffffff;
                        v49 = v52;
                    }
                    // 0xfd8c
                    v50 = v51;
                }
                char * v53 = (char *)(v9 + 736); // 0xfd1b
                FUSB_ExFreePool2((int32_t)str, 0);
                int64_t v54 = v9 + 0x926e0; // 0xfd94
                memcpy(v54, v46, (int64_t)*v44, v50);
                *(int32_t *)(v9 + 0x92820) = *v44;
                *v53 = 0;
                v23 = (char *)(v9 + 0x148a);
                *(char *)(v9 + 737) = *v23 == 0 ? 0 : 64;
                *(char *)(v9 + 738) = (char)v45;
                int64_t v55 = v45; // 0xfddd
                int64_t v56 = v9 + 739;
                memcpy(v56, v46, v55, v50);
                char * v57 = (char *)(v56 + v55); // 0xfdfa
                *v57 = 0;
                *(char *)v46 = -112;
                char v58 = *v53; // 0xfe13
                *v57 = v58;
                if (v45 + 3 > (int32_t)&g1) {
                    char v59 = v58; // 0xfe32
                    int64_t v60 = v9; // 0xfe32
                    v59 ^= *(char *)(v60 + 737);
                    *v57 = v59;
                    v60 += (int64_t)&g1;
                    while (v60 != v9 + (int64_t)&g1 + (int64_t)v47) {
                        // 0xfe37
                        v59 ^= *(char *)(v60 + 737);
                        *v57 = v59;
                        v60 += (int64_t)&g1;
                    }
                }
                uint32_t v61 = v45 + 4; // 0xfe4f
                *(int32_t *)(v9 + 1056) = v61;
                int64_t * v62 = (int64_t *)(v9 + 80); // 0xfe59
                ASV5220_bWtBCAS_Data2(*v62, v53, (int64_t *)(int64_t)v61);
                int64_t v63 = v9 + 1072; // 0xfe71
                int64_t v64 = v9 + 1076; // 0xfe78
                int64_t v65 = v31 & (int64_t)(int32_t)&g1 & 0xffffff00; // 0xfe89
                int64_t v66 = ASV5220_bReadBCAS_Data2(*v62, (int64_t *)v64, (int64_t *)v63, 0, v65, 320); // 0xfe92
                int32_t v67 = v25; // 0xfe9c
                int64_t v68 = 0; // 0xfe9c
                int64_t v69 = v63; // 0xfe9c
                if ((char)v66 != 0) {
                    uint32_t v70 = *(int32_t *)v63; // 0xfe9e
                    v67 = &g1;
                    v68 = 0;
                    v69 = v63;
                    if (v70 >= 1) {
                        // 0xfea8
                        v67 = 0;
                        v68 = 0;
                        v69 = v9;
                        if (*(char *)v64 == 0) {
                            uint64_t v71 = (int64_t)v70; // 0xfe9e
                            int64_t v72 = &g1; // 0xfecf
                            int64_t v73 = v9; // 0xfecf
                            v67 = &g1;
                            v68 = 0;
                            v69 = v9;
                            if (v70 > (int32_t)&g1) {
                                unsigned char v74 = *(char *)(v73 + 1077); // 0xfebb
                                int64_t v75 = v73 + (int64_t)&g1; // 0xfec2
                                int32_t v76 = 0; // 0xfec8
                                while (v74 == 0) {
                                    int64_t v77 = v72 + (int64_t)(int32_t)&g1 & 0xffffffff; // 0xfeca
                                    v72 = v77;
                                    v73 = v75;
                                    v76 = &g1;
                                    if (v77 >= v71) {
                                        // break -> 0xfee9
                                        break;
                                    }
                                    v74 = *(char *)(v73 + 1077);
                                    v75 = v73 + (int64_t)&g1;
                                    v76 = 0;
                                }
                                // 0xfee9
                                v67 = v76;
                                v68 = v74;
                                v69 = v75;
                            }
                        }
                    }
                }
                int64_t v78 = v68;
                v20 = v67;
                int64_t v79 = v69; // 0xfef0
                if (*(char *)(v9 + 0x15d4) == 1) {
                    int32_t v80 = *(int32_t *)v63;
                    if (*(char *)(v9 + 0x15d5) != 0) {
                        // 0xff1f
                        *(int32_t *)(v9 + 3000) = v80;
                        int64_t v81 = v80; // 0xff32
                        memcpy(v9 + 3004, v64, v81, v78);
                        v79 = v81;
                    } else {
                        // 0xfefb
                        *(int32_t *)(v9 + 2036) = v80;
                        int64_t v82 = v80; // 0xff0e
                        memcpy(v9 + 2040, v64, v82, v78);
                        v79 = v82;
                    }
                }
                // 0xff41
                v24 = v79 & 0xffffff00 | (int64_t)((char)v66 != 0 == v20 == 0);
                v17 = v78;
                v11 = v65;
                if ((char)v66 != 0 != (v20 == 0)) {
                    goto lab_0x101bd;
                } else {
                    int32_t * v83 = (int32_t *)v63; // 0xff5c
                    int32_t v84 = *v83; // 0xff5c
                    char v85 = *(char *)v64; // 0xff65
                    char * v86 = (char *)(v64 + (int64_t)v84); // 0xff6c
                    *v86 = v85;
                    int32_t v87 = v84 - 1; // 0xff73
                    char v88 = v85; // 0xff7b
                    int64_t v89 = v78; // 0xff7b
                    if (v87 > (int32_t)&g1) {
                        int64_t v90 = v9; // 0xff88
                        char v91 = *(char *)(v90 + 1077) ^ v85; // 0xff93
                        *v86 = v91;
                        v90 += (int64_t)&g1;
                        char v92 = v91; // 0xffa7
                        while (v90 != v9 + (int64_t)&g1 + (int64_t)(v84 - 3)) {
                            // 0xff8b
                            v91 = *(char *)(v90 + 1077) ^ v92;
                            *v86 = v91;
                            v90 += (int64_t)&g1;
                            v92 = v91;
                        }
                        // 0xffa9
                        v88 = v91;
                        v89 = v91;
                    }
                    int64_t v93 = v89;
                    int64_t v94 = v87; // 0xffac
                    v17 = v93;
                    v11 = v94;
                    if (v88 != *(char *)(v64 + v94)) {
                        goto lab_0x101bd;
                    } else {
                        // 0xffce
                        *v23 = (char)(*v23 == 0);
                        ASV5220_GetCardInDetect2(&v1);
                        int64_t v95 = v93; // 0xffff
                        if (v1 == 1) {
                            // 0x10001
                            v95 = *(int64_t *)(v9 + 1064);
                            TS_SetBCASResponse2(v9 + 1079, *v83 - 4, *(char *)(v9 + 1060), v95);
                        }
                        int64_t v96 = v95;
                        int32_t v97 = *v83; // 0x10024
                        if (v97 > (int32_t)&g94) {
                            char v98 = 0; // 0x10066
                            if (*(char *)(v9 + 1080) >= 2) {
                                // 0x10068
                                v98 = *(char *)(v9 + 1083);
                            }
                            char v99 = v98;
                            memcpy(v9 + 0x92824, v64, (int64_t)v97, v96);
                            *(int32_t *)(v9 + 0x92964) = *v83;
                            char * v100 = (char *)(v9 + 1060); // 0x100b8
                            unsigned char v101 = *v100; // 0x100b8
                            int64_t v102 = *(int64_t *)(((int64_t)(v101 / 2) & (int64_t)(int32_t)&g94) * (int64_t)&g95 + v2); // 0x100c5
                            if (v102 != 0) {
                                // 0x100d2
                                DTV_SaveBCASCommand2(v102, v54);
                                unsigned char v103 = *v100; // 0x100de
                                int64_t v104 = *(int64_t *)(((int64_t)(v103 / 2) & (int64_t)(int32_t)&g94) * (int64_t)&g95 + v2); // 0x100eb
                                if (v104 != 0) {
                                    // 0x100f8
                                    DTV_SaveBcasReturnCode2(v104, &v99);
                                }
                            }
                        }
                        int32_t v105 = *v83; // 0x10104
                        int64_t str2 = FUSB_ExAllocatePool2(0, (int64_t)(v105 + 1 + 2 * v105)); // 0x10116
                        int32_t v106 = *v83; // 0x1011e
                        memset(str2, 0, (int64_t)(v106 + 1 + 2 * v106));
                        int64_t v107 = v9; // 0x1013f
                        int64_t v108 = v96; // 0x1013f
                        if (*v83 >= 1) {
                            unsigned char v109 = *(char *)(v107 + 1076); // 0x1014a
                            sprintf(str2, 0, str2, v109, v94, v24);
                            int64_t v110 = (int64_t)(int32_t)&g1 & 0xffffffff; // 0x10169
                            v107 += (int64_t)&g1;
                            int64_t v111 = v110; // 0x10178
                            while (v110 < (int64_t)*v83) {
                                // 0x1014a
                                v109 = *(char *)(v107 + 1076);
                                sprintf(str2, 0, str2, v109, v94, v24);
                                v110 = v111 + (int64_t)(int32_t)&g1 & 0xffffffff;
                                v107 += (int64_t)&g1;
                                v111 = v110;
                            }
                            // 0x1017a
                            v108 = v109;
                        }
                        int64_t v112 = v108;
                        FUSB_ExFreePool2((int32_t)str2, 0);
                        if ((*(char *)(v9 + 1077) & -126) != -126) {
                            // 0x101b4
                            *v21 = (char)&g1;
                            v7 = v20;
                            v19 = v22;
                            v16 = v112;
                            v12 = v94;
                            v14 = v24;
                        } else {
                            // 0x10195
                            *v23 = 0;
                            *(char *)(v9 + 0x15d6) = (char)&g1;
                            ASV5220_ResetUart2(a1);
                            *v21 = 0;
                            v7 = v20;
                            v19 = v22;
                            v16 = v112;
                            v12 = v94;
                            v14 = v24;
                        }
                        goto lab_0x101da;
                    }
                }
            }
        }
    }
  lab_0x10263_3:
    // 0x10263
    *(char *)(a1 + 0x54f9) = 0;
    *v4 = (char)&g1;
    return complete(a1 + 0x54d8);
  lab_0x101da:;
    char v113 = v19;
    v8 = 0x1000000 * (v8 + (int32_t)(char)&g1) / 0x1000000;
    if (*(char *)(a1 + 0x5510) == 1) {
        char v114 = 37 * ((int16_t)v8 % 256) >> (int16_t)&g95; // 0x101f7
        char v115 = v8; // 0x10202
        if (((v115 - v114 >> (char)&g1) + v114 * (char)&g1 >> (char)&g25) * (1 - (char)&g95) == -v115) {
            // 0x1021d
            ASV5220_GetCardInDetect2(&v1);
            if (v1 == 0) {
                int64_t v116 = v113; // 0x10235
                *(char *)(v116 + 0x15ce) = 0;
                *(char *)(v116 + (int64_t)&g6) = 0;
            }
        }
    }
    // 0x1024a
    vUSB_Wait2(50);
    v18 = v113;
    v15 = v16;
    v10 = v12;
    v13 = v14;
    if (*v4 != 0) {
        // break -> 0x10263
        goto lab_0x10263_3;
    }
    goto lab_0xfa9d_3;
  lab_0x101bd:
    // 0x101bd
    *v23 = 0;
    *(char *)(v9 + 0x15d6) = (char)&g1;
    ASV5220_ResetUart2(a1);
    *v21 = 0;
    v7 = v20;
    v19 = v22;
    v16 = v17;
    v12 = v11;
    v14 = v24;
    goto lab_0x101da;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x10283 - 0x102b3
// Line range:    2782 - 3058
int32_t DTV_StreamDataRead(int64_t pTnim, char * Buffer, int32_t MaxReadLen) {
    // 0x10283
    int64_t result; // 0x10283
    int64_t v1; // 0x10283
    if (__readgsqword(40) != (int64_t)*(int32_t *)(v1 - 56)) {
        // 0x1029c
        result = __stack_chk_fail();
    }
    // 0x102a1
    return result;
}

// Address range: 0x102b3 - 0x10996
int64_t DTV_StreamDataRead2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x102b3
    mcount();
    int64_t v1 = a3 & 0xffffffff; // 0x102da
    int64_t v2 = *(int64_t *)(a1 + 0x1d38); // 0x102dd
    int64_t v3 = (int64_t)*(char *)(a1 + 0x1d30); // 0x102e4
    uint32_t v4 = (int32_t)a3; // 0x1030e
    int64_t v5 = v4 > (int32_t)"k : 0x%x" ? (int64_t)(int32_t)" : 0x%x" : v1; // 0x10321
    int64_t v6 = FUSB_ExAllocatePool2(0, v5); // 0x1032f
    int32_t * v7 = (int32_t *)(a1 + 0x1d48); // 0x1033b
    int32_t v8 = *v7; // 0x1033b
    if (v8 == 0) {
        int64_t v9 = USB_BulkStreamRead2(v2, v3); // 0x1035c
        int64_t v10 = 0;
        int64_t v11 = a1 + 0x1d4c + 0x100000000 * v10 / 0x100000000; // 0x10388
        int64_t result = DTV_CheckSync2(v11, (int64_t *)&g95); // 0x10395
        while ((int32_t)result == 0) {
            int64_t v12 = v10 + (int64_t)(int32_t)&g1 & 0xffffffff; // 0x1039e
            if ((v9 + 0xfffffa20 & 0xffffffff) <= v12) {
                // 0x103a7
                return result;
            }
            v10 = v12;
            v11 = a1 + 0x1d4c + 0x100000000 * v10 / 0x100000000;
            result = DTV_CheckSync2(v11, (int64_t *)&g95);
        }
        int64_t v13 = (v9 & 0xffffffff) - v10; // 0x103b8
        int32_t v14 = v13; // 0x103cc
        uint32_t v15 = v14 >> (int32_t)&g24; // 0x103cf
        int32_t v16 = -188 * (((int32_t)((-0x51b3bea3 * 0x100000000 * v13 / 0x100000000 >> (int64_t)&g26) + (v13 & 0xffffffff) * (int64_t)&g1) >> (int32_t)&g94) - v15);
        int32_t v17 = v16 + v14; // 0x103dd
        *(int32_t *)(a1 + (int64_t)&g35) = v17;
        int32_t v18 = -v16; // 0x103e5
        *(int32_t *)(a1 + (int64_t)&g36) = (int32_t)v9 - v17;
        char v19 = *(char *)(a1 + 0x8f475); // 0x103f2
        if (v19 != 0 != v19 != 3) {
            int32_t v20 = (int32_t)(-0x51b3bea3 * (int64_t)v18 >> (int64_t)&g26) - v16; // 0x1040e
            DTV_CleanEncFlag2(v11, (v20 >> (int32_t)&g94) - (v18 >> (int32_t)&g24), v20, v15);
        }
        char v21 = *(char *)(a1 + (int64_t)&g49); // 0x1042b
        if (v21 == (char)&g1) {
            // 0x10434
            if (*(char *)(a1 + (int64_t)&g42) == 0) {
                int64_t result2 = DTV_EncAES_MultiTS2(a1, v11, (0x100000000 * (int64_t)(v18 >> 31) | (int64_t)v18) / 188 & 0xffffffff, a2); // 0x10465
                // 0x104a5
                *v7 = (int32_t)&g1;
                return result2;
            }
        }
        int64_t v22 = v18; // 0x10467
        memcpy(v6, v11, v22, (int64_t)v15);
        int64_t result3 = DTV_DecrypMultiTS2(a1, v6, ((int32_t)(-0x51b3bea3 * v22 >> (int64_t)&g26) - v16 >> (int32_t)&g94) - (v18 >> (int32_t)&g24), a2); // 0x104a0
        // 0x104a5
        *v7 = (int32_t)&g1;
        return result3;
    }
    char * v23 = (char *)(a1 + (int64_t)&g49);
    char v24 = *v23;
    int32_t v25; // 0x102b3
    int64_t v26; // 0x102b3
    int64_t v27; // 0x102b3
    int64_t v28; // 0x102b3
    int32_t v29; // bp-57, 0x102b3
    int64_t result4; // 0x102b3
    char * v30; // 0x10337
    int64_t v31; // 0x102b3
    if (v8 != 1) {
        // 0x10662
        v30 = (char *)v6;
        if (v24 != (char)&g1) {
            goto lab_0x10771;
        } else {
            // 0x1066f
            if (*(char *)(a1 + (int64_t)&g42) != 0) {
                goto lab_0x10771;
            } else {
                int32_t * v32 = (int32_t *)(a1 + 0x8fab8); // 0x1067c
                *v32 = 0;
                int64_t v33 = USB_BulkStreamRead2(v2, v3); // 0x10695
                int64_t v34 = v6 + 184; // 0x106a0
                int64_t v35 = a1; // 0x106a8
                int64_t v36 = v6; // 0x106a8
                char v37 = *(char *)(v36 + (int64_t)&g86); // 0x106ab
                *(char *)(v35 + 0x1c78) = v37;
                v36 += (int64_t)&g1;
                v35 += (int64_t)&g1;
                while (v36 != v34) {
                    // 0x106ab
                    v37 = *(char *)(v36 + (int64_t)&g86);
                    *(char *)(v35 + 0x1c78) = v37;
                    v36 += (int64_t)&g1;
                    v35 += (int64_t)&g1;
                }
                int64_t v38 = v33 & 0xffffffff; // 0x1069a
                char v39 = *(char *)(a1 + 0x8f475); // 0x106c4
                int64_t v40 = v34; // 0x106cd
                if (v39 != 0 != v39 != 3) {
                    int64_t v41 = 0x100000000 * (int64_t)((int32_t)v33 >> (int32_t)&g24) | v38; // 0x106e1
                    DTV_CleanEncFlag2(v6, (int32_t)(v41 / 188), (int32_t)(v41 % 188), 188);
                    v40 = 188;
                }
                char v42 = *v30; // 0x106f2
                v29 = v42;
                int64_t v43 = v40; // 0x106fa
                if (v42 == 71) {
                    int64_t v44 = 0x100000000 * (int64_t)((int32_t)v33 >> (int32_t)&g24) | v38; // 0x1070a
                    v43 = 188;
                    if ((int32_t)(v44 % 188) == 0) {
                        // 0x10710
                        DTV_EncAES_MultiTS2(a1, v6, v44 / 188 & 0xffffffff, a2);
                        int64_t v45 = a2 + 184; // 0x1072f
                        int64_t v46 = a2; // 0x1072f
                        int64_t v47 = a1; // 0x1072f
                        char v48 = *(char *)(v46 + (int64_t)&g86); // 0x10736
                        *(char *)(v47 + 0x8edea) = v48;
                        v46 += (int64_t)&g1;
                        v47 += (int64_t)&g1;
                        while (v46 != v45) {
                            // 0x10736
                            v48 = *(char *)(v46 + (int64_t)&g86);
                            *(char *)(v47 + 0x8edea) = v48;
                            v46 += (int64_t)&g1;
                            v47 += (int64_t)&g1;
                        }
                        // 0x1074e
                        *v32 = (int32_t)&g1;
                        v29 = (int32_t)*v30;
                        v43 = v45;
                    }
                }
                // 0x10762
                *v32 = (int32_t)&g1;
                v25 = v29;
                v28 = v43;
                v27 = v38;
                goto lab_0x10816;
            }
        }
    } else {
        if (v24 != (char)&g1) {
            goto lab_0x10577;
        } else {
            // 0x104ca
            if (*(char *)(a1 + (int64_t)&g42) != 0) {
                goto lab_0x10577;
            } else {
                int32_t * v49 = (int32_t *)(a1 + (int64_t)&g35); // 0x104d7
                int32_t v50 = *(int32_t *)(a1 + (int64_t)&g36); // 0x104de
                memcpy(v6, a1 + 0x1d4c + (int64_t)v50, (int64_t)*v49, v31);
                int32_t v51 = *v49 + (int32_t)USB_BulkStreamRead2(v2, v3); // 0x1051a
                int64_t v52 = v51; // 0x1051a
                char v53 = *(char *)(a1 + 0x8f475); // 0x10521
                uint32_t v54 = v51 >> (int32_t)&g24;
                if (v53 != 0 != v53 != 3) {
                    int64_t v55 = 0x100000000 * (int64_t)v54 | v52; // 0x1053e
                    DTV_CleanEncFlag2(v6, (int32_t)(v55 / 188), (int32_t)(v55 % 188), 188);
                }
                int64_t v56 = DTV_EncAES_MultiTS2(a1, v6, (int64_t)((v51 + (int32_t)(-0x51b3bea3 * (int64_t)v51 >> (int64_t)&g26) >> (int32_t)&g94) - v54), a2); // 0x1056d
                v26 = v52;
                result4 = v56;
                goto lab_0x1061a;
            }
        }
    }
  lab_0x10771:;
    int64_t v57 = USB_BulkStreamRead2(v2, v3); // 0x10780
    int64_t v58 = v57 & 0xffffffff; // 0x10785
    char v59 = *(char *)(a1 + 0x8f475); // 0x10788
    if (v59 != 0 != v59 != 3) {
        int64_t v60 = -0x51b3bea3 * 0x100000000 * v57 / 0x100000000 >> (int64_t)&g26; // 0x1079f
        DTV_CleanEncFlag2(v6, ((int32_t)(v60 + v58 * (int64_t)&g1) >> (int32_t)&g94) - ((int32_t)v57 >> (int32_t)&g24), (int32_t)v60, v4);
    }
    char v61 = *v30; // 0x107bd
    v29 = v61;
    int64_t v62 = v1; // 0x107c5
    int64_t v63 = v58; // 0x107c5
    if (v61 != 71) {
        goto lab_0x10844;
    } else {
        int64_t v64 = -0x51b3bea3 * 0x100000000 * v57 / 0x100000000 >> (int64_t)&g26; // 0x107cf
        int32_t v65 = v57; // 0x107d8
        uint32_t v66 = v65 >> (int32_t)&g24; // 0x107db
        if (-188 * (((int32_t)(v64 + v58 * (int64_t)&g1) >> (int32_t)&g94) - v66) != -v65) {
            goto lab_0x10844;
        } else {
            // 0x107eb
            DTV_DecrypMultiTS2(a1, v6, ((int32_t)v64 + v65 >> (int32_t)&g94) - v66, a2);
            int32_t v67 = (int32_t)*v30; // 0x10813
            v29 = v67;
            v25 = v67;
            v28 = a2;
            v27 = v58;
            goto lab_0x10816;
        }
    }
  lab_0x10577:;
    int32_t * v68 = (int32_t *)(a1 + (int64_t)&g35); // 0x10577
    int32_t v69 = *(int32_t *)(a1 + (int64_t)&g36); // 0x1057e
    memcpy(v6, a1 + 0x1d4c + (int64_t)v69, (int64_t)*v68, v31);
    int32_t v70 = *v68 + (int32_t)USB_BulkStreamRead2(v2, v3); // 0x105ba
    char v71 = *(char *)(a1 + 0x8f475); // 0x105c1
    int32_t v72; // 0x102b3
    if (v71 != 0 == (v71 != 3)) {
        // 0x10577
        v72 = (v70 + (int32_t)(-0x51b3bea3 * (int64_t)v70 >> (int64_t)&g26) >> (int32_t)&g94) - (v70 >> (int32_t)&g24);
    } else {
        int32_t v73 = v70 + (int32_t)(-0x51b3bea3 * (int64_t)v70 >> (int64_t)&g26);
        int32_t v74 = (v73 >> (int32_t)&g94) - (v70 >> (int32_t)&g24);
        DTV_CleanEncFlag2(v6, v74, v73, v4 - *v68);
        v72 = v74;
    }
    // 0x105f3
    v26 = v70;
    result4 = DTV_DecrypMultiTS2(a1, v6, v72, a2);
    goto lab_0x1061a;
  lab_0x10844:;
    int64_t v79 = a1 + 0x1d4c; // 0x10844
    memcpy(v79, v6, 0x100000000 * v63 / 0x100000000, v62);
    int64_t v80 = v63 + 0xfffffa20; // 0x10868
    uint64_t v81 = v80 & 0xffffffff; // 0x10868
    int64_t result6; // 0x108ae
    if ((int32_t)v80 < 1) {
        // 0x108a3
        v29 = &g25;
        result6 = DTV_SaveTSReSync2(a1, (char *)&v29);
        *v7 = 0;
        return result6;
    }
    uint64_t v82 = 0;
    int64_t v83 = 0x100000000 * v82 / 0x100000000 + v79; // 0x1087d
    while ((int32_t)DTV_CheckSync2(v83, (int64_t *)&g95) == 0) {
        int64_t v84 = v82 + (int64_t)(int32_t)&g1 & 0xffffffff; // 0x10893
        if (v81 <= v84) {
            // 0x108a3
            v29 = &g25;
            result6 = DTV_SaveTSReSync2(a1, (char *)&v29);
            *v7 = 0;
            return result6;
        }
        v82 = v84;
        v83 = 0x100000000 * v82 / 0x100000000 + v79;
    }
    if (v82 >= v81) {
        // 0x108a3
        v29 = &g25;
        result6 = DTV_SaveTSReSync2(a1, (char *)&v29);
        *v7 = 0;
        return result6;
    }
    int64_t v85 = v63 - v82; // 0x108cb
    int32_t v86 = v85; // 0x108df
    uint32_t v87 = v86 >> (int32_t)&g24; // 0x108e2
    int32_t v88 = -188 * (((int32_t)((-0x51b3bea3 * 0x100000000 * v85 / 0x100000000 >> (int64_t)&g26) + (v85 & 0xffffffff) * (int64_t)&g1) >> (int32_t)&g94) - v87);
    int32_t v89 = v88 + v86; // 0x108f0
    *(int32_t *)(a1 + (int64_t)&g35) = v89;
    int32_t v90 = -v88; // 0x108f8
    *(int32_t *)(a1 + (int64_t)&g36) = (int32_t)v63 - v89;
    if (*v23 == (char)&g1) {
        // 0x1090e
        if (*(char *)(a1 + (int64_t)&g42) == 0) {
            int64_t result7 = DTV_EncAES_MultiTS2(a1, v83, (int64_t)(((int32_t)(-0x51b3bea3 * (int64_t)v90 >> (int64_t)&g26) - v88 >> (int32_t)&g94) - (v90 >> (int32_t)&g24)), a2); // 0x10940
            // 0x10981
            *v7 = (int32_t)&g1;
            return result7;
        }
    }
    int64_t v91 = v90; // 0x10947
    memcpy(v6, v83, v91, (int64_t)v87);
    int64_t result8 = DTV_DecrypMultiTS2(a1, v6, ((int32_t)(-0x51b3bea3 * v91 >> (int64_t)&g26) - v88 >> (int32_t)&g94) - (v90 >> (int32_t)&g24), a2); // 0x1097c
    // 0x10981
    *v7 = (int32_t)&g1;
    return result8;
  lab_0x1061a:;
    // 0x1061a
    int64_t v75; // 0x102b3
    if ((char)v75 != 71) {
        // 0x10644
        *v7 = 0;
        return result4;
    }
    int64_t v76 = v26;
    int32_t v77 = v76; // 0x10631
    uint32_t v78 = 188 * (((int32_t)((-0x51b3bea3 * 0x100000000 * v76 / 0x100000000 >> (int64_t)&g26) + v76 * (int64_t)&g1) >> (int32_t)&g94) - (v77 >> (int32_t)&g24)); // 0x10639
    int64_t result5 = v78; // 0x10639
    if (v78 == v77) {
        // 0x10653
        *v7 = (int32_t)&g25;
        return result5;
    }
    // 0x10644
    *v7 = 0;
    return result5;
  lab_0x10816:
    // 0x10816
    v62 = v28;
    v63 = v27;
    if ((char)v25 == 71) {
        // 0x1081c
        v62 = (int32_t)v27 >> (int32_t)&g24;
        v63 = v27;
    }
    goto lab_0x10844;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x1099a - 0x109ca
// Line range:    2675 - 2736
int32_t DTV_StreamThreadRun(int64_t pTnim) {
    // 0x1099a
    int64_t result; // 0x1099a
    return result;
}

// Address range: 0x109ca - 0x10aa0
int64_t DTV_StreamThreadRun2(int64_t a1) {
    // 0x109ca
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x1d38); // 0x109ed
    int64_t v2 = (int64_t)*(char *)(a1 + 0x1d30); // 0x109f4
    *(char *)(v1 + 0x5958 + v2) = 0;
    int64_t * v3 = (int64_t *)(a1 + (int64_t)&g38);
    int64_t result; // 0x109ca
    if (*(int32_t *)(a1 + 0x1d44) != 1) {
        // 0x10a47
        *v3 = (int64_t)&g95;
        result = USB_BulkStreamStart2(v1, v2, a1, (int64_t)&g95, 0x4970);
    } else {
        // 0x10a11
        *v3 = 128;
        result = USB_BulkStreamStart2(v1, v2, a1, 128, 0x4970);
    }
    // 0x10a77
    if ((int32_t)result != (int32_t)&g1) {
        // 0x10aa0
        return result;
    }
    char v4 = *(char *)(a1 + (int64_t)&g39); // 0x10a7d
    int64_t result2 = result; // 0x10a84
    if (v4 != (char)&g1) {
        // 0x10a86
        result2 = USB_FilterStart_Stop2(v1, v2);
    }
    // 0x10a96
    *(int32_t *)(a1 + 0x1d48) = 0;
    // 0x10aa0
    return result2;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x10aa6 - 0x10ad6
// Line range:    2630 - 2659
int32_t DTV_GetTunerSignalLevel(int64_t pTnim, char * SNR, int64_t * IF_AGC) {
    // 0x10aa6
    int64_t v1; // 0x10aa6
    int64_t v2; // 0x10aa6
    char * v3 = (char *)(v1 - 66 + v2 * (int64_t)&g1); // 0x10aa6
    *v3 = *v3 + (char)((int64_t)IF_AGC >> (int64_t)&g95);
    int64_t v4; // 0x10aa6
    int64_t v5 = v4;
    *(int32_t *)v5 = *(int32_t *)&v4 + (int32_t)v5;
    int64_t v6 = v4;
    *(char *)v6 = *(char *)&v4 + (char)v6;
    int64_t v7; // 0x10aa6
    DTV_StartStop_Enc2(v7, (int64_t)SNR);
    int64_t result; // 0x10aa6
    return result;
}

// Address range: 0x10ad6 - 0x10b30
int64_t DTV_GetTunerSignalLevel2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x10ad6
    mcount();
    if (*(char *)(a1 + (int64_t)&g39) == 0) {
        // 0x10b30
        return 0xfffffff6;
    }
    if (a2 != 0) {
        // 0x10b14
        *(char *)a2 = 0;
    }
    // 0x10b17
    *(int64_t *)a3 = 0;
    return &g1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x10b34 - 0x10b63
// Line range:    2609 - 2627
int32_t DTV_TunerLockCheck(int64_t pTnim) {
    // 0x10b34
    int64_t v1; // 0x10b34
    char * v2 = (char *)(v1 - 120); // 0x10b34
    int64_t v3; // 0x10b34
    *v2 = *v2 + (char)v3;
    int64_t v4; // 0x10b34
    if (v4 != 0) {
        // 0x10b3e
        int64_t v5; // 0x10b34
        *(int64_t *)v4 = Tnim_SignalLevel2(v5);
    }
    // 0x10b56
    return &g1;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x10b63 - 0x10b64
// Line range:    2327 - 2372
int32_t DTV_SetPidTable(int64_t pTnim, int32_t * PID_TableBuf, char WordLen) {
    // 0x10b63
    int64_t result; // 0x10b63
    return result;
}

// Address range: 0x10b64 - 0x10b93
int64_t DTV_TunerLockCheck2(int64_t a1) {
    // 0x10b64
    mcount();
    if (*(int32_t *)(a1 + 0x1d40) == 0) {
        // 0x10b91
        return 0xfffffff6;
    }
    int64_t result = 0; // 0x10b87
    if (*(char *)(a1 + (int64_t)&g39) == 0) {
        // 0x10b89
        result = Tnim_IsLocked2() % 256;
    }
    // 0x10b91
    return result;
}

// Address range: 0x10b93 - 0x10bf4
int64_t DTV_SetPidTable2(int64_t a1, int64_t a2, uint64_t a3) {
    // 0x10b93
    mcount();
    if (a2 != 0 != (char)a3 <= (char)&g26) {
        // 0x10bca
        return 0xfffffffe;
    }
    // 0x10bd1
    if (a3 % 256 == 0) {
        // 0x10bca
        return 0;
    }
    // 0x10be3
    int64_t v1; // bp-136, 0x10b93
    *(int32_t *)&v1 = *(int32_t *)a2;
    GetDeviceUniqueString((int64_t)&v1, (char *)a2, NULL);
    return &g107;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x10bf4 - 0x10c24
// Line range:    1251 - 1285
void GetDeviceUniqueString(int64_t deviceExtension, char * buf, int32_t * len) {
    // 0x10bf4
    uint64_t v1; // 0x10bf4
    int64_t v2; // 0x10bf4
    int64_t v3; // 0x10bf4
    USB_SetPidTable2(v2, v1 % 256, v3 - 128, (int64_t *)&g26);
}

// Address range: 0x10c24 - 0x10d54
int64_t GetDeviceUniqueString2(int64_t a1, int64_t str, int64_t a3) {
    // 0x10c24
    mcount();
    __readgsqword(40);
    unsigned char v1 = *(char *)(a1 + 0x4f74); // 0x10c6f
    unsigned char v2 = *(char *)(a1 + 0x4f75); // 0x10c79
    char v3 = 0; // bp-88, 0x10c8d
    TLIB_I2C_Write2(a1, 160, 0, (int64_t)&v3, (int64_t)&g25, (int64_t)&g25);
    int64_t v4; // bp-67, 0x10c24
    TLIB_I2C_Read2(a1, 160, 0, &v4, (int64_t *)&g94, (int64_t)&g25);
    int64_t v5; // 0x10c24
    memset(str, 0, v5 & 0xffffffff);
    sprintf(str, 0, 0, *(char *)(a1 + 0x4f73), (int64_t)v1, (int64_t)v2);
    return 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x10d58 - 0x10d59
// Line range:    885 - 893
int32_t DTV_TunerPower(int64_t pTnim, char bPowerOn) {
    // 0x10d58
    int64_t result; // 0x10d58
    return result;
}

// Address range: 0x10d5a - 0x10d88
int64_t function_10d5a(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8) {
    // 0x10d5a
    int64_t v1; // 0x10d5a
    *(int32_t *)v1 = -1 - (int32_t)a4 - (int32_t)&g1;
    int64_t result = 0; // 0x10d74
    int64_t v2; // 0x10d5a
    if (*(int64_t *)(v2 - 40) != __readgsqword(40)) {
        // 0x10d76
        result = __stack_chk_fail();
    }
    // 0x10d7b
    return result;
}

// Address range: 0x10d88 - 0x10d94
int64_t DTV_TunerPower2(int64_t result) {
    // 0x10d88
    mcount();
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x10d98 - 0x10dc8
// Line range:    818 - 831
int32_t DTV_TunerHardReset(int64_t deviceExtension, unsigned char TunerNum) {
    // 0x10d98
    int64_t v1; // 0x10d98
    bool v2; // 0x10d98
    uint64_t v3 = v1 - (v2 ? 0xb60f0001 : 0xb60f0000); // 0x10d98
    char * v4 = (char *)(v3 & 0xffffffff); // 0x10d9d
    *v4 = (*v4 ^ (char)&g22) + (char)v3;
    uint64_t v5 = v3 % 256; // 0x10da2
    TC_PowerTunerDemod2(deviceExtension, v5, (int64_t)TunerNum, deviceExtension + 0x5960 + v5 * ((int64_t)&g86 + 1 << (int64_t)&g86));
    return &g1;
}

// Address range: 0x10dc8 - 0x10dc9
int64_t DTV_TunerHardReset2(int64_t a1, int64_t a2) {
    // 0x10dc8
    int64_t result; // 0x10dc8
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x10dc9 - 0x10df9
// Line range:    834 - 883
int32_t TunerReset(int64_t pTnim, unsigned char bInitTuner, char bChkRstFlag) {
    // 0x10dc9
    mcount();
    int64_t v1; // 0x10dc9
    int64_t v2; // 0x10dc9
    int64_t v3; // 0x10dc9
    char v4 = ReadWrite_Customization_Data((char *)pTnim, bInitTuner, (char)(pTnim + 96 + (int64_t)bInitTuner * ((int64_t)&g86 + 1 << (uint64_t)(int64_t)&g86)), v3, (char *)v2, v1, (char *)&g107); // 0x10de9
    return (int32_t)v4 + (int32_t)&g25 + (int32_t)(-1 - v4) + (int32_t)(v4 < (char)&g1);
}

// Address range: 0x10df9 - 0x10e4b
int64_t TunerReset2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x10df9
    mcount();
    unsigned char v1 = *(char *)(a1 + 0x1d30); // 0x10e22
    *(char *)(a1 + 0x8faae) = 0;
    DTV_TunerHardReset2(*(int64_t *)(a1 + 0x1d38), (int64_t)v1);
    return 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x10e4c - 0x10e7c
// Line range:    3060 - 3099
int32_t DTV_StreamThreadStop(int64_t pTnim, char bRstTuner) {
    // 0x10e4c
    int64_t v1; // 0x10e4c
    char v2 = *(char *)(v1 - 124); // 0x10e4c
    int64_t v3; // 0x10e4c
    __asm_in_623((int16_t)v3);
    int32_t result = &g1; // 0x10e50
    int64_t v4; // 0x10e4c
    if ((int32_t)v3 == (int32_t)&g1 || (v2 || (char)v4) == 0) {
        // 0x10e5e
        int64_t v5; // 0x10e4c
        result = (char)Tnim_Initialise2(v5) != 0;
    }
    // 0x10e6e
    return result;
}

// Address range: 0x10e7c - 0x10f4d
int64_t DTV_StreamThreadStop2(int64_t a1, int64_t a2) {
    // 0x10e7c
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x1d38); // 0x10ea4
    int64_t v2 = (int64_t)*(char *)(a1 + 0x1d30); // 0x10eab
    char * v3 = (char *)(v1 + 0x5958 + v2); // 0x10eb6
    if (*v3 == 1) {
        vUSB_Wait2((int64_t)&g1);
        while (*v3 == 1) {
            // 0x10ec4
            vUSB_Wait2((int64_t)&g1);
        }
    }
    // 0x10ed9
    USB_BulkStreamStop2(v1, v2);
    int64_t v4 = v1 + 248; // 0x10ee4
    down(v4, v2);
    int64_t v5 = 312 * v2 + v1; // 0x10efe
    *(int64_t *)(v5 + 1328) = 0;
    up(v4);
    *(char *)(v5 + 1320) = 0;
    if (*(char *)(a1 + (int64_t)&g49) != 0) {
        // 0x10f26
        DTV_StartStop_Enc2(a1, 0);
    }
    // 0x10f33
    return TunerReset2(a1, 0, 0);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x10f4d - 0x10f7d
// Line range:    348 - 400
char bWriteMPUI2CData(char MPU_Slave_Addr, char Target_Slave_Addr, char RegOffset, char u16WriteLen, char * pDataBuf, char withRSA, int64_t hCtrlTransfer) {
    char result = -2; // 0x10f55
    if ((int32_t)RegOffset == (int32_t)&g1) {
        // 0x10f57
        int64_t v1; // 0x10f4d
        *(int32_t *)(v1 + 0x1d48) = 0;
        result = &g1;
    }
    // 0x10f67
    return result;
}

// Address range: 0x10f7d - 0x10f8f
int64_t bWriteMPUI2CData2(int64_t a1) {
    // 0x10f7d
    mcount();
    return 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x10f90 - 0x10fc0
// Line range:    10473 - 10479
char DTV_DecEncChip_I2C_Write(uint64_t pTuner, unsigned char I2C_Addr, unsigned char byReg, char * pBuffer, char byCount, unsigned char withRSA) {
    char * v1 = (char *)(pTuner + 42); // 0x10f91
    *v1 = *v1 & byReg / 128;
    int64_t v2; // 0x10f90
    int64_t v3 = *(int64_t *)(v2 + (int64_t)&g2); // 0x10fb0
    int64_t v4 = FUSBDTV_Cmd_MPU_I2CWrite2(v3, pTuner % 256, (int64_t)I2C_Addr, (int64_t)byReg, (int64_t)pBuffer % 256, (int64_t)byCount, (int64_t)withRSA); // 0x10fb4
    return (char)v4 == (char)&g1;
}

// Address range: 0x10fc0 - 0x10ff3
int64_t DTV_DecEncChip_I2C_Write2(int64_t a1, char a2, int64_t * a3, char * a4, int64_t * a5) {
    // 0x10fc0
    mcount();
    return (int64_t)*(char *)(a1 + 0x92969);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x10ff5 - 0x11025
// Line range:    10559 - 10634
char DTV_EnableEncryptionChipTSOutput(int64_t pTnim) {
    // 0x10ff5
    int64_t v1; // 0x10ff5
    return bWriteMPUI2CData2(v1 & 0xffffffff);
}

// Address range: 0x11025 - 0x11126
int64_t DTV_EnableEncryptionChipTSOutput2(int64_t a1) {
    // 0x11025
    mcount();
    char * v1 = (char *)(a1 + 0x148d); // 0x1104c
    char v2 = *v1;
    char result; // 0x11025
    switch (v2) {
        case 3: {
            goto lab_0x11063;
        }
        case 15: {
            goto lab_0x11063;
        }
        case 4: {
            goto lab_0x11063;
        }
        default: {
            // 0x1105f
            result = v2;
            if (v2 != 17) {
                goto lab_0x1108e;
            } else {
                goto lab_0x11063;
            }
        }
    }
  lab_0x11063:;
    char v3 = *(char *)(a1 + 0x15e9) == 0 ? 0 : (char)&g2; // 0x1106e
    char v4 = v3; // bp-25, 0x11071
    int32_t v5 = *(int32_t *)(a1 + (int64_t)&g21); // 0x11074
    char v6 = v3; // 0x1107b
    if (v5 == (int32_t)&g1) {
        char v7 = v3 | -128; // 0x1107d
        v4 = v7;
        v6 = v7;
    }
    // 0x11081
    if (*(char *)(a1 + 0x15ea) == 1) {
        // 0x1108a
        v4 = v6 | (char)&g26;
    }
    // 0x1108e
    result = *v1;
    goto lab_0x1108e;
  lab_0x1108e:
    // 0x1108e
    switch (result) {
        default: {
            if (result != 17) {
                // 0x11126
                return result;
            }
        }
        case 15: {
        }
        case 4: {
            // 0x110a5
            if (*(char *)(a1 + 0x1d30) == 0) {
                char v8 = *(char *)(a1 + 0x8fcac); // 0x110b2
                DTV_DecEncChip_I2C_Write2(a1, v8, (int64_t *)&g89, &v4, (int64_t *)&g1);
            }
            // break -> 0x110db
            break;
        }
    }
    int64_t v9 = 0; // 0x110db
    while (v9 != 64 - (int64_t)&g95) {
        // 0x110e0
        v9 += (int64_t)&g95;
    }
    char v10 = *(char *)(a1 + 0x8fcac); // 0x11104
    int64_t result2 = DTV_DecEncChip_I2C_Write2(a1, v10, (int64_t *)&g89, &v4, (int64_t *)&g1); // 0x1111f
    return result2;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x11128 - 0x11158
// Line range:    9965 - 9984
char SWResetSlowdownIC(int64_t pTuner, int32_t outputPin) {
    // 0x11128
    int64_t v1; // 0x11128
    int64_t v2; // 0x11128
    __asm_out((int16_t)v1, (int32_t)v2);
    int64_t v3; // 0x11128
    char v4 = *(char *)(v3 + 0x8fcac); // 0x1112a
    int64_t v5; // 0x11128
    DTV_DecEncChip_I2C_Write2(v3, v4, (int64_t *)&g89, (char *)v5, (int64_t *)&g1);
    return &g1;
}

// Address range: 0x11158 - 0x111b3
int64_t SWResetSlowdownIC2(int64_t a1, int64_t a2) {
    // 0x11158
    mcount();
    return 0x100000001;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x111b6 - 0x111e6
// Line range:    9913 - 9963
char SetSlowdownIC(int64_t pTuner, int32_t inputPin, int32_t outputPin, char bInverse, char IsAutoSyncEnable, char SyncByte) {
    // 0x111b6
    int64_t result; // 0x111b6
    return result;
}

// Address range: 0x111b8 - 0x111ba
int64_t function_111b8(void) {
    // 0x111b8
    int64_t result; // 0x111b8
    return result;
}

// Address range: 0x111e6 - 0x112bf
int64_t SetSlowdownIC2(int64_t a1, int32_t a2, uint64_t a3, int64_t * a4, int64_t * a5, int64_t a6) {
    // 0x111e6
    mcount();
    if (*(int64_t *)(a1 + 0x92968) % 0x100000100 == 0x100000001) {
        int64_t v1 = -46; // bp-56, 0x11237
        char v2 = *(char *)(a1 + 0x92969); // 0x1125b
        int64_t result = DTV_DecEncChip_I2C_Write2(a1, v2, (int64_t *)&g98, (char *)&v1, (int64_t *)&g91); // 0x11273
        return result;
    }
    int64_t v3 = *(int64_t *)(a1 + 0x1d38); // 0x11210
    int16_t v4 = a2 << (int32_t)&g86; // 0x1127d
    int16_t v5 = (char)(int64_t)a4 != 0 ? v4 : v4 | (int16_t)(char)&g33;
    int16_t v6 = 256 * v5 / 256;
    int16_t v7 = (char)(int64_t)a5 != 0 ? v6 : v6 | (int16_t)(char)&g86;
    int16_t v8 = v7;
    int64_t result2 = TLIB_I2C_Write2(v3, 210, a3 % 256, (int64_t)&v8, (int64_t)&g1, 0); // 0x112b3
    return result2;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x112c2 - 0x112f2
// Line range:    2376 - 2606
int32_t DTV_SetTunerFreq(int64_t pTnim, int64_t Freq, char BW) {
    // 0x112c2
    int64_t v1; // 0x112c2
    int128_t v2; // 0x112c2
    __asm_vpalignr(v2, *(int128_t *)(v1 + 0xb941d4), 0);
    int64_t v3; // 0x112c2
    *(char *)v3 = 2 * (char)v3;
    int64_t v4; // 0x112c2
    int64_t v5; // 0x112c2
    int64_t v6; // 0x112c2
    int64_t result = TLIB_I2C_Write2(v4, 210, (int64_t)BW, v6, (int64_t)&g1, v5); // 0x112df
    return result;
}

// Address range: 0x112f2 - 0x11695
int64_t DTV_SetTunerFreq2(int64_t a1, uint64_t a2, int64_t * a3) {
    // 0x112f2
    mcount();
    char v1 = *(char *)(a1 + (int64_t)&g39); // 0x1134c
    if (v1 == (char)&g1) {
        // 0x11355
        TLIB_Delay2((int64_t *)400);
        return &g1;
    }
    int64_t v2 = *(int64_t *)(a1 + 0x1d38); // 0x1131c
    char * v3 = (char *)(a1 + 0x1d30); // 0x11323
    unsigned char v4 = *v3; // 0x11323
    int64_t v5 = v4; // 0x11323
    int64_t v6 = *(int64_t *)(v2 + 1160 + 8 * v5); // 0x1132e
    TunerReset2(a1, (int64_t)&g1, (int64_t)&g1);
    int64_t v7 = v2 + v5;
    if (*(char *)(a1 + (int64_t)&g49) != 0) {
        // 0x113b2
        if (!((v6 == 0 | *(char *)(v7 + 1152) != 1))) {
            // 0x113c7
            DTV_StartStop_Enc2(a1, 0);
        }
    }
    // 0x113d4
    vUSB_Wait2(50);
    char * v8 = (char *)(v7 + 1312); // 0x113e1
    *v8 = (char)&g1;
    unsigned char v9 = *v3; // 0x113ea
    *(int64_t *)(v2 + 0x5968 + 80 * (int64_t)v9) = (int64_t)&g1;
    *(int64_t *)(v2 + 0x5970 + 80 * (int64_t)*v3) = 0;
    unsigned char v10 = *v3; // 0x11418
    *(int64_t *)(v2 + 0x5978 + 80 * (int64_t)v10) = (int64_t)&g12;
    int64_t v11 = Tnim_AcquireFrequency2(a1, a2, (int64_t)a3 % 256); // 0x11439
    if ((char)v11 == (char)&g1) {
        // 0x11442
        *(int64_t *)(a1 + 0x929a8) = a2;
        *(int32_t *)(a1 + 0x929b0) = 0;
        if (*(char *)(a1 + 0x8fabc) != 0) {
            int64_t v12 = *(int64_t *)(a1 + 0x8fab0);
            if (a2 < 0xbb8bb8) {
                // 0x11478
                TS_EnableProcProgramID2(v12, 0);
            } else {
                // 0x11465
                TS_EnableProcProgramID2(v12, (int64_t)&g1);
            }
        }
    }
    // 0x11489
    *v8 = 0;
    if (*(int32_t *)(a1 + (int64_t)&g21) == 0) {
        unsigned char v13 = *(char *)(v2 + 0x4fb0); // 0x1149e
        unsigned char v14 = *(char *)(v2 + 0x4faf); // 0x114aa
        unsigned char v15 = *(char *)(v2 + 0x5512); // 0x114b5
        unsigned char v16 = *(char *)(v2 + 0x5511); // 0x114c1
        *(int32_t *)(a1 + 0x8fac0) = (256 * (int32_t)v15 | (int32_t)v16) ^ (256 * (int32_t)v13 | (int32_t)v14);
    }
    // 0x114d4
    Tnim_AcqInit2(a1);
    if (*(char *)(a1 + 0x92978) == 1) {
        // 0x114e9
        if (*(char *)(a1 + 0x8fd7e) == 1) {
            char v17 = *v3; // 0x114f6
            int32_t v18 = (int32_t)(v17 == 0) + (int32_t)&g1; // 0x114ff
            int64_t v19 = (int64_t)(v17 == 0) + (int64_t)(int32_t)&g25 & 0xffffffff; // 0x1150f
            vUSB_Wait2((int64_t)&g98);
            if (*(char *)(v2 + 0x5799) != 0) {
                // 0x11581
                SetSlowdownIC2(a1, v18, v19, NULL, (int64_t *)&g1, 71);
                vUSB_Wait2((int64_t)&g98);
                SetSlowdownIC2(a1, v18, v19, (int64_t *)&g1, (int64_t *)&g1, 71);
            } else {
                // 0x11528
                SetSlowdownIC2(a1, v18, v19, (int64_t *)&g1, (int64_t *)&g1, 71);
                vUSB_Wait2((int64_t)&g98);
                int64_t result = SetSlowdownIC2(a1, v18, v19, NULL, (int64_t *)&g1, 71); // 0x11573
                if ((char)result == 0) {
                    // 0x1157c
                    return result;
                }
            }
            // 0x115d9
            vUSB_Wait2((int64_t)&g98);
        }
    }
    char v20 = *(char *)(a1 + 0x148d); // 0x115e3
    switch (v20) {
        case 3: {
            goto lab_0x115fa;
        }
        case 15: {
            goto lab_0x115fa;
        }
        case 4: {
            goto lab_0x115fa;
        }
        default: {
            if (a2 < 0xb2f278 || v20 != 17) {
                goto lab_0x1160d;
            } else {
                // 0x11603
                vUSB_Wait2(500);
                goto lab_0x1160d;
            }
        }
    }
  lab_0x115fa:
    if (a2 < 0xb2f278) {
        goto lab_0x1160d;
    } else {
        // 0x11603
        vUSB_Wait2(500);
        goto lab_0x1160d;
    }
  lab_0x1160d:;
    int64_t v21 = USB_FilterReset2(v2, v5); // 0x11621
    DTV_SetPidFilterBoundary2(a1, 0x1fff, 0x1fff);
    if ((int32_t)v21 != (int32_t)&g1) {
        // 0x1157c
        return 0xfffffffa;
    }
    // 0x11644
    if (!((v6 == 0 | *(char *)(v7 + 1152) != 1))) {
        // 0x1166b
        Hardware_StopTSStream2(v2, v5);
        Hardware_StartTSStream2(v2, v4);
    }
    // 0x11681
    *(char *)(a1 + 0x8fabd) = (char)&g1;
    return DTV_SetIsStreamScramble2(a1);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x11698 - 0x116c8
// Line range:    1023 - 1046
char InitSlowDownIC(int64_t pTnim) {
    // 0x11698
    int64_t v1; // 0x11698
    bool v2; // 0x11698
    int64_t v3 = v1 - (int64_t)v2; // 0x11698
    char * v4 = (char *)(v3 & 0xffffffff); // 0x1169d
    *v4 = *v4 + (char)v3;
    return &g1;
}

// Address range: 0x116c8 - 0x116f5
int64_t InitSlowDownIC2(int64_t a1) {
    // 0x116c8
    mcount();
    return 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x116f6 - 0x11726
// Line range:    8663 - 8723
char bBCardUninit(int64_t BCAS_Dev) {
    // 0x116f6
    int64_t v1; // 0x116f6
    unsigned char v2 = *(char *)(v1 + 0x5799); // 0x11707
    int64_t v3; // 0x116f6
    int64_t v4 = SetSlowdownIC2(BCAS_Dev, (int32_t)v3, (int64_t)(int32_t)&g25, (int64_t *)(int64_t)v2, (int64_t *)&g1, 71); // 0x1171a
    return (char)v4 != 0;
}

// Address range: 0x11726 - 0x1183e
int64_t bBCardUninit2(int64_t a1, int64_t a2) {
    // 0x11726
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 64); // 0x11736
    unsigned char v2 = *(char *)(a1 + 0x1481); // 0x1173a
    int64_t v3 = v2; // 0x1173a
    int64_t v4 = 0; // 0x11754
    if (*(char *)(v1 + 0x54c1) == 0) {
        // 0x11756
        *(char *)(v1 + 0x54c2 + v3) = 0;
        // 0x11784
        return (int64_t)&g1 & 0xffffffff;
    }
    int64_t result; // 0x11726
    if (v2 != (char)v4) {
        // 0x11770
        if (*(char *)(v1 + 0x54c2) == 1) {
            // 0x11789
            *(char *)(v1 + 0x54c2 + v3) = 0;
            result = (int64_t)&g1 & 0xffffffff;
            return result;
        }
    }
    int64_t v5 = v4 + (int64_t)(int32_t)&g1; // 0x11779
    v4 = v5 & 0xffffffff;
    int64_t v6 = v1 + 1; // 0x11782
    result = v4;
    while ((char)v5 != (char)&g95) {
        int64_t v7 = v6;
        if (v2 != (char)v4) {
            // 0x11770
            if (*(char *)(v7 + 0x54c2) == 1) {
                // 0x11789
                *(char *)(v1 + 0x54c2 + v3) = 0;
                result = (int64_t)&g1 & 0xffffffff;
                return result;
            }
        }
        // 0x11779
        v5 = v4 + (int64_t)(int32_t)&g1;
        v4 = v5 & 0xffffffff;
        v6 = v7 + 1;
        result = v4;
    }
  lab_0x11784:
    // 0x11784
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x1183e - 0x1186e
// Line range:    900 - 973
int32_t DTV_UnInit(int64_t pTnim) {
    // 0x1183e
    int64_t result; // 0x1183e
    return result;
}

// Address range: 0x1186e - 0x1196e
int64_t DTV_UnInit2(int64_t a1) {
    // 0x1186e
    mcount();
    int32_t * v1 = (int32_t *)(a1 + 0x1d40); // 0x11899
    int32_t v2 = *v1; // 0x11899
    *v1 = 0;
    char * v3 = (char *)(a1 + 0x15d8); // 0x118c4
    int64_t v4 = &g1; // 0x118cb
    int64_t v5; // 0x1186e
    if (*v3 == 1) {
        char v6 = 0; // bp-41, 0x118cd
        char * v7 = (char *)(a1 + 0x8fcac); // 0x118d5
        char v8 = *v7; // 0x118d5
        DTV_DecEncChip_I2C_Write2(a1, v8, (int64_t *)(int64_t)(v2 & -256 | 128), &v6, (int64_t *)&g1);
        char v9 = v8; // 0x118f6
        if (*v3 != 1) {
            // 0x118f8
            v9 = *v7;
            DTV_DecEncChip_I2C_Write2(a1, v9, (int64_t *)128, &v6, (int64_t *)&g1);
        }
        int64_t v10 = v9;
        int64_t v11 = bBCardUninit2(a1 + (int64_t)&g95, v10); // 0x11920
        char * v12 = (char *)(a1 + 0x8fabc); // 0x11925
        v4 = v11;
        v5 = v10;
        if (*v12 == 1) {
            // 0x1192e
            *v12 = 0;
            int64_t * v13 = (int64_t *)(a1 + 0x8fab0); // 0x11935
            int64_t v14 = TS_Destroy2(*v13); // 0x1193c
            *v13 = 0;
            v4 = v14;
            v5 = v10;
        }
    }
    int64_t v15 = *(int64_t *)(a1 + 0x8fc98); // 0x1194c
    int64_t v16 = v4; // 0x11956
    if (v15 != 0) {
        // 0x11958
        v16 = FUSB_ExFreePool2((int32_t)v15, v5);
    }
    int64_t v17 = *(int64_t *)(a1 + 0x8fca0); // 0x1195d
    int64_t result = v16; // 0x11967
    if (v17 != 0) {
        // 0x11969
        result = FUSB_ExFreePool2((int32_t)v17, v5);
    }
    // 0x1196e
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x1196f - 0x1199f
// Line range:    292 - 346
char bReadMPUI2CData(char MPU_Slave_Addr, char Target_Slave_Addr, char RegOffset, char u16ReadLen, char * pDataBuf, char withRSA, int64_t hCtrlTransfer) {
    // 0x1196f
    int64_t v1; // 0x1196f
    uint64_t v2; // 0x1196f
    FUSBDTV_Cmd_StartDSC(v1, (char)(v2 >> (uint64_t)(int64_t)&g95));
    int64_t v3; // 0x1196f
    DTV_TunerPower2(v3);
    return &g1;
}

// Address range: 0x1199f - 0x119de
int64_t bReadMPUI2CData2(int64_t a1, int64_t a2, uint64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7) {
    // 0x1199f
    mcount();
    return a3 % 256;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x119e0 - 0x11a10
// Line range:    10465 - 10471
char DTV_DecEncChip_I2C_Read(int64_t pTuner, char I2C_Addr, char byReg, char * pBuffer, char byCount, char withRSA) {
    // 0x119e0
    int64_t result; // 0x119e0
    return result;
}

// Address range: 0x119e3 - 0x119e5
int64_t function_119e3(void) {
    // 0x119e3
    int64_t result; // 0x119e3
    return result;
}

// Address range: 0x11a10 - 0x11a43
int64_t DTV_DecEncChip_I2C_Read2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x11a10
    mcount();
    return (int64_t)*(char *)(a1 + 0x92969);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x11a45 - 0x11a75
// Line range:    9448 - 9464
char ReadSlowdownICVersion(int64_t pTuner, char * SlowdownICVersion) {
    // 0x11a45
    int64_t v1; // 0x11a45
    int64_t v2; // 0x11a45
    int64_t v3; // 0x11a45
    int64_t v4; // 0x11a45
    int64_t v5; // 0x11a45
    int64_t result = bReadMPUI2CData2(v5 & 0xffffffff, (int64_t)SlowdownICVersion, v3 & -0xff01 | 0xc900, v1 & 0xffffffff, v4, v2, (int64_t)&g107); // 0x11a4f
    return result;
}

// Address range: 0x11a75 - 0x11abc
int64_t ReadSlowdownICVersion2(int64_t a1, int64_t a2) {
    // 0x11a75
    mcount();
    return 0x100000001;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x11abf - 0x11ac8
// Line range:    9467 - 9489
char DTV_IsSlowDownICExisted(int64_t pTuner) {
    // 0x11abf
    int64_t v1; // 0x11abf
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x11abf
    int64_t v3; // 0x11abf
    int64_t v4; // 0x11abf
    int64_t v5; // 0x11abf
    return DTV_DecEncChip_I2C_Read2(pTuner, v3, v4, v5, v2);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x11ad6 - 0x11aef
// Line range:    8445 - 8660
char bBCardInit(int64_t BCAS_Dev) {
    // 0x11ad6
    int64_t v1; // 0x11ad6
    int64_t v2; // 0x11ad6
    int64_t v3; // 0x11ad6
    return TLIB_I2C_Read2(BCAS_Dev, 210, 0, (int64_t *)v3, (int64_t *)v2, v1);
}

// Address range: 0x11aef - 0x11b06
int64_t DTV_IsSlowDownICExisted2(int64_t a1) {
    // 0x11aef
    mcount();
    return ReadSlowdownICVersion2(a1, a1 + 0x92978);
}

// Address range: 0x11b06 - 0x11d8b
int64_t bBCardInit2(int64_t a1) {
    // 0x11b06
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 64); // 0x11b2a
    unsigned char v2 = *(char *)(a1 + 0x1481); // 0x11b2e
    int64_t v3 = *(int64_t *)(a1 + 72); // 0x11b36
    int32_t v4; // bp-72, 0x11b06
    int64_t v5 = &v4;
    char v6 = 74; // 0x11b3d
    int64_t v7 = 90; // 0x11b3d
    if (v2 == 0) {
        goto lab_0x11beb;
    } else {
        int64_t v8 = DTV_DecEncChip_I2C_Read2(v3, 74, (int64_t)&g97, v5, (int64_t)&g1); // 0x11b60
        if ((char)v8 != (char)&g1) {
            goto lab_0x11b81;
        } else {
            // 0x11b69
            v6 = 74;
            v7 = 90;
            uint32_t v9; // 0x11b69
            switch (v9 / 2 % 32) {
                case 15: {
                    goto lab_0x11beb;
                }
                case 4: {
                    goto lab_0x11beb;
                }
                case 17: {
                    goto lab_0x11beb;
                }
                default: {
                    goto lab_0x11b81;
                }
            }
        }
    }
  lab_0x11beb:;
    int64_t v10 = DTV_DecEncChip_I2C_Read2(v3, v7, (int64_t)&g97, v5, (int64_t)&g1); // 0x11c07
    char * v11; // 0x11b06
    int64_t v12; // 0x11b06
    if ((char)v10 != 0) {
        char * v13 = (char *)(v3 + 0x8fcac);
        *v13 = (char)v7;
        v12 = v7;
        v11 = v13;
    } else {
        // 0x11c10
        TLIB_Delay2((int64_t *)&g98);
        int64_t v14 = v6;
        DTV_DecEncChip_I2C_Read2(v3, v14, (int64_t)&g97, v5, (int64_t)&g1);
        char * v15 = (char *)(v3 + 0x8fcac);
        *v15 = v6;
        v12 = v14;
        v11 = v15;
    }
    // 0x11c5c
    DTV_DecEncChip_I2C_Read2(v3, v12, (int64_t)&g97, v5, (int64_t)&g1);
    uint32_t v16 = v4 / 2 % 32;
    int64_t result = v16; // 0x11c8c
    unsigned char v17 = (char)v16; // 0x11c8e
    *(char *)(a1 + 0x1485) = v17;
    if (v17 >= 18) {
        // 0x11c98
        return result;
    }
    int64_t result2 = result; // 0x11cac
    unsigned char v18; // 0x11cae
    if (*(char *)(v3 + 0x92968) == 1) {
        goto lab_0x11cec;
    } else {
        // 0x11cae
        v18 = *(char *)(v3 + 0x148d);
        switch (v18) {
            case 15: {
                goto lab_0x11cc3;
            }
            case 4: {
                goto lab_0x11cc3;
            }
            default: {
                if (v18 != 17) {
                    // 0x11cdb
                    result2 = FUSBDTV_Cmd_ReadIR(v1, (char *)(int64_t)*v11);
                    goto lab_0x11cec;
                } else {
                    goto lab_0x11cc3;
                }
            }
        }
    }
  lab_0x11cec:
    // 0x11cec
    if (*(char *)(v1 + 0x54c1) == 0) {
        // 0x11d0e
        *(char *)(a1 + 0x1480) = (char)&g1;
        *(int32_t *)(a1 + 0x133c) = 0;
        *(char *)(a1 + 0x1482) = 0;
        *(int32_t *)(a1 + 1064) = 64;
        *(int32_t *)(a1 + 2028) = 64;
        *(int32_t *)(a1 + 2992) = 64;
        *(char *)(a1 + (int64_t)&g6) = 0;
        *(int32_t *)(a1 + 400) = 0;
        *(int32_t *)(a1 + (int64_t)" c") = 0;
        *(int32_t *)(a1 + 0x15c8) = 0;
        *(int64_t *)(a1 + 1056) = 0;
        *(char *)(a1 + 0x15cc) = 0;
        *(char *)(v1 + 0x54c0) = 0;
        *(char *)(v1 + 0x5510) = (char)&g1;
        return result2;
    }
    // 0x11cf6
    *(char *)(v1 + 0x54c2 + (int64_t)v2) = (char)&g1;
    return result2;
  lab_0x11b81:
    // 0x11b81
    TLIB_SetGPIO2(v1, (int64_t *)255, (int64_t *)128);
    TLIB_Delay2((int64_t *)&g16);
    TLIB_SetGPIO2(v1, NULL, (int64_t *)128);
    TLIB_Delay2((int64_t *)&g16);
    TLIB_SetGPIO2(v1, (int64_t *)255, (int64_t *)128);
    TLIB_Delay2((int64_t *)50);
    v6 = 76;
    v7 = 92;
    goto lab_0x11beb;
  lab_0x11cc3:
    // 0x11cc3
    result2 = v18;
    if (v2 == 0) {
        // 0x11cc8
        result2 = FUSBDTV_Cmd_ReadIR(v1, (char *)(int64_t)*v11);
    }
    goto lab_0x11cec;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x11d90 - 0x11dc0
// Line range:    1794 - 2325
int32_t DTV_Init(int64_t pTnim, int32_t Mode, char bAPKeyIdenfy) {
    // 0x11d90
    int64_t v1; // 0x11d90
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x11d90
    *(char *)(v2 + 0x54c1) = (char)&g1;
    uint64_t v3; // 0x11d90
    *(char *)(v2 + 0x54c2 + v3 % 256) = (char)&g1;
    int64_t result; // 0x11d90
    return result;
}

// Address range: 0x11dc0 - 0x12768
int64_t DTV_Init2(int64_t a1, int64_t * a2, int64_t * a3) {
    // 0x11dc0
    mcount();
    __readgsqword(40);
    int64_t * v1 = (int64_t *)(a1 + 0x1d38); // 0x11df4
    int64_t v2 = *v1; // 0x11df4
    char * v3 = (char *)(a1 + 0x1d30); // 0x11dfb
    char v4 = *v3; // 0x11dfb
    char * v5 = (char *)(v2 + 0x55a1); // 0x11ed2
    *v5 = (char)&g1;
    *(int64_t *)(a1 + 0x8fe30) = 0;
    *(int64_t *)(a1 + 0x8fe20) = 0;
    *(int64_t *)(a1 + 0x8fe28) = 0;
    *(char *)(a1 + 0x8fe38) = 0;
    char * v6 = (char *)(a1 + 0x8fd6d); // 0x11f03
    *v6 = 0;
    *(int64_t *)(a1 + 0x929a8) = 0;
    *(int32_t *)(a1 + 0x929b0) = 0;
    char v7; // bp-216, 0x11dc0
    int64_t v8 = FUSBDTV_Cmd_SysCtrlRead2(v2, (int64_t *)&g25, (int64_t *)&g25, (int64_t *)&v7); // 0x11f33
    if ((char)v8 != (char)&g1) {
        goto lab_0x11f5e;
    } else {
        // 0x11f3c
        char v9; // 0x11dc0
        if (v9 == 82 == v7 == (char)&g10) {
            // 0x11f4e
            *(char *)(a1 + 0x8f475) = (char)&g1;
            *(char *)(a1 + 0x15eb) = (char)&g10;
            goto lab_0x11f7a;
        } else {
            goto lab_0x11f5e;
        }
    }
  lab_0x11f5e:
    // 0x11f5e
    *(char *)(a1 + (int64_t)&g49) = (char)&g1;
    *(char *)(a1 + 0x8f475) = (char)&g33;
    *(char *)(a1 + 0x15e9) = 0;
    *(char *)(a1 + 0x15eb) = (char)&g3;
    goto lab_0x11f7a;
  lab_0x11f7a:;
    int64_t v10; // bp-120, 0x11dc0
    int64_t v11; // bp-200, 0x11dc0
    if ((char)(int64_t)a3 == 0) {
        // 0x120a6
        *(char *)(a1 + 0x15ec) = 0;
    } else {
        char v12 = 60; // bp-136, 0x11f83
        *(char *)(a1 + 0x15ec) = (char)&g1;
        int64_t v13 = &v12; // 0x11fe6
        int64_t v14 = &v10; // 0x11fed
        int64_t v15 = v13; // 0x11ff1
        int64_t v16 = a1; // 0x11ff1
        char * v17 = (char *)v15; // 0x11ffb
        *v17 = *v17 ^ *(char *)(v16 + 0x15ed);
        v15 += (int64_t)&g1;
        v16 += (int64_t)&g1;
        while (v15 != v14) {
            // 0x11ff4
            v17 = (char *)v15;
            *v17 = *v17 ^ *(char *)(v16 + 0x15ed);
            v15 += (int64_t)&g1;
            v16 += (int64_t)&g1;
        }
        // 0x1200a
        __asm_rep_stosq_memset((char *)&v11, 0, (int64_t)&g95);
        int64_t v18 = v13; // 0x1201e
        int64_t str = &v11; // 0x1201e
        int64_t v19; // 0x11dc0
        int64_t v20; // 0x11dc0
        sprintf(str, 0, (int64_t)*(char *)v18, 0, v20, v19);
        v18 += (int64_t)&g1;
        str += (int64_t)&g25;
        while (v18 != v14) {
            // 0x12021
            sprintf(str, 0, (int64_t)*(char *)v18, 0, v20, v19);
            v18 += (int64_t)&g1;
            str += (int64_t)&g25;
        }
        int64_t v21 = v2 + 3816; // 0x1204e
        makeKey2((int64_t *)(a1 + 0x8f478), 0, 128, &v11, v21);
        makeKey2((int64_t *)(a1 + 0x8f758), (int64_t)&g1, 128, &v11, v21);
        cipherInit2(a1 + 0x8fa38, (int64_t *)&g1, 0);
    }
    // 0x120ad
    DTV_TunerPower2(a1);
    char * v22 = (char *)(a1 + 0x15d8); // 0x120ba
    *v22 = 0;
    int64_t v23 = TunerReset2(a1, (int64_t)&g1, 0); // 0x120ce
    if ((int32_t)v23 != (int32_t)&g1) {
        // 0x120d8
        DTV_TunerPower2(a1);
        if (v4 == 0) {
            // 0x120ee
            TLIB_SetGPIO2(*v1, (int64_t *)&g95, (int64_t *)&g95);
        }
        // 0x12104
        TLIB_Delay2((int64_t *)600);
        DTV_TunerPower2(a1);
        TLIB_Delay2((int64_t *)100);
        int64_t v24 = TunerReset2(a1, (int64_t)&g1, 0); // 0x12132
        if ((int32_t)v24 != (int32_t)&g1) {
            // 0x1213c
            DTV_TunerPower2(a1);
            return 0xfffffffe;
        }
    }
    // 0x12153
    *(int32_t *)(a1 + (int64_t)&g21) = 0;
    *(int32_t *)(a1 + 0x8fab8) = 0;
    FUSBDTV_Cmd_Get_DevRandomKey2(v2);
    *(char *)(a1 + 0x92968) = 0;
    *(char *)(a1 + 0x92969) = 0;
    *(int64_t *)(a1 + 0x15e0) = 0xe020;
    *(char *)(a1 + 0x15e8) = 0;
    *(char *)(a1 + 0x8fa49) = 0;
    *(char *)(a1 + 0x8fabc) = 0;
    *(int64_t *)(a1 + 0x8fab0) = 0;
    *(char *)(a1 + 0x8fabd) = 0;
    int32_t * v25 = (int32_t *)(a1 + 0x8fac0); // 0x121af
    *v25 = 0;
    if (*(char *)(v2 + 0x3e68) == 0) {
        unsigned char v26 = *(char *)(v2 + 0x4fb0); // 0x121c4
        unsigned char v27 = *(char *)(v2 + 0x4faf); // 0x121d0
        unsigned char v28 = *(char *)(v2 + 0x5512); // 0x121db
        unsigned char v29 = *(char *)(v2 + 0x5511); // 0x121e7
        *v25 = (256 * (int32_t)v28 | (int32_t)v29) ^ (256 * (int32_t)v26 | (int32_t)v27);
    }
    // 0x121fa
    *(int64_t *)(v2 + 1248 + 8 * (int64_t)*v3) = a1;
    if (v4 < 8) {
        // 0x12212
        *(int64_t *)(a1 + 72) = v2;
        *(char *)(a1 + 0x1489) = v4;
        *(int64_t *)(a1 + 80) = a1;
        if ((char)bBCardInit2(a1 + (int64_t)&g95) == 0) {
            // 0x12234
            *v22 = 0;
            return 0xffffffff;
        }
        char v30 = *(char *)(a1 + 0x148d); // 0x12245
        switch (v30) {
            case 3: {
                // 0x12258
                *(char *)(a1 + 0x8f475) = (char)&g94;
                // 0x1226c
                *v22 = (char)&g1;
                goto lab_0x12273;
            }
            case 15: {
                // 0x12258
                *(char *)(a1 + 0x8f475) = (char)&g94;
                // 0x1226c
                *v22 = (char)&g1;
                goto lab_0x12273;
            }
            default: {
                if (v30 != 4) {
                    if (v30 == 17) {
                        // 0x12265
                        *(char *)(a1 + 0x8f475) = (char)&g95;
                    }
                    // 0x1226c
                    *v22 = (char)&g1;
                    goto lab_0x12273;
                } else {
                    // 0x12258
                    *(char *)(a1 + 0x8f475) = (char)&g94;
                    // 0x1226c
                    *v22 = (char)&g1;
                    goto lab_0x12273;
                }
            }
        }
    } else {
        goto lab_0x12273;
    }
  lab_0x12273:
    // 0x12273
    FUSBDTV_Cmd_StartDSC(v2, v4);
    int32_t v31 = (int64_t)a2; // 0x122a5
    if (v31 != 0) {
        // 0x12310
        USB_FilterONOFF2(v2, (int32_t)v4);
        if (v31 != (int32_t)&g1) {
            // 0x12341
            DTV_SetPidFilterBoundary2(a1, 0x1fff, 0x1fff);
            if ((int32_t)USB_IsHighSpeed2(v2) == 0) {
                // 0x12387
                *v5 = 0;
                *(int32_t *)(a1 + 0x1d44) = 0;
            } else {
                // 0x12372
                *v5 = (char)&g1;
                *(int32_t *)(a1 + 0x1d44) = (int32_t)&g1;
            }
        } else {
            // 0x12319
            *(int32_t *)(a1 + 0x1d44) = 0;
            *v5 = 0;
        }
    } else {
        int64_t v32 = USB_IsHighSpeed2(v2); // 0x122b1
        USB_FilterONOFF2(v2, (int32_t)v4);
        int32_t * v33 = (int32_t *)(a1 + 0x1d44);
        if ((int32_t)v32 == 0) {
            // 0x122e5
            *v33 = 0;
            *v5 = 0;
        } else {
            // 0x122ba
            *v33 = (int32_t)&g1;
            *v5 = (char)&g1;
        }
    }
    int32_t * v34 = (int32_t *)(a1 + 0x1d40); // 0x1239a
    *v34 = *v34 + 1;
    *(int32_t *)(a1 + 0x1d48) = 0;
    *(char *)(a1 + 0x8ede5) = 0;
    *(char *)(a1 + (int64_t)&g37) = (char)&g1;
    int64_t v35 = FUSB_ExAllocatePool2(0, 264); // 0x123c3
    int64_t * v36 = (int64_t *)(a1 + 0x8fc98); // 0x123c8
    *v36 = v35;
    int64_t v37 = FUSB_ExAllocatePool2(0, 264); // 0x123d9
    int64_t * v38 = (int64_t *)(a1 + 0x8fca0); // 0x123de
    *v38 = v37;
    __asm_rep_stosq_memset((char *)*v36, 0, (int64_t)&g28);
    __asm_rep_stosq_memset((char *)*v38, 0, (int64_t)&g28);
    int64_t v39 = (int64_t)*(char *)(a1 + 0x8fcac); // 0x1240f
    int64_t v40 = DTV_DecEncChip_I2C_Read2(a1, v39, (int64_t)&g97, (int64_t)&v10, (int64_t)&g1); // 0x1242a
    if ((char)v40 != 0) {
        // 0x12433
        *v6 = (char)&g1;
    }
    // 0x1243a
    DTV_Reset_EncChipEx2(a1, v39, (int64_t)&g97);
    char * v41 = (char *)(a1 + (int64_t)&g49); // 0x12442
    *v41 = (char)&g1;
    *(char *)(a1 + (int64_t)&g42) = 0;
    *(int64_t *)(a1 + (int64_t)&g45) = -83;
    *(int64_t *)(a1 + (int64_t)&g45 + (int64_t)&g95) = -112;
    *(int64_t *)(a1 + (int64_t)&g46) = -3;
    *(int64_t *)(a1 + (int64_t)&g46 + (int64_t)&g95) = -85;
    char * v42; // 0x11dc0
    int64_t v43; // 0x11dc0
    int64_t v44; // bp-168, 0x11dc0
    int32_t v45; // bp-201, 0x11dc0
    if (*v41 != (char)&g1) {
        // 0x125b5
        __asm_rep_stosq_memset((char *)&v11, 0, (int64_t)&g95);
        int64_t str2 = &v11; // 0x1260f
        int64_t v46 = a1; // 0x1260f
        unsigned char v47 = *(char *)(v46 + (int64_t)&g45); // 0x12613
        sprintf(str2, 0, (int64_t)v47, 0, (int64_t)&g1, 0);
        str2 += (int64_t)&g25;
        v46 += (int64_t)&g1;
        while (str2 != (int64_t)&v44) {
            // 0x12613
            v47 = *(char *)(v46 + (int64_t)&g45);
            sprintf(str2, 0, (int64_t)v47, 0, (int64_t)&g1, 0);
            str2 += (int64_t)&g25;
            v46 += (int64_t)&g1;
        }
        int64_t v48 = v2 + 3816; // 0x12643
        makeKey2((int64_t *)(a1 + 0x8eea4), 0, 128, &v11, v48);
        makeKey2((int64_t *)(a1 + 0x8f184), 0, 128, &v11, v48);
        cipherInit2(a1 + 0x8f464, (int64_t *)&g1, 0);
        v42 = (char *)(a1 + 0x15eb);
        v43 = v48;
    } else {
        // 0x1244f
        *(int64_t *)(a1 + (int64_t)&g47) = -3;
        *(int64_t *)(a1 + (int64_t)&g47 + (int64_t)&g95) = -85;
        __asm_rep_stosq_memset((char *)&v11, 0, (int64_t)&g95);
        int64_t str3 = &v11; // 0x124b7
        int64_t v49 = a1; // 0x124b7
        unsigned char v50 = *(char *)(v49 + (int64_t)&g45); // 0x124bb
        sprintf(str3, 0, (int64_t)v50, 0, (int64_t)&g1, 0);
        str3 += (int64_t)&g25;
        v49 += (int64_t)&g1;
        while (str3 != (int64_t)&v44) {
            // 0x124bb
            v50 = *(char *)(v49 + (int64_t)&g45);
            sprintf(str3, 0, (int64_t)v50, 0, (int64_t)&g1, 0);
            str3 += (int64_t)&g25;
            v49 += (int64_t)&g1;
        }
        int64_t v51 = v2 + 3816; // 0x124eb
        makeKey2((int64_t *)(a1 + 0x8eea4), 0, 128, &v11, v51);
        makeKey2((int64_t *)(a1 + 0x8f184), 0, 128, &v11, v51);
        cipherInit2(a1 + 0x8f464, (int64_t *)&g1, 0);
        DTV_Reset_EncChip2(a1);
        char * v52 = (char *)(a1 + 0x15eb);
        int64_t v53 = v51; // 0x12550
        if (*v52 == 22) {
            // 0x12552
            FUSBDTV_Cmd_Rst_Enc(v2);
            char v54 = *(char *)(a1 + 0x8f475); // 0x1257e
            v45 = v54 | (char)v45 & 124 | -128;
            FUSBDTV_Cmd_WriteEncReg(v2, v4, 64);
            v53 = &v45;
        }
        // 0x125a8
        DTV_EnableEncryptionChipTSOutput2(a1);
        v42 = v52;
        v43 = v53;
    }
    // 0x12699
    if (*v42 == 22) {
        // 0x126a2
        FUSBDTV_Cmd_SysCtrlRead2(v2, (int64_t *)&g91, (int64_t *)&g1, (int64_t *)&v45);
        char v55 = *(char *)(a1 + 0x15e9);
        int32_t v56 = 0x1000000 * v45 / 0x1000000;
        if (v4 != 0) {
            if (v55 != 0) {
                // 0x126f1
                v45 = v56 | 8;
            } else {
                // 0x126e8
                v45 = v56 & -9;
            }
        } else {
            if (v55 != 0) {
                // 0x126d6
                v45 = v56 | 4;
            } else {
                // 0x126cd
                v45 = v56 & -5;
            }
        }
        // 0x126f8
        FUSBDTV_Cmd_EncRead(v2, (char)&g91, (char)&g1, (int16_t)(int64_t)&v45, (char *)v43);
    }
    if (v4 == 0) {
        // 0x1271a
        *(char *)(a1 + 0x1340) = 0;
    }
    // 0x12721
    *(char *)(a1 + (int64_t)&g39) = (char)&g1;
    FUSBDTV_Cmd_StartDSC(v2, v4);
    *(char *)(a1 + (int64_t)&g40) = (char)&g1;
    *(char *)(a1 + (int64_t)&g41) = (char)&g1;
    int64_t v57 = a1 + (int64_t)&g1; // 0x12750
    int64_t v58 = v57; // 0x12757
    while (v57 != a1 + (int64_t)&g26) {
        // 0x12742
        *(char *)(v58 + (int64_t)&g40) = (char)&g1;
        *(char *)(v58 + (int64_t)&g41) = (char)&g1;
        v57 = v58 + (int64_t)&g1;
        v58 = v57;
    }
    // 0x12759
    *(char *)(a1 + 0x8fd7e) = 0;
    return InitSlowDownIC2(a1);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x1276a - 0x1279a
// Line range:    251 - 262
char bReadI2CEncData(char Slave_Addr, char RegOffset, int16_t u16ReadLen, char * pDataBuf, char I2CFlag, int64_t hCtrlTransfer) {
    // 0x1276a
    int64_t v1; // 0x1276a
    *(char *)v1 = 2 * (char)v1;
    int64_t v2 = v1 + 0xfffffeb8; // 0x1276e
    int32_t * v3 = (int32_t *)((v2 & 0xffffffff) - 117); // 0x12773
    *v3 = *v3 - (int32_t)&g1;
    int64_t v4 = (v1 + 221 + (int64_t)((int32_t)v1 > 327)) % 256 | v2 & 0xffffff00; // 0x1277b
    int64_t result = v4; // 0x12781
    if (*(char *)v4 != 0) {
        // 0x12783
        result = __stack_chk_fail();
    }
    // 0x12788
    return result;
}

// Address range: 0x1279a - 0x1279e
int64_t bReadI2CEncData2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1279a
    int64_t result; // 0x1279a
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x127a0 - 0x127a1
// Line range:    10481 - 10487
char DTV_ReadI2CEncData(int64_t pTuner, char I2C_Addr, char byReg, char byCount, char * pBuffer, char I2CFlag, char withRSA) {
    // 0x127a0
    int64_t result; // 0x127a0
    return result;
}

// Address range: 0x127a1 - 0x127d0
int64_t function_127a1(uint64_t a1, uint64_t a2, uint64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    uint64_t v1 = FUSBDTV_Cmd_I2CReadEnc2(a6, a1 % 256, a2 % 256, a3 % 0x10000, a4); // 0x127bc
    int64_t v2 = NT_SUCCESS2(v1 % 256); // 0x127c4
    return v2 & -256 | (int64_t)((char)v2 != 0);
}

// Address range: 0x127d0 - 0x12811
int64_t DTV_ReadI2CEncData2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int64_t a5, int64_t a6, int32_t a7) {
    // 0x127d0
    mcount();
    return *(int64_t *)(a1 + 0x1d38);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x12813 - 0x12843
// Line range:    240 - 250
char bWriteI2CEncData(char Slave_Addr, char RegOffset, int16_t u16WriteLen, char * pDataBuf, int64_t hCtrlTransfer) {
    // 0x12813
    int64_t v1; // 0x12813
    int64_t v2; // 0x12813
    int64_t v3; // 0x12813
    int64_t result = bReadMPUI2CData2(v2 & 0xffffffff, (int64_t)RegOffset, (int64_t)u16WriteLen & -0xff01 | 0xc900, (int64_t)pDataBuf, v1, v3, (int64_t)&g107); // 0x1281b
    return result;
}

// Address range: 0x12843 - 0x12844
int64_t bWriteI2CEncData2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x12843
    int64_t result; // 0x12843
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x12845 - 0x12875
// Line range:    10489 - 10495
char DTV_WriteI2CEncData(uint64_t pTuner, unsigned char I2C_Addr, char byReg, char byCount, char * pBuffer, char withRSA) {
    // 0x12845
    mcount();
    uint64_t v1 = FUSBDTV_Cmd_I2CWriteEnc2((int64_t)pBuffer, pTuner % 256, (int64_t)I2C_Addr, (uint64_t)(int64_t)byReg % 0x10000, (int64_t)byCount); // 0x12861
    return (char)NT_SUCCESS2(v1 % 256) != 0;
}

// Address range: 0x12875 - 0x128a2
int64_t DTV_WriteI2CEncData2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, char * a5) {
    // 0x12875
    mcount();
    return (int64_t)*(char *)(a1 + 0x92969);
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x128a7 - 0x128d7
// Line range:    7881 - 8046
char bReadBCAS_Data(char * DevExt, char * DataBuf, int32_t * GetLen, char bRdATR, int32_t BufferSz, char ASIE5606Ver) {
    // 0x128a7
    int64_t v1; // 0x128a7
    *(char *)v1 = 2 * (char)v1;
    return bWriteMPUI2CData2(v1 & 0xffffffff);
}

// Address range: 0x128d7 - 0x12c4a
int64_t bReadBCAS_Data2(int64_t a1, int64_t * a2, int64_t * a3, int64_t a4, int64_t a5, char a6) {
    // 0x128d7
    mcount();
    int64_t v1 = *(int64_t *)(a1 + (int64_t)&g87); // 0x12900
    char v2 = a4; // 0x12907
    int32_t v3; // bp-86, 0x128d7
    int64_t v4 = &v3; // 0x12928
    int64_t v5 = (int64_t)*(char *)(v1 + 0x8fcac); // 0x1292c
    char v6; // bp-88, 0x128d7
    int64_t v7 = &v6;
    int64_t v8; // bp-87, 0x128d7
    int64_t v9 = &v8;
    uint64_t v10 = v2 == (char)&g1 ? (int64_t)(int32_t)"NU" : (int64_t)(int32_t)&g33;
    TLIB_Delay2((int64_t *)50);
    if ((int32_t)a5 < 65) {
        // 0x12973
        v3 = 0;
    } else {
        // 0x1294c
        DTV_ReadI2CEncData2(v1, v5, 57, (int64_t *)&g1, 0x100000000 * v4 / 0x100000000, 0, 0);
    }
    // 0x12977
    DTV_ReadI2CEncData2(v1, v5, (int64_t)&g33, (int64_t *)&g1, v7, 0, 0);
    DTV_ReadI2CEncData2(v1, v5, (int64_t)&g86, (int64_t *)&g1, v9, 0, 0);
    uint32_t v11 = (v3 & (int32_t)&g1 & 255) << (int32_t)&g95 | (int32_t)v6; // 0x129e6
    int64_t v12 = v11; // 0x129e6
    while (v10 > v12) {
        // 0x1293c
        TLIB_Delay2((int64_t *)50);
        if ((int32_t)a5 < 65) {
            // 0x12973
            v3 = 0;
        } else {
            // 0x1294c
            DTV_ReadI2CEncData2(v1, v5, 57, (int64_t *)&g1, 0x100000000 * v4 / 0x100000000, 0, 0);
        }
        // 0x12977
        DTV_ReadI2CEncData2(v1, v5, (int64_t)&g33, (int64_t *)&g1, v7, 0, 0);
        DTV_ReadI2CEncData2(v1, v5, (int64_t)&g86, (int64_t *)&g1, v9, 0, 0);
        v11 = (v3 & (int32_t)&g1 & 255) << (int32_t)&g95 | (int32_t)v6;
        v12 = v11;
    }
    int64_t v13 = (int64_t)a2;
    char v14; // bp-72, 0x128d7
    if (v11 >= 0 == (v11 != 0)) {
        int64_t v15 = v13; // 0x128d7
        uint64_t v16 = 0;
        uint64_t v17 = v16 % 64;
        if (a6 != 0 && v17 == 0) {
            // 0x12a33
            v14 = (int32_t)v16 >> (int32_t)&g91;
            DTV_WriteI2CEncData2(v1, v5, 58, (int64_t *)&g1, &v14);
        }
        // 0x12a5a
        DTV_ReadI2CEncData2(v1, v5, v17 | 64, (int64_t *)&g1, v7, 0, 0);
        *(char *)v15 = v6;
        int64_t v18 = v16 + (int64_t)(int32_t)&g1; // 0x12a8e
        v15 += (int64_t)&g1;
        while (v11 > (int32_t)v18) {
            // 0x12a29
            v16 = v18 & 0xffffffff;
            v17 = v16 % 64;
            if (a6 != 0 && v17 == 0) {
                // 0x12a33
                v14 = (int32_t)v16 >> (int32_t)&g91;
                DTV_WriteI2CEncData2(v1, v5, 58, (int64_t *)&g1, &v14);
            }
            // 0x12a5a
            DTV_ReadI2CEncData2(v1, v5, v17 | 64, (int64_t *)&g1, v7, 0, 0);
            *(char *)v15 = v6;
            v18 = v16 + (int64_t)(int32_t)&g1;
            v15 += (int64_t)&g1;
        }
    }
    // 0x12a9e
    if (v2 != 0) {
        // 0x12c3d
        *(int32_t *)a3 = v11;
        return (int64_t)a3;
    }
    unsigned char v19 = *(char *)(v13 + (int64_t)&g25); // 0x12ab1
    int64_t v20 = ChangeEndian2((int64_t)v19); // 0x12ab5
    int64_t v21 = 0x100000000 * v9 / 0x100000000;
    uint64_t v22 = (int64_t)(0x1000000 * ((int32_t)v20 + (int32_t)(int16_t)(char)&g86) / 0x1000000);
    TLIB_Delay2((int64_t *)50);
    if ((int32_t)a5 < 65) {
        // 0x12b17
        v3 = 0;
    } else {
        // 0x12aec
        DTV_ReadI2CEncData2(v1, v5, 57, (int64_t *)&g1, v4, 0, 0);
    }
    // 0x12b1b
    DTV_ReadI2CEncData2(v1, v5, (int64_t)&g33, (int64_t *)&g1, v7, 0, 0);
    DTV_ReadI2CEncData2(v1, v5, (int64_t)&g86, (int64_t *)&g1, v21, 0, 0);
    uint32_t v23 = (v3 & (int32_t)&g1 & 255) << (int32_t)&g95 | (int32_t)v6; // 0x12b89
    while (v22 > (int64_t)v23) {
        // 0x12adc
        TLIB_Delay2((int64_t *)50);
        if ((int32_t)a5 < 65) {
            // 0x12b17
            v3 = 0;
        } else {
            // 0x12aec
            DTV_ReadI2CEncData2(v1, v5, 57, (int64_t *)&g1, v4, 0, 0);
        }
        // 0x12b1b
        DTV_ReadI2CEncData2(v1, v5, (int64_t)&g33, (int64_t *)&g1, v7, 0, 0);
        DTV_ReadI2CEncData2(v1, v5, (int64_t)&g86, (int64_t *)&g1, v21, 0, 0);
        v23 = (v3 & (int32_t)&g1 & 255) << (int32_t)&g95 | (int32_t)v6;
    }
    int32_t v24 = v23 - v11; // 0x12b92
    uint32_t v25 = v24 + v11 * (int32_t)&g1; // 0x12b99
    if (v25 <= v11) {
        // 0x12c3d
        *(int32_t *)a3 = v24 + v11;
        return (int64_t)a3;
    }
    uint64_t v26 = v12 % 64;
    if (a6 != 0 && v26 == 0) {
        // 0x12bd1
        v14 = (int32_t)v12 >> (int32_t)&g91;
        DTV_WriteI2CEncData2(v1, v5, 58, (int64_t *)&g1, &v14);
    }
    // 0x12bf9
    DTV_ReadI2CEncData2(v1, v5, v26 | 64, (int64_t *)&g1, v7, 0, 0);
    *(char *)(0x100000000 * v12 / 0x100000000 * (int64_t)&g1 + v13) = v6;
    int64_t v27 = v12 + (int64_t)(int32_t)&g1 & 0xffffffff; // 0x12c34
    while (v27 < (int64_t)v25) {
        uint64_t v28 = v27;
        v26 = v28 % 64;
        if (a6 != 0 && v26 == 0) {
            // 0x12bd1
            v14 = (int32_t)v28 >> (int32_t)&g91;
            DTV_WriteI2CEncData2(v1, v5, 58, (int64_t *)&g1, &v14);
        }
        // 0x12bf9
        DTV_ReadI2CEncData2(v1, v5, v26 | 64, (int64_t *)&g1, v7, 0, 0);
        *(char *)(0x100000000 * v28 / 0x100000000 * (int64_t)&g1 + v13) = v6;
        v27 = v28 + (int64_t)(int32_t)&g1 & 0xffffffff;
    }
    // 0x12c3d
    *(int32_t *)a3 = v24 + v11;
    return (int64_t)a3;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x12c4f - 0x12c7f
// Line range:    7819 - 7879
char bWtBCAS_Data(char * DevExt, char * DataBuf, int32_t WtLen, char ASIE5606Ver) {
    int64_t v1 = ASIE5606Ver;
    int64_t v2; // 0x12c4f
    char * v3 = (char *)(4 * v1 + 69 + v2); // 0x12c4f
    *v3 = *v3 + ASIE5606Ver;
    int64_t v4; // 0x12c4f
    int64_t v5 = v4;
    *(char *)v5 = *(char *)&v4 + (char)v5;
    int64_t v6 = v4;
    *(char *)v6 = *(char *)&v4 + (char)v6;
    int64_t v7; // 0x12c4f
    int64_t v8; // 0x12c4f
    int64_t v9; // 0x12c4f
    return DTV_WriteI2CEncData2(v8, v7 & 0xffffffff, (int64_t)WtLen, (int64_t *)v1, (char *)v9);
}

// Address range: 0x12c7f - 0x12d8e
int64_t bWtBCAS_Data2(int64_t a1, char * a2, int64_t * a3, char a4) {
    int64_t v1 = (int64_t)a3;
    mcount();
    int64_t v2 = *(int64_t *)(a1 + (int64_t)&g87); // 0x12c9e
    int32_t v3 = v1; // 0x12cad
    int32_t v4 = 0x1000000 * v3 / 0x1000000; // bp-72, 0x12cb1
    int64_t v5 = (int64_t)*(char *)(v2 + 0x8fcac); // 0x12cb4
    int64_t v6 = DTV_WriteI2CEncData2(v2, v5, (int64_t)&g25, (int64_t *)&g1, (char *)&v4); // 0x12cd2
    int64_t result = v6; // 0x12cda
    if (a4 != 0) {
        // 0x12cdc
        v4 = 0x1000000 * (v3 >> (int32_t)&g95 & (int32_t)(char)&g1) / 0x1000000;
        result = DTV_WriteI2CEncData2(v2, v5, 56, (int64_t *)&g1, (char *)&v4);
    }
    // 0x12d07
    if (v3 < 1) {
        // 0x12d80
        return result;
    }
    int64_t v7 = (int64_t)a2; // 0x12c7f
    uint64_t v8 = 0;
    uint64_t v9 = v8 % 64;
    if (a4 != 0 && v9 == 0) {
        // 0x12d1e
        v4 = 0x1000000 * ((int32_t)v8 >> (int32_t)&g91) / 0x1000000;
        DTV_WriteI2CEncData2(v2, v5, 58, (int64_t *)&g1, (char *)&v4);
    }
    // 0x12d46
    v4 = (int32_t)*(char *)v7;
    int64_t result2 = DTV_WriteI2CEncData2(v2, v5, v9 | 64, (int64_t *)&g1, (char *)&v4); // 0x12d6d
    int64_t v10 = v8 + (int64_t)(int32_t)&g1 & 0xffffffff; // 0x12d72
    v7 += (int64_t)&g1;
    while (0x100000000 * v1 / 0x100000000 > v10) {
        // 0x12d13
        v8 = v10;
        v9 = v8 % 64;
        if (a4 != 0 && v9 == 0) {
            // 0x12d1e
            v4 = 0x1000000 * ((int32_t)v8 >> (int32_t)&g91) / 0x1000000;
            DTV_WriteI2CEncData2(v2, v5, 58, (int64_t *)&g1, (char *)&v4);
        }
        // 0x12d46
        v4 = (int32_t)*(char *)v7;
        result2 = DTV_WriteI2CEncData2(v2, v5, v9 | 64, (int64_t *)&g1, (char *)&v4);
        v10 = v8 + (int64_t)(int32_t)&g1 & 0xffffffff;
        v7 += (int64_t)&g1;
    }
    // 0x12d80
    return result2;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x12d90 - 0x12dc0
// Line range:    3119 - 3201
char Get_BCAS_INFO(int64_t BCAS_Dev) {
    // 0x12d90
    int64_t v1; // 0x12d90
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x12d90
    char v3 = *(char *)&v2; // 0x12d92
    uint64_t v4; // 0x12d90
    *(char *)v2 = v3 + (char)(v4 >> (int64_t)&g95);
    int64_t v5; // 0x12d90
    int64_t v6; // 0x12d90
    int64_t v7; // 0x12d90
    int64_t v8; // 0x12d90
    int64_t result = DTV_WriteI2CEncData2(v6, v5 & 0xffffffff, v2, (int64_t *)v8, (char *)v7); // 0x12d9e
    TLIB_Delay2((int64_t *)100);
    return result;
}

// Address range: 0x12dc0 - 0x12f62
int64_t Get_BCAS_INFO2(int64_t a1) {
    // 0x12dc0
    mcount();
    __readgsqword(40);
    char v1 = 0; // bp-120, 0x12e0c
    char * v2 = (char *)(a1 + 0x1482); // 0x12e10
    char v3 = *v2 == 0 ? 0 : 64; // bp-119, 0x12e1e
    char v4 = 0; // bp-112, 0x12e3b
    char * v5 = (char *)(a1 + 0x1480); // 0x12e3f
    v1 = 0;
    if (*v5 != 0) {
        int64_t v6 = &v1; // 0x12e4c
        char * v7 = (char *)v6; // 0x12e50
        *v7 = (char)ChangeEndian2((int64_t)*v7);
        v6 += (int64_t)&g1;
        int64_t v8; // bp-111, 0x12dc0
        while (v6 != (int64_t)&v8) {
            // 0x12e50
            v7 = (char *)v6;
            *v7 = (char)ChangeEndian2((int64_t)*v7);
            v6 += (int64_t)&g1;
        }
    }
    // 0x12e63
    v4 = v1;
    int64_t v9 = &v4; // 0x12e72
    char v10 = v1; // 0x12e72
    int64_t v11 = &v3; // 0x12e72
    v10 ^= *(char *)v11;
    v4 = v10;
    v11 += (int64_t)&g1;
    while (v11 != v9) {
        // 0x12e76
        v10 ^= *(char *)v11;
        v4 = v10;
        v11 += (int64_t)&g1;
    }
    char * v12 = (char *)(a1 + 0x1485); // 0x12e85
    int64_t * v13 = (int64_t *)(a1 + 64); // 0x12e91
    bWtBCAS_Data2(*v13, &v1, (int64_t *)&g97, *v12);
    int64_t v14; // bp-440, 0x12dc0
    int32_t v15; // bp-444, 0x12dc0
    bReadBCAS_Data2(*v13, &v14, (int64_t *)&v15, 0, 320, *v12);
    unsigned char result; // 0x12dc0
    if (v15 <= (int32_t)&g86) {
        // 0x12f42
        *(int32_t *)(a1 + 0x15c8) = 0;
        // 0x12f4d
        result = *v2 % 2 ^ 1;
        *v2 = result;
        return result;
    }
    // 0x12ee4
    *(int32_t *)(a1 + 0x15c8) = v15 - (int32_t)&g86;
    if (*v5 == 0 || v15 - (int32_t)&g1 <= (int32_t)&g33) {
        // 0x12f4d
        result = *v2 % 2 ^ 1;
        *v2 = result;
        return result;
    }
    // 0x12f06
    int64_t v16; // bp-437, 0x12dc0
    int64_t v17 = &v16; // 0x12f10
    int64_t v18 = a1; // 0x12f10
    int64_t v19 = (int64_t)&g33; // 0x12f10
    int64_t v20 = ChangeEndian2((int64_t)*(char *)v17); // 0x12f19
    *(char *)(v18 + 0x1486) = (char)v20;
    v19 = v19 + (int64_t)(int32_t)&g1 & 0xffffffff;
    v17 += (int64_t)&g1;
    v18 += (int64_t)&g1;
    while (v19 < (int64_t)(v15 - (int32_t)&g1)) {
        // 0x12f16
        v20 = ChangeEndian2((int64_t)*(char *)v17);
        *(char *)(v18 + 0x1486) = (char)v20;
        v19 = v19 + (int64_t)(int32_t)&g1 & 0xffffffff;
        v17 += (int64_t)&g1;
        v18 += (int64_t)&g1;
    }
    // 0x12f4d
    result = *v2 % 2 ^ 1;
    *v2 = result;
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x12f62 - 0x12f92
// Line range:    5979 - 6132
int32_t DTV_Set_EncSeedRegASV5606(int64_t pTuner, char * EncSeed_CE, char EncSeedLen) {
    int64_t v1 = __readgsqword(40); // 0x12f72
    int64_t result = &g1; // 0x12f7b
    int64_t v2; // 0x12f62
    if (*(int64_t *)(v2 - 40) != v1) {
        // 0x12f7d
        result = __stack_chk_fail();
    }
    // 0x12f82
    return result;
}

// Address range: 0x12f92 - 0x13092
int64_t DTV_Set_EncSeedRegASV5606_(int64_t a1, int64_t a2, int64_t * a3) {
    // 0x12f92
    mcount();
    char v1 = *(char *)(a1 + 0x1d30); // 0x12fd0
    char v2 = *(char *)(a1 + 0x148d); // 0x12fd7
    switch (v2) {
        case 15: {
            goto lab_0x12fea;
        }
        case 4: {
            goto lab_0x12fea;
        }
        default: {
            if (v1 == 0 || v2 != 17) {
                goto lab_0x1301b;
            } else {
                goto lab_0x12ff2;
            }
        }
    }
  lab_0x12fea:
    if (v1 == 0) {
        goto lab_0x1301b;
    } else {
        goto lab_0x12ff2;
    }
  lab_0x1301b:;
    char * v3 = (char *)(a1 + 0x8fa49); // 0x1301b
    if (*v3 != 0) {
        TLIB_Delay2((int64_t *)&g1);
        while (*v3 != 0) {
            // 0x13024
            TLIB_Delay2((int64_t *)&g1);
        }
    }
    uint64_t v4 = (int64_t)a3;
    *v3 = (char)&g1;
    unsigned char v5 = *(char *)(a1 + 0x8fcac); // 0x13066
    int64_t * v6 = (char)v4 == 0 ? (int64_t *)(v4 % 256) : (int64_t *)(char)&g1; // 0x1307a
    DTV_WriteI2CEncData2(a1, (int64_t)v5, (int64_t)(char)&g2, v6, (char *)a2);
    *v3 = 0;
    return 0xfffffffe;
  lab_0x12ff2:;
    int64_t v7 = 0; // 0x12ff2
    while (v7 != 64 - (int64_t)&g95) {
        // 0x12ff7
        v7 += (int64_t)&g95;
    }
    goto lab_0x1301b;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x13092 - 0x130c2
// Line range:    6591 - 6764
int32_t DTV_GenEncSeed(int64_t pTnim, char * APEncSeed, char APEncSeedLen, char * PCKey, char PCKeyLen) {
    // 0x13092
    int64_t result; // 0x13092
    return result;
}

// Address range: 0x130c2 - 0x13711
int64_t DTV_GenEncSeed2(int64_t a1, int64_t a2, char a3, int64_t a4, char a5) {
    // 0x130c2
    mcount();
    __readgsqword(40);
    char v1 = (char)&g24; // bp-120, 0x13105
    char v2 = -59; // bp-119, 0x13109
    if (a3 == (char)&g2 != (a5 == (char)&g2)) {
        // 0x136db
        __readgsqword(40);
        return 0xfffffffe;
    }
    // 0x1315a
    TLIB_Delay2((int64_t *)&g98);
    char v3 = -83; // bp-136, 0x13164
    char v4 = -3; // bp-152, 0x131a4
    int64_t v5; // 0x130c2
    int64_t v6; // 0x130c2
    if (*(char *)(a1 + 0x15d8) == 1) {
        int64_t v7 = a1 + (int64_t)&g45; // 0x132bd
        v6 = v7;
        bool v8; // 0x130c2
        int64_t v9 = v8 ? -1 : (int64_t)&g1;
        int64_t v10 = v7; // 0x132cd
        int64_t v11 = &v3; // 0x130c2
        int64_t v12 = &g2; // 0x132cd
        unsigned char v13 = *(char *)v10; // 0x132cd
        char v14 = *(char *)v11; // 0x132cd
        v10 += v9;
        v6 = v10;
        char v15 = v14; // 0x132cd
        bool v16 = false; // 0x132cd
        while (v13 == v14) {
            v12 -= (int64_t)&g1;
            v11 += v9;
            v15 = v13;
            v16 = true;
            if (v12 == 0) {
                // break ->
                break;
            }
            v13 = *(char *)v10;
            v14 = *(char *)v11;
            v10 += v9;
            v6 = v10;
            v15 = v14;
            v16 = false;
        }
        unsigned char v17 = v15;
        if ((v13 < v17 || v16) != (bool)&g1 != v13 < v17) {
            // 0x136db
            __readgsqword(40);
            return &g1;
        }
        int64_t v18 = a1 + (int64_t)&g46; // 0x132dd
        v6 = v18;
        int64_t v19 = &v4; // 0x132e4
        int64_t v20 = v18; // 0x132f0
        int64_t v21 = v19; // 0x130c2
        int64_t v22 = &g2; // 0x132f0
        unsigned char v23 = *(char *)v20; // 0x132f0
        char v24 = *(char *)v21; // 0x132f0
        v20 += v9;
        v6 = v20;
        char v25 = v24; // 0x132f0
        bool v26 = false; // 0x132f0
        while (v23 == v24) {
            v22 -= (int64_t)&g1;
            v21 += v9;
            v25 = v23;
            v26 = true;
            if (v22 == 0) {
                // break ->
                break;
            }
            v23 = *(char *)v20;
            v24 = *(char *)v21;
            v20 += v9;
            v6 = v20;
            v25 = v24;
            v26 = false;
        }
        unsigned char v27 = v25;
        if ((v23 < v27 || v26) != (bool)&g1 != v23 < v27) {
            // 0x136db
            __readgsqword(40);
            return &g1;
        }
        int64_t v28 = a1 + (int64_t)&g47; // 0x13300
        v6 = v28;
        int64_t v29 = v19; // 0x130c2
        int64_t v30 = &g2; // 0x13313
        unsigned char v31 = *(char *)v28; // 0x13313
        char v32 = *(char *)v29; // 0x13313
        int64_t v33 = v28 + v9; // 0x13313
        v6 = v33;
        char v34 = v32; // 0x13313
        bool v35 = false; // 0x13313
        while (v31 == v32) {
            v30 -= (int64_t)&g1;
            v29 += v9;
            v34 = v31;
            v35 = true;
            if (v30 == 0) {
                // break ->
                break;
            }
            v31 = *(char *)v33;
            v32 = *(char *)v29;
            v33 += v9;
            v6 = v33;
            v34 = v32;
            v35 = false;
        }
        unsigned char v36 = v34;
        v5 = v33;
        if ((v31 < v36 || v35) != (bool)&g1 != v31 < v36) {
            // 0x136db
            __readgsqword(40);
            return &g1;
        }
    }
    char v37 = v5;
    int64_t v38; // bp-104, 0x130c2
    int64_t v39 = &v38; // 0x13251
    char v40; // bp-88, 0x130c2
    int64_t v41 = &v40; // 0x1325c
    int64_t v42; // bp-87, 0x130c2
    int64_t v43 = &v42; // 0x13276
    int64_t v44; // bp-72, 0x130c2
    int64_t v45 = &v44; // 0x13285
    int64_t v46 = &v2; // 0x13294
    char * v47 = (char *)(a1 + 0x15ec);
    int64_t v48 = &v1;
    int64_t v49 = 0x100000000 * (a2 + (int64_t)(int32_t)&g1) / 0x100000000;
    char v50 = v45;
    int64_t v51 = a1; // 0x132bb
    int64_t v52 = 0;
    int64_t v53 = 0;
    char v54 = *(char *)(v51 + (int64_t)&g40); // 0x1332f
    char v55 = v37; // 0x13337
    char v56 = v37; // 0x13337
    int64_t v57; // 0x130c2
    int64_t v58; // 0x130c2
    int64_t v59; // 0x130c2
    int64_t v60; // 0x130c2
    int64_t v61; // 0x130c2
    char * v62; // 0x133c8
    int64_t v63; // 0x133ca
    char v64; // 0x130c2
    int64_t v65; // 0x1337d
    char v66; // 0x1337d
    int64_t v67; // 0x1338b
    int64_t v68; // 0x13417
    if (v54 == (char)&g1) {
        // 0x1333d
        if (*v47 != 0) {
            // 0x133a4
            v38 = *(int64_t *)v53;
            v6 = v41;
            v63 = v39;
            v60 = v48;
            v62 = (char *)v63;
            *v62 = *v62 ^ *(char *)v60;
            v63 += (int64_t)&g1;
            v60 += (int64_t)&g1;
            while (v63 != v6) {
                // 0x133c5
                v62 = (char *)v63;
                *v62 = *v62 ^ *(char *)v60;
                v63 += (int64_t)&g1;
                v60 += (int64_t)&g1;
            }
            // 0x133d7
            v64 = v6;
            Gen_Identify_Key2(v41, v39);
            v55 = v64;
            v56 = v64;
            if (v40 == v64) {
                // 0x133f7
                v6 = v45;
                v61 = v49;
                v58 = v43;
                v55 = v50;
                v56 = v50;
                while (*(char *)v61 == *(char *)v58) {
                    // 0x13413
                    v68 = v58 + (int64_t)&g1;
                    if (v68 == v45) {
                        // 0x13427
                        *(char *)(a1 + (int64_t)&g42) = 0;
                        *(char *)(a1 + (int64_t)&g43) = (char)v52;
                        // 0x136ec
                        *(int32_t *)(a1 + (int64_t)&g21) = (int32_t)&g1;
                        return 0;
                    }
                    v61 += (int64_t)&g1;
                    v58 = v68;
                    v55 = v50;
                    v56 = v50;
                }
            }
        } else {
            // 0x1334d
            v55 = v37;
            v56 = v37;
            if (v37 == (*(char *)v53 ^ v1)) {
                // 0x1335f
                v65 = a2;
                v59 = 0x100000000 * v52 / 0x100000000 << (int64_t)&g86;
                v57 = v46;
                v65 += (int64_t)&g1;
                v66 = *(char *)v65;
                v55 = v37;
                v56 = v37;
                while (v66 == (*(char *)v59 ^ *(char *)v57)) {
                    // 0x13387
                    v67 = v57 + (int64_t)&g1;
                    if (v67 == v39) {
                        // 0x13427
                        *(char *)(a1 + (int64_t)&g42) = 0;
                        *(char *)(a1 + (int64_t)&g43) = (char)v52;
                        // 0x136ec
                        *(int32_t *)(a1 + (int64_t)&g21) = (int32_t)&g1;
                        return 0;
                    }
                    v59 += (int64_t)&g1;
                    v57 = v67;
                    v65 += (int64_t)&g1;
                    v66 = *(char *)v65;
                    v55 = v37;
                    v56 = v37;
                }
            }
        }
    }
    char v69 = v55;
    int64_t v70 = v52 + (int64_t)(int32_t)&g1; // 0x13440
    int64_t v71 = v53 + (int64_t)&g2; // 0x13450
    v51 += (int64_t)&g1;
    while ((int32_t)v70 != 64) {
        // 0x13328
        v52 = v70 & 0xffffffff;
        v53 = v71;
        char v72 = v56; // 0x13356
        char v73 = v69;
        v54 = *(char *)(v51 + (int64_t)&g40);
        v55 = v73;
        v56 = v72;
        if (v54 == (char)&g1) {
            // 0x1333d
            if (*v47 != 0) {
                // 0x133a4
                v38 = *(int64_t *)v53;
                v6 = v41;
                v63 = v39;
                v60 = v48;
                v62 = (char *)v63;
                *v62 = *v62 ^ *(char *)v60;
                v63 += (int64_t)&g1;
                v60 += (int64_t)&g1;
                while (v63 != v6) {
                    // 0x133c5
                    v62 = (char *)v63;
                    *v62 = *v62 ^ *(char *)v60;
                    v63 += (int64_t)&g1;
                    v60 += (int64_t)&g1;
                }
                // 0x133d7
                v64 = v6;
                Gen_Identify_Key2(v41, v39);
                v55 = v64;
                v56 = v64;
                if (v40 == v64) {
                    // 0x133f7
                    v6 = v45;
                    v61 = v49;
                    v58 = v43;
                    v55 = v50;
                    v56 = v50;
                    while (*(char *)v61 == *(char *)v58) {
                        // 0x13413
                        v68 = v58 + (int64_t)&g1;
                        if (v68 == v45) {
                            // 0x13427
                            *(char *)(a1 + (int64_t)&g42) = 0;
                            *(char *)(a1 + (int64_t)&g43) = (char)v52;
                            // 0x136ec
                            *(int32_t *)(a1 + (int64_t)&g21) = (int32_t)&g1;
                            return 0;
                        }
                        v61 += (int64_t)&g1;
                        v58 = v68;
                        v55 = v50;
                        v56 = v50;
                    }
                }
            } else {
                // 0x1334d
                v55 = v73;
                v56 = v72;
                if (v72 == (*(char *)v53 ^ v1)) {
                    // 0x1335f
                    v65 = a2;
                    v59 = 0x100000000 * v52 / 0x100000000 << (int64_t)&g86;
                    v57 = v46;
                    v65 += (int64_t)&g1;
                    v66 = *(char *)v65;
                    v55 = v73;
                    v56 = v72;
                    while (v66 == (*(char *)v59 ^ *(char *)v57)) {
                        // 0x13387
                        v67 = v57 + (int64_t)&g1;
                        if (v67 == v39) {
                            // 0x13427
                            *(char *)(a1 + (int64_t)&g42) = 0;
                            *(char *)(a1 + (int64_t)&g43) = (char)v52;
                            // 0x136ec
                            *(int32_t *)(a1 + (int64_t)&g21) = (int32_t)&g1;
                            return 0;
                        }
                        v59 += (int64_t)&g1;
                        v57 = v67;
                        v65 += (int64_t)&g1;
                        v66 = *(char *)v65;
                        v55 = v73;
                        v56 = v72;
                    }
                }
            }
        }
        // 0x13440
        v69 = v55;
        v70 = v52 + (int64_t)(int32_t)&g1;
        v71 = v53 + (int64_t)&g2;
        v51 += (int64_t)&g1;
    }
    int64_t v74 = a1; // 0x134d9
    int64_t v75 = 0;
    int64_t v76 = v70 & 0xffffff00;
    char v77 = *(char *)(v74 + (int64_t)&g40); // 0x134e3
    char v78 = v69; // 0x134eb
    int64_t v79; // 0x130c2
    int64_t v80; // 0x130c2
    int64_t v81; // 0x130c2
    int64_t v82; // 0x130c2
    int64_t v83; // 0x130c2
    char * v84; // 0x13580
    int64_t v85; // 0x13582
    char v86; // 0x135ad
    int64_t v87; // 0x13535
    char v88; // 0x13535
    int64_t v89; // 0x13543
    int64_t v90; // 0x135d5
    if (v77 == (char)&g1) {
        // 0x134f1
        if (*v47 != 0) {
            // 0x13563
            v38 = *(int64_t *)v75;
            v85 = v39;
            v82 = v48;
            v84 = (char *)v85;
            *v84 = *v84 ^ *(char *)v82;
            v85 += (int64_t)&g1;
            v82 += (int64_t)&g1;
            while (v85 != v41) {
                // 0x1357d
                v84 = (char *)v85;
                *v84 = *v84 ^ *(char *)v82;
                v85 += (int64_t)&g1;
                v82 += (int64_t)&g1;
            }
            // 0x1358f
            Gen_Identify_Key2(v41, v39);
            v86 = *(char *)&v6;
            v78 = v86;
            if (v86 == v40) {
                // 0x135b5
                v6 = v45;
                v83 = v49;
                v80 = v43;
                v78 = v50;
                while (*(char *)v83 == *(char *)v80) {
                    // 0x135d1
                    v90 = v80 + (int64_t)&g1;
                    if (v90 == v45) {
                        goto lab_0x135ec_2;
                    }
                    v83 += (int64_t)&g1;
                    v80 = v90;
                    v78 = v50;
                }
            }
        } else {
            // 0x13501
            v78 = v69;
            if (v69 == (*(char *)v75 ^ v1)) {
                // 0x1351a
                v87 = a2;
                v81 = 0x100000000 * v76 / 0x100000000 << (int64_t)&g86;
                v79 = v46;
                v87 += (int64_t)&g1;
                v88 = *(char *)v87;
                v78 = v69;
                while (v88 == (*(char *)v81 ^ *(char *)v79)) {
                    // 0x1353f
                    v89 = v79 + (int64_t)&g1;
                    if (v89 == v39) {
                        goto lab_0x135ec_2;
                    }
                    v81 += (int64_t)&g1;
                    v79 = v89;
                    v87 += (int64_t)&g1;
                    v88 = *(char *)v87;
                    v78 = v69;
                }
            }
        }
    }
    int64_t v91 = v76 + (int64_t)(int32_t)&g1; // 0x13614
    v74 += (int64_t)&g1;
    int64_t v92 = v75 + (int64_t)&g2; // 0x13624
    while ((int32_t)v91 != 64) {
        // 0x134dc
        v75 = v92;
        v76 = v91 & 0xffffffff;
        char v93 = v78; // 0x13512
        v77 = *(char *)(v74 + (int64_t)&g40);
        v78 = v93;
        if (v77 == (char)&g1) {
            // 0x134f1
            if (*v47 != 0) {
                // 0x13563
                v38 = *(int64_t *)v75;
                v85 = v39;
                v82 = v48;
                v84 = (char *)v85;
                *v84 = *v84 ^ *(char *)v82;
                v85 += (int64_t)&g1;
                v82 += (int64_t)&g1;
                while (v85 != v41) {
                    // 0x1357d
                    v84 = (char *)v85;
                    *v84 = *v84 ^ *(char *)v82;
                    v85 += (int64_t)&g1;
                    v82 += (int64_t)&g1;
                }
                // 0x1358f
                Gen_Identify_Key2(v41, v39);
                v86 = *(char *)&v6;
                v78 = v86;
                if (v86 == v40) {
                    // 0x135b5
                    v6 = v45;
                    v83 = v49;
                    v80 = v43;
                    v78 = v50;
                    while (*(char *)v83 == *(char *)v80) {
                        // 0x135d1
                        v90 = v80 + (int64_t)&g1;
                        if (v90 == v45) {
                            goto lab_0x135ec_2;
                        }
                        v83 += (int64_t)&g1;
                        v80 = v90;
                        v78 = v50;
                    }
                }
            } else {
                // 0x13501
                v78 = v93;
                if (v93 == (*(char *)v75 ^ v1)) {
                    // 0x1351a
                    v87 = a2;
                    v81 = 0x100000000 * v76 / 0x100000000 << (int64_t)&g86;
                    v79 = v46;
                    v87 += (int64_t)&g1;
                    v88 = *(char *)v87;
                    v78 = v93;
                    while (v88 == (*(char *)v81 ^ *(char *)v79)) {
                        // 0x1353f
                        v89 = v79 + (int64_t)&g1;
                        if (v89 == v39) {
                            goto lab_0x135ec_2;
                        }
                        v81 += (int64_t)&g1;
                        v79 = v89;
                        v87 += (int64_t)&g1;
                        v88 = *(char *)v87;
                        v78 = v93;
                    }
                }
            }
        }
        // 0x13614
        v91 = v76 + (int64_t)(int32_t)&g1;
        v74 += (int64_t)&g1;
        v92 = v75 + (int64_t)&g2;
    }
    // 0x136db
    __readgsqword(40);
    return 0xfffffffd;
  lab_0x135ec_2:
    // 0x135ec
    *(char *)(a1 + (int64_t)&g42) = (char)&g1;
    char v94 = v76; // 0x135f3
    char v95 = v94 != 62 ? v94 : (char)&g1; // 0x13609
    *(char *)(a1 + (int64_t)&g44) = v95;
    // 0x136ec
    *(int32_t *)(a1 + (int64_t)&g21) = (int32_t)&g1;
    return 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x13712 - 0x13742
// Line range:    3389 - 4452
void DTV_PollingThread(char * Context) {
    // 0x13712
    bool v1; // 0x13712
    int64_t v2 = v1 ? -8 : (int64_t)&g95; // 0x13712
    *(int16_t *)(v2 + (int64_t)Context) = 0;
}

// Address range: 0x13742 - 0x14a69
int64_t DTV_PollingThread2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x13742
    mcount();
    __readgsqword(40);
    Tnim_PollingThreadDelayTime2();
    int64_t v1 = a1 + 0x5960; // 0x137a1
    int128_t v2; // bp-448, 0x13742
    int64_t v3 = &v2;
    int128_t v4; // bp-456, 0x13742
    int64_t v5 = &v4;
    int64_t v6; // bp-392, 0x13742
    int64_t str = &v6;
    char * v7 = (char *)(a1 + 0x5510);
    char v8; // bp-424, 0x13742
    int64_t v9 = &v8;
    char * v10 = (char *)(a1 + 0x53d8);
    int32_t v11; // bp-408, 0x13742
    int64_t v12 = &v11;
    int32_t v13 = 0; // 0x137e9
    int64_t v14 = -0x5c28f5c28f5c28f5; // 0x137e9
    int64_t v15 = 0; // 0x137e9
    int64_t v16 = 0; // 0x137e9
    int64_t v17; // 0x13742
    int64_t v18; // 0x13742
    int64_t v19; // 0x13742
    int64_t v20; // 0x13742
    int64_t v21; // 0x13742
    int64_t v22; // 0x13742
    int64_t v23; // 0x13742
    int64_t v24; // 0x13742
    int64_t v25; // 0x13742
    int64_t v26; // 0x13742
    int64_t v27; // 0x13742
    int64_t v28; // 0x13742
    int64_t v29; // 0x13742
    int64_t v30; // 0x13742
    int64_t v31; // 0x13742
    int64_t v32; // 0x13742
    int64_t v33; // 0x13742
    int64_t v34; // 0x13742
    int64_t v35; // 0x13742
    int64_t v36; // 0x13742
    int64_t v37; // 0x13742
    int64_t v38; // 0x13742
    int64_t v39; // 0x13742
    int64_t v40; // 0x13742
    int64_t v41; // 0x13742
    int64_t v42; // 0x13742
    int64_t v43; // 0x13742
    int64_t v44; // 0x13742
    int64_t v45; // 0x13742
    int64_t v46; // 0x13742
    int64_t v47; // 0x13742
    int64_t v48; // 0x13742
    int64_t v49; // 0x13742
    int64_t v50; // 0x13742
    int64_t v51; // 0x13742
    int64_t v52; // 0x13742
    int64_t v53; // 0x13742
    int64_t v54; // 0x13742
    char * v55; // 0x13742
    char * v56; // 0x13742
    char * v57; // 0x13742
    char * v58; // 0x13742
    int32_t v59; // 0x13742
    int64_t v60; // 0x138e3
    int64_t * v61; // 0x1393a
    int64_t v62; // 0x14345
    char v63; // 0x144c0
    char * v64; // 0x144dd
    int64_t v65; // 0x13c4c
    int64_t v66; // 0x13c6a
    while (true) {
      lab_0x137ef:;
        int64_t v67 = v16;
        int64_t v68 = v36;
        int64_t v69 = v28;
        int64_t v70 = v14;
        v56 = v55;
        v59 = v13;
        int64_t v71 = v70; // 0x137f6
        int64_t v72 = v69; // 0x137f6
        int64_t v73 = v68; // 0x137f6
        int64_t v74 = v15; // 0x137f6
        int64_t v75 = v67; // 0x137f6
        // 0x137fc
        v71 = v70;
        v72 = v69;
        v73 = v68;
        v74 = 0;
        v75 = v67;
        if (*(char *)(a1 + 0x5798) == 0) {
            // 0x1380b
            TC_SetLNB2(a1, 0);
            int64_t v76 = 0;
            int64_t v77 = v76 + a1;
            *(int64_t *)(v77 + 0x5968) = (int64_t)&g1;
            *(int64_t *)(v77 + 0x5970) = 0;
            *(int64_t *)(v77 + 0x5978) = (int64_t)&g12;
            int64_t v78 = v76 + 80; // 0x13857
            while (v76 != 560) {
                // 0x13829
                v76 = v78;
                v77 = v76 + a1;
                *(int64_t *)(v77 + 0x5968) = (int64_t)&g1;
                *(int64_t *)(v77 + 0x5970) = 0;
                *(int64_t *)(v77 + 0x5978) = (int64_t)&g12;
                v78 = v76 + 80;
            }
            uint64_t v79 = *(int64_t *)(a1 + 1312); // 0x13863
            if ((v79 < 0xff00000001000000 ? v79 : v79 + 0xffffffff000000) == 0) {
                // 0x1386d
                Tnim_PollingThreadOnlyCallOnce2(a1, a1 + 0x53da, (int64_t *)&g95, v1);
            }
            // 0x13888
            if (*(char *)(a1 + 0x53dc) == 0) {
                // 0x13893
                *(int64_t *)(a1 + 0x5a18) = 255;
            }
            // 0x1389f
            if (*(char *)(a1 + 0x53dd) == 0) {
                // 0x138aa
                *(int64_t *)(a1 + 0x5a68) = 255;
            }
            // 0x138b6
            v50 = v1;
            v44 = a1;
            v29 = v69;
            v37 = v68;
            v18 = a1;
            v20 = v1;
            while (true) {
              lab_0x138e0:
                // 0x138e0
                v21 = v20;
                v19 = v18;
                int64_t v80 = v37;
                int64_t v81 = v29;
                v45 = v44;
                int64_t v82 = v50;
                v52 = v82;
                v31 = v81;
                v39 = v80;
                if (*(char *)(v45 + 0x53da) != 1) {
                    goto lab_0x13c24;
                } else {
                    // 0x138f7
                    v60 = v45 - a1 & 0xffffffff;
                    int64_t * v83 = (int64_t *)(v19 + 0x53f0); // 0x138f7
                    if (*v83 == 1) {
                        // 0x13901
                        FUSB_RstBulkPipe2(a1, v60);
                        *v83 = 0;
                    }
                    // 0x13917
                    TC_ReadSNR2(a1, v60, v21);
                    TC_GetSignaLevel2(a1, v60, v21);
                    v61 = (int64_t *)(v19 + (int64_t)&g87);
                    int64_t v84 = *(int64_t *)(*v61 + 0x929a8);
                    v17 = v84;
                    v51 = v82;
                    v30 = v81;
                    v38 = v80;
                    if (v84 < 0xf4240) {
                        // 0x13958
                        v52 = v82;
                        v31 = v81;
                        v39 = v80;
                        if (*(char *)(v45 + 888) != 1) {
                            goto lab_0x13c24;
                        } else {
                            int64_t v85 = 0x100000000 * v21 / 0x100000000; // 0x13965
                            TC_GetBER2(a1, v60, v5, v3, v85);
                            int64_t v86 = TC_GetCN2(a1, v60, v85); // 0x13992
                            int64_t v87 = 0xabcc77118461cefd * (v4 & 0xffffffffffffffff) / 0x8000000000000000; // 0x139b8
                            sprintf(str, 0, *(int64_t *)(*v61 + 0x929a8), 0, v86, v87);
                            v17 = *(int64_t *)(*v61 + 0x929a8);
                            v51 = 0;
                            v30 = v86;
                            v38 = v87;
                            goto lab_0x13a42;
                        }
                    } else {
                        goto lab_0x13a42;
                    }
                }
            }
          lab_0x13c3d:
            // 0x13c3d
            v71 = v53;
            v72 = v32;
            v73 = v40;
            v74 = 0;
            v75 = 0x100000000 * v67 / 0x100000000;
        }
        // 0x13c4c
        v26 = v75;
        v22 = v74;
        int64_t v88 = v73;
        int64_t v89 = v72;
        int64_t v90 = v71;
        v65 = *(int64_t *)(a1 + (int64_t)&g87);
        v13 = v59;
        v58 = v56;
        v14 = v90;
        v35 = v89;
        v43 = v88;
        v25 = v22;
        v27 = v26;
        if (v65 == 0) {
            goto lab_0x149d4;
        } else {
            // 0x13c5d
            v13 = v59;
            v58 = v56;
            v14 = v90;
            v35 = v89;
            v43 = v88;
            v25 = v22;
            v27 = v26;
            if (*(char *)(v65 + 0x15d8) != 1) {
                goto lab_0x149d4;
            } else {
                char * v91 = (char *)(v65 + 0x148d); // 0x13c6a
                unsigned char v92 = *v91; // 0x13c6a
                v66 = v92;
                v13 = v59;
                v58 = v56;
                v14 = v90;
                v35 = v89;
                v43 = v66;
                v25 = v22;
                v27 = v26;
                if (*v7 == 1) {
                    goto lab_0x149d4;
                } else {
                    int64_t v93 = v92 == 0 ? 64 : 320; // 0x13c7d
                    char * v94 = (char *)(v65 + 0x1340); // 0x13c93
                    char v95 = *v94; // 0x13c93
                    if (v95 != 0) {
                        if (v95 != 2) {
                            if (v95 != 4) {
                                // 0x142a8
                                v57 = v56;
                                v49 = v90;
                                v47 = v65;
                                v34 = v89;
                                v42 = v66;
                                v24 = v22;
                                if (v95 != 3) {
                                    goto lab_0x14962;
                                } else {
                                    int64_t v96 = v65 + 1072; // 0x142b0
                                    int64_t v97 = v65 + 1076; // 0x142b7
                                    bReadBCAS_Data2(a1, (int64_t *)v97, (int64_t *)v96, 0, v93, v92);
                                    int32_t * v98 = (int32_t *)v96; // 0x142de
                                    uint32_t v99 = *v98; // 0x142de
                                    uint64_t v100 = (int64_t)v99; // 0x142de
                                    char v101 = *(char *)v97; // 0x142ec
                                    int64_t v102 = 0; // 0x142fe
                                    int64_t v103 = v65; // 0x142fe
                                    int64_t v104 = 0; // 0x142fe
                                    int64_t v105; // 0x13742
                                    int64_t result; // 0x13742
                                    if (v101 == 0) {
                                        int64_t v106 = v102;
                                        int64_t v107 = v106 + (int64_t)(int32_t)&g1 & 0xffffffff; // 0x14318
                                        v105 = v107;
                                        // 0x1431f
                                        result = v105;
                                        while (v107 < v100) {
                                            int64_t v108 = v103;
                                            unsigned char v109 = *(char *)(v108 + 1077); // 0x14305
                                            v102 = v107;
                                            v103 = v108 + (int64_t)&g1;
                                            if (v109 != 0) {
                                                // break -> 0x14a45
                                                break;
                                            }
                                            v106 = v102;
                                            v107 = v106 + (int64_t)(int32_t)&g1 & 0xffffffff;
                                            v105 = v107;
                                            // 0x1431f
                                            result = v105;
                                        }
                                        return result;
                                    }
                                    int64_t v110 = v104;
                                    *(char *)(v97 + (int64_t)v99) = v101;
                                    int32_t v111 = v99 - 1; // 0x14a50
                                    v105 = v65;
                                    if (v111 > (int32_t)&g1) {
                                        // 0x1431f
                                        result = v105;
                                        return result;
                                    }
                                    char v112 = *(char *)(v65 + 0x1488); // 0x1435e
                                    int64_t v113 = v65; // 0x14365
                                    int64_t v114 = v22; // 0x14365
                                    if (v112 != 0) {
                                        uint32_t v115 = *v98; // 0x14367
                                        v113 = v65;
                                        v114 = v22;
                                        if (v115 >= 1) {
                                            uint64_t v116 = (int64_t)v115; // 0x14367
                                            int64_t v117 = v65; // 0x1438b
                                            int64_t v118 = v117;
                                            char * v119 = (char *)(v118 + 1076); // 0x1438e
                                            unsigned char v120 = *v119; // 0x1438e
                                            int64_t v121 = ChangeEndian2((int64_t)v120); // 0x14396
                                            *v119 = (char)v121;
                                            int64_t v122 = v118 + (int64_t)&g1; // 0x143a2
                                            v117 = v122;
                                            while ((v122 - v65 & 0xffffffff) < v116) {
                                                // 0x1438e
                                                v118 = v117;
                                                v119 = (char *)(v118 + 1076);
                                                v120 = *v119;
                                                v121 = ChangeEndian2((int64_t)v120);
                                                *v119 = (char)v121;
                                                v122 = v118 + (int64_t)&g1;
                                                v117 = v122;
                                            }
                                            // 0x143b0
                                            v113 = 0x100000000 * v65 / 0x100000000;
                                            v114 = 0x100000000 * v22 / 0x100000000;
                                        }
                                    }
                                    // 0x143c1
                                    v62 = v111;
                                    v23 = v114;
                                    v46 = v113;
                                    char * v123 = (char *)(v46 + 1077); // 0x143c1
                                    char v124 = *v123; // 0x143c1
                                    if ((v124 & 32) == 0) {
                                        char * v125 = (char *)(v46 + 0x148a); // 0x144b2
                                        char v126 = *v125; // 0x144b2
                                        *v125 = (char)(v126 == 0);
                                        v63 = *v123;
                                        v64 = (char *)(v46 + 0x148c);
                                        char v127 = *v64; // 0x144dd
                                        if (v127 != 0) {
                                            int32_t * v128 = (int32_t *)(v46 + 3964);
                                            int32_t * v129; // 0x13742
                                            int32_t v130; // 0x13742
                                            if ((v63 & -126) == -126) {
                                                int32_t v131 = *v128;
                                                v130 = v131;
                                                v129 = (int32_t *)(v46 + 1072);
                                            } else {
                                                int32_t v132 = *v128; // 0x144ea
                                                int32_t * v133 = (int32_t *)(v46 + 1072);
                                                int32_t v134 = *v133; // 0x144f9
                                                memcpy(v46 + 3967 + (int64_t)v132, v46 + 1079, (int64_t)(v134 - 3), v110);
                                                int32_t v135 = *v128; // 0x14511
                                                int32_t v136 = *v133; // 0x14517
                                                int32_t v137 = v135 - 4 + v136; // 0x1451d
                                                *v128 = v137;
                                                v130 = v137;
                                                v129 = v133;
                                            }
                                            int32_t * v138 = v129;
                                            int32_t v139 = v130; // 0x14526
                                            *v138 = v139;
                                            memcpy(v46 + 1076, v46 + 3968, (int64_t)v139, v110);
                                        }
                                        // 0x14548
                                        int64_t v140; // 0x137da
                                        int64_t v141 = v140; // 0x14556
                                        int64_t v142 = a1; // 0x14556
                                        int64_t v143 = v142;
                                        int64_t v144 = v141;
                                        char * v145 = (char *)v144; // 0x1455a
                                        *v145 = 0;
                                        int64_t v146 = *(int64_t *)(v143 + 1256); // 0x1455d
                                        int64_t v147 = 0; // 0x14567
                                        unsigned char v148; // 0x14569
                                        if (v146 != 0) {
                                            // 0x14569
                                            v148 = *(char *)(v146 + 0x8fabc);
                                            *v145 = v148;
                                            v147 = v148;
                                        }
                                        int64_t v149 = v144 + (int64_t)&g1; // 0x14572
                                        v141 = v149;
                                        v142 = v143 + (int64_t)&g95;
                                        int64_t v150; // 0x13742
                                        while (v149 != v150) {
                                            // 0x1455a
                                            v143 = v142;
                                            v144 = v141;
                                            v145 = (char *)v144;
                                            *v145 = 0;
                                            v146 = *(int64_t *)(v143 + 1256);
                                            v147 = 0;
                                            if (v146 != 0) {
                                                // 0x14569
                                                v148 = *(char *)(v146 + 0x8fabc);
                                                *v145 = v148;
                                                v147 = v148;
                                            }
                                            // 0x14572
                                            v149 = v144 + (int64_t)&g1;
                                            v141 = v149;
                                            v142 = v143 + (int64_t)&g95;
                                        }
                                        // 0x1457f
                                        v54 = v147;
                                        char v151; // bp-71, 0x13742
                                        char v152 = v151; // 0x1457f
                                        int64_t v153; // 0x13742
                                        int64_t v154 = v153; // 0x14583
                                        if (v152 != (char)&g1) {
                                            int64_t v155 = v154;
                                            char v156 = *(char *)v155; // 0x1458d
                                            while (v156 != (char)&g1) {
                                                int64_t v157 = v155 + (int64_t)&g1; // 0x14592
                                                v154 = v157;
                                                if (v157 == v150) {
                                                    char v158 = *(char *)(v46 + 0x8fabc); // 0x1459b
                                                    if (v158 == 1) {
                                                        goto lab_0x145ba;
                                                    } else {
                                                        // 0x145a4
                                                        v48 = v54;
                                                        v33 = v62;
                                                        v41 = v66;
                                                        if ((char)v59 != (char)&g1) {
                                                            goto lab_0x1474e;
                                                        } else {
                                                            goto lab_0x145ba;
                                                        }
                                                    }
                                                }
                                                v155 = v154;
                                                v156 = *(char *)v155;
                                            }
                                        }
                                        goto lab_0x145ba;
                                    } else {
                                        // 0x143ce
                                        *(char *)(v46 + 0x1340) = (char)&g86;
                                        char * v159 = (char *)(v46 + 0x148c); // 0x143d5
                                        char v160 = *v159; // 0x143d5
                                        if (v160 != 0) {
                                            // 0x1446a
                                            *(char *)(v46 + (int64_t)&g8) = 0;
                                            int32_t * v161 = (int32_t *)(v46 + 3964); // 0x14471
                                            int32_t v162 = *v161; // 0x14471
                                            int32_t * v163 = (int32_t *)(v46 + 1072); // 0x14480
                                            int32_t v164 = *v163; // 0x14480
                                            memcpy(v46 + 3967 + (int64_t)v162, v46 + 1079, (int64_t)(v164 - 3), v110);
                                            int32_t v165 = *v161; // 0x14498
                                            int32_t v166 = *v163; // 0x1449e
                                            *v161 = v165 - 4 + v166;
                                            v57 = v56;
                                            v49 = v110;
                                            v47 = v46;
                                            v34 = v62;
                                            v42 = v66;
                                            v24 = v23;
                                        } else {
                                            // 0x143e2
                                            *v159 = (char)&g1;
                                            *(char *)(v46 + (int64_t)&g8) = 0;
                                            int32_t * v167 = (int32_t *)(v46 + 1072); // 0x143f0
                                            int32_t v168 = *v167; // 0x143f0
                                            *(int32_t *)(v46 + 3964) = v168;
                                            int64_t v169 = v46 + 3968; // 0x143fc
                                            int64_t v170 = 960; // 0x14414
                                            int64_t v171 = v169; // 0x14414
                                            if (v169 % 2 != 0) {
                                                // 0x14416
                                                *(char *)v169 = 0;
                                                v170 = 959;
                                                int64_t v172; // 0x13742
                                                v171 = v169 + v172;
                                            }
                                            int64_t v173 = v171;
                                            int64_t v174 = v170;
                                            int64_t v175 = v174; // 0x14421
                                            int64_t v176 = v173; // 0x14421
                                            if ((v173 & 2) != 0) {
                                                // 0x14423
                                                *(int16_t *)v173 = 0;
                                                v175 = (v174 + 1022) % 1024;
                                                int64_t v177; // 0x13742
                                                v176 = v173 + v177;
                                            }
                                            int64_t v178 = v176;
                                            int64_t v179 = v175;
                                            int64_t v180 = v179; // 0x1442c
                                            int64_t v181 = v178; // 0x1442c
                                            if ((v178 & 4) != 0) {
                                                // 0x1442e
                                                *(int32_t *)v178 = 0;
                                                v180 = v179 + 0xfffffffc & 0xffffffff;
                                                int64_t v182; // 0x13742
                                                v181 = v178 + v182;
                                            }
                                            int64_t v183 = v181;
                                            int64_t v184 = v180;
                                            int64_t v185 = (int32_t)v184 >> (int32_t)&g33; // 0x14437
                                            __asm_rep_stosq_memset((char *)v183, 0, v185);
                                            int64_t v186; // 0x13742
                                            int64_t v187 = v186 * v185 + v183; // 0x14439
                                            char v188 = v184; // 0x1443c
                                            int64_t v189 = v187; // 0x1443f
                                            if ((v188 & (char)&g86) != 0) {
                                                // 0x14441
                                                *(int32_t *)v187 = 0;
                                                int64_t v190; // 0x13742
                                                v189 = v187 + v190;
                                            }
                                            int64_t v191 = v189;
                                            int64_t v192 = v191; // 0x14445
                                            if ((v188 & (char)&g25) != 0) {
                                                // 0x14447
                                                *(int16_t *)v191 = 0;
                                                int64_t v193; // 0x13742
                                                v192 = v191 + v193;
                                            }
                                            if ((v188 & (char)&g1) != 0) {
                                                int64_t v194 = v192;
                                                *(char *)v194 = 0;
                                            }
                                            int32_t v195 = *v167; // 0x1444f
                                            memcpy(v169, v46 + 1076, (int64_t)v195, 0);
                                            v57 = v56;
                                            v49 = 0;
                                            v47 = v46;
                                            v34 = v169;
                                            v42 = v66;
                                            v24 = v23;
                                        }
                                        goto lab_0x14962;
                                    }
                                }
                            } else {
                                int64_t v196 = (int64_t)v56; // 0x14248
                                *v56 = 0;
                                char * v197 = (char *)(v196 + 3);
                                if (*(char *)(v65 + (int64_t)&g8) != 0) {
                                    // 0x14265
                                    *v197 = (char)&g1;
                                    *(char *)(v196 + 1) = (char)&g1;
                                } else {
                                    // 0x1425b
                                    *v197 = (char)&g97;
                                    *(char *)(v196 + 1) = (char)&g97;
                                }
                                // 0x14274
                                *(char *)(v196 + 2) = 0;
                                unsigned char v198 = *v91; // 0x1427f
                                uint32_t v199 = *(int32_t *)(v65 + 1056); // 0x14286
                                int64_t v200 = *(int64_t *)(v65 + 72); // 0x14293
                                bWtBCAS_Data2(v200, (char *)(v65 + 736), (int64_t *)(int64_t)v199, v198);
                                *v94 = (char)&g33;
                                v57 = v56;
                                v49 = v198;
                                v47 = v65;
                                v34 = v89;
                                v42 = v66;
                                v24 = v22;
                                goto lab_0x14962;
                            }
                        } else {
                            int32_t * v201 = (int32_t *)(v65 + 408); // 0x14029
                            int32_t v202 = *v201; // 0x14029
                            int64_t v203 = FUSB_ExAllocatePool2(0, (int64_t)(v202 + 1 + 2 * v202)); // 0x14060
                            int32_t v204 = *v201; // 0x1406c
                            memset(v203, 0, (int64_t)(v204 + 1 + 2 * v204));
                            int64_t v205 = v90; // 0x14091
                            int64_t v206 = v22; // 0x14091
                            if (*v201 >= 1) {
                                int64_t str2 = 0x100000000 * v203 / 0x100000000; // 0x140a3
                                int64_t v207 = 0; // 0x140a3
                                unsigned char v208 = *(char *)(v65 + 88 + 0x100000000 * v207 / 0x100000000); // 0x140ad
                                sprintf(str2, 0, str2, v208, v89, v66);
                                v207 = v207 + (int64_t)(int32_t)&g1 & 0xffffffff;
                                while (v207 < (int64_t)*v201) {
                                    // 0x140aa
                                    v208 = *(char *)(v65 + 88 + 0x100000000 * v207 / 0x100000000);
                                    sprintf(str2, 0, str2, v208, v89, v66);
                                    v207 = v207 + (int64_t)(int32_t)&g1 & 0xffffffff;
                                }
                                // 0x140d6
                                v205 = v208;
                                v206 = 0x100000000 * v22 / 0x100000000;
                            }
                            int64_t v209 = v202; // 0x1402f
                            int64_t v210 = v65 + 736;
                            char * v211 = (char *)v210;
                            int64_t v212 = v206;
                            FUSB_ExFreePool2((int32_t)v203, 0);
                            int64_t v213 = 0x100000000 * v65;
                            int64_t v214 = (v213 + 0x5800000000) / 0x100000000; // 0x140fa
                            memcpy(v65 + 0x926e0, v214, (int64_t)*v201, v205);
                            *(int32_t *)(v65 + 0x92820) = *v201;
                            *v211 = 0;
                            *(char *)(v65 + 737) = *(char *)(v65 + 0x148a) == 0 ? 0 : 64;
                            *(char *)(v65 + 738) = (char)v202;
                            memcpy(v65 + 739, v214, v209, v205);
                            int64_t v215 = v209 + 3; // 0x14158
                            char * v216 = (char *)(v215 + v210);
                            *v216 = 0;
                            char * v217 = v216; // 0x1416c
                            char * v218 = v211; // 0x1416c
                            int64_t v219 = v65; // 0x1416c
                            int64_t v220 = v212; // 0x1416c
                            if (!((v202 < -3 | *(char *)(v65 + 0x1488) == 0))) {
                                int64_t v221 = v65 + (int64_t)&g1 + (v209 + (int64_t)(int32_t)&g33 & 0xffffffff) * (int64_t)&g1; // 0x14184
                                int64_t v222 = v65; // 0x1419a
                                char * v223 = (char *)(v222 + 736); // 0x1419d
                                *v223 = (char)ChangeEndian2((int64_t)*v223);
                                v222 += (int64_t)&g1;
                                while (v222 != v221) {
                                    // 0x1419d
                                    v223 = (char *)(v222 + 736);
                                    *v223 = (char)ChangeEndian2((int64_t)*v223);
                                    v222 += (int64_t)&g1;
                                }
                                // 0x141b8
                                v219 = v213 / 0x100000000;
                                int64_t v224 = v219 + 736; // 0x141c9
                                v217 = (char *)(v215 + v224);
                                v218 = (char *)v224;
                                v220 = 0x100000000 * v212 / 0x100000000;
                            }
                            int64_t v225 = v219;
                            char * v226 = v217;
                            char v227 = *v218; // 0x141c9
                            *v226 = v227;
                            if (v202 + 3 > (int32_t)&g1) {
                                int64_t v228 = (v209 + (int64_t)(int32_t)&g1 & 0xffffffff) * (int64_t)&g1 + (int64_t)&g1 + v225; // 0x141f2
                                char v229 = v227; // 0x141f2
                                int64_t v230 = v225; // 0x141f2
                                v229 ^= *(char *)(v230 + 737);
                                *v226 = v229;
                                v230 += (int64_t)&g1;
                                while (v230 != v228) {
                                    // 0x141f7
                                    v229 ^= *(char *)(v230 + 737);
                                    *v226 = v229;
                                    v230 += (int64_t)&g1;
                                }
                            }
                            int64_t v231 = v209 + 4; // 0x14215
                            *(int32_t *)(v225 + 1056) = (int32_t)v231;
                            unsigned char v232 = *(char *)(v225 + 0x148d); // 0x1421e
                            bWtBCAS_Data2(a1, v211, (int64_t *)(v231 & 0xffffffff), v232);
                            *(char *)(v225 + 0x1340) = (char)&g33;
                            v57 = v211;
                            v49 = v232;
                            v47 = v225;
                            v34 = v89;
                            v42 = v66;
                            v24 = v220;
                            goto lab_0x14962;
                        }
                    } else {
                        // 0x13ca2
                        *(int32_t *)(v65 + 0x15d0) = 0;
                        *(int64_t *)(v65 + 0x8fdd0) = 0;
                        *(int64_t *)(v65 + 0x8fdc0) = 0;
                        *(int64_t *)(v65 + 0x8fdc8) = 0;
                        *(char *)(v65 + 0x8fdd8) = 0;
                        v11 = -128;
                        char * v233 = (char *)(v65 + 0x8fcac); // 0x13cdb
                        char v234 = *v233; // 0x13cdb
                        DTV_DecEncChip_I2C_Write2(v65, v234, NULL, (char *)&v11, (int64_t *)&g1);
                        TLIB_Delay2((int64_t *)&g98);
                        v11 = 0;
                        char v235 = *v233; // 0x13d13
                        DTV_DecEncChip_I2C_Write2(v65, v235, NULL, (char *)&v11, (int64_t *)&g1);
                        v11 = 0;
                        char v236 = *v233; // 0x13d41
                        DTV_DecEncChip_I2C_Write2(v65, v236, (int64_t *)&g86, (char *)&v11, (int64_t *)&g1);
                        v11 = 0;
                        char v237 = *v233; // 0x13d6f
                        DTV_DecEncChip_I2C_Write2(v65, v237, NULL, (char *)&v11, (int64_t *)&g1);
                        int64_t v238 = v65 + 0x1348; // 0x13d96
                        __asm_rep_stosq_memset((char *)v238, 0, 40);
                        TLIB_Delay2((int64_t *)100);
                        unsigned char v239 = *v233; // 0x13dbe
                        DTV_DecEncChip_I2C_Read2(v65, (int64_t)v239, (int64_t)&g86, v9, (int64_t)&g1);
                        if ((v8 & (char)&g1) == 0) {
                            goto lab_0x14006;
                        } else {
                            // 0x13deb
                            if (*v10 != 0) {
                                goto lab_0x14006;
                            } else {
                                // 0x13dfa
                                TLIB_SetGPIO2(a1, (int64_t *)255, (int64_t *)&g1);
                                TLIB_Delay2((int64_t *)50);
                                v11 = &g95;
                                char v240 = *v233; // 0x13e21
                                DTV_DecEncChip_I2C_Write2(v65, v240, NULL, (char *)&v11, (int64_t *)&g1);
                                v11 = -128;
                                char v241 = *v233; // 0x13e4f
                                DTV_DecEncChip_I2C_Write2(v65, v241, (int64_t *)&g86, (char *)&v11, (int64_t *)&g1);
                                TLIB_Delay2((int64_t *)200);
                                v57 = v56;
                                v49 = v12;
                                v47 = v65;
                                v34 = &g1;
                                v42 = 0;
                                v24 = v22;
                                if (*v10 == 0) {
                                    // 0x13e8f
                                    v11 = (char)&g97;
                                    char v242 = *v233; // 0x13e96
                                    DTV_DecEncChip_I2C_Write2(v65, v242, NULL, (char *)&v11, (int64_t *)&g1);
                                    char v243 = *v91; // 0x13ecb
                                    bReadBCAS_Data2(a1, (int64_t *)v238, (int64_t *)(v65 + 0x1344), (int64_t)&g1, v93, v243);
                                    v11 = &g1;
                                    char v244 = *v233; // 0x13eee
                                    DTV_DecEncChip_I2C_Write2(v65, v244, (int64_t *)&g1, (char *)&v11, (int64_t *)&g1);
                                    char * v245 = (char *)(v65 + 0x1488); // 0x13f15
                                    *v245 = (char)&g1;
                                    *(char *)(v65 + (int64_t)&g8) = 0;
                                    *(char *)(v65 + 0x148a) = 0;
                                    *(char *)(v65 + 0x148c) = 0;
                                    int64_t v246 = v12; // 0x13f38
                                    int64_t v247 = &g1; // 0x13f38
                                    if (*v91 != 0) {
                                        char v248 = 0; // bp-136, 0x13f3e
                                        if (*v245 != 0) {
                                            // 0x13f57
                                            v248 = ChangeEndian2(0);
                                            ChangeEndian2(193);
                                            ChangeEndian2((int64_t)((int32_t)(char)&g1 & 255));
                                            ChangeEndian2(254);
                                        }
                                        int64_t v249 = *(int64_t *)(v65 + 72); // 0x13fa2
                                        bWtBCAS_Data2(v249, &v248, (int64_t *)&g89, *v91);
                                        v11 = (char)"GNU";
                                        unsigned char v250 = *v233; // 0x13fb7
                                        DTV_WriteI2CEncData2(v65, (int64_t)v250, 0, (int64_t *)&g1, (char *)&v11);
                                        v246 = &g1;
                                        v247 = v12;
                                    }
                                    // 0x13fdd
                                    Get_BCAS_INFO2(v65 + (int64_t)&g95);
                                    *(int32_t *)(v65 + 732) = 0;
                                    *(int32_t *)(v65 + 408) = 0;
                                    *v94 = (char)&g1;
                                    v57 = v56;
                                    v49 = v246;
                                    v47 = v65;
                                    v34 = v247;
                                    v42 = 0;
                                    v24 = v22;
                                }
                                goto lab_0x14962;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x149f6:
    // 0x149f6
    *(char *)(a1 + 0x53d9) = 0;
    *v10 = (char)&g1;
    *(char *)(a1 + 0x5430) = 0;
    *(char *)(a1 + (int64_t)&g90) = (char)&g1;
    int64_t result2 = complete(a1 + 0x53b8); // 0x14a22
    __readgsqword(40);
    return result2;
  lab_0x13c24:
    // 0x13c24
    v40 = v39;
    v32 = v31;
    v53 = v52;
    int64_t v251 = v45 + (int64_t)&g1; // 0x13c24
    v50 = v53;
    v44 = v251;
    v29 = v32;
    v37 = v40;
    v18 = v19 + (int64_t)&g95;
    v20 = v21 + 80;
    if (v251 == 0x100000000 * (a1 + (int64_t)(int32_t)&g95) / 0x100000000) {
        // break -> 0x13c3d
        goto lab_0x13c3d;
    }
    goto lab_0x138e0;
  lab_0x13a42:;
    int64_t v252 = v38;
    int64_t v253 = v30;
    int64_t v254 = v51;
    v52 = v254;
    v31 = v253;
    v39 = v252;
    if (v17 >= 0xf4241) {
        // 0x13a5a
        v52 = v254;
        v31 = v253;
        v39 = v252;
        if (*(char *)(v45 + 888) == 1) {
            int64_t v255 = 0x100000000 * v21 / 0x100000000; // 0x13a67
            TC_GetBER2(a1, v60, v5, v3, v255);
            int64_t v256 = TC_GetCN2(a1, v60, v255); // 0x13a94
            sprintf(str, 0, *(int64_t *)(*v61 + 0x929a8), 0, v256, v252);
            int64_t v257 = 0xabcc77118461cefd * (v2 & 0xffffffffffffffff) / 0x8000000000000000;
            sprintf(str, 0, *(int64_t *)(*v61 + 0x929a8), 0, v256, v257);
            v52 = 0;
            v31 = v256;
            v39 = v257;
        }
    }
    goto lab_0x13c24;
  lab_0x149d4:
    // 0x149d4
    vUSB_Wait2(50);
    if (*v10 != 0) {
        // break -> 0x149f6
        goto lab_0x149f6;
    }
    // 0x149e9
    v55 = v58;
    v28 = v35;
    v36 = v43;
    v15 = v25 + (int64_t)&g1;
    v16 = v27 + (int64_t)&g1;
    goto lab_0x137ef;
  lab_0x14006:
    // 0x14006
    TLIB_SetGPIO2(a1, NULL, (int64_t *)&g1);
    v57 = v56;
    v49 = v9;
    v47 = v65;
    v34 = &g1;
    v42 = 0;
    v24 = v22;
    goto lab_0x14962;
  lab_0x14962:;
    int64_t v258 = v26;
    int64_t v259 = v24;
    int64_t v260 = v42;
    int64_t v261 = v34;
    int64_t v262 = v49;
    char * v263 = v57;
    int32_t v264 = v59;
    v13 = v264;
    v58 = v263;
    v14 = v262;
    v35 = v261;
    v43 = v260;
    v25 = v259;
    v27 = v258;
    if (*v7 == 0) {
        // 0x1496d
        v13 = v264;
        v58 = v263;
        v14 = v262;
        v35 = v261;
        v43 = v260;
        v25 = v259;
        v27 = v258;
        if (v258 == 0) {
            int64_t v265 = v47;
            unsigned char v266 = *(char *)(v265 + 0x8fcac); // 0x149a4
            DTV_DecEncChip_I2C_Read2(v265, (int64_t)v266, (int64_t)&g86, v9, (int64_t)&g1);
            v13 = v264;
            v58 = v263;
            v14 = v9;
            v35 = &g1;
            v43 = 0;
            v25 = v259;
            v27 = v258;
            if ((v8 & (char)&g1) == 0) {
                // 0x149cd
                *(char *)(v265 + 0x1340) = 0;
                v13 = v264;
                v58 = v263;
                v14 = v9;
                v35 = &g1;
                v43 = 0;
                v25 = v259;
                v27 = v258;
            }
        }
    }
    goto lab_0x149d4;
  lab_0x145ba:;
    int64_t * v267 = (int64_t *)(v46 + 1064); // 0x145ba
    int64_t v268 = *v267; // 0x145ba
    v48 = v54;
    v33 = v62;
    v41 = v66;
    if (v268 != 0) {
        unsigned char v269 = *(char *)(v46 + 0x8fcac); // 0x145cf
        DTV_DecEncChip_I2C_Read2(v46, (int64_t)v269, (int64_t)&g86, v9, (int64_t)&g1);
        char * v270 = (char *)(v46 + 1060); // 0x145ef
        unsigned char v271 = *v270; // 0x145ef
        int64_t v272; // 0x13742
        int64_t v273 = *(int64_t *)(((int64_t)(v271 / 2) & (int64_t)(int32_t)&g94) * (int64_t)&g95 + v272); // 0x145fc
        int64_t v274 = v9; // 0x14607
        if (v273 != 0) {
            char v275 = *(char *)(v273 + 0x8fabc); // 0x14609
            v274 = v9;
            if (v275 != 0) {
                int64_t v276 = *(int64_t *)(v273 + 0x8fab0); // 0x14616
                int64_t v277 = 0; // 0x14625
                if (v276 != 0) {
                    // 0x14627
                    v277 = TS_GetBcasPtr2(v276);
                }
                char v278 = v8; // 0x1462c
                v274 = v9;
                if (v275 == 1 && (v278 & (char)&g1) != 0) {
                    int64_t v279 = v277;
                    int64_t v280 = *v267; // 0x1463b
                    v274 = v280;
                    if (v280 == v279) {
                        char v281 = *v270; // 0x14647
                        int32_t v282 = *(int32_t *)(v46 + 1072); // 0x1464e
                        TS_SetBCASResponse2(v46 + 1079, v282 - 4, v281, v280);
                        v274 = v280;
                    }
                }
            }
        }
        int64_t v283 = v274;
        int32_t * v284 = (int32_t *)(v46 + 1072); // 0x14663
        int32_t v285 = *v284; // 0x14663
        if (v285 > (int32_t)&g94) {
            unsigned char v286 = *(char *)(v46 + 1080); // 0x1469e
            char v287 = 0; // 0x146a5
            if (v286 >= 2) {
                char v288 = *(char *)(v46 + 1083); // 0x146a7
                v287 = v288;
            }
            char v289 = v287;
            char v290 = v289;
            memcpy(v46 + 0x92824, v46 + 1076, (int64_t)v285, v283);
            int32_t v291 = *v284; // 0x146eb
            *(int32_t *)(v46 + 0x92964) = v291;
            unsigned char v292 = *v270; // 0x146f7
            int64_t v293 = *(int64_t *)(((int64_t)(v292 / 2) & (int64_t)(int32_t)&g94) * (int64_t)&g95 + v272); // 0x14704
            if (v293 != 0) {
                // 0x14711
                DTV_SaveBCASCommand2(v293, v46 + 0x926e0);
                unsigned char v294 = *v270; // 0x1471d
                int64_t v295 = *(int64_t *)(((int64_t)(v294 / 2) & (int64_t)(int32_t)&g94) * (int64_t)&g95 + v272); // 0x1472a
                if (v295 != 0) {
                    // 0x14737
                    DTV_SaveBcasReturnCode2(v295, &v290);
                }
            }
        }
        // 0x14743
        *v267 = 0;
        v48 = v283;
        v33 = &g1;
        v41 = 0;
    }
    goto lab_0x1474e;
  lab_0x1474e:;
    int64_t v296 = v41;
    int64_t v297 = v33;
    int64_t v298 = v48;
    char v299 = *(char *)(v46 + 0x15d4); // 0x1474e
    int32_t * v300; // 0x13742
    if (v299 != 1) {
        // 0x1474e
        v300 = (int32_t *)(v46 + 1072);
    } else {
        char v301 = *(char *)(v46 + 0x15d5); // 0x14757
        int32_t * v302 = (int32_t *)(v46 + 1072);
        int32_t v303 = *v302;
        if (v301 != 0) {
            // 0x14784
            *(int32_t *)(v46 + 3000) = v303;
            memcpy(v46 + 3004, v46 + 1076, (int64_t)v303, v298);
            v300 = v302;
        } else {
            // 0x14760
            *(int32_t *)(v46 + 2036) = v303;
            memcpy(v46 + 2040, v46 + 1076, (int64_t)v303, v298);
            v300 = v302;
        }
    }
    int32_t * v304 = v300;
    int32_t v305 = *v304; // 0x147a6
    int64_t str3 = FUSB_ExAllocatePool2(0, (int64_t)(v305 + 1 + 2 * v305)); // 0x147b8
    int32_t v306 = *v304; // 0x147c4
    memset(str3, 0, (int64_t)(v306 + 1 + 2 * v306));
    uint32_t v307 = *v304; // 0x147e2
    int64_t v308 = 0; // 0x147e9
    int64_t v309 = v46; // 0x147e9
    int64_t v310 = v298; // 0x147e9
    int64_t v311 = v23; // 0x147e9
    if (v307 >= 1) {
        int64_t v312 = v309;
        int64_t v313 = v308;
        unsigned char v314 = *(char *)(v312 + 1076); // 0x1480e
        sprintf(str3, 0, str3, v314, v297, v296);
        int64_t v315 = v313 + (int64_t)(int32_t)&g1 & 0xffffffff; // 0x1482d
        int32_t v316 = *v304; // 0x14834
        v308 = v315;
        v309 = v312 + (int64_t)&g1;
        while (v315 < (int64_t)v316) {
            // 0x1480e
            v312 = v309;
            v313 = v308;
            v314 = *(char *)(v312 + 1076);
            sprintf(str3, 0, str3, v314, v297, v296);
            v315 = v313 + (int64_t)(int32_t)&g1 & 0xffffffff;
            v316 = *v304;
            v308 = v315;
            v309 = v312 + (int64_t)&g1;
        }
        // 0x1483d
        v310 = v314;
        v311 = 0x100000000 * v23 / 0x100000000;
    }
    int64_t v317 = v311;
    int64_t v318 = v310;
    FUSB_ExFreePool2((int32_t)str3, 0);
    *(char *)(v46 + 0x1340) = (char)((v63 & -126) != -126);
    *v64 = 0;
    v57 = v56;
    v49 = v318;
    v47 = v46;
    v34 = v297;
    v42 = v296;
    v24 = v317;
    goto lab_0x14962;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x14a6a - 0x14a9a
// Line range:    158 - 168
char bWritePcieReg(int16_t RegOffset, int16_t u16WriteLen, char * pDataBuf, int64_t hCtrlTransfer) {
    // 0x14a6a
    int64_t result; // 0x14a6a
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x14a9a - 0x14aca
// Line range:    146 - 156
char bReadPcieReg(uint16_t RegOffset, uint16_t u16ReadLen, char * pDataBuf, int64_t hCtrlTransfer) {
    // 0x14a9a
    mcount();
    uint64_t v1 = cfg_access2(NULL, hCtrlTransfer, (int64_t)RegOffset, (int64_t *)(int64_t)u16ReadLen, (int64_t *)pDataBuf); // 0x14ab6
    return (char)NT_SUCCESS2(v1 % 256) != 0;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x14aca - 0x14afa
// Line range:    207 - 238
char bTunerReset(char u8ChanNum, char ResetPin, char * hCtrlTransfer) {
    // 0x14aca
    mcount();
    int64_t v1; // 0x14aca
    uint64_t v2 = cfg_access2((int64_t *)&g1, v1, (uint64_t)(int64_t)u8ChanNum % 0x10000, (int64_t *)((uint64_t)(int64_t)ResetPin % 0x10000), (int64_t *)hCtrlTransfer); // 0x14ae6
    return (char)NT_SUCCESS2(v2 % 256) != 0;
}

// Address range: 0x14afa - 0x14b54
int64_t bTunerReset2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x14afa
    mcount();
    int64_t v1; // bp-48, 0x14afa
    bTunerReset(-120, (char)&g86, (char *)&v1);
    int64_t result = (char)a1 == (char)&g1 ? (int64_t)&g1 : 256; // 0x14b47
    return result;
}

// From module:   /root/asv5220\dtvlib.c
// Address range: 0x14b54 - 0x14b84
// Line range:    170 - 205
char bReadPcieCfgReg(int16_t RegOffset, int16_t u16ReadLen, char * pDataBuf, int64_t hCtrlTransfer) {
    // 0x14b54
    int64_t v1; // 0x14b54
    int64_t v2; // 0x14b54
    return bReadPcieReg(2184, (int16_t)&g86, (char *)v1, v2);
}

// Address range: 0x14b84 - 0x14c5c
int64_t bReadPcieCfgReg2(int64_t a1, int64_t * a2, int64_t * a3, int64_t a4) {
    // 0x14b84
    mcount();
    char v1 = a1; // bp-48, 0x14bcc
    bReadPcieReg(2212, (int16_t)&g86, &v1, a4);
    v1 = &g2;
    bReadPcieReg(2208, (int16_t)&g86, &v1, a4);
    v1 = 0;
    bTunerReset(-96, (char)&g86, &v1);
    bTunerReset(-88, (char)&g86, &v1);
    int64_t dest_mem = memcpy((int64_t)a3, (int64_t)&v1, (int64_t)a2 % 0x10000, a4); // 0x14c49
    return dest_mem;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x14c60 - 0x14c6d
// Line range:    90 - 109
int32_t USB_IsHighSpeed(int64_t deviceExtension) {
    char * v1 = (char *)(deviceExtension + 2208); // 0x14c60
    uint64_t v2; // 0x14c60
    *v1 = *v1 + (char)(v2 / 256);
    int64_t v3; // 0x14c60
    int64_t v4; // 0x14c60
    int64_t v5; // 0x14c60
    return bReadPcieReg((int16_t)deviceExtension, (int16_t)v3, (char *)v4, v5);
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x14c70 - 0x14c8a
// Line range:    110 - 157
int32_t USB_IsPidNeedToKeep(int64_t deviceExtension, char CF_Num, int32_t pid) {
    // 0x14c70
    return CF_Num;
}

// Address range: 0x14c90 - 0x14ca0
int64_t USB_IsHighSpeed2(int64_t a1) {
    // 0x14c90
    mcount();
    return &g1;
}

// Address range: 0x14ca0 - 0x14d54
int64_t USB_IsPidNeedToKeep2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x14ca0
    mcount();
    return 0;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x14d55 - 0x14d85
// Line range:    158 - 176
int32_t USB_SetPidTable(int64_t deviceExtension, char CF_Num, int32_t * PID_TABLE, char Num) {
    // 0x14d55
    int64_t v1; // 0x14d55
    int32_t * v2 = (int32_t *)(v1 - 125); // 0x14d55
    int32_t v3 = *v2 ^ (int32_t)Num; // 0x14d55
    *v2 = v3;
    int32_t * v4 = (int32_t *)(deviceExtension * (int64_t)&g1 + (int64_t)Num); // 0x14d58
    uint32_t v5 = *v4; // 0x14d58
    *v4 = v5 >> (int32_t)&g98 | v5 << (int32_t)&g10;
    return !((v3 != 0 | (int32_t)&g25 < 0)) == (v3 == 0 != ((int32_t)&g25 == 0));
}

// Address range: 0x14d85 - 0x14e1b
int64_t USB_SetPidTable2(int64_t a1, uint64_t a2, int64_t a3, int64_t * a4) {
    uint64_t v1 = (int64_t)a4;
    mcount();
    uint64_t v2 = a2 % 256; // 0x14d8e
    if ((int32_t)a3 >= 0x2000) {
        // 0x14dc4
        return 0;
    }
    int64_t v3 = 0; // 0x14dc2
    while ((v3 + (int64_t)(int32_t)&g1 & 0xffffffff) < v1 % 256) {
        // 0x14dd7
        v3 = v3 + (int64_t)(int32_t)&g1 & 0xffffffff;
    }
    int64_t v4 = v2 * ((int64_t)&g95 + (int64_t)&g1 << (int64_t)&g86) + a1;
    *(int32_t *)(v4 + 0x5c6c) = (int32_t)v1 % 256;
    *(int32_t *)(v4 + 0x5bec) = *(int32_t *)a3;
    return &g86;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x14e1b - 0x14e4b
// Line range:    289 - 370
int32_t USB_FilterReset(int64_t deviceExtension, char CF_Num, char bRestoreCFReg, char bCFSerialMode) {
    // 0x14e1b
    return &g1;
}

// Address range: 0x14e4b - 0x14e9b
int64_t USB_FilterReset2(int64_t a1, uint64_t a2) {
    // 0x14e4b
    mcount();
    uint64_t v1 = a2 % 256; // 0x14e54
    int64_t v2 = v1 * ((int64_t)&g95 + (int64_t)&g1 << (int64_t)&g86) * (int64_t)&g1 + a1; // 0x14e82
    *(int32_t *)(v2 + 0x5be8) = 0;
    *(int32_t *)(v2 + 0x5be4) = 0;
    return v1 * (int64_t)&g95;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x14e9f - 0x14ecf
// Line range:    372 - 409
int32_t USB_FilterStart_Stop(int64_t deviceExtension, char CF_Num, char ONOFF) {
    // 0x14e9f
    int64_t v1; // 0x14e9f
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x14e9f
    int64_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    int64_t v4 = v2;
    *(char *)v4 = *(char *)&v2 + (char)v4;
    int64_t v5 = v2; // 0x14ea5
    v2 = 0;
    int64_t v6 = deviceExtension + 0x5bec + (v5 + (int64_t)CF_Num << (int64_t)&g86); // 0x14eb4
    *(int32_t *)v6 = 0;
    int64_t v7 = v2 + (int64_t)(int32_t)&g1; // 0x14ebf
    v2 = v7 & 0xffffffff;
    int32_t v8 = v7;
    v6 += 4;
    while (v8 != (int32_t)&g26) {
        // 0x14eb9
        *(int32_t *)v6 = 0;
        v7 = v2 + (int64_t)(int32_t)&g1;
        v2 = v7 & 0xffffffff;
        v8 = v7;
        v6 += 4;
    }
    // 0x14ecb
    return v8 & -256 | (int32_t)&g1;
}

// Address range: 0x14ecf - 0x14edc
int64_t USB_FilterStart_Stop2(int64_t a1, int64_t a2) {
    // 0x14ecf
    return mcount();
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x14edc - 0x14f0c
// Line range:    841 - 879
int32_t USB_FilterONOFF(int64_t deviceExtension, char CF_Num, char ONOFF) {
    int64_t v1 = (int64_t)CF_Num * ((int64_t)&g95 + 1 << (uint64_t)(int64_t)&g86); // 0x14ee0
    int64_t v2 = deviceExtension + 0x5be0; // 0x14ee4
    int32_t result = 0; // 0x14ef4
    if (v2 != -v1) {
        // 0x14ef6
        *(char *)(v1 + v2) = ONOFF;
        result = &g1;
    }
    // 0x14f0a
    return result;
}

// Address range: 0x14f0c - 0x14f19
int64_t USB_FilterONOFF2(int64_t a1, int32_t a2) {
    // 0x14f0c
    return mcount();
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x14f19 - 0x14f49
// Line range:    881 - 912
int32_t USB_FilterON_and_Start(int64_t deviceExtension, char CF_Num) {
    int64_t v1 = (int64_t)CF_Num * ((int64_t)&g95 + 1 << (uint64_t)(int64_t)&g86); // 0x14f1d
    int64_t v2 = deviceExtension + 0x5be0; // 0x14f21
    int32_t result = 0; // 0x14f31
    if (v2 != -v1) {
        // 0x14f33
        int64_t v3; // 0x14f19
        *(char *)(v1 + v2) = (char)v3;
        result = &g1;
    }
    // 0x14f47
    return result;
}

// Address range: 0x14f49 - 0x14f56
int64_t USB_FilterON_and_Start2(int64_t a1, int64_t a2) {
    // 0x14f49
    return mcount();
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x14f57 - 0x14f6b
// Line range:    956 - 961
int32_t USB_BulkStreamRead(int64_t deviceExtension, char Channel_Num, char * Buffer, int64_t ReadLen) {
    // 0x14f57
    return 0;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x14f6b - 0x14f87
// Line range:    940 - 954
int32_t USB_BulkStreamStop(int64_t deviceExtension, char Channel_Num) {
    // 0x14f6b
    int64_t result; // 0x14f6b
    int64_t v1; // 0x14f6b
    if (v1 != 0) {
        // 0x14f70
        *(char *)(deviceExtension + 0x5be0 + (int64_t)Channel_Num * ((int64_t)&g95 + 1 << (uint64_t)(int64_t)&g86)) = (char)&g1;
        result = &g1;
    }
    // 0x14f85
    return result;
}

// Address range: 0x14f87 - 0x14f9b
int64_t USB_BulkStreamRead2(int64_t a1, uint64_t a2) {
    // 0x14f87
    mcount();
    int64_t v1; // 0x14f87
    int64_t v2; // 0x14f87
    return iGetStreamData2(a1, a2 % 256, v1, v2);
}

// Address range: 0x14f9b - 0x14fac
int64_t USB_BulkStreamStop2(int64_t a1, int64_t a2) {
    // 0x14f9b
    int64_t result; // 0x14f9b
    return result;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x14fae - 0x14fde
// Line range:    914 - 938
int32_t USB_BulkStreamStart(int64_t deviceExtension, unsigned char Channel_Num, char * Contex, int64_t TransferObjBufSize, int64_t StreamBufSize) {
    // 0x14fae
    FUSBDTV_Cmd_I2CRead_NoWt(deviceExtension, Channel_Num, (int16_t)(int64_t)Contex, (char *)TransferObjBufSize);
    int64_t v1 = FUSBDTV_StopBulkStream2(deviceExtension, (int64_t)Channel_Num); // 0x14fc4
    return v1 == (int64_t)&g1;
}

// Address range: 0x14fde - 0x1501e
int64_t USB_BulkStreamStart2(int64_t a1, uint64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x14fde
    mcount();
    FUSBDTV_StartBulkStream2(a1, a2 % 256, a4, a5, a3);
    return 0;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x1501e - 0x1504c
// Line range:    825 - 838
int32_t USB_GetFilterStat(int64_t deviceExtension, char CF_Num) {
    // 0x1501e
    int64_t v1; // 0x1501e
    int64_t v2 = FUSBDTV_Cmd_GetDev_Speed(v1, (char *)(int64_t)CF_Num); // 0x15021
    int32_t result = &g1; // 0x15032
    if (v2 != (int64_t)&g1) {
        // 0x15034
        int64_t v3; // 0x1501e
        FUSBDTV_StopBulkStream2(v1, v3 & 0xffffffff);
        result = 0;
    }
    // 0x15043
    return result;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x1504c - 0x1504e
// Line range:    257 - 287
char USB_CF_Read(int64_t deviceExtension, char CF_Num, char byReg, char byCount, char * pBuffer) {
    // 0x1504c
    int64_t result; // 0x1504c
    return result;
}

// Address range: 0x1504e - 0x1507c
int64_t USB_GetFilterStat2(int64_t a1, int64_t a2) {
    // 0x1504e
    mcount();
    char result = 0; // bp-9, 0x1505b
    FUSBDTV_Cmd_EncWrite(a1, (char)a2, 64, (int16_t)&g1, &result);
    return result;
}

// Address range: 0x1507c - 0x150d7
int64_t USB_CF_Read2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x1507c
    mcount();
    return 0;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x150d9 - 0x15109
// Line range:    717 - 772
char USB_I2C_Write(int64_t deviceExtension, char byID, char byReg, char * pBuffer, char byCount, char byI2CFlag) {
    // 0x150d9
    int64_t result; // 0x150d9
    return result;
}

// Address range: 0x150db - 0x150ef
int64_t function_150db(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a4 + (int64_t)&g1; // 0x150db
    int32_t * v2 = (int32_t *)v1; // 0x150db
    *v2 = *v2 + (int32_t)&g1;
    int16_t v3 = *(int16_t *)v1; // 0x150de
    int64_t result; // 0x150db
    float80_t v4; // 0x150db
    *(int64_t *)(result - 125) = (int64_t)(v4 + (float80_t)v3);
    int32_t * v5 = (int32_t *)(a1 - 72 + result * (int64_t)&g1); // 0x150e5
    *v5 = *v5 + (int32_t)a2;
    int64_t v6 = result;
    *(char *)v6 = *(char *)&result + (char)v6;
    int64_t v7 = result;
    *(char *)v7 = *(char *)&result + (char)v7;
    return result;
}

// Address range: 0x150ef - 0x150f5
int64_t function_150ef(void) {
    // 0x150ef
    int64_t result; // 0x150ef
    return result;
}

// Address range: 0x15109 - 0x15178
int64_t USB_I2C_Write2(int64_t a1, uint64_t a2, uint64_t a3, int64_t a4, uint64_t a5, int64_t * a6) {
    // 0x15109
    mcount();
    char v1 = (int64_t)a6; // 0x15112
    if (v1 == (char)&g33) {
        // 0x15118
        return FPCIEDTV_Cmd_I2CWrite2(a1, a2 % 256, 255, a5 % 256, a4, (int64_t *)&g89);
    }
    if (v1 != (char)&g86) {
        // 0x1515a
        return a5 % 256;
    }
    int64_t result = FPCIEDTV_Cmd_I2CWrite2(a1, a2 % 256, a3 % 256, a5 % 256, a4, (int64_t *)&g86); // 0x15153
    return result;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x15178 - 0x151a8
// Line range:    542 - 590
char USB_I2C_Read(int64_t deviceExtension, char byID, char byReg, char * pBuffer, char byCount, char byI2CFlag) {
    int64_t v1 = FPCIEDTV_Cmd_I2CWrite2(deviceExtension, (int64_t)byID, (int64_t)byReg, (int64_t)pBuffer, (int64_t)byCount, (int64_t *)(int64_t)byI2CFlag); // 0x15178
    return v1 == (int64_t)&g1;
}

// Address range: 0x151a8 - 0x151f3
int64_t USB_I2C_Read2(int64_t a1, uint64_t a2, uint64_t a3, int64_t a4, uint64_t a5, int64_t * a6) {
    int64_t result = mcount(); // 0x151ac
    unsigned char v1 = (char)(int64_t)a6; // 0x151b1
    if (v1 == (char)&g1) {
        // 0x151e2
        return a5 % 256;
    }
    if (v1 < (char)&g1) {
        // 0x151c5
        return FPCIEDTV_Cmd_I2CRead2(a1, a2 % 256, a3 % 256, a5 % 256, a4, (int64_t *)&g33);
    }
    // 0x151bd
    return result;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x151f3 - 0x15223
// Line range:    774 - 824
char USB_I2C_WriteAndRead(int64_t deviceExtension, char slave_addr, char * Write_buffer, char Write_size, char * Read_buffer, char Read_size, char mode) {
    // 0x151f3
    int64_t v1; // 0x151f3
    int64_t v2 = FPCIEDTV_Cmd_I2CRead2(deviceExtension, (int64_t)slave_addr, (int64_t)Write_buffer, v1 & 0xffffffff, (int64_t)Write_size, (int64_t *)(int64_t)Read_size); // 0x151f8
    return v2 == (int64_t)&g1;
}

// Address range: 0x15223 - 0x152f4
int64_t USB_I2C_WriteAndRead2(int64_t a1, uint64_t a2, int64_t a3, uint64_t a4, int64_t a5, uint64_t a6, unsigned char a7) {
    // 0x15223
    mcount();
    if (a7 == 0) {
        uint64_t v1 = a2 % 256; // 0x15258
        USB_I2C_Write2(a1, v1, 0, a3, a4 % 256, (int64_t *)&g33);
        return USB_I2C_Read2(a1, v1, 0, a5, a6 % 256, (int64_t *)&g25);
    }
    int64_t v2 = a3 + (int64_t)&g1; // 0x152a7
    uint64_t v3 = a2 % 256; // 0x152ab
    USB_I2C_Write2(a1, v3, (int64_t)a7, v2, (int64_t)&g25, NULL);
    char * v4 = (char *)v2; // 0x152cd
    *v4 = *v4 | (char)&g1;
    int64_t result = USB_I2C_Write2(a1, v3, 0, a3, (int64_t)&g25, (int64_t *)&g33); // 0x152eb
    return result;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x152f7 - 0x1530c
// Line range:    441 - 484
int32_t USB_CleanStreamBuffer(int64_t deviceExtension, char Channel_Num) {
    // 0x152f7
    int64_t result; // 0x152f7
    char v1 = result;
    *(char *)result = 2 * v1;
    int64_t v2; // 0x152f7
    char * v3 = (char *)(v2 + (int64_t)&g105); // 0x152f9
    *v3 = *v3 + v1;
    return result;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x15310 - 0x15327
// Line range:    207 - 254
char USB_CF_Write(int64_t deviceExtension, char CF_Num, char byReg, char * pBuffer, char byCount, char bZeroNoSend) {
    // 0x15310
    int64_t result; // 0x15310
    int32_t * v1 = (int32_t *)(result - 117); // 0x15310
    *v1 = *v1 - (int32_t)&g1;
    return result;
}

// Address range: 0x15327 - 0x15340
int64_t USB_CleanStreamBuffer2(int64_t a1, int64_t a2) {
    // 0x15327
    mcount();
    vCleanStreamBuffer2(a1, (char)a2);
    return &g1;
}

// Address range: 0x15340 - 0x1540b
int64_t USB_CF_Write2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x15340
    return mcount();
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x1540e - 0x15423
// Line range:    58 - 63
void DelayMilliseconds_i2c(int32_t ms) {
    // 0x1540e
    int64_t v1; // 0x1540e
    int32_t * v2 = (int32_t *)(v1 + (int64_t)&g4); // 0x1540e
    int64_t v3; // 0x1540e
    *v2 = *v2 + (int32_t)v3;
    char * v4 = (char *)(v1 - 49); // 0x1541a
    int64_t v5; // 0x1540e
    *v4 = *v4 + (char)v5;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x15425 - 0x15429
// Line range:    36 - 56
void DelayMilliseconds(int32_t ms) {
    // 0x15425
    int64_t v1; // 0x15425
    *(char *)v1 = 2 * (char)v1;
}

// From module:   /root/asv5220\ASV5212.c
// Address range: 0x15435 - 0x1543e
// Line range:    65 - 87
void vUSB_Wait(int64_t dwMilliseconds) {
    // 0x15435
    return;
}

// Address range: 0x1543e - 0x15447
int64_t DelayMilliseconds_i2c2(int64_t * a1) {
    // 0x1543e
    return mcount();
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x15448 - 0x15455
// Line range:    509 - 525
int64_t private_data(char * m2) {
    // 0x15448
    return __udelay(2 * (int64_t)m2 & 0xfffffffe);
}

// Address range: 0x15455 - 0x15465
int64_t DelayMilliseconds2(int64_t * a1, int64_t a2) {
    // 0x15455
    mcount();
    return msleep_interruptible();
}

// Address range: 0x15465 - 0x15469
int64_t vUSB_Wait2(int64_t a1) {
    // 0x15465
    int64_t result; // 0x15465
    return result;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x1546c - 0x15475
// Line range:    232 - 251
int32_t set_init_cbc_multi2(char * m2, char * val) {
    // 0x1546c
    return DelayMilliseconds2((int64_t *)m2, (int64_t)val);
}

// Address range: 0x15478 - 0x1549c
int64_t private_data2(int64_t a1) {
    // 0x15478
    mcount();
    return 0;
}

// Address range: 0x1549c - 0x154e4
int64_t set_init_cbc_multi2_(int64_t a1, int64_t a2) {
    // 0x1549c
    mcount();
    int64_t result = private_data2(a1); // 0x154a9
    if (a2 != 0 != result != 0) {
        // 0x154b8
        return 0xffffffff;
    }
    unsigned char v1 = *(char *)(a2 + (int64_t)&g33); // 0x154bf
    unsigned char v2 = *(char *)(a2 + (int64_t)&g1); // 0x154cb
    unsigned char v3 = *(char *)(a2 + (int64_t)&g25); // 0x154d4
    int64_t v4; // 0x1549c
    *(int32_t *)(result + (int64_t)&g86) = (int32_t)v4 % 256 << (int32_t)&g13 | (int32_t)v1 | (int32_t)v2 << (int32_t)&g2 | (int32_t)v3 << (int32_t)&g95;
    return result;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x154e4 - 0x15514
// Line range:    210 - 230
int32_t set_system_key_multi2(char * m2, char * val) {
    // 0x154e4
    int64_t v1; // 0x154e4
    unsigned char v2 = *(char *)(v1 + (int64_t)&g33); // 0x154e4
    unsigned char v3 = *(char *)(v1 + (int64_t)&g1); // 0x154f0
    unsigned char v4 = *(char *)(v1 + (int64_t)&g25); // 0x154f9
    int64_t v5; // 0x154e4
    *(int32_t *)(v5 + (int64_t)&g95) = (int32_t)v1 % 256 << (int32_t)&g13 | (int32_t)v2 | (int32_t)v3 << (int32_t)&g2 | (int32_t)v4 << (int32_t)&g95;
    int32_t * v6 = (int32_t *)(v5 + 128); // 0x15505
    *v6 = *v6 | 1;
    return 0;
}

// Address range: 0x15514 - 0x1554b
int64_t set_system_key_multi2_(int64_t a1, int64_t a2) {
    // 0x15514
    mcount();
    int64_t v1 = private_data2(a1); // 0x15521
    return a2 != 0 == (v1 != 0) ? v1 : 0xffffffff;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x1554b - 0x15573
// Line range:    195 - 208
int32_t set_round_multi2(char * m2, int32_t val) {
    // 0x1554b
    int64_t v1; // 0x1554b
    int64_t v2; // 0x1554b
    int64_t v3 = v2 * (int64_t)&g1 + v1;
    unsigned char v4 = *(char *)(v3 + (int64_t)&g33); // 0x1554d
    unsigned char v5 = *(char *)(v3 + (int64_t)&g25); // 0x15554
    int64_t v6; // 0x1554b
    int64_t result; // 0x1554b
    *(int32_t *)(v2 + (int64_t)"GNU" + result) = (int32_t)v6 | val | (int32_t)v4 | (int32_t)v5 << (int32_t)&g95;
    int32_t * v7 = (int32_t *)(result + 128); // 0x1556c
    *v7 = *v7 | 2;
    return result;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x15574 - 0x1557b
// Line range:    181 - 193
int32_t add_ref_multi2(char * m2) {
    // 0x15574
    int64_t v1; // 0x15574
    *(char *)v1 = 2 * (char)v1;
    int64_t result; // 0x15574
    int64_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0x1557b - 0x15597
int64_t set_round_multi2_(int64_t a1, int64_t a2) {
    // 0x1557b
    mcount();
    private_data2(a1);
    return 0xffffffff;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x15598 - 0x155a4
// Line range:    667 - 671
void core_pi1(int64_t dst, int64_t src) {
    // 0x15598
    int64_t v1; // 0x15598
    char * v2 = (char *)(v1 + 0xb87c5a); // 0x15598
    *v2 = *v2 | (char)v1;
    int64_t v3; // 0x15598
    int64_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    int64_t v5; // 0x15598
    char * v6 = (char *)(v5 - 55); // 0x155a0
    *v6 = *v6 + (char)v5;
}

// Address range: 0x155a4 - 0x155ad
int64_t add_ref_multi2_(void) {
    // 0x155a4
    return mcount();
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x155af - 0x155b0
// Line range:    673 - 683
void core_pi2(int64_t dst, int64_t src, int32_t a) {
    // 0x155af
    return;
}

// Address range: 0x155b2 - 0x155c8
int64_t function_155b2(void) {
    int64_t result = 0xffffffff; // 0x155ba
    int64_t v1; // 0x155b2
    if (v1 != 0) {
        // 0x155bc
        *(int32_t *)v1 = (int32_t)v1 + (int32_t)&g1;
        result = 0;
    }
    // 0x155c4
    return result;
}

// Address range: 0x155c8 - 0x155d7
int64_t core_pi1_(int64_t * a1) {
    // 0x155c8
    mcount();
    int64_t v1; // 0x155c8
    *(int32_t *)a1 = (int32_t)v1;
    return v1 & 0xffffffff;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x155d7 - 0x155df
// Line range:    685 - 700
void core_pi3(int64_t dst, int64_t src, int32_t a, int32_t b) {
    int32_t v1 = *(int32_t *)(src + (int64_t)&g86); // 0x155d7
    int64_t v2; // 0x155d7
    *(int32_t *)(dst + (int64_t)&g86) = v1 ^ (int32_t)v2;
}

// Address range: 0x155df - 0x15607
int64_t core_pi2_(int64_t * a1, int64_t * a2, int32_t a3) {
    // 0x155df
    mcount();
    int32_t * v1 = (int32_t *)((int64_t)a2 + (int64_t)&g86); // 0x155e8
    uint32_t v2 = *v1 + a3; // 0x155e8
    uint32_t v3 = v2 - 1 + (v2 >> (int32_t)&g24 | v2 << (int32_t)&g1) * (int32_t)&g1; // 0x155f0
    int64_t v4; // 0x155df
    *(int32_t *)a1 = v3 ^ (int32_t)v4 ^ (v3 >> (int32_t)&g19 | v3 << (int32_t)&g86);
    uint32_t result = *v1; // 0x155ff
    *(int32_t *)((int64_t)a1 + (int64_t)&g86) = result;
    return result;
}

// Address range: 0x15607 - 0x15614
int64_t core_pi3_(int64_t a1, int64_t a2, int64_t a3) {
    // 0x15607
    mcount();
    int64_t v1; // 0x15607
    return v1 & 0xffffffff;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x15615 - 0x15636
// Line range:    702 - 711
void core_pi4(int64_t dst, int64_t src, int32_t a) {
    // 0x15615
    *(int32_t *)dst = a;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x15636 - 0x15645
// Line range:    558 - 576
void core_encrypt(int64_t dst, int64_t src, int64_t w, int32_t round) {
    uint32_t v1 = (int32_t)w; // 0x15638
    int32_t v2 = *(int32_t *)(src + (int64_t)&g86); // 0x1563d
    int64_t v3; // 0x15636
    *(int32_t *)(dst + (int64_t)&g86) = v2 ^ (v1 >> (int32_t)&g2 | v1 << (int32_t)&g2) ^ (int32_t)(v3 | w);
}

// Address range: 0x15645 - 0x15666
int64_t core_pi4_(int64_t a1, int64_t a2, int32_t a3) {
    // 0x15645
    mcount();
    int32_t * v1 = (int32_t *)(a2 + (int64_t)&g86); // 0x1564e
    uint32_t v2 = *v1 + a3; // 0x1564e
    int64_t v3; // 0x15645
    *(int32_t *)a1 = v2 + (int32_t)&g1 + (v2 >> (int32_t)&g23 | v2 << (int32_t)&g25) * (int32_t)&g1 ^ (int32_t)v3;
    uint32_t result = *v1; // 0x1565e
    *(int32_t *)(a1 + (int64_t)&g86) = result;
    return result;
}

// Address range: 0x15666 - 0x156a1
int64_t core_encrypt2(int32_t * a1, int32_t * a2, int64_t a3, int32_t a4) {
    // 0x15666
    mcount();
    int64_t v1; // 0x15666
    *a1 = (int32_t)v1;
    uint32_t result = *(int32_t *)((int64_t)a2 + (int64_t)&g86); // 0x15689
    *(int32_t *)((int64_t)a1 + (int64_t)&g86) = result;
    return result;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x156f8 - 0x15728
// Line range:    361 - 504
int32_t decrypt_multi2(char * m2, int32_t type, char * buf, int32_t size) {
    // 0x156f8
    int64_t v1; // 0x156f8
    int64_t v2; // 0x156f8
    core_pi3_(v1, v2 & 0xffffffff, (int64_t)buf);
    int64_t v3; // 0x156f8
    int32_t v4 = *(int32_t *)(v3 + (int64_t)&g19); // 0x15702
    int64_t v5; // 0x156f8
    return core_pi4_(v5, v1, v4);
}

// Address range: 0x15728 - 0x15a8b
int64_t decrypt_multi2_(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x15728
    mcount();
    int64_t v1 = 0x100000000 * a4 / 0x100000000; // 0x15747
    __readgsqword(40);
    int64_t result = private_data2(a1); // 0x15759
    int32_t v2 = v1; // 0x15772
    if (v2 < 1 || a3 == 0 || result == 0) {
        // 0x15a89
        return result;
    }
    int64_t v3 = result + ((int32_t)a2 != (int32_t)&g25 ? 60 : 92); // 0x157b9
    int32_t v4 = *(int32_t *)(result + (int64_t)&g86); // bp-104, 0x157c7
    int32_t v5 = *(int32_t *)(v3 + (int64_t)&g13); // 0x157e9
    uint32_t v6 = *(int32_t *)(v3 + (int64_t)&g19); // 0x157f6
    int32_t * v7 = (int32_t *)(result + 124); // 0x157fa
    uint32_t v8 = *v7; // 0x157fa
    int32_t v9 = v8; // 0x15805
    int64_t v10 = v1; // 0x15805
    int64_t v11 = a3; // 0x15805
    int32_t v12; // bp-88, 0x15728
    if (v2 > (int32_t)&g94) {
        uint32_t v13 = *(int32_t *)(v3 + (int64_t)&g7); // 0x157f2
        int32_t v14 = *(int32_t *)(v3 + (int64_t)&g2); // 0x157e5
        int32_t v15 = *(int32_t *)(v3 + (int64_t)&g86); // 0x157dd
        int32_t v16 = *(int32_t *)(v3 + (int64_t)&g95); // 0x157da
        uint32_t v17 = v2 - (int32_t)&g95 >> (int32_t)&g33; // 0x15811
        v11 = a3 + (int64_t)&g95 + (int64_t)v17 * (int64_t)&g95;
        int32_t v18 = *(int32_t *)(v3 + (int64_t)"GNU") * (int32_t)&g1;
        char * v19 = (char *)a3;
        unsigned char v20 = *v19; // 0x1583c
        char * v21 = (char *)(a3 + (int64_t)&g1);
        unsigned char v22 = *v21; // 0x15842
        char * v23 = (char *)(a3 + (int64_t)&g33);
        unsigned char v24 = *v23; // 0x1584b
        char * v25 = (char *)(a3 + (int64_t)&g25);
        unsigned char v26 = *v25; // 0x15851
        int32_t v27 = (int32_t)v22 << (int32_t)&g2 | (int32_t)v20 << (int32_t)&g13 | (int32_t)v24 | (int32_t)v26 << (int32_t)&g95; // 0x15858
        unsigned char v28 = *(char *)(a3 + (int64_t)&g86); // 0x1585d
        char * v29 = (char *)(a3 + (int64_t)&g89);
        unsigned char v30 = *v29; // 0x15864
        char * v31 = (char *)(a3 + (int64_t)&g94);
        unsigned char v32 = *v31; // 0x1586d
        char * v33 = (char *)(a3 + (int64_t)&g91);
        unsigned char v34 = *v33; // 0x15873
        int32_t v35 = (int32_t)v30 << (int32_t)&g2 | (int32_t)v28 << (int32_t)&g13 | (int32_t)v32 | (int32_t)v34 << (int32_t)&g95; // 0x1587a
        v12 = v27;
        int32_t v36 = v27; // 0x1588a
        int32_t v37 = v35; // 0x1588a
        char * v38 = v31; // 0x1588a
        char * v39 = v33; // 0x1588a
        char * v40 = v29; // 0x1588a
        char * v41 = v23; // 0x1588a
        char * v42 = v25; // 0x1588a
        char * v43 = v21; // 0x1588a
        char * v44 = v19; // 0x1588a
        int32_t v45 = v27; // 0x1588a
        int32_t v46 = v35; // 0x1588a
        int64_t v47 = a3; // 0x1588a
        int64_t v48; // 0x15728
        int64_t v49; // 0x1589f
        uint32_t v50; // 0x158a3
        int64_t v51; // 0x15728
        int64_t v52; // 0x158b2
        uint32_t v53; // 0x158b6
        uint32_t v54; // 0x158c2
        uint32_t v55; // 0x158cc
        uint32_t v56; // 0x158d6
        int32_t v57; // 0x158e0
        int32_t v58; // 0x158e6
        uint32_t v59; // 0x158e9
        uint32_t v60; // 0x158f4
        int32_t v61; // 0x15900
        int32_t v62; // 0x15906
        uint32_t v63; // 0x15909
        int32_t v64; // 0x15919
        uint32_t v65; // 0x1591b
        uint32_t v66; // 0x15926
        uint32_t v67; // 0x15935
        uint32_t v68; // 0x1593e
        int32_t v69; // 0x1594d
        uint32_t v70; // 0x15950
        uint32_t v71; // 0x1595b
        int32_t v72; // 0x15967
        int32_t v73; // 0x1596a
        int64_t v74; // 0x1596c
        if (v8 != 0) {
            v49 = (int64_t)v37 * (int64_t)&g1 + (int64_t)v6;
            v50 = (int32_t)v49;
            v51 = v49 + (int64_t)&g1 + (int64_t)(v50 >> (int32_t)&g23 | v50 << (int32_t)&g25) * (int64_t)&g1 ^ (int64_t)v36;
            v52 = v51 + (int64_t)v13 * (int64_t)&g1;
            v53 = (int32_t)v52;
            v54 = (int32_t)(v52 + (int64_t)&g1 + (int64_t)(v53 >> (int32_t)&g23 | v53 << (int32_t)&g25) * (int64_t)&g1);
            v55 = ((v54 >> (int32_t)&g13 | v54 << (int32_t)&g95) ^ v54) + v5;
            v56 = (v55 >> (int32_t)&g24 | v55 << (int32_t)&g1) - v55;
            v57 = v51;
            v58 = (v56 | v57) ^ v37 ^ (v56 >> (int32_t)&g2 | v56 << (int32_t)&g2);
            v59 = v58 + v14 * (int32_t)&g1;
            v60 = v59 - 1 + (v59 >> (int32_t)&g24 | v59 << (int32_t)&g1) * (int32_t)&g1;
            v61 = v60 ^ v57 ^ (v60 >> (int32_t)&g19 | v60 << (int32_t)&g86);
            v62 = v61 ^ v58;
            v63 = v62 + v18;
            v64 = v63 + (int32_t)&g1 + (v63 >> (int32_t)&g23 | v63 << (int32_t)&g25) * (int32_t)&g1 ^ v61;
            v65 = v64 + v15 * (int32_t)&g1;
            v66 = v65 + (int32_t)&g1 + (v65 >> (int32_t)&g23 | v65 << (int32_t)&g25) * (int32_t)&g1;
            v67 = ((v66 >> (int32_t)&g13 | v66 << (int32_t)&g95) ^ v66) + v16;
            v68 = (v67 >> (int32_t)&g24 | v67 << (int32_t)&g1) - v67;
            v69 = (v68 | v64) ^ v62 ^ (v68 >> (int32_t)&g2 | v68 << (int32_t)&g2);
            v70 = v69 + *(int32_t *)v3 * (int32_t)&g1;
            v71 = v70 - 1 + (v70 >> (int32_t)&g24 | v70 << (int32_t)&g1) * (int32_t)&g1;
            v72 = v71 ^ v64 ^ (v71 >> (int32_t)&g19 | v71 << (int32_t)&g86);
            v73 = v72 ^ v69;
            v74 = &g1;
            v48 = v74 & 0xffffffff;
            v37 = v73;
            while (v8 > (int32_t)v74) {
                // 0x1589f
                v49 = (int64_t)v37 * (int64_t)&g1 + (int64_t)v6;
                v50 = (int32_t)v49;
                v51 = v49 + (int64_t)&g1 + (int64_t)(v50 >> (int32_t)&g23 | v50 << (int32_t)&g25) * (int64_t)&g1 ^ (int64_t)v72;
                v52 = v51 + (int64_t)v13 * (int64_t)&g1;
                v53 = (int32_t)v52;
                v54 = (int32_t)(v52 + (int64_t)&g1 + (int64_t)(v53 >> (int32_t)&g23 | v53 << (int32_t)&g25) * (int64_t)&g1);
                v55 = ((v54 >> (int32_t)&g13 | v54 << (int32_t)&g95) ^ v54) + v5;
                v56 = (v55 >> (int32_t)&g24 | v55 << (int32_t)&g1) - v55;
                v57 = v51;
                v58 = (v56 | v57) ^ v37 ^ (v56 >> (int32_t)&g2 | v56 << (int32_t)&g2);
                v59 = v58 + v14 * (int32_t)&g1;
                v60 = v59 - 1 + (v59 >> (int32_t)&g24 | v59 << (int32_t)&g1) * (int32_t)&g1;
                v61 = v60 ^ v57 ^ (v60 >> (int32_t)&g19 | v60 << (int32_t)&g86);
                v62 = v61 ^ v58;
                v63 = v62 + v18;
                v64 = v63 + (int32_t)&g1 + (v63 >> (int32_t)&g23 | v63 << (int32_t)&g25) * (int32_t)&g1 ^ v61;
                v65 = v64 + v15 * (int32_t)&g1;
                v66 = v65 + (int32_t)&g1 + (v65 >> (int32_t)&g23 | v65 << (int32_t)&g25) * (int32_t)&g1;
                v67 = ((v66 >> (int32_t)&g13 | v66 << (int32_t)&g95) ^ v66) + v16;
                v68 = (v67 >> (int32_t)&g24 | v67 << (int32_t)&g1) - v67;
                v69 = (v68 | v64) ^ v62 ^ (v68 >> (int32_t)&g2 | v68 << (int32_t)&g2);
                v70 = v69 + *(int32_t *)v3 * (int32_t)&g1;
                v71 = v70 - 1 + (v70 >> (int32_t)&g24 | v70 << (int32_t)&g1) * (int32_t)&g1;
                v72 = v71 ^ v64 ^ (v71 >> (int32_t)&g19 | v71 << (int32_t)&g86);
                v73 = v72 ^ v69;
                v74 = v48 + (int64_t)(int32_t)&g1;
                v48 = v74 & 0xffffffff;
                v37 = v73;
            }
            // 0x15977
            v47 = 0x100000000000000 * a3 / 0x100000000000000;
            v12 = v72;
            v38 = (char *)(v47 + (int64_t)&g94);
            v39 = (char *)(v47 + (int64_t)&g91);
            v40 = (char *)(v47 + (int64_t)&g89);
            v41 = (char *)(v47 + (int64_t)&g33);
            v42 = (char *)(v47 + (int64_t)&g25);
            v43 = (char *)(v47 + (int64_t)&g1);
            v44 = (char *)v47;
            v45 = v72;
            v46 = v73;
        }
        int32_t v75 = v4 ^ v45; // 0x15984
        v12 = v75;
        uint32_t v76 = v46 ^ *(int32_t *)(result + (int64_t)&g95); // 0x1598d
        v4 = v27;
        *v44 = (char)(v75 >> (int32_t)&g13);
        int16_t v77; // 0x15728
        *v43 = (char)v77;
        *v42 = (char)(v12 >> (int32_t)&g95);
        *v41 = (char)v12;
        int16_t v78; // 0x15728
        *v40 = (char)v78;
        *v39 = (char)(v76 >> (int32_t)&g95);
        *v38 = (char)v76;
        int64_t v79 = v47 + (int64_t)&g95; // 0x159d4
        while (v11 != v79) {
            int64_t v80 = v79;
            int32_t v81 = v35;
            v19 = (char *)v80;
            v20 = *v19;
            v21 = (char *)(v80 + (int64_t)&g1);
            v22 = *v21;
            v23 = (char *)(v80 + (int64_t)&g33);
            v24 = *v23;
            v25 = (char *)(v80 + (int64_t)&g25);
            v26 = *v25;
            v27 = (int32_t)v22 << (int32_t)&g2 | (int32_t)v20 << (int32_t)&g13 | (int32_t)v24 | (int32_t)v26 << (int32_t)&g95;
            v28 = *(char *)(v80 + (int64_t)&g86);
            v29 = (char *)(v80 + (int64_t)&g89);
            v30 = *v29;
            v31 = (char *)(v80 + (int64_t)&g94);
            v32 = *v31;
            v33 = (char *)(v80 + (int64_t)&g91);
            v34 = *v33;
            v35 = (int32_t)v30 << (int32_t)&g2 | (int32_t)v28 << (int32_t)&g13 | (int32_t)v32 | (int32_t)v34 << (int32_t)&g95;
            v12 = v27;
            v36 = v27;
            v37 = v35;
            v38 = v31;
            v39 = v33;
            v40 = v29;
            v41 = v23;
            v42 = v25;
            v43 = v21;
            v44 = v19;
            v45 = v27;
            v46 = v35;
            v47 = v80;
            if (v8 != 0) {
                v49 = (int64_t)v37 * (int64_t)&g1 + (int64_t)v6;
                v50 = (int32_t)v49;
                v51 = v49 + (int64_t)&g1 + (int64_t)(v50 >> (int32_t)&g23 | v50 << (int32_t)&g25) * (int64_t)&g1 ^ (int64_t)v36;
                v52 = v51 + (int64_t)v13 * (int64_t)&g1;
                v53 = (int32_t)v52;
                v54 = (int32_t)(v52 + (int64_t)&g1 + (int64_t)(v53 >> (int32_t)&g23 | v53 << (int32_t)&g25) * (int64_t)&g1);
                v55 = ((v54 >> (int32_t)&g13 | v54 << (int32_t)&g95) ^ v54) + v5;
                v56 = (v55 >> (int32_t)&g24 | v55 << (int32_t)&g1) - v55;
                v57 = v51;
                v58 = (v56 | v57) ^ v37 ^ (v56 >> (int32_t)&g2 | v56 << (int32_t)&g2);
                v59 = v58 + v14 * (int32_t)&g1;
                v60 = v59 - 1 + (v59 >> (int32_t)&g24 | v59 << (int32_t)&g1) * (int32_t)&g1;
                v61 = v60 ^ v57 ^ (v60 >> (int32_t)&g19 | v60 << (int32_t)&g86);
                v62 = v61 ^ v58;
                v63 = v62 + v18;
                v64 = v63 + (int32_t)&g1 + (v63 >> (int32_t)&g23 | v63 << (int32_t)&g25) * (int32_t)&g1 ^ v61;
                v65 = v64 + v15 * (int32_t)&g1;
                v66 = v65 + (int32_t)&g1 + (v65 >> (int32_t)&g23 | v65 << (int32_t)&g25) * (int32_t)&g1;
                v67 = ((v66 >> (int32_t)&g13 | v66 << (int32_t)&g95) ^ v66) + v16;
                v68 = (v67 >> (int32_t)&g24 | v67 << (int32_t)&g1) - v67;
                v69 = (v68 | v64) ^ v62 ^ (v68 >> (int32_t)&g2 | v68 << (int32_t)&g2);
                v70 = v69 + *(int32_t *)v3 * (int32_t)&g1;
                v71 = v70 - 1 + (v70 >> (int32_t)&g24 | v70 << (int32_t)&g1) * (int32_t)&g1;
                v72 = v71 ^ v64 ^ (v71 >> (int32_t)&g19 | v71 << (int32_t)&g86);
                v73 = v72 ^ v69;
                v74 = &g1;
                v48 = v74 & 0xffffffff;
                v37 = v73;
                while (v8 > (int32_t)v74) {
                    // 0x1589f
                    v49 = (int64_t)v37 * (int64_t)&g1 + (int64_t)v6;
                    v50 = (int32_t)v49;
                    v51 = v49 + (int64_t)&g1 + (int64_t)(v50 >> (int32_t)&g23 | v50 << (int32_t)&g25) * (int64_t)&g1 ^ (int64_t)v72;
                    v52 = v51 + (int64_t)v13 * (int64_t)&g1;
                    v53 = (int32_t)v52;
                    v54 = (int32_t)(v52 + (int64_t)&g1 + (int64_t)(v53 >> (int32_t)&g23 | v53 << (int32_t)&g25) * (int64_t)&g1);
                    v55 = ((v54 >> (int32_t)&g13 | v54 << (int32_t)&g95) ^ v54) + v5;
                    v56 = (v55 >> (int32_t)&g24 | v55 << (int32_t)&g1) - v55;
                    v57 = v51;
                    v58 = (v56 | v57) ^ v37 ^ (v56 >> (int32_t)&g2 | v56 << (int32_t)&g2);
                    v59 = v58 + v14 * (int32_t)&g1;
                    v60 = v59 - 1 + (v59 >> (int32_t)&g24 | v59 << (int32_t)&g1) * (int32_t)&g1;
                    v61 = v60 ^ v57 ^ (v60 >> (int32_t)&g19 | v60 << (int32_t)&g86);
                    v62 = v61 ^ v58;
                    v63 = v62 + v18;
                    v64 = v63 + (int32_t)&g1 + (v63 >> (int32_t)&g23 | v63 << (int32_t)&g25) * (int32_t)&g1 ^ v61;
                    v65 = v64 + v15 * (int32_t)&g1;
                    v66 = v65 + (int32_t)&g1 + (v65 >> (int32_t)&g23 | v65 << (int32_t)&g25) * (int32_t)&g1;
                    v67 = ((v66 >> (int32_t)&g13 | v66 << (int32_t)&g95) ^ v66) + v16;
                    v68 = (v67 >> (int32_t)&g24 | v67 << (int32_t)&g1) - v67;
                    v69 = (v68 | v64) ^ v62 ^ (v68 >> (int32_t)&g2 | v68 << (int32_t)&g2);
                    v70 = v69 + *(int32_t *)v3 * (int32_t)&g1;
                    v71 = v70 - 1 + (v70 >> (int32_t)&g24 | v70 << (int32_t)&g1) * (int32_t)&g1;
                    v72 = v71 ^ v64 ^ (v71 >> (int32_t)&g19 | v71 << (int32_t)&g86);
                    v73 = v72 ^ v69;
                    v74 = v48 + (int64_t)(int32_t)&g1;
                    v48 = v74 & 0xffffffff;
                    v37 = v73;
                }
                // 0x15977
                v47 = 0x100000000000000 * v80 / 0x100000000000000;
                v12 = v72;
                v38 = (char *)(v47 + (int64_t)&g94);
                v39 = (char *)(v47 + (int64_t)&g91);
                v40 = (char *)(v47 + (int64_t)&g89);
                v41 = (char *)(v47 + (int64_t)&g33);
                v42 = (char *)(v47 + (int64_t)&g25);
                v43 = (char *)(v47 + (int64_t)&g1);
                v44 = (char *)v47;
                v45 = v72;
                v46 = v73;
            }
            // 0x15981
            v75 = v4 ^ v45;
            v12 = v75;
            v76 = v46 ^ v81;
            v4 = v27;
            *v44 = (char)(v75 >> (int32_t)&g13);
            *v43 = (char)v77;
            *v42 = (char)(v12 >> (int32_t)&g95);
            *v41 = (char)v12;
            *v40 = (char)v78;
            *v39 = (char)(v76 >> (int32_t)&g95);
            *v38 = (char)v76;
            v79 = v47 + (int64_t)&g95;
        }
        // 0x159e5
        v9 = *v7;
        v10 = 0x100000000 * (v1 + 0xfffffff8 + (int64_t)-((v17 << (int32_t)&g33)) * (int64_t)&g1) / 0x100000000;
    }
    // 0x15a17
    core_encrypt2(&v12, &v4, v3, v9);
    int32_t * v82 = (int32_t *)(int64_t)((v12 >> (int32_t)&g13) % 256); // bp-72, 0x15a36
    int64_t result2 = v11; // 0x15a71
    int64_t v83 = (int64_t)&v82; // 0x15a71
    char * v84 = (char *)result2; // 0x15a77
    *v84 = *v84 ^ *(char *)v83;
    result2 += (int64_t)&g1;
    v83 += (int64_t)&g1;
    while ((v10 & 0xffffffff) > (result2 - v11 & 0xffffffff)) {
        // 0x15a74
        v84 = (char *)result2;
        *v84 = *v84 ^ *(char *)v83;
        result2 += (int64_t)&g1;
        v83 += (int64_t)&g1;
    }
    // 0x15a89
    return result2;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x15a8f - 0x15abf
// Line range:    296 - 359
int32_t encrypt_multi2(char * m2, int32_t type, char * buf, int32_t size) {
    // 0x15a8f
    int64_t result; // 0x15a8f
    return result;
}

// Address range: 0x15abf - 0x15cdb
int64_t encrypt_multi2_(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x15abf
    mcount();
    __readgsqword(40);
    int64_t v1 = private_data2(a1); // 0x15af7
    int32_t v2 = a4; // 0x15b11
    if (v2 < 1 || a3 == 0 || v1 == 0) {
        // 0x15cd4
        return 0xffffffff;
    }
    int64_t v3 = a4 & 0xffffffff; // 0x15ae5
    int64_t v4 = v1 + ((int32_t)a2 != (int32_t)&g25 ? 60 : 92); // 0x15b59
    int32_t v5 = *(int32_t *)(v1 + (int64_t)&g86); // 0x15b61
    int32_t v6 = v5; // bp-104, 0x15b66
    uint32_t v7 = *(int32_t *)(v1 + (int64_t)&g95); // 0x15b69
    int32_t * v8 = (int32_t *)(v1 + 124);
    v6 = v5;
    int64_t v9 = a3; // 0x15b7f
    int64_t v10 = v3; // 0x15b7f
    int32_t v11; // bp-88, 0x15abf
    if (v2 > (int32_t)&g94) {
        char v12 = v7 >> (int32_t)&g13;
        char v13 = v7 >> (int32_t)&g2;
        char v14 = v7 >> (int32_t)&g95;
        int64_t v15 = a3; // 0x15abf
        char * v16 = (char *)v15; // 0x15b85
        unsigned char v17 = *v16; // 0x15b85
        char * v18 = (char *)(v15 + (int64_t)&g1); // 0x15b8b
        unsigned char v19 = *v18; // 0x15b8b
        char * v20 = (char *)(v15 + (int64_t)&g33); // 0x15b94
        unsigned char v21 = *v20; // 0x15b94
        char * v22 = (char *)(v15 + (int64_t)&g25); // 0x15b9a
        unsigned char v23 = *v22; // 0x15b9a
        v11 = ((int32_t)v19 << (int32_t)&g2 | (int32_t)v17 << (int32_t)&g13 | (int32_t)v21 | (int32_t)v23 << (int32_t)&g95) ^ v5;
        core_encrypt2(&v6, &v11, v4, *v8);
        *v16 = (char)(v6 >> (int32_t)&g13);
        *v18 = (char)(v6 >> (int32_t)&g2);
        *v22 = (char)(v6 >> (int32_t)&g95);
        *v20 = (char)v6;
        *(char *)(v15 + (int64_t)&g86) = v12;
        *(char *)(v15 + (int64_t)&g89) = v13;
        *(char *)(v15 + (int64_t)&g91) = v14;
        *(char *)(v15 + (int64_t)&g94) = (char)v7;
        int64_t v24 = v3 - (int64_t)(int32_t)&g95; // 0x15c28
        while ((int32_t)v24 > (int32_t)&g94) {
            // 0x15b85
            v15 += (int64_t)&g95;
            v16 = (char *)v15;
            v17 = *v16;
            v18 = (char *)(v15 + (int64_t)&g1);
            v19 = *v18;
            v20 = (char *)(v15 + (int64_t)&g33);
            v21 = *v20;
            v22 = (char *)(v15 + (int64_t)&g25);
            v23 = *v22;
            v11 = ((int32_t)v19 << (int32_t)&g2 | (int32_t)v17 << (int32_t)&g13 | (int32_t)v21 | (int32_t)v23 << (int32_t)&g95) ^ v6;
            core_encrypt2(&v6, &v11, v4, *v8);
            *v16 = (char)(v6 >> (int32_t)&g13);
            *v18 = (char)(v6 >> (int32_t)&g2);
            *v22 = (char)(v6 >> (int32_t)&g95);
            *v20 = (char)v6;
            *(char *)(v15 + (int64_t)&g86) = v12;
            *(char *)(v15 + (int64_t)&g89) = v13;
            *(char *)(v15 + (int64_t)&g91) = v14;
            *(char *)(v15 + (int64_t)&g94) = (char)v7;
            v24 = (v24 & 0xffffffff) - (int64_t)(int32_t)&g95;
        }
        int64_t v25 = v3 - (int64_t)(int32_t)&g95; // 0x15c36
        v9 = a3 + (int64_t)&g95 + (int64_t)((int32_t)v25 >> (int32_t)&g33) * (int64_t)&g95;
        v10 = v25 & (int64_t)(int32_t)&g94;
    }
    // 0x15c55
    v11 = v6;
    core_encrypt2(&v6, &v11, v4, *v8);
    int32_t * v26 = (int32_t *)(int64_t)((v6 >> (int32_t)&g13) % 256); // bp-72, 0x15c7f
    int64_t result = v9; // 0x15cbb
    int64_t v27 = (int64_t)&v26; // 0x15cbb
    char * v28 = (char *)result; // 0x15cc1
    *v28 = *v28 ^ *(char *)v27;
    result += (int64_t)&g1;
    v27 += (int64_t)&g1;
    while (v10 > (result - v9 & 0xffffffff)) {
        // 0x15cbe
        v28 = (char *)result;
        *v28 = *v28 ^ *(char *)v27;
        result += (int64_t)&g1;
        v27 += (int64_t)&g1;
    }
    // 0x15cd4
    return result;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x15cdc - 0x15d0c
// Line range:    527 - 556
void core_schedule(int64_t work, int64_t skey, int64_t dkey) {
    // 0x15cdc
    int64_t v1; // 0x15cdc
    int64_t v2 = v1 + 184; // 0x15cdc
    char * v3 = (char *)((v2 & 0xffffffff) - 117); // 0x15ce1
    unsigned char v4 = *v3; // 0x15ce1
    int64_t v5; // 0x15cdc
    unsigned char v6 = v4 + (char)v5; // 0x15ce1
    *v3 = v6;
    if (*(char *)((v1 + 221 + (int64_t)(v6 < v4)) % 256 || v2 & 0xffffff00) != 0) {
        // 0x15cf1
        __stack_chk_fail();
    }
}

// Address range: 0x15d0c - 0x15e0e
int64_t core_schedule2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x15d0c
    mcount();
    int64_t v1; // bp-72, 0x15d0c
    core_pi1_(&v1);
    int32_t v2; // bp-88, 0x15d0c
    int64_t v3; // 0x15d0c
    core_pi2_((int64_t *)&v2, &v1, (int32_t)v3);
    *(int32_t *)a1 = v2;
    uint32_t v4 = *(int32_t *)(a2 + (int64_t)&g86); // 0x15d60
    int64_t v5; // bp-104, 0x15d0c
    int64_t v6 = &v5; // 0x15d6a
    core_pi3_(v6, (int64_t)&v2, (int64_t)v4);
    int32_t v7 = *(int32_t *)(a2 + (int64_t)"GNU"); // 0x15d7a
    int32_t v8; // bp-120, 0x15d0c
    core_pi4_((int64_t)&v8, v6, v7);
    *(int32_t *)(a1 + (int64_t)&g95) = v8;
    int64_t v9; // bp-136, 0x15d0c
    core_pi1_(&v9);
    int32_t v10 = *(int32_t *)(a2 + (int64_t)&g2); // 0x15dab
    int32_t v11; // bp-152, 0x15d0c
    core_pi2_((int64_t *)&v11, &v9, v10);
    *(int32_t *)(a1 + (int64_t)&g2) = v11;
    uint32_t v12 = *(int32_t *)(a2 + (int64_t)&g7); // 0x15dce
    int64_t v13; // bp-168, 0x15d0c
    int64_t v14 = &v13; // 0x15ddb
    core_pi3_(v14, (int64_t)&v11, (int64_t)v12);
    int32_t v15 = *(int32_t *)(a2 + (int64_t)&g19); // 0x15dee
    int32_t result; // bp-184, 0x15d0c
    core_pi4_((int64_t)&result, v14, v15);
    *(int32_t *)(a1 + (int64_t)&g13) = result;
    return result;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x15e0e - 0x15e3e
// Line range:    253 - 277
int32_t set_scramble_key_multi2(char * m2, char * val) {
    // 0x15e0e
    int64_t v1; // 0x15e0e
    core_pi1_((int64_t *)(v1 - 192));
    int32_t result = *(int32_t *)(v1 - 188); // 0x15e1d
    int64_t v2; // 0x15e0e
    *(int32_t *)(v2 + (int64_t)&g19) = result;
    return result;
}

// Address range: 0x15e3e - 0x15f13
int64_t set_scramble_key_multi2_(int64_t a1, int64_t a2) {
    // 0x15e3e
    mcount();
    int64_t v1 = private_data2(a1); // 0x15e4d
    if (a2 != 0 != v1 != 0) {
        // 0x15e5f
        return 0xffffffff;
    }
    unsigned char v2 = *(char *)(a2 + (int64_t)&g33); // 0x15e69
    unsigned char v3 = *(char *)(a2 + (int64_t)&g1); // 0x15e79
    unsigned char v4 = *(char *)(a2 + (int64_t)&g25); // 0x15e84
    int64_t v5; // 0x15e3e
    *(int32_t *)(v1 + 44) = (int32_t)v5 % 256 << (int32_t)&g13 | (int32_t)v2 | (int32_t)v3 << (int32_t)&g2 | (int32_t)v4 << (int32_t)&g95;
    unsigned char v6 = *(char *)(a2 + (int64_t)&g86 + (int64_t)&g33); // 0x15e97
    unsigned char v7 = *(char *)(a2 + (int64_t)&g86); // 0x15e9b
    unsigned char v8 = *(char *)(a2 + (int64_t)&g86 + (int64_t)&g1); // 0x15ea3
    unsigned char v9 = *(char *)(a2 + (int64_t)&g86 + (int64_t)&g25); // 0x15eac
    *(int32_t *)(v1 + 48) = (int32_t)v7 << (int32_t)&g13 | (int32_t)v6 | (int32_t)v8 << (int32_t)&g2 | (int32_t)v9 << (int32_t)&g95;
    unsigned char v10 = *(char *)(a2 + (int64_t)&g95 + (int64_t)&g33); // 0x15ebf
    unsigned char v11 = *(char *)(a2 + (int64_t)&g95); // 0x15ec3
    unsigned char v12 = *(char *)(a2 + (int64_t)&g95 + (int64_t)&g1); // 0x15ecb
    unsigned char v13 = *(char *)(a2 + (int64_t)&g95 + (int64_t)&g25); // 0x15ed4
    *(int32_t *)(v1 + 52) = (int32_t)v11 << (int32_t)&g13 | (int32_t)v10 | (int32_t)v12 << (int32_t)&g2 | (int32_t)v13 << (int32_t)&g95;
    unsigned char v14 = *(char *)(a2 + (int64_t)"GNU" + (int64_t)&g33); // 0x15ee6
    unsigned char v15 = *(char *)(a2 + (int64_t)"GNU"); // 0x15eec
    unsigned char v16 = *(char *)(a2 + (int64_t)"GNU" + (int64_t)&g1); // 0x15ef6
    unsigned char v17 = *(char *)(a2 + (int64_t)"GNU" + (int64_t)&g25); // 0x15f01
    uint32_t result = (int32_t)v15 << (int32_t)&g13 | (int32_t)v14 | (int32_t)v16 << (int32_t)&g2 | (int32_t)v17 << (int32_t)&g95; // 0x15f0a
    *(int32_t *)(v1 + 56) = result;
    return result;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x15f14 - 0x15f44
// Line range:    279 - 294
int32_t clear_scramble_key_multi2(char * m2) {
    // 0x15f14
    int64_t v1; // 0x15f14
    int64_t v2; // 0x15f14
    core_schedule2(v2 + 60, v1, v2 + 44 & 0xffffffff);
    core_schedule2(v2 + 92, v1, v2 + 52);
    int32_t * v3 = (int32_t *)(v2 + 128); // 0x15f33
    *v3 = *v3 | 4;
    return 0;
}

// Address range: 0x15f44 - 0x15f99
int64_t clear_scramble_key_multi2_(void) {
    // 0x15f44
    mcount();
    int64_t v1; // 0x15f44
    int64_t v2 = private_data2(v1); // 0x15f4d
    *(int64_t *)(v2 + 44) = 0;
    *(int64_t *)(v2 + 52) = 0;
    int64_t v3 = v2 + 60; // 0x15f72
    int64_t v4 = 8; // 0x15f84
    int64_t v5 = v3; // 0x15f84
    if ((v3 & 4) != 0) {
        // 0x15f86
        *(int32_t *)v3 = 0;
        v4 = 7;
        v5 = v2 + 64;
    }
    // 0x15f8f
    __asm_rep_stosq_memset((char *)v5, 0, v4);
    return 0;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x15f9c - 0x15fcc
// Line range:    105 - 139
int64_t create_multi2(void) {
    // 0x15f9c
    int64_t v1; // 0x15f9c
    return (uint64_t)(v1 + 116) % 256 | v1 & -256;
}

// Address range: 0x15f9f - 0x15fca
int64_t function_15f9f(int64_t a1, int64_t a2, int64_t a3) {
    // 0x15f9f
    int64_t v1; // 0x15f9f
    *(int32_t *)a1 = (int32_t)v1;
    int64_t v2 = a1 + (int64_t)&g86; // 0x15fa1
    int32_t v3 = a2;
    int64_t v4 = v2; // 0x15fac
    if ((v3 & (int32_t)&g25) != 0) {
        // 0x15fae
        *(int16_t *)v2 = (int16_t)v1;
        v4 = a1 + (int64_t)&g86 + (int64_t)&g25;
    }
    if ((v3 & (int32_t)&g1) != 0) {
        // 0x15fbc
        *(char *)v4 = (char)v1;
    }
    int32_t * v5 = (int32_t *)(a3 + 128); // 0x15fbe
    *v5 = *v5 & -5;
    return 0;
}

// Address range: 0x15fcc - 0x160e4
int64_t create_multi2_(void) {
    // 0x15fcc
    mcount();
    int64_t v1 = *(int64_t *)0x3ed28; // 0x15fec
    int64_t v2 = kmem_cache_alloc_notrace(v1, (int64_t *)&g26); // 0x15ffb
    slab_buffer_size(v1);
    if (g84 != 0) {
        // 0x1601e
        if (g85 != 0) {
            int64_t v3 = g85 + (int64_t)&g95; // 0x16041
            int64_t v4 = v3; // 0x16049
            while (*(int64_t *)v3 != 0) {
                // 0x1602a
                v3 = v4 + (int64_t)&g95;
                v4 = v3;
            }
        }
    }
    int64_t v5 = 212; // 0x16065
    int64_t v6 = v2; // 0x16065
    if (((char)v2 & (char)&g86) != 0) {
        // 0x16067
        *(int32_t *)v2 = 0;
        v5 = 208;
        v6 = v2 + (int64_t)&g86;
    }
    int64_t v7 = (int32_t)v5 >> (int32_t)&g33; // 0x16077
    __asm_rep_stosq_memset((char *)v6, 0, v7);
    if ((v5 & 4) != 0) {
        // 0x16081
        bool v8; // 0x15fcc
        *(int32_t *)((v8 ? -8 : (int64_t)&g95) * v7 + v6) = 0;
    }
    int64_t result = v2 + 132; // 0x160a0
    *(int64_t *)result = v2;
    *(int32_t *)v2 = (int32_t)&g1;
    *(int32_t *)(v2 + 124) = (int32_t)&g86;
    *(int64_t *)(v2 + 140) = 0;
    *(int64_t *)(v2 + 148) = 0;
    *(int64_t *)(v2 + 156) = 0;
    *(int64_t *)(v2 + 164) = 0;
    *(int64_t *)(v2 + 172) = 0;
    return result;
}

// From module:   /root/asv5220\multi2.c
// Address range: 0x160e9 - 0x1610d
// Line range:    165 - 179
void release_multi2(char * m2) {
    // 0x160e9
    int64_t v1; // 0x160e9
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x160e9
    char * v3 = (char *)(v2 - 57); // 0x160eb
    int64_t v4; // 0x160e9
    char v5 = v4; // 0x160eb
    *v3 = *v3 + v5;
    int64_t v6 = v2;
    *(char *)v6 = *(char *)&v2 + (char)v6;
    char * v7 = (char *)(v2 - 57); // 0x160f3
    *v7 = *v7 + v5;
    int64_t v8 = v2;
    *(char *)v8 = *(char *)&v2 + (char)v8;
    int64_t v9 = v2;
    *(char *)v9 = *(char *)&v2 + (char)v9;
    *(int64_t *)(v2 + 72) = 0;
}

// Address range: 0x1610d - 0x16119
int64_t function_1610d(int64_t a1, int64_t a2) {
    // 0x1610d
    int64_t result; // 0x1610d
    return result;
}

// Address range: 0x16119 - 0x1611d
int64_t release_multi2_(void) {
    // 0x16119
    int64_t result; // 0x16119
    return result;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x16120 - 0x16141
// Line range:    131 - 143
void TS_Reset(char * Multi2_Lib) {
    int64_t v1 = private_data2((int64_t)Multi2_Lib); // 0x16122
    if (v1 == 0) {
        // 0x1613f
        return;
    }
    int32_t * v2 = (int32_t *)v1; // 0x1612c
    int32_t v3 = *v2 - (int32_t)&g1; // 0x1612e
    *v2 = v3;
    if (v3 == 0) {
        // 0x16137
        kfree(v1);
    }
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x1614e - 0x16150
// Line range:    145 - 164
void TS_Destroy(char * Multi2_Lib) {
    // 0x1614e
    return;
}

// Address range: 0x16150 - 0x1617e
int64_t TS_Reset2(int64_t a1) {
    int64_t result = mcount(); // 0x16159
    if (a1 == 0) {
        // 0x16177
        return result;
    }
    char * v1 = (char *)(a1 + (int64_t)&g95); // 0x16166
    if (*v1 == 0) {
        // 0x1616c
        *v1 = 0;
    }
    // 0x16177
    return result;
}

// Address range: 0x1617e - 0x16183
int64_t TS_Destroy2(int64_t a1) {
    // 0x1617e
    int64_t result; // 0x1617e
    return result;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x16184 - 0x1619f
// Line range:    257 - 266
char * TS_GetBcasPtr(char * Multi2_Lib) {
    // 0x16184
    return (char *)mcount();
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x1619f - 0x161b4
// Line range:    268 - 275
void TS_SetBcasCardID(char * Multi2_Lib, char * buffer, int32_t size) {
    // 0x1619f
    return;
}

// Address range: 0x161b4 - 0x161b5
int64_t TS_GetBcasPtr2(int64_t a1) {
    // 0x161b4
    int64_t result; // 0x161b4
    return result;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x161b5 - 0x161cf
// Line range:    277 - 292
void TS_EnableProcProgramID(char * Multi2_Lib, char enable) {
    // 0x161b5
    mcount();
}

// Address range: 0x161cf - 0x161e0
int64_t TS_SetBcasCardID2(int64_t result) {
    // 0x161cf
    mcount();
    return result;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x161e1 - 0x161e5
// Line range:    294 - 300
void TS_SetProgramID(char * Multi2_Lib, int16_t program_id) {
    // 0x161e1
    return;
}

// Address range: 0x161e5 - 0x161f9
int64_t TS_EnableProcProgramID2(int64_t result, int64_t a2) {
    // 0x161e5
    mcount();
    return result;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x161fa - 0x16211
// Line range:    302 - 314
void TS_GetTsProgramID(char * Multi2_Lib, char index, int16_t * program_id) {
    // 0x161fa
    return;
}

// Address range: 0x16211 - 0x1622a
int64_t TS_SetProgramID2(int64_t result, int64_t a2) {
    // 0x16211
    mcount();
    return result;
}

// Address range: 0x1622a - 0x1622f
int64_t TS_GetTsProgramID2(void) {
    // 0x1622a
    int64_t result; // 0x1622a
    return result;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x16231 - 0x16257
// Line range:    316 - 328
char TS_GetTsProgramID_Ex(char * Multi2_Lib, char * program_id) {
    // 0x16231
    int64_t v1; // 0x16231
    __asm_in((int16_t)v1);
    int64_t v2; // 0x16231
    return (char)*(int16_t *)(v2 - 18);
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x16259 - 0x16261
// Line range:    330 - 336
void TS_SetIsStreamScramble(char * Multi2_Lib, char isStreamScramble) {
    // 0x16259
    return;
}

// Address range: 0x16261 - 0x16272
int64_t TS_GetTsProgramID_Ex2(int64_t result) {
    // 0x16261
    mcount();
    return result;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x16273 - 0x16289
// Line range:    338 - 344
void TS_GetIsStreamScramble(char * Multi2_Lib, char * isStreamScramble) {
    // 0x16273
    return;
}

// Address range: 0x16289 - 0x1628a
int64_t TS_SetIsStreamScramble2(int64_t a1, int64_t a2) {
    // 0x16289
    int64_t result; // 0x16289
    return result;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x1628c - 0x162a3
// Line range:    346 - 352
void TS_SetBCASCardExist(char * Multi2_Lib, char isExist) {
    int32_t v1 = __asm_in_624(232); // 0x1628c
    int64_t v2; // 0x1628c
    *(int32_t *)v2 = v1;
    char * v3 = (char *)((int64_t)v1 - 119); // 0x16291
    int64_t v4; // 0x1628c
    *v3 = *v3 + (char)v4;
}

// Address range: 0x162a3 - 0x162a7
int64_t TS_GetIsStreamScramble2(int64_t a1) {
    // 0x162a3
    int64_t result; // 0x162a3
    return result;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x162a9 - 0x162bc
// Line range:    354 - 360
void TS_GetResetMulti2LibFlag(char * Multi2_Lib, char * isNeedResetMulti2Lib) {
    // 0x162a9
    int64_t v1; // 0x162a9
    int64_t v2; // 0x162a9
    *(int32_t *)v1 = (int32_t)v2;
    char * v3 = (char *)(v2 - 119); // 0x162ab
    int64_t v4; // 0x162a9
    *v3 = *v3 + (char)v4;
}

// Address range: 0x162bc - 0x162c0
int64_t TS_SetBCASCardExist2(int64_t a1, int64_t a2) {
    // 0x162bc
    int64_t result; // 0x162bc
    return result;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x162c2 - 0x162d9
// Line range:    362 - 381
char TS_GetDigitalCopyControlDescriptor(char * Multi2_Lib, int16_t pid, char * dataBuffer, int16_t * length) {
    // 0x162c2
    int64_t result; // 0x162c2
    *(int32_t *)dataBuffer = (int32_t)result;
    char * v1 = (char *)(result - 119); // 0x162c4
    *v1 = *v1 + (char)(int64_t)length;
    return result;
}

// Address range: 0x162d9 - 0x162f2
int64_t TS_GetResetMulti2LibFlag2(int64_t result) {
    // 0x162d9
    mcount();
    return result;
}

// Address range: 0x162f2 - 0x16303
int64_t TS_GetDigitalCopyControlDescriptor2(int64_t result) {
    // 0x162f2
    mcount();
    return result;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x16303 - 0x16333
// Line range:    383 - 402
char TS_GetContentAvailabilityDescriptor(char * Multi2_Lib, int16_t pid, char * dataBuffer, int16_t * length) {
    // 0x16303
    int64_t v1; // 0x16303
    bool v2 = Multi2_Lib == NULL | (int32_t)v1 < 0;
    *length = v2 ? 0 : (int16_t)v1;
    return v2 ? 0 : (char)&g1;
}

// Address range: 0x16333 - 0x16344
int64_t TS_GetContentAvailabilityDescriptor2(int64_t result) {
    // 0x16333
    mcount();
    return result;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x16344 - 0x1636d
// Line range:    404 - 422
char TS_GetProgramNumber_ByPID(char * Multi2_Lib, int16_t pid, int32_t * program_number) {
    // 0x16344
    int64_t v1; // 0x16344
    bool v2 = Multi2_Lib == NULL | (int32_t)v1 < 0;
    int64_t v3; // 0x16344
    *(int16_t *)v3 = v2 ? 0 : (int16_t)v1;
    return v2 ? 0 : (char)&g1;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x16370 - 0x16374
// Line range:    168 - 255
void TS_SetBCASResponse(char * buffer, int32_t size, char bInitCmd, char * bcas) {
    // 0x16370
    int64_t v1; // 0x16370
    char * v2 = (char *)(v1 - 55); // 0x16370
    *v2 = *v2 | (char)v1;
}

// Address range: 0x16374 - 0x163a0
int64_t TS_GetProgramNumber_ByPID2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x16374
    mcount();
    *(int32_t *)a3 = 0;
    return 0;
}

// Address range: 0x163a0 - 0x16499
int64_t TS_SetBCASResponse2(int64_t a1, int32_t a2, char a3, int64_t a4) {
    int64_t v1 = a2;
    mcount();
    if ((a3 & (char)&g1) != 0) {
        // 0x16467
        memcpy(a4 + 86, a1, v1 & 0xffffffff, a4);
        *(int32_t *)(a4 + 600) = a2;
        int64_t result = a4 + 40; // 0x1647f
        *(int64_t *)result = *(int64_t *)(a4 + 102);
        *(int64_t *)(a4 + 48) = *(int64_t *)(a4 + 110);
        return result;
    }
    // 0x163d9
    memcpy(a4 + 606, a1, v1 & 0xffffffff, a4);
    *(int32_t *)(a4 + 1120) = a2;
    unsigned char v2 = *(char *)(a4 + 611); // 0x16415
    int64_t result2 = 256 * (int64_t)*(char *)(a4 + 610) | (int64_t)v2; // 0x1641c
    if (result2 == 0x2100) {
        // 0x16430
        *(char *)(a4 + 604) = 0;
        return result2;
    }
    int16_t v3 = result2; // 0x16424
    if (v3 != -0x5efe != v3 != -0x5ef9) {
        // 0x16430
        *(char *)(a4 + 604) = 0;
        return result2;
    }
    switch (v3) {
        case 2048: {
        }
        case 1024: {
        }
        case 512: {
            // 0x16457
            *(char *)(a4 + 605) = (char)&g1;
            // break -> 0x1645e
            break;
        }
        default: {
            // 0x1644e
            *(char *)(a4 + 605) = 0;
            // break -> 0x1645e
            break;
        }
    }
    // 0x1645e
    *(char *)(a4 + 604) = (char)&g1;
    return result2;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x16499 - 0x164c9
// Line range:    95 - 129
int32_t TS_Process(char * Multi2_Lib, char * pbuf, int32_t size) {
    int64_t v1 = *(int64_t *)((int64_t)size + (int64_t)&g13); // 0x1649d
    int64_t v2; // 0x16499
    *(int64_t *)(v2 + (int64_t)&g13) = v1;
    int64_t v3; // 0x16499
    *(int64_t *)(v3 + 72) = *(int64_t *)(v3 + 134);
    unsigned char v4 = *(char *)(v3 + 88); // 0x164b4
    int32_t result = 256 * (int32_t)v4 | (int32_t)*(char *)(v3 + 89); // 0x164bb
    *(int32_t *)(v3 + 80) = result;
    *(char *)(v3 + 84) = (char)&g1;
    return result;
}

// Address range: 0x164c9 - 0x16511
int64_t TS_Process2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x164c9
    mcount();
    *(char *)(a1 + (int64_t)&g95) = (char)&g1;
    return a3 & 0xffffffff;
}

// From module:   /root/asv5220\multi2_lib.c
// Address range: 0x16513 - 0x16543
// Line range:    35 - 82
char * TS_Init(char * DevExt, int32_t (*bcas_callback)(char *, char *, int32_t, char, char *), char ucTunerNum) {
    // 0x16513
    int64_t v1; // 0x16513
    *(char *)(v1 + (int64_t)&g95) = 0;
    int64_t v2; // 0x16513
    int32_t * v3 = (int32_t *)(v2 - 56); // 0x16518
    int32_t v4 = *v3; // 0x16518
    if (v4 > v4) {
        // 0x1651e
        *v3 = v4;
    }
    // 0x16522
    int64_t v5; // 0x16513
    int64_t v6; // 0x16513
    memcpy(v5, *(int64_t *)(v2 - 64), (int64_t)v4, v6);
    return (char *)(int64_t)*v3;
}

// Address range: 0x16543 - 0x165ce
int64_t TS_Init2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x16543
    mcount();
    int64_t result = create_arib_std_b25_(); // 0x16571
    if (result == 0 || (int32_t)result < 0) {
        // 0x165ce
        return result;
    }
    int64_t v1 = create_b_cas_card2(a1, a2); // 0x16593
    if (v1 == 0) {
        // 0x165ce
        return 0;
    }
    // 0x165a0
    *(int32_t *)(v1 + 380) = (int32_t)a3 % 256;
    return result;
}

// From module:   /root/asv5220\AES_TS.c
// Address range: 0x165d0 - 0x165ff
// Line range:    731 - 820
int32_t rijndaelKeySetupEnc(int32_t * rk, char * cipherKey, int32_t keyBits, int64_t pTable) {
    // 0x165d0
    int64_t result; // 0x165d0
    *(char *)result = 2 * (char)result;
    return result;
}

// Address range: 0x16600 - 0x1698c
int64_t rijndaelKeySetupEnc2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x16600
    mcount();
    unsigned char v1 = *(char *)(a2 + (int64_t)&g33); // 0x16609
    unsigned char v2 = *(char *)(a2 + (int64_t)&g1); // 0x16617
    unsigned char v3 = *(char *)(a2 + (int64_t)&g25); // 0x16623
    *(int32_t *)a1 = (int32_t)a2 % 256 << (int32_t)&g13 ^ (int32_t)v1 ^ (int32_t)v2 << (int32_t)&g2 ^ (int32_t)v3 << (int32_t)&g95;
    unsigned char v4 = *(char *)(a2 + (int64_t)&g86); // 0x16631
    unsigned char v5 = *(char *)(a2 + (int64_t)&g89); // 0x1663a
    unsigned char v6 = *(char *)(a2 + (int64_t)&g94); // 0x16644
    unsigned char v7 = *(char *)(a2 + (int64_t)&g91); // 0x1664c
    *(int32_t *)(a1 + (int64_t)&g86) = (int32_t)v5 << (int32_t)&g2 ^ (int32_t)v4 << (int32_t)&g13 ^ (int32_t)v6 ^ (int32_t)v7 << (int32_t)&g95;
    unsigned char v8 = *(char *)(a2 + (int64_t)&g95); // 0x1665b
    unsigned char v9 = *(char *)(a2 + (int64_t)&g97); // 0x16664
    unsigned char v10 = *(char *)(a2 + (int64_t)&g99); // 0x1666e
    unsigned char v11 = *(char *)(a2 + (int64_t)&g98); // 0x16676
    *(int32_t *)(a1 + (int64_t)&g95) = (int32_t)v9 << (int32_t)&g2 ^ (int32_t)v8 << (int32_t)&g13 ^ (int32_t)v10 ^ (int32_t)v11 << (int32_t)&g95;
    unsigned char v12 = *(char *)(a2 + (int64_t)"GNU"); // 0x16685
    unsigned char v13 = *(char *)(a2 + (int64_t)"NU"); // 0x1668e
    unsigned char v14 = *(char *)(a2 + (int64_t)&g105); // 0x16698
    unsigned char v15 = *(char *)(a2 + (int64_t)&g103); // 0x166a0
    *(int32_t *)(a1 + (int64_t)"GNU") = (int32_t)v13 << (int32_t)&g2 ^ (int32_t)v12 << (int32_t)&g13 ^ (int32_t)v14 ^ (int32_t)v15 << (int32_t)&g95;
    int32_t v16 = a3; // 0x166af
    if (v16 == 128) {
        int64_t v17 = a4 + 0x1000; // 0x166d7
        int64_t v18 = a4; // 0x166be
        int32_t * v19 = (int32_t *)(a1 + 12); // 0x166c2
        uint32_t v20 = *v19; // 0x166c2
        int64_t v21 = a1 + 16; // 0x166c5
        int32_t v22 = *(int32_t *)(v18 + 0x2800); // 0x166c9
        int32_t v23 = *(int32_t *)a1; // 0x166d0
        int32_t v24 = *(int32_t *)(v17 + (int64_t)(4 * v20 & 1020)); // 0x166d7
        unsigned char v25 = *(char *)(v17 + (int64_t)(4 * v20 / 0x1000000)); // 0x166ee
        int32_t v26 = *(int32_t *)(v17 + (int64_t)(v20 / 0x4000 & 1020)); // 0x16702
        int32_t v27 = *(int32_t *)(v17 + (int64_t)(v20 / 64 & 1020)); // 0x16715
        int32_t v28 = v23 ^ v22 ^ v24 & 0xff00 ^ (int32_t)v25 ^ v26 & -0x1000000 ^ v27 & 0xff0000; // 0x16725
        *(int32_t *)v21 = v28;
        int32_t v29 = v28 ^ *(int32_t *)(a1 + 4); // 0x16729
        *(int32_t *)(a1 + 20) = v29;
        int32_t v30 = *(int32_t *)(a1 + 8) ^ v29; // 0x1672f
        *(int32_t *)(a1 + 24) = v30;
        uint32_t result = *v19 ^ v30; // 0x16735
        *(int32_t *)(a1 + 28) = result;
        v18 += (int64_t)&g86;
        while (v18 != a4 + 40) {
            int64_t v31 = v21;
            v19 = (int32_t *)(v31 + 12);
            v20 = *v19;
            v21 = v31 + 16;
            v22 = *(int32_t *)(v18 + 0x2800);
            v23 = *(int32_t *)v31;
            v24 = *(int32_t *)(v17 + (int64_t)(4 * v20 & 1020));
            v25 = *(char *)(v17 + (int64_t)(4 * v20 / 0x1000000));
            v26 = *(int32_t *)(v17 + (int64_t)(v20 / 0x4000 & 1020));
            v27 = *(int32_t *)(v17 + (int64_t)(v20 / 64 & 1020));
            v28 = v23 ^ v22 ^ v24 & 0xff00 ^ (int32_t)v25 ^ v26 & -0x1000000 ^ v27 & 0xff0000;
            *(int32_t *)v21 = v28;
            v29 = v28 ^ *(int32_t *)(v31 + 4);
            *(int32_t *)(v31 + 20) = v29;
            v30 = *(int32_t *)(v31 + 8) ^ v29;
            *(int32_t *)(v31 + 24) = v30;
            result = *v19 ^ v30;
            *(int32_t *)(v31 + 28) = result;
            v18 += (int64_t)&g86;
        }
        // 0x16748
        return result;
    }
    unsigned char v32 = *(char *)(a2 + (int64_t)&g2); // 0x1674d
    unsigned char v33 = *(char *)(a2 + (int64_t)&g3); // 0x16756
    unsigned char v34 = *(char *)(a2 + (int64_t)&g5); // 0x16760
    unsigned char v35 = *(char *)(a2 + (int64_t)&g4); // 0x16768
    *(int32_t *)(a1 + (int64_t)&g2) = (int32_t)v33 << (int32_t)&g2 ^ (int32_t)v32 << (int32_t)&g13 ^ (int32_t)v34 ^ (int32_t)v35 << (int32_t)&g95;
    unsigned char v36 = *(char *)(a2 + (int64_t)&g7); // 0x16777
    unsigned char v37 = *(char *)(a2 + (int64_t)&g9); // 0x16780
    unsigned char v38 = *(char *)(a2 + (int64_t)&g12); // 0x1678a
    unsigned char v39 = *(char *)(a2 + (int64_t)&g10); // 0x16792
    *(int32_t *)(a1 + (int64_t)&g7) = (int32_t)v37 << (int32_t)&g2 ^ (int32_t)v36 << (int32_t)&g13 ^ (int32_t)v38 ^ (int32_t)v39 << (int32_t)&g95;
    if (v16 != 192) {
        unsigned char v40 = *(char *)(a2 + (int64_t)&g13); // 0x16851
        unsigned char v41 = *(char *)(a2 + (int64_t)&g16); // 0x1685a
        unsigned char v42 = *(char *)(a2 + (int64_t)&g18); // 0x16864
        unsigned char v43 = *(char *)(a2 + (int64_t)&g17); // 0x1686c
        *(int32_t *)(a1 + (int64_t)&g13) = (int32_t)v41 << (int32_t)&g2 ^ (int32_t)v40 << (int32_t)&g13 ^ (int32_t)v42 ^ (int32_t)v43 << (int32_t)&g95;
        unsigned char v44 = *(char *)(a2 + (int64_t)&g19); // 0x1687b
        unsigned char v45 = *(char *)(a2 + (int64_t)&g22); // 0x16884
        unsigned char v46 = *(char *)(a2 + (int64_t)&g24); // 0x1688e
        unsigned char v47 = *(char *)(a2 + (int64_t)&g23); // 0x16896
        uint32_t v48 = (int32_t)v45 << (int32_t)&g2 ^ (int32_t)v44 << (int32_t)&g13 ^ (int32_t)v46 ^ (int32_t)v47 << (int32_t)&g95; // 0x1689d
        *(int32_t *)(a1 + (int64_t)&g19) = v48;
        int32_t v49 = *(int32_t *)(a4 + 0x2800); // 0x168bf
        int32_t v50 = *(int32_t *)(a1 + (int64_t)&g26 - 32); // 0x168c6
        int64_t v51 = a4 + 0x1000; // 0x168cd
        int32_t v52 = *(int32_t *)(v51 + (int64_t)(4 * v48 & 1020)); // 0x168cd
        unsigned char v53 = *(char *)(4 * (int64_t)(v48 >> (int32_t)&g13) + v51); // 0x168e9
        int32_t v54 = *(int32_t *)(v51 + (int64_t)(4 * (v48 >> (int32_t)&g2) & 1020)); // 0x16900
        int32_t v55 = *(int32_t *)((4 * ((int64_t)v48 >> (int64_t)&g95) & 1020) + v51); // 0x16915
        int32_t v56 = v50 ^ v49 ^ v52 & 0xff00 ^ (int32_t)v53 ^ v54 & -0x1000000 ^ v55 & 0xff0000; // 0x16922
        *(int32_t *)(a1 + (int64_t)&g26) = v56;
        int32_t v57 = v56 ^ *(int32_t *)(a1 + (int64_t)&g26 - 28); // 0x16926
        *(int32_t *)(a1 + (int64_t)&g26 + (int64_t)&g86) = v57;
        int32_t v58 = *(int32_t *)(a1 + (int64_t)&g26 - 24) ^ v57; // 0x1692c
        *(int32_t *)(a1 + (int64_t)&g26 + (int64_t)&g95) = v58;
        uint32_t v59 = *(int32_t *)(a1 + (int64_t)&g26 - 20) ^ v58; // 0x16932
        *(int32_t *)(a1 + (int64_t)&g26 + (int64_t)"GNU") = v59;
        if ((int64_t)&g86 - (int64_t)&g19 != 0) {
            // 0x16949
            return ((int64_t)v59 >> (int64_t)&g95) % 256;
        }
        // 0x16836
        return (int64_t)&g103;
    }
    int64_t v60 = a4 + 0x1000; // 0x167c8
    int64_t v61 = 0; // 0x1682c
    int64_t v62 = a1;
    int32_t * v63 = (int32_t *)(v62 + 20); // 0x167b2
    uint32_t v64 = *v63; // 0x167b2
    int64_t v65 = v62 + 24; // 0x167b5
    int32_t v66 = *(int32_t *)(a4 + 0x2800 + v61); // 0x167b9
    int32_t v67 = *(int32_t *)v62; // 0x167c1
    int32_t v68 = *(int32_t *)(v60 + (int64_t)(4 * v64 & 1020)); // 0x167c8
    unsigned char v69 = *(char *)(v60 + (int64_t)(4 * v64 / 0x1000000)); // 0x167df
    int32_t v70 = *(int32_t *)(v60 + (int64_t)(v64 / 0x4000 & 1020)); // 0x167f3
    int32_t v71 = *(int32_t *)(v60 + (int64_t)(v64 / 64 & 1020)); // 0x16806
    int32_t v72 = v67 ^ v66 ^ v68 & 0xff00 ^ (int32_t)v69 ^ v70 & -0x1000000 ^ v71 & 0xff0000; // 0x16816
    *(int32_t *)v65 = v72;
    int32_t v73 = v72 ^ *(int32_t *)(v62 + 4); // 0x1681a
    *(int32_t *)(v62 + 28) = v73;
    int32_t v74 = *(int32_t *)(v62 + 8) ^ v73; // 0x16820
    *(int32_t *)(v62 + 32) = v74;
    int32_t v75 = *(int32_t *)(v62 + 12) ^ v74; // 0x16826
    *(int32_t *)(v62 + 36) = v75;
    v61 += (int64_t)&g86;
    while (v61 != (int64_t)&g26) {
        int32_t v76 = *(int32_t *)(v62 + 16) ^ v75; // 0x16840
        *(int32_t *)(v62 + 40) = v76;
        *(int32_t *)(v62 + 44) = *v63 ^ v76;
        v62 = v65;
        v63 = (int32_t *)(v62 + 20);
        v64 = *v63;
        v65 = v62 + 24;
        v66 = *(int32_t *)(a4 + 0x2800 + v61);
        v67 = *(int32_t *)v62;
        v68 = *(int32_t *)(v60 + (int64_t)(4 * v64 & 1020));
        v69 = *(char *)(v60 + (int64_t)(4 * v64 / 0x1000000));
        v70 = *(int32_t *)(v60 + (int64_t)(v64 / 0x4000 & 1020));
        v71 = *(int32_t *)(v60 + (int64_t)(v64 / 64 & 1020));
        v72 = v67 ^ v66 ^ v68 & 0xff00 ^ (int32_t)v69 ^ v70 & -0x1000000 ^ v71 & 0xff0000;
        *(int32_t *)v65 = v72;
        v73 = v72 ^ *(int32_t *)(v62 + 4);
        *(int32_t *)(v62 + 28) = v73;
        v74 = *(int32_t *)(v62 + 8) ^ v73;
        *(int32_t *)(v62 + 32) = v74;
        v75 = *(int32_t *)(v62 + 12) ^ v74;
        *(int32_t *)(v62 + 36) = v75;
        v61 += (int64_t)&g86;
    }
    // 0x16836
    return (int64_t)"GNU";
}

// From module:   /root/asv5220\AES_TS.c
// Address range: 0x1698f - 0x169bf
// Line range:    827 - 866
int32_t rijndaelKeySetupDec(int32_t * rk, char * cipherKey, int32_t keyBits, int64_t pTable) {
    int64_t v1 = (int64_t)rk;
    int64_t v2; // 0x1698f
    *(char *)v2 = (char)v2 + (char)keyBits;
    int64_t v3; // 0x1698f
    int64_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    int64_t v5; // 0x1698f
    int32_t v6 = keyBits & 0xff00 ^ (int32_t)v5; // 0x1699c
    *(int32_t *)(v1 + (int64_t)&g2) = v6;
    int32_t v7 = *(int32_t *)(v1 - 12) ^ v6; // 0x169a1
    *(int32_t *)(v1 + (int64_t)&g7) = v7;
    int32_t v8 = *(int32_t *)(v1 - 8) ^ v7; // 0x169a7
    *(int32_t *)(v1 + (int64_t)&g13) = v8;
    int32_t result = *(int32_t *)(v1 - 4) ^ v8; // 0x169ad
    *(int32_t *)(v1 + (int64_t)&g19) = result;
    return result;
}

// Address range: 0x169bf - 0x16baf
int64_t rijndaelKeySetupDec2(int64_t a1, int64_t * a2, int64_t a3, int64_t a4) {
    // 0x169bf
    mcount();
    int64_t result = rijndaelKeySetupEnc2(a1, (int64_t)a2, a3, a4); // 0x169d1
    int64_t v1 = result * (int64_t)(int32_t)&g86; // 0x169d6
    if ((int32_t)v1 >= 1) {
        int64_t v2 = a1 + (int64_t)&g86; // 0x16a00
        int64_t v3 = a1 + (int64_t)&g95; // 0x16a16
        int64_t v4 = a1 + (int64_t)"GNU"; // 0x16a2c
        int64_t v5 = v1 & 0xfffffffe; // 0x169e1
        int64_t v6 = 0; // 0x169e1
        int64_t v7 = 0x100000000 * v6 / 0x100000000 * (int64_t)&g86; // 0x169e9
        int32_t * v8 = (int32_t *)(v7 + a1); // 0x169ed
        int64_t v9 = 0x100000000 * v5 / 0x100000000 * (int64_t)&g86; // 0x169f3
        int32_t * v10 = (int32_t *)(v9 + a1); // 0x169f7
        *v8 = *v10;
        *v10 = *v8;
        int32_t * v11 = (int32_t *)(v7 + v2); // 0x16a05
        int32_t * v12 = (int32_t *)(v9 + v2); // 0x16a0d
        *v11 = *v12;
        *v12 = *v11;
        int32_t * v13 = (int32_t *)(v7 + v3); // 0x16a1b
        int32_t * v14 = (int32_t *)(v9 + v3); // 0x16a23
        *v13 = *v14;
        *v14 = *v13;
        int32_t * v15 = (int32_t *)(v7 + v4); // 0x16a31
        int32_t * v16 = (int32_t *)(v9 + v4); // 0x16a39
        *v15 = *v16;
        *v16 = *v15;
        v6 = v6 + (int64_t)(int32_t)&g86 & 0xffffffff;
        v5 = v5 - (int64_t)(int32_t)&g86 & 0xffffffff;
        while (v6 < v5) {
            // 0x169e6
            v7 = 0x100000000 * v6 / 0x100000000 * (int64_t)&g86;
            v8 = (int32_t *)(v7 + a1);
            v9 = 0x100000000 * v5 / 0x100000000 * (int64_t)&g86;
            v10 = (int32_t *)(v9 + a1);
            *v8 = *v10;
            *v10 = *v8;
            v11 = (int32_t *)(v7 + v2);
            v12 = (int32_t *)(v9 + v2);
            *v11 = *v12;
            *v12 = *v11;
            v13 = (int32_t *)(v7 + v3);
            v14 = (int32_t *)(v9 + v3);
            *v13 = *v14;
            *v14 = *v13;
            v15 = (int32_t *)(v7 + v4);
            v16 = (int32_t *)(v9 + v4);
            *v15 = *v16;
            *v16 = *v15;
            v6 = v6 + (int64_t)(int32_t)&g86 & 0xffffffff;
            v5 = v5 - (int64_t)(int32_t)&g86 & 0xffffffff;
        }
    }
    int32_t * v17 = (int32_t *)(a1 + (int64_t)&g2); // 0x16a65
    uint32_t v18 = *v17; // 0x16a65
    int64_t v19 = a4 + 0x1000; // 0x16a6c
    unsigned char v20 = *(char *)(v19 + (int64_t)(4 * v18 & 1020)); // 0x16a6c
    unsigned char v21 = *(char *)(4 * (int64_t)(v18 >> (int32_t)&g13) + v19); // 0x16a7b
    int64_t v22 = a4 + 0x2000; // 0x16a83
    int32_t v23 = *(int32_t *)(4 * (int64_t)v20 + v22); // 0x16a83
    int64_t v24 = a4 + 0x1400; // 0x16a8a
    unsigned char v25 = *(char *)(v19 + (int64_t)(4 * (v18 >> (int32_t)&g2) & 1020)); // 0x16a99
    int64_t v26 = a4 + (int64_t)&g14; // 0x16aa1
    int32_t v27 = *(int32_t *)(4 * (int64_t)v25 + v26); // 0x16aa1
    unsigned char v28 = *(char *)((4 * ((int64_t)v18 >> (int64_t)&g95) & 1020) + v19); // 0x16aab
    int64_t v29 = a4 + 0x1c00; // 0x16ab5
    int32_t v30 = *(int32_t *)(4 * (int64_t)v28 + v29); // 0x16ab5
    *v17 = *(int32_t *)(4 * (int64_t)v21 + v24) ^ v23 ^ v27 ^ v30;
    int32_t * v31 = (int32_t *)(a1 + (int64_t)&g2 + (int64_t)&g86); // 0x16ac0
    uint32_t v32 = *v31; // 0x16ac0
    unsigned char v33 = *(char *)(v19 + (int64_t)(4 * v32 & 1020)); // 0x16ac8
    unsigned char v34 = *(char *)(4 * (int64_t)(v32 >> (int32_t)&g13) + v19); // 0x16ad7
    int32_t v35 = *(int32_t *)(4 * (int64_t)v34 + v24); // 0x16ae6
    unsigned char v36 = *(char *)(v19 + (int64_t)(4 * (v32 >> (int32_t)&g2) & 1020)); // 0x16af5
    int32_t v37 = *(int32_t *)(4 * (int64_t)v36 + v26); // 0x16afd
    unsigned char v38 = *(char *)((4 * ((int64_t)v32 >> (int64_t)&g95) & 1020) + v19); // 0x16b07
    int32_t v39 = *(int32_t *)(4 * (int64_t)v38 + v29); // 0x16b11
    *v31 = v35 ^ *(int32_t *)(4 * (int64_t)v33 + v22) ^ v37 ^ v39;
    int32_t * v40 = (int32_t *)(a1 + (int64_t)&g2 + (int64_t)&g95); // 0x16b1d
    uint32_t v41 = *v40; // 0x16b1d
    unsigned char v42 = *(char *)(v19 + (int64_t)(4 * v41 & 1020)); // 0x16b25
    unsigned char v43 = *(char *)(4 * (int64_t)(v41 >> (int32_t)&g13) + v19); // 0x16b34
    int32_t v44 = *(int32_t *)(4 * (int64_t)v43 + v24); // 0x16b43
    unsigned char v45 = *(char *)(v19 + (int64_t)(4 * (v41 >> (int32_t)&g2) & 1020)); // 0x16b52
    int32_t v46 = *(int32_t *)(4 * (int64_t)v45 + v26); // 0x16b5a
    unsigned char v47 = *(char *)((4 * ((int64_t)v41 >> (int64_t)&g95) & 1020) + v19); // 0x16b64
    int32_t v48 = *(int32_t *)(4 * (int64_t)v47 + v29); // 0x16b6e
    *v40 = v44 ^ *(int32_t *)(4 * (int64_t)v42 + v22) ^ v46 ^ v48;
    return result;
}

// From module:   /root/asv5220\AES_TS.c
// Address range: 0x16bb5 - 0x16be5
// Line range:    870 - 962
void rijndaelEncryptRound(int32_t * rk, int32_t Nr, char * block, int32_t rounds, int64_t pTable) {
    // 0x16bb5
    int64_t v1; // 0x16bb5
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x16bb5
    int32_t v3 = *(int32_t *)((int64_t)rounds * (int64_t)&g86 + (int64_t)&g14 + v2); // 0x16bb7
    unsigned char v4 = *(char *)(v2 + (4 * ((int64_t)block >> (int64_t)&g95) & 1020 | 0x1000)); // 0x16bc1
    int32_t v5 = *(int32_t *)(v2 + 0x1c00 + 4 * (int64_t)v4); // 0x16bcb
    int64_t v6; // 0x16bb5
    *(int32_t *)(v6 + (int64_t)"GNU") = v3 ^ Nr ^ v5;
}

// Address range: 0x16be5 - 0x170ba
int64_t rijndaelEncryptRound2(int64_t a1, int32_t a2, int64_t * a3, int64_t a4, int64_t a5) {
    int64_t v1 = (int64_t)a3;
    mcount();
    int64_t v2 = v1 + (int64_t)&g1; // 0x16c01
    int64_t v3 = v1 + (int64_t)&g25; // 0x16c0c
    char * v4 = (char *)(v1 + (int64_t)&g33); // 0x16c1b
    unsigned char v5 = *v4; // 0x16c2a
    unsigned char v6 = *(char *)v2; // 0x16c3b
    unsigned char v7 = *(char *)v3; // 0x16c4b
    int64_t v8 = (int32_t)v1 % 256 << (int32_t)&g13 ^ (int32_t)a1 ^ (int32_t)v5 ^ (int32_t)v6 << (int32_t)&g2 ^ (int32_t)v7 << (int32_t)&g95; // 0x16c52
    int64_t v9 = v1 + (int64_t)&g86; // 0x16c55
    int64_t v10 = v1 + (int64_t)&g89; // 0x16c60
    int64_t v11 = v1 + (int64_t)&g91; // 0x16c6b
    char * v12 = (char *)(v1 + (int64_t)&g94); // 0x16c77
    unsigned char v13 = *v12; // 0x16c7b
    int32_t v14 = *(int32_t *)(a1 + (int64_t)&g86); // 0x16c7f
    unsigned char v15 = *(char *)v9; // 0x16c8a
    unsigned char v16 = *(char *)v10; // 0x16c9a
    unsigned char v17 = *(char *)v11; // 0x16ca8
    int32_t v18 = v14 ^ (int32_t)v13 ^ (int32_t)v15 << (int32_t)&g13 ^ (int32_t)v16 << (int32_t)&g2 ^ (int32_t)v17 << (int32_t)&g95; // 0x16cae
    int64_t v19 = v1 + (int64_t)&g95; // 0x16cb1
    char * v20 = (char *)(v1 + (int64_t)&g97); // 0x16cbd
    int64_t v21 = v1 + (int64_t)&g98; // 0x16cc1
    char * v22 = (char *)(v1 + (int64_t)&g99); // 0x16ccd
    unsigned char v23 = *v22; // 0x16cd1
    int32_t v24 = *(int32_t *)(a1 + (int64_t)&g95); // 0x16cd5
    unsigned char v25 = *(char *)v19; // 0x16cdc
    unsigned char v26 = *v20; // 0x16ce8
    unsigned char v27 = *(char *)v21; // 0x16cf5
    int64_t v28 = v24 ^ (int32_t)v23 ^ (int32_t)v25 << (int32_t)&g13 ^ (int32_t)v26 << (int32_t)&g2 ^ (int32_t)v27 << (int32_t)&g95; // 0x16cfb
    unsigned char v29 = *(char *)(v1 + (int64_t)&g105); // 0x16d1d
    int32_t v30 = *(int32_t *)(a1 + (int64_t)"GNU"); // 0x16d21
    unsigned char v31 = *(char *)(v1 + (int64_t)"GNU"); // 0x16d28
    unsigned char v32 = *(char *)(v1 + (int64_t)"NU"); // 0x16d35
    unsigned char v33 = *(char *)(v1 + (int64_t)&g103); // 0x16d42
    int64_t v34 = v30 ^ (int32_t)v29 ^ (int32_t)v31 << (int32_t)&g13 ^ (int32_t)v32 << (int32_t)&g2 ^ (int32_t)v33 << (int32_t)&g95; // 0x16d49
    int64_t v35 = a1 + (int64_t)&g2; // 0x16d4b
    int32_t v36 = a4;
    int32_t v37 = v36 - a2; // 0x16d55
    uint32_t v38 = v37 < 0 == ((v37 ^ v36) & (v36 ^ a2)) < 0 ? a2 - (int32_t)&g1 : v36; // 0x16d58
    int64_t v39 = v34; // 0x16d60
    int64_t v40 = v28; // 0x16d60
    int32_t v41 = v18; // 0x16d60
    int64_t v42 = v8; // 0x16d60
    int64_t v43 = v35; // 0x16d60
    if (v38 >= 1) {
        int64_t v44 = a1 + (int64_t)&g26 + (((int64_t)v38 - (int64_t)(int32_t)&g1 & 0xffffffff) << (int64_t)&g86) * (int64_t)&g1; // 0x16d6d
        int64_t v45 = a5 + 3072; // 0x16d95
        int64_t v46 = a5 + 1024; // 0x16dad
        int64_t v47 = a5 + 2048; // 0x16db8
        int64_t v48 = v35; // 0x16d81
        int32_t v49 = *(int32_t *)((int64_t)((int32_t)v8 >> (int32_t)&g13) * (int64_t)&g86 + a5); // 0x16d91
        int32_t v50 = *(int32_t *)((4 * v34 & 1020) + v45); // 0x16d95
        int32_t v51 = *(int32_t *)(v46 + (int64_t)(v18 / 0x4000 & 1020)); // 0x16dad
        int32_t v52 = *(int32_t *)((v28 / 64 & 1020) + v47); // 0x16db8
        v42 = (int64_t)(v50 ^ v49 ^ *(int32_t *)v48 ^ v51 ^ v52);
        int32_t v53 = *(int32_t *)((int64_t)(v18 >> (int32_t)&g13) * (int64_t)&g86 + a5); // 0x16dd2
        int32_t v54 = *(int32_t *)(v48 + (int64_t)&g86); // 0x16dde
        int32_t v55 = *(int32_t *)((v28 / 0x4000 & 1020) + v46); // 0x16deb
        int32_t v56 = *(int32_t *)((v34 / 64 & 1020) + v47); // 0x16df6
        v41 = *(int32_t *)((4 * v8 & 1020) + v45) ^ v53 ^ v54 ^ v55 ^ v56;
        int32_t v57 = *(int32_t *)((int64_t)((int32_t)v28 >> (int32_t)&g13) * (int64_t)&g86 + a5); // 0x16e0f
        int32_t v58 = *(int32_t *)(v45 + (int64_t)(4 * v18 & 1020)); // 0x16e13
        int32_t v59 = *(int32_t *)(v48 + (int64_t)&g95); // 0x16e1b
        int32_t v60 = *(int32_t *)((v34 / 0x4000 & 1020) + v46); // 0x16e28
        int32_t v61 = *(int32_t *)((v8 / 64 & 1020) + v47); // 0x16e36
        v40 = v58 ^ v57 ^ v59 ^ v60 ^ v61;
        int32_t v62 = *(int32_t *)(4 * (int64_t)((int32_t)v34 >> (int32_t)&g13) + a5); // 0x16e46
        int32_t v63 = *(int32_t *)((4 * v28 & 1020) + v45); // 0x16e4a
        int32_t v64 = *(int32_t *)(v48 + (int64_t)"GNU"); // 0x16e52
        int32_t v65 = *(int32_t *)((v8 / 0x4000 & 1020) + v46); // 0x16e5d
        int32_t v66 = *(int32_t *)(v47 + (int64_t)(v18 / 64 & 1020)); // 0x16e6e
        v39 = v63 ^ v62 ^ v64 ^ v65 ^ v66;
        v48 += (int64_t)&g2;
        int64_t v67 = v40; // 0x16e7d
        int32_t v68 = v41; // 0x16e7d
        int64_t v69 = v39; // 0x16e7d
        int64_t v70 = v42; // 0x16e7d
        while (v48 != v44) {
            // 0x16d84
            v49 = *(int32_t *)((int64_t)((int32_t)v70 >> (int32_t)&g13) * (int64_t)&g86 + a5);
            v50 = *(int32_t *)((4 * v69 & 1020) + v45);
            v51 = *(int32_t *)(v46 + (int64_t)(v68 / 0x4000 & 1020));
            v52 = *(int32_t *)((v67 / 64 & 1020) + v47);
            v42 = (int64_t)(v50 ^ v49 ^ *(int32_t *)v48 ^ v51 ^ v52);
            v53 = *(int32_t *)((int64_t)(v68 >> (int32_t)&g13) * (int64_t)&g86 + a5);
            v54 = *(int32_t *)(v48 + (int64_t)&g86);
            v55 = *(int32_t *)((v67 / 0x4000 & 1020) + v46);
            v56 = *(int32_t *)((v69 / 64 & 1020) + v47);
            v41 = *(int32_t *)((4 * v70 & 1020) + v45) ^ v53 ^ v54 ^ v55 ^ v56;
            v57 = *(int32_t *)((int64_t)((int32_t)v67 >> (int32_t)&g13) * (int64_t)&g86 + a5);
            v58 = *(int32_t *)(v45 + (int64_t)(4 * v68 & 1020));
            v59 = *(int32_t *)(v48 + (int64_t)&g95);
            v60 = *(int32_t *)((v69 / 0x4000 & 1020) + v46);
            v61 = *(int32_t *)((v70 / 64 & 1020) + v47);
            v40 = v58 ^ v57 ^ v59 ^ v60 ^ v61;
            v62 = *(int32_t *)(4 * (int64_t)((int32_t)v69 >> (int32_t)&g13) + a5);
            v63 = *(int32_t *)((4 * v67 & 1020) + v45);
            v64 = *(int32_t *)(v48 + (int64_t)"GNU");
            v65 = *(int32_t *)((v70 / 0x4000 & 1020) + v46);
            v66 = *(int32_t *)(v47 + (int64_t)(v68 / 64 & 1020));
            v39 = v63 ^ v62 ^ v64 ^ v65 ^ v66;
            v48 += (int64_t)&g2;
            v67 = v40;
            v68 = v41;
            v69 = v39;
            v70 = v42;
        }
        // 0x16e91
        v43 = v35 * (int64_t)&g1 + (int64_t)&g2 + ((int64_t)(v38 - (int32_t)&g1) << (int64_t)&g86);
    }
    uint64_t v71 = (int64_t)v41;
    int64_t v72 = v39; // 0x16eb2
    int64_t v73 = v40; // 0x16eb2
    int64_t v74 = v71; // 0x16eb2
    int64_t v75 = v42; // 0x16eb2
    if (v36 == a2) {
        int64_t v76 = a5 + 0x1000; // 0x16ec0
        int32_t v77 = *(int32_t *)((v42 / 0x400000 & 1020) + v76); // 0x16ec0
        unsigned char v78 = *(char *)((4 * v39 & 1020) + v76); // 0x16ed1
        int32_t v79 = *(int32_t *)v43; // 0x16edc
        int32_t v80 = *(int32_t *)((v71 / 0x4000 & 1020) + v76); // 0x16ee8
        int32_t v81 = *(int32_t *)((v40 / 64 & 1020) + v76); // 0x16f01
        int32_t v82 = *(int32_t *)((v71 / 0x400000 & 1020) + v76); // 0x16f1b
        unsigned char v83 = *(char *)((4 * v42 & 1020) + v76); // 0x16f2d
        int32_t v84 = *(int32_t *)(v43 + (int64_t)&g86); // 0x16f38
        int32_t v85 = *(int32_t *)((v40 / 0x4000 & 1020) + v76); // 0x16f44
        int32_t v86 = *(int32_t *)((v39 / 64 & 1020) + v76); // 0x16f5a
        int32_t v87 = *(int32_t *)((v40 / 0x400000 & 1020) + v76); // 0x16f73
        unsigned char v88 = *(char *)((4 * v71 & 1020) + v76); // 0x16f85
        int32_t v89 = *(int32_t *)(v43 + (int64_t)&g95); // 0x16f90
        int32_t v90 = *(int32_t *)((v39 / 0x4000 & 1020) + v76); // 0x16f9c
        int32_t v91 = *(int32_t *)((v42 / 64 & 1020) + v76); // 0x16fb3
        int32_t v92 = *(int32_t *)((v39 / 0x400000 & 1020) + v76); // 0x16fc8
        int32_t v93 = *(int32_t *)(v43 + (int64_t)"GNU"); // 0x16fe4
        v72 = v92 & -0x1000000 ^ v93;
        v73 = (v87 & -0x1000000 | (int32_t)v88) ^ v89 ^ v90 & 0xff0000 ^ v91 & 0xff00;
        v74 = (v82 & -0x1000000 | (int32_t)v83) ^ v84 ^ v85 & 0xff0000 ^ v86 & 0xff00;
        v75 = (v77 & -0x1000000 | (int32_t)v78) ^ v79 ^ v80 & 0xff0000 ^ v81 & 0xff00;
    }
    uint32_t v94 = (int32_t)v75; // 0x17025
    *(char *)a3 = (char)(v94 / 0x1000000);
    *(char *)(0x100000000 * v2 / 0x100000000) = (char)(v94 / 0x10000);
    *(char *)(0x100000000 * v3 / 0x100000000) = (char)(v94 / 256);
    *v4 = (char)v75;
    uint32_t v95 = (int32_t)v74; // 0x17056
    *(char *)(0x1000000000000 * v9 / 0x1000000000000) = (char)(v95 / 0x1000000);
    *(char *)(0x100000000000000 * v10 / 0x100000000000000) = (char)(v95 / 0x10000);
    *(char *)(0x100000000000000 * v11 / 0x100000000000000) = (char)(v95 / 256);
    *v12 = (char)v74;
    uint32_t v96 = (int32_t)v73; // 0x17088
    *(char *)(0x100000000000000 * v19 / 0x100000000000000) = (char)(v96 / 0x1000000);
    *v20 = (char)(v96 / 0x10000);
    *(char *)(0x100000000000000 * v21 / 0x100000000000000) = (char)(v96 / 256);
    *v22 = (char)v73;
    return v72 / 0x1000000 % 256;
}

// From module:   /root/asv5220\AES_TS.c
// Address range: 0x170bb - 0x170eb
// Line range:    964 - 1052
void rijndaelDecryptRound(int32_t * rk, int32_t Nr, char * block, int32_t rounds, int64_t pTable) {
    // 0x170bb
    int64_t v1; // 0x170bb
    int64_t v2; // 0x170bb
    *(char *)*(int64_t *)(v1 - 72) = (char)v2;
    int64_t v3 = *(int64_t *)(v1 - 64); // 0x170cc
    int64_t v4; // 0x170bb
    *(char *)v3 = (char)((int32_t)v4 >> (int32_t)&g95);
    *(char *)*(int64_t *)(v1 - 56) = (char)v4;
}

// Address range: 0x170eb - 0x175c5
int64_t rijndaelDecryptRound2(int64_t a1, int32_t a2, int64_t * a3, int64_t a4, int64_t a5) {
    int64_t v1 = (int64_t)a3;
    mcount();
    int64_t v2 = v1 + (int64_t)&g1; // 0x17107
    int64_t v3 = v1 + (int64_t)&g25; // 0x17112
    char * v4 = (char *)(v1 + (int64_t)&g33); // 0x17121
    unsigned char v5 = *v4; // 0x17130
    unsigned char v6 = *(char *)v2; // 0x17140
    unsigned char v7 = *(char *)v3; // 0x1714a
    int64_t v8 = (int32_t)v1 % 256 << (int32_t)&g13 ^ (int32_t)a1 ^ (int32_t)v5 ^ (int32_t)v6 << (int32_t)&g2 ^ (int32_t)v7 << (int32_t)&g95; // 0x17150
    int64_t v9 = v1 + (int64_t)&g86; // 0x17153
    int64_t v10 = v1 + (int64_t)&g89; // 0x1715e
    int64_t v11 = v1 + (int64_t)&g91; // 0x17169
    char * v12 = (char *)(v1 + (int64_t)&g94); // 0x17175
    unsigned char v13 = *v12; // 0x17179
    int32_t v14 = *(int32_t *)(a1 + (int64_t)&g86); // 0x1717c
    unsigned char v15 = *(char *)v9; // 0x1717f
    unsigned char v16 = *(char *)v10; // 0x1718f
    unsigned char v17 = *(char *)v11; // 0x1719c
    int32_t v18 = v14 ^ (int32_t)v13 ^ (int32_t)v15 << (int32_t)&g13 ^ (int32_t)v16 << (int32_t)&g2 ^ (int32_t)v17 << (int32_t)&g95; // 0x171a3
    int64_t v19 = v1 + (int64_t)&g95; // 0x171a5
    char * v20 = (char *)(v1 + (int64_t)&g97); // 0x171b1
    int64_t v21 = v1 + (int64_t)&g98; // 0x171b5
    char * v22 = (char *)(v1 + (int64_t)&g99); // 0x171c1
    unsigned char v23 = *v22; // 0x171c5
    int32_t v24 = *(int32_t *)(a1 + (int64_t)&g95); // 0x171c9
    unsigned char v25 = *(char *)v19; // 0x171cc
    unsigned char v26 = *v20; // 0x171d8
    unsigned char v27 = *(char *)v21; // 0x171e5
    int64_t v28 = v24 ^ (int32_t)v23 ^ (int32_t)v25 << (int32_t)&g13 ^ (int32_t)v26 << (int32_t)&g2 ^ (int32_t)v27 << (int32_t)&g95; // 0x171ec
    unsigned char v29 = *(char *)(v1 + (int64_t)&g105); // 0x1720e
    int32_t v30 = *(int32_t *)(a1 + (int64_t)"GNU"); // 0x17212
    char * v31 = (char *)(v1 + (int64_t)"GNU"); // 0x1721a
    unsigned char v32 = *v31; // 0x1721a
    unsigned char v33 = *(char *)(v1 + (int64_t)"NU"); // 0x17228
    unsigned char v34 = *(char *)(v1 + (int64_t)&g103); // 0x17236
    int64_t v35 = v30 ^ (int32_t)v29 ^ (int32_t)v32 << (int32_t)&g13 ^ (int32_t)v33 << (int32_t)&g2 ^ (int32_t)v34 << (int32_t)&g95; // 0x1723d
    int64_t v36 = a1 + (int64_t)&g2; // 0x17240
    int32_t v37 = a4;
    int32_t v38 = v37 - a2; // 0x17244
    int32_t v39 = v38 == 0 | v38 < 0 != ((v38 ^ v37) & (v37 ^ a2)) < 0 ? v37 : a2; // 0x1724a
    int32_t v40 = v18; // 0x17255
    int64_t v41 = v28; // 0x17255
    int64_t v42 = v35; // 0x17255
    int64_t v43 = v8; // 0x17255
    int64_t v44 = v36; // 0x17255
    if (v39 - (int32_t)&g1 >= 1) {
        int64_t v45 = (int64_t)(v39 - (int32_t)&g25) << (int64_t)&g86; // 0x17261
        int64_t v46 = a5 + 0x1400; // 0x1728f
        int64_t v47 = a5 + 0x2000; // 0x17297
        int64_t v48 = a5 + (int64_t)&g14; // 0x172ab
        int64_t v49 = a5 + 0x1c00; // 0x172b6
        int64_t v50 = v36; // 0x1727b
        int32_t v51 = *(int32_t *)((v8 / 0x400000 & 1020) + v46); // 0x1728f
        int32_t v52 = *(int32_t *)(v47 + (int64_t)(4 * v18 & 1020)); // 0x17297
        int32_t v53 = *(int32_t *)((v35 / 0x4000 & 1020) + v48); // 0x172ab
        int32_t v54 = *(int32_t *)((v28 / 64 & 1020) + v49); // 0x172b6
        v43 = (int64_t)(v52 ^ v51 ^ *(int32_t *)v50 ^ v53 ^ v54);
        int32_t v55 = *(int32_t *)(v46 + (int64_t)(4 * v18 / 0x1000000)); // 0x172cf
        int32_t v56 = *(int32_t *)(v50 + (int64_t)&g86); // 0x172df
        int32_t v57 = *(int32_t *)((v8 / 0x4000 & 1020) + v48); // 0x172ed
        int32_t v58 = *(int32_t *)((v35 / 64 & 1020) + v49); // 0x172f8
        v40 = *(int32_t *)((4 * v28 & 1020) + v47) ^ v55 ^ v56 ^ v57 ^ v58;
        int32_t v59 = *(int32_t *)((v28 / 0x400000 & 1020) + v46); // 0x1730d
        int32_t v60 = *(int32_t *)((4 * v35 & 1020) + v47); // 0x17315
        int32_t v61 = *(int32_t *)(v50 + (int64_t)&g95); // 0x1731d
        int32_t v62 = *(int32_t *)(v48 + (int64_t)(v18 / 0x4000 & 1020)); // 0x1732e
        int32_t v63 = *(int32_t *)((v8 / 64 & 1020) + v49); // 0x1733c
        v41 = v60 ^ v59 ^ v61 ^ v62 ^ v63;
        int32_t v64 = *(int32_t *)((v35 / 0x400000 & 1020) + v46); // 0x1734d
        int32_t v65 = *(int32_t *)((4 * v8 & 1020) + v47); // 0x17355
        int32_t v66 = *(int32_t *)(v50 + (int64_t)"GNU"); // 0x1735d
        int32_t v67 = *(int32_t *)((v28 / 0x4000 & 1020) + v48); // 0x17366
        int32_t v68 = *(int32_t *)(v49 + (int64_t)(v18 / 64 & 1020)); // 0x17377
        v42 = v65 ^ v64 ^ v66 ^ v67 ^ v68;
        v50 += (int64_t)&g2;
        int64_t v69 = v41; // 0x17386
        int32_t v70 = v40; // 0x17386
        int64_t v71 = v42; // 0x17386
        int64_t v72 = v43; // 0x17386
        while (v50 != a1 + (int64_t)&g26 + v45 * (int64_t)&g1) {
            // 0x1727e
            v51 = *(int32_t *)((v72 / 0x400000 & 1020) + v46);
            v52 = *(int32_t *)(v47 + (int64_t)(4 * v70 & 1020));
            v53 = *(int32_t *)((v71 / 0x4000 & 1020) + v48);
            v54 = *(int32_t *)((v69 / 64 & 1020) + v49);
            v43 = (int64_t)(v52 ^ v51 ^ *(int32_t *)v50 ^ v53 ^ v54);
            v55 = *(int32_t *)(v46 + (int64_t)(4 * v70 / 0x1000000));
            v56 = *(int32_t *)(v50 + (int64_t)&g86);
            v57 = *(int32_t *)((v72 / 0x4000 & 1020) + v48);
            v58 = *(int32_t *)((v71 / 64 & 1020) + v49);
            v40 = *(int32_t *)((4 * v69 & 1020) + v47) ^ v55 ^ v56 ^ v57 ^ v58;
            v59 = *(int32_t *)((v69 / 0x400000 & 1020) + v46);
            v60 = *(int32_t *)((4 * v71 & 1020) + v47);
            v61 = *(int32_t *)(v50 + (int64_t)&g95);
            v62 = *(int32_t *)(v48 + (int64_t)(v70 / 0x4000 & 1020));
            v63 = *(int32_t *)((v72 / 64 & 1020) + v49);
            v41 = v60 ^ v59 ^ v61 ^ v62 ^ v63;
            v64 = *(int32_t *)((v71 / 0x400000 & 1020) + v46);
            v65 = *(int32_t *)((4 * v72 & 1020) + v47);
            v66 = *(int32_t *)(v50 + (int64_t)"GNU");
            v67 = *(int32_t *)((v69 / 0x4000 & 1020) + v48);
            v68 = *(int32_t *)(v49 + (int64_t)(v70 / 64 & 1020));
            v42 = v65 ^ v64 ^ v66 ^ v67 ^ v68;
            v50 += (int64_t)&g2;
            v69 = v41;
            v70 = v40;
            v71 = v42;
            v72 = v43;
        }
        // 0x1739a
        v44 = v36 * (int64_t)&g1 + (int64_t)&g2 + v45;
    }
    uint64_t v73 = (int64_t)v40;
    int64_t v74 = a5 + 0x2400; // 0x173be
    unsigned char v75 = *(char *)((4 * v73 & 1020) + v74); // 0x173be
    int32_t v76 = *(int32_t *)((v43 / 0x400000 & 1020) + v74); // 0x173cf
    int32_t v77 = *(int32_t *)((v42 / 0x4000 & 1020) + v74); // 0x173e8
    int32_t v78 = *(int32_t *)((v41 / 64 & 1020) + v74); // 0x173fd
    int32_t v79 = v76 & -0x1000000 | (int32_t)v75 | v77 & 0xff0000 | v78 & 0xff00;
    unsigned char v80 = *(char *)((4 * v41 & 1020) + v74); // 0x17410
    int32_t v81 = *(int32_t *)((v73 / 0x400000 & 1020) + v74); // 0x17420
    int32_t v82 = *(int32_t *)((v43 / 0x4000 & 1020) + v74); // 0x1743b
    int32_t v83 = *(int32_t *)((v42 / 64 & 1020) + v74); // 0x17456
    int32_t v84 = v81 & -0x1000000 | (int32_t)v80 | v82 & 0xff0000 | v83 & 0xff00;
    unsigned char v85 = *(char *)((4 * v42 & 1020) + v74); // 0x1746c
    int32_t v86 = *(int32_t *)((v41 / 0x400000 & 1020) + v74); // 0x1747f
    int32_t v87 = *(int32_t *)((v73 / 0x4000 & 1020) + v74); // 0x1749c
    int32_t v88 = *(int32_t *)((v43 / 64 & 1020) + v74); // 0x174b4
    int32_t v89 = v86 & -0x1000000 | (int32_t)v85 | v87 & 0xff0000 | v88 & 0xff00;
    int32_t v90 = *(int32_t *)((v42 / 0x400000 & 1020) + v74) & -0x1000000; // 0x174e2
    int32_t v91 = v79; // 0x1751d
    int32_t v92 = v90; // 0x1751d
    int32_t v93 = v89; // 0x1751d
    int32_t v94 = v84; // 0x1751d
    if (v37 == a2) {
        // 0x1751f
        v91 = *(int32_t *)v44 ^ v79;
        v92 = *(int32_t *)(v44 + (int64_t)"GNU") ^ v90;
        v93 = *(int32_t *)(v44 + (int64_t)&g95) ^ v89;
        v94 = *(int32_t *)(v44 + (int64_t)&g86) ^ v84;
    }
    // 0x1752e
    *(char *)a3 = (char)(v91 / 0x1000000);
    *(char *)(0x100000000 * v2 / 0x100000000) = (char)(v91 / 0x10000);
    *(char *)(0x100000000 * v3 / 0x100000000) = (char)(v91 / 256);
    *v4 = (char)v91;
    *(char *)(0x1000000000000 * v9 / 0x1000000000000) = (char)(v94 / 0x1000000);
    *(char *)(0x100000000000000 * v10 / 0x100000000000000) = (char)(v94 / 0x10000);
    *(char *)(0x100000000000000 * v11 / 0x100000000000000) = (char)(v94 / 256);
    *v12 = (char)v94;
    *(char *)(0x100000000000000 * v19 / 0x100000000000000) = (char)(v93 / 0x1000000);
    *v20 = (char)(v93 / 0x10000);
    *(char *)(0x100000000000000 * v21 / 0x100000000000000) = (char)(v93 / 256);
    *v22 = (char)v93;
    uint32_t result = v92 / 0x1000000;
    *v31 = (char)result;
    return result;
}

// From module:   /root/asv5220\AES_TS.c
// Address range: 0x175c7 - 0x175f7
// Line range:    1160 - 1210
int32_t cipherUpdateRounds(int64_t cipher, int64_t key, char * input, int32_t inputLen, char * outBuffer, int32_t rounds, int64_t pTable) {
    char v1 = inputLen; // 0x175c7
    char v2 = v1 << (char)&g1 | v1; // 0x175c7
    unknown_758cbdde();
    int64_t result = unknown_4d8cc1e2(); // 0x175d5
    char * v3 = (char *)(((int64_t)(v2 << (char)&g1 | v2) | (int64_t)(inputLen & -256)) - 120); // 0x175da
    char v4 = *v3; // 0x175da
    *v3 = v4 << (char)&g1 | v4;
    int64_t v5; // 0x175c7
    int64_t v6; // 0x175c7
    *(char *)*(int64_t *)(v6 - 56) = (char)v5;
    return result;
}

// Address range: 0x175f7 - 0x1779f
int64_t cipherUpdateRounds2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int64_t a5, int32_t a6, int64_t a7) {
    // 0x175f7
    mcount();
    __readgsqword(40);
    if (a1 != 0 != a2 != 0) {
        // 0x17642
        return 0xfffffffb;
    }
    int64_t v1 = a6;
    int64_t v2 = (int64_t)a4;
    int64_t v3; // bp-248, 0x175f7
    if ((char)a2 != 0) {
        int32_t v4 = v2; // 0x17661
        if (v4 >= 0 != v4 != 0) {
            // 0x17642
            return 0xffffffff;
        }
        // 0x1770e
        v3 = *(int64_t *)a3;
        int64_t result = *(int64_t *)(a3 + (int64_t)&g95); // 0x1774c
        int32_t v5 = *(int32_t *)(a2 + 76); // 0x17757
        rijndaelDecryptRound2(a2 + 80, v5, &v3, v1 & 0xffffffff, a7);
        *(int64_t *)a5 = v3;
        *(int64_t *)(a5 + (int64_t)&g95) = result;
        return result;
    }
    int32_t * v6 = (int32_t *)(a2 + 76); // 0x176bf
    int64_t v7 = 0; // 0x176a0
    int64_t v8 = 0x100000000 * v7 / 0x100000000; // 0x176a3
    int64_t v9 = v8 * (int64_t)&g1 + a3; // 0x176a6
    v3 = *(int64_t *)v9;
    int64_t result2 = *(int64_t *)(v9 + (int64_t)&g95); // 0x176b4
    rijndaelEncryptRound2(a2 + 80, *v6, &v3, v1 & 0xffffffff, a7);
    int64_t v10 = v8 + a5; // 0x176e0
    *(int64_t *)v10 = v3;
    *(int64_t *)(v10 + (int64_t)&g95) = result2;
    v7 = v7 + (int64_t)(int32_t)&g2 & 0xffffffff;
    while (0x100000000 * v2 / 0x100000000 > v7) {
        // 0x176a3
        v8 = 0x100000000 * v7 / 0x100000000;
        v9 = v8 * (int64_t)&g1 + a3;
        v3 = *(int64_t *)v9;
        result2 = *(int64_t *)(v9 + (int64_t)&g95);
        rijndaelEncryptRound2(a2 + 80, *v6, &v3, v1 & 0xffffffff, a7);
        v10 = v8 + a5;
        *(int64_t *)v10 = v3;
        *(int64_t *)(v10 + (int64_t)&g95) = result2;
        v7 = v7 + (int64_t)(int32_t)&g2 & 0xffffffff;
    }
    // 0x17642
    return result2;
}

// From module:   /root/asv5220\AES_TS.c
// Address range: 0x177a0 - 0x177d0
// Line range:    1128 - 1158
int32_t cipherInit(int64_t cipher, char mode, char * IV) {
    // 0x177a0
    int64_t result; // 0x177a0
    return result;
}

// Address range: 0x177d0 - 0x17873
int64_t cipherInit2(int64_t a1, int64_t * a2, int64_t a3) {
    // 0x177d0
    mcount();
    *(char *)a1 = (char)(int64_t)a2;
    char v1 = *(char *)a3; // 0x177fb
    int32_t v2 = v1;
    uint32_t v3 = v2 - 48; // 0x17805
    int64_t v4; // 0x177d0
    if (v3 > (int32_t)&g97) {
        int64_t v5 = 16 * (int64_t)v1;
        if (v2 - 97 > (int32_t)&g89) {
            // 0x17822
            v4 = v5 + 0xfffffc90 & 0xfffffff0;
        } else {
            // 0x1781a
            v4 = v5 + 0xfffffa90 & 0xfffffff0;
        }
    } else {
        // 0x1780a
        v4 = v3 << (int32_t)&g86;
    }
    char v6 = *(char *)(a3 + (int64_t)&g1); // 0x17832
    int64_t v7 = v6; // 0x17832
    int64_t v8 = v7 + 0xffffffd0; // 0x1783a
    if ((int32_t)v8 <= (int32_t)&g97) {
        // 0x1786b
        *(char *)(a1 + (int64_t)&g1) = (char)(v8 ^ v4);
        return &g25;
    }
    int64_t v9; // 0x177d0
    if ((int32_t)v6 - 97 > (int32_t)&g89) {
        // 0x1785c
        v9 = v7 + 0xffffffc9;
    } else {
        // 0x17855
        v9 = v7 + 0xffffffa9;
    }
    // 0x1786b
    *(char *)(a1 + (int64_t)&g1) = (char)(v9 ^ v4);
    return &g25;
}

// From module:   /root/asv5220\AES_TS.c
// Address range: 0x17876 - 0x178a6
// Line range:    1056 - 1126
int32_t makeKey(int64_t key, char direction, int32_t keyLen, char * keyMaterial, int64_t pTable) {
    int64_t v1 = (int64_t)keyMaterial;
    int64_t result; // 0x17876
    int32_t * v2 = (int32_t *)(result - 125); // 0x17876
    *v2 = *v2 + (int32_t)v1;
    int64_t v3; // 0x17876
    *(char *)key = *(char *)&v3 & (char)v1;
    return result;
}

// Address range: 0x17881 - 0x17885
int64_t function_17881(void) {
    // 0x17881
    int64_t v1; // 0x17881
    return v1 & -256 | (int64_t)&g1;
}

// Address range: 0x178a6 - 0x17a2e
int64_t makeKey2(int64_t * a1, int64_t a2, int64_t a3, int64_t * str, int64_t a5) {
    int64_t v1 = (int64_t)a1;
    mcount();
    __readgsqword(40);
    char v2 = a2; // 0x178f2
    *(char *)a1 = v2;
    int32_t v3 = a3; // 0x17911
    int32_t * v4 = (int32_t *)(v1 + (int64_t)&g86); // 0x17911
    *v4 = v3;
    int32_t v5 = v3; // 0x17918
    if (str != NULL) {
        int32_t v6 = v3 >= 0 ? v3 : v3 + (int32_t)&g33; // 0x17922
        strncpy(v1 + (int64_t)&g95, (int64_t)str, (int64_t)(v6 >> (int32_t)&g25));
        v5 = *v4;
    }
    // 0x17938
    int64_t v7; // bp-88, 0x178a6
    if (v5 > (int32_t)&g94) {
        int64_t v8 = v1 + (int64_t)&g95; // 0x1794a
        int64_t v9 = 0; // 0x1794a
        int64_t v10 = &v7; // 0x1794a
        char v11 = *(char *)v8; // 0x1794f
        int32_t v12 = v11;
        uint32_t v13 = v12 - 48; // 0x17958
        int64_t v14; // 0x178a6
        int64_t v15; // 0x178a6
        if (v13 > (int32_t)&g97) {
            // 0x17964
            v15 = 16 * (int64_t)v11;
            if (v12 - 97 > (int32_t)&g89) {
                // 0x17975
                v14 = v15 + 0xfffffc90 & 0xfffffff0;
            } else {
                // 0x1796d
                v14 = v15 + 0xfffffa90 & 0xfffffff0;
            }
        } else {
            // 0x1795d
            v14 = v13 << (int32_t)&g86;
        }
        char v16 = *(char *)(v8 + (int64_t)&g1); // 0x17989
        int64_t v17 = v16; // 0x17989
        int64_t v18 = v17 + 0xffffffd0; // 0x17990
        int64_t v19 = v18; // 0x17998
        if ((int32_t)v18 > (int32_t)&g97) {
            if ((int32_t)v16 - 97 > (int32_t)&g89) {
                // 0x179b2
                v19 = v17 + 0xffffffc9;
            } else {
                // 0x179ab
                v19 = v17 + 0xffffffa9;
            }
        }
        // 0x179c1
        *(char *)v10 = (char)(v19 ^ v14);
        v9 = v9 + (int64_t)(int32_t)&g1 & 0xffffffff;
        int32_t v20 = *v4; // 0x179ca
        while (v9 < (int64_t)((v20 < 0 ? v20 + (int32_t)&g94 : v20) >> (int32_t)&g33)) {
            // 0x179dc
            v8 += (int64_t)&g25;
            v10 += (int64_t)&g1;
            v11 = *(char *)v8;
            v12 = v11;
            v13 = v12 - 48;
            if (v13 > (int32_t)&g97) {
                // 0x17964
                v15 = 16 * (int64_t)v11;
                if (v12 - 97 > (int32_t)&g89) {
                    // 0x17975
                    v14 = v15 + 0xfffffc90 & 0xfffffff0;
                } else {
                    // 0x1796d
                    v14 = v15 + 0xfffffa90 & 0xfffffff0;
                }
            } else {
                // 0x1795d
                v14 = v13 << (int32_t)&g86;
            }
            // 0x17989
            v16 = *(char *)(v8 + (int64_t)&g1);
            v17 = v16;
            v18 = v17 + 0xffffffd0;
            v19 = v18;
            if ((int32_t)v18 > (int32_t)&g97) {
                if ((int32_t)v16 - 97 > (int32_t)&g89) {
                    // 0x179b2
                    v19 = v17 + 0xffffffc9;
                } else {
                    // 0x179ab
                    v19 = v17 + 0xffffffa9;
                }
            }
            // 0x179c1
            *(char *)v10 = (char)(v19 ^ v14);
            v9 = v9 + (int64_t)(int32_t)&g1 & 0xffffffff;
            v20 = *v4;
        }
    }
    int64_t v21 = a3 & 0xffffffff; // 0x178bd
    int64_t v22; // 0x178a6
    if (v2 != 0) {
        int64_t v23 = rijndaelKeySetupDec2(v1 + 80, &v7, v21, a5); // 0x17a10
        *(int32_t *)(v1 + 76) = (int32_t)v23;
        v22 = &v7;
    } else {
        int64_t v24 = &v7;
        *(int32_t *)(v1 + 76) = (int32_t)rijndaelKeySetupEnc2(v1 + 80, v24, v21, a5);
        v22 = v24;
    }
    // 0x17a18
    return rijndaelKeySetupEnc2(v1 + 320, v22, v21, a5);
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17a30 - 0x17a3a
// Line range:    1417 - 1433
int64_t private_data3(char * std_b25) {
    // 0x17a30
    int64_t result; // 0x17a30
    *(char *)result = 2 * (char)result;
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17a54 - 0x17a5b
// Line range:    1292 - 1300
int32_t get_reset_multi2_lib_flag(char * std_b25, char * isNeedResetMulti2Lib) {
    // 0x17a54
    int64_t result; // 0x17a54
    return result;
}

// Address range: 0x17a60 - 0x17a71
int64_t private_data4(int64_t result) {
    // 0x17a60
    mcount();
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17a77 - 0x17a84
// Line range:    1391 - 1412
int32_t get_ProgramNumberByPid(char * std_b25, int16_t pid, int32_t * program_number) {
    // 0x17a77
    uint64_t v1; // 0x17a77
    char * v2 = (char *)(v1 + 57); // 0x17a77
    int64_t v3; // 0x17a77
    char v4 = *v2 + (char)v3; // 0x17a77
    *v2 = v4;
    int64_t v5; // 0x17a77
    unsigned char v6 = *(char *)(v1 % 256 + v5); // 0x17a7a
    return v4 == 0 ? (int32_t)(v1 & 0xffffff00 | (int64_t)v6) : 0;
}

// Address range: 0x17a84 - 0x17aa7
int64_t get_reset_multi2_lib_flag2(int64_t a1, int64_t a2) {
    // 0x17a84
    mcount();
    *(char *)a2 = *(char *)(private_data4(a1) + 0x10672);
    return 0;
}

// Address range: 0x17aa7 - 0x17afc
int64_t get_ProgramNumberByPid2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x17aa7
    mcount();
    return private_data4(a1);
}

// Address range: 0x17afc - 0x17b08
int64_t function_17afc(int64_t a1, int64_t a2, int64_t a3) {
    // 0x17afc
    int64_t result; // 0x17afc
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17b0c - 0x17b26
// Line range:    1282 - 1290
int32_t set_bcas_card_exist(char * std_b25, char isExist) {
    // 0x17b0c
    int64_t v1; // 0x17b0c
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x17b0c
    char * v3 = (char *)(v2 + 0x1b803); // 0x17b0e
    *v3 = *v3 + (char)v2;
    int64_t result; // 0x17b0c
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17b2b - 0x17b3c
// Line range:    1272 - 1280
int32_t get_is_streamscramble(char * std_b25, char * isScramble) {
    // 0x17b2b
    int64_t v1; // 0x17b2b
    *(char *)v1 = 2 * (char)v1;
    return -1;
}

// Address range: 0x17b3c - 0x17b4d
int64_t set_bcas_card_exist2(int64_t a1, int64_t a2) {
    // 0x17b3c
    mcount();
    return private_data4(a1);
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17b4e - 0x17b5b
// Line range:    1262 - 1270
int32_t set_is_streamscramble(char * std_b25, char isScramble) {
    // 0x17b4e
    int64_t v1; // 0x17b4e
    int32_t v2 = 0x10000 * (int32_t)v1;
    int32_t result = v2 / 0x10000; // 0x17b4e
    bool v3; // 0x17b4e
    if (v3) {
        // 0x17b51
        *(int32_t *)(int64_t)result = v2 / 0x8000;
        return result;
    }
    // 0x17b57
    int64_t v4; // 0x17b4e
    char * v5 = (char *)(v4 - 55); // 0x17b57
    *v5 = *v5 + (char)v4;
    return result;
}

// Address range: 0x17b5b - 0x17b6d
int64_t get_is_streamscramble2(int64_t a1, int64_t a2) {
    // 0x17b5b
    mcount();
    return private_data4(a1);
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17b6d - 0x17b7e
// Line range:    1238 - 1246
int32_t get_prognum(char * std_b25, char index, int16_t * prognum) {
    // 0x17b6d
    int64_t v1; // 0x17b6d
    int64_t v2; // 0x17b6d
    *(char *)v1 = *(char *)(v2 + 0x10670);
    return 0;
}

// Address range: 0x17b7e - 0x17b9d
int64_t set_is_streamscramble2(int64_t a1, int64_t a2) {
    // 0x17b7e
    mcount();
    *(char *)(private_data4(a1) + 0x10670) = (char)a2;
    return 0;
}

// Address range: 0x17b9d - 0x17bae
int64_t get_prognum2(void) {
    // 0x17b9d
    int64_t result; // 0x17b9d
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17bae - 0x17bcb
// Line range:    1228 - 1236
int32_t enable_prognum_proc(char * std_b25, unsigned char enable) {
    // 0x17bae
    mcount();
    int64_t v1 = private_data4((int64_t)std_b25); // 0x17bb9
    return (int32_t)*(int16_t *)(2 * (int64_t)enable + 0x10410 + v1);
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17bcd - 0x17bde
// Line range:    1218 - 1226
int32_t set_prognum(char * std_b25, int16_t prog_num) {
    // 0x17bcd
    int64_t result; // 0x17bcd
    return result;
}

// Address range: 0x17bde - 0x17bea
int64_t enable_prognum_proc2(int64_t a1, int64_t a2) {
    // 0x17bde
    return mcount();
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17bed - 0x17bee
// Line range:    1183 - 1216
int32_t set_bcas_id(char * std_b25, char * card_info, int32_t info_len) {
    // 0x17bed
    int64_t result; // 0x17bed
    return result;
}

// Address range: 0x17bee - 0x17bfd
int64_t function_17bee(int64_t a1) {
    // 0x17bee
    int64_t v1; // 0x17bee
    int32_t * v2 = (int32_t *)(v1 + 0x1066c98); // 0x17bee
    *v2 = *v2 - 1;
    int64_t result; // 0x17bee
    char v3 = *(char *)&result; // 0x17bf4
    uint64_t v4; // 0x17bee
    *(char *)result = v3 + (char)(v4 >> (int64_t)&g95);
    return result;
}

// Address range: 0x17bfd - 0x17c1d
int64_t set_prognum2(int64_t a1, int64_t a2) {
    // 0x17bfd
    mcount();
    *(int16_t *)(private_data4(a1) + 0x1066e) = (int16_t)a2;
    return 0;
}

// Address range: 0x17c1d - 0x17c69
int64_t set_bcas_id2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x17c1d
    mcount();
    int64_t result = private_data4(a1); // 0x17c2f
    if ((int32_t)a3 > (int32_t)&g97 != result != 0) {
        // 0x17c3f
        return 0xffffffff;
    }
    int32_t * v1 = (int32_t *)(result + 0x10624); // 0x17c46
    *v1 = 0;
    int32_t v2 = (int32_t)*(char *)(a2 + (int64_t)&g25); // 0x17c54
    *v1 = v2;
    unsigned char v3 = *(char *)(a2 + (int64_t)&g33); // 0x17c5a
    *v1 = v2 << (int32_t)&g95 | (int32_t)v3;
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17c6f - 0x17c93
// Line range:    533 - 543
int64_t get_b_cas_card_arib_std_b25(char * std_b25) {
    // 0x17c6f
    int64_t v1; // 0x17c6f
    *(char *)v1 = 2 * (char)v1;
    int64_t result; // 0x17c6f
    int64_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    int64_t v3; // 0x17c6f
    unsigned char v4 = *(char *)(v3 + (int64_t)&g86); // 0x17c77
    int32_t * v5 = (int32_t *)(result + 0x10620); // 0x17c7b
    *v5 = 256 * *v5 | (int32_t)v4;
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17c93 - 0x17c9f
// Line range:    519 - 531
int32_t set_b_cas_card_arib_std_b25(char * std_b25, int64_t bcas) {
    // 0x17c93
    return 0;
}

// Address range: 0x17c9f - 0x17cc1
int64_t get_b_cas_card_arib_std_b25_(void) {
    // 0x17c9f
    mcount();
    int64_t v1; // 0x17c9f
    int64_t v2 = private_data4(v1); // 0x17ca8
    if (v2 == 0) {
        int64_t v3; // 0x17c9f
        set_multi2_round_arib_std_b25((char *)v1, (int32_t)v3);
    }
    // 0x17cba
    return *(int64_t *)(v2 + 0x10618);
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17cc1 - 0x17cc3
// Line range:    505 - 517
int32_t set_multi2_round_arib_std_b25(char * std_b25, int32_t round) {
    // 0x17cc1
    int64_t result; // 0x17cc1
    return result;
}

// Address range: 0x17cc3 - 0x17ce9
int64_t set_b_cas_card_arib_std_b25_(int64_t a1, int64_t a2) {
    // 0x17cc3
    mcount();
    *(int64_t *)(private_data4(a1) + 0x10618) = a2;
    return 0xffffffff;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17ce9 - 0x17cf1
// Line range:    1799 - 1834
int32_t proc_cat(int64_t prv) {
    // 0x17ce9
    return 0;
}

// Address range: 0x17cf1 - 0x17d19
int64_t set_multi2_round_arib_std_b25_(int64_t a1, int64_t a2) {
    // 0x17cf1
    mcount();
    int64_t v1 = private_data4(a1); // 0x17cfd
    int64_t result = 0xffffffff; // 0x17d0d
    if (v1 != 0) {
        // 0x17d0f
        *(int32_t *)v1 = (int32_t)a2;
        result = 0;
    }
    // 0x17d16
    return result;
}

// Address range: 0x17d19 - 0x17d50
int64_t proc_cat2(int64_t a1) {
    // 0x17d19
    mcount();
    return *(int64_t *)(a1 + 176) + 8;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17d6c - 0x17d9c
// Line range:    1166 - 1181
int32_t get_arib_std_b25(char * std_b25, int64_t buf) {
    // 0x17d6c
    int64_t v1; // 0x17d6c
    unsigned char v2 = *(char *)(v1 + (int64_t)&g25); // 0x17d6c
    unsigned char v3 = *(char *)(v1 + (int64_t)&g33); // 0x17d73
    *(int32_t *)((int64_t)std_b25 + 600) = ((int32_t)v2 << (int32_t)&g95) % 0x2000 | (int32_t)v3;
    return 0;
}

// Address range: 0x17d9c - 0x17dc6
int64_t get_arib_std_b25_(int64_t a1, int64_t a2) {
    // 0x17d9c
    mcount();
    int64_t v1 = private_data4(a1); // 0x17da9
    return a2 != 0 == (v1 != 0) ? v1 : 0xffffffff;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17dc6 - 0x17dee
// Line range:    3488 - 3505
int32_t check_ts_section(int64_t sect) {
    // 0x17dc6
    int64_t result; // 0x17dc6
    int64_t * v1 = (int64_t *)(result + 0x10658); // 0x17dc9
    int64_t v2 = result + 0x10650; // 0x17dd0
    int32_t v3 = *(int32_t *)v2; // 0x17dd0
    int64_t v4; // 0x17dc6
    *(int32_t *)(v4 + (int64_t)&g95) = (int32_t)*v1 - v3;
    int64_t v5 = *(int64_t *)(result + 0x10648); // 0x17dd9
    *(int64_t *)v2 = v5;
    *v1 = v5;
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17def - 0x17df6
// Line range:    1709 - 1722
int32_t check_pmt_complete(int64_t prv) {
    // 0x17def
    int64_t v1; // 0x17def
    *(char *)v1 = 2 * (char)v1;
    int64_t result; // 0x17def
    int64_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0x17df6 - 0x17e1f
int64_t check_ts_section2(int64_t a1) {
    // 0x17df6
    mcount();
    uint32_t v1 = *(int32_t *)(a1 + 44); // 0x17dff
    int64_t result = 0; // 0x17e09
    if (v1 >= 1) {
        int32_t v2 = v1 + 3; // 0x17e0b
        int32_t v3 = *(int32_t *)(a1 + (int64_t)&g95); // 0x17e12
        int32_t v4 = (int32_t)*(int64_t *)(a1 + (int64_t)&g2) - v3; // 0x17e12
        int32_t v5 = v2 - v4; // 0x17e15
        result = v5 == 0 | v5 < 0 != ((v5 ^ v2) & (v4 ^ v2)) < 0;
    }
    // 0x17e1d
    return result;
}

// Address range: 0x17e1f - 0x17e49
int64_t check_pmt_complete2(int64_t a1) {
    // 0x17e1f
    return mcount();
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17e4e - 0x17e7e
// Line range:    2293 - 2320
int32_t check_ecm_complete(int64_t prv) {
    int64_t v1 = check_ts_section2(prv + (int64_t)&g95); // 0x17e57
    return (int32_t)v1 == 0 ? 0 : (int32_t)&g1;
}

// Address range: 0x17e7e - 0x17ea8
int64_t check_ecm_complete2(int64_t a1) {
    // 0x17e7e
    return mcount();
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17ec6 - 0x17ef6
// Line range:    3560 - 3570
void extract_ts_header(int64_t dst, char * src) {
    // 0x17ec6
    bool v1; // 0x17ec6
    if (!v1) {
        // 0x17eed
        return;
    }
    // 0x17ec8
    check_ts_section2(dst + 168);
}

// Address range: 0x17ef6 - 0x17f35
int64_t extract_ts_header2(int64_t * a1, int64_t a2) {
    int64_t v1 = (int64_t)a1;
    mcount();
    int64_t v2; // 0x17ef6
    *(int32_t *)a1 = (int32_t)v2 % 256;
    char * v3 = (char *)(a2 + (int64_t)&g1); // 0x17f08
    *(int32_t *)(v1 + (int64_t)&g86) = (int32_t)*v3;
    unsigned char v4 = *v3; // 0x17f14
    *(int32_t *)(v1 + (int64_t)&g95) = (int32_t)(v4 >> (char)&g91) & (int32_t)&g1;
    unsigned char v5 = *v3; // 0x17f20
    *(int32_t *)(v1 + (int64_t)"GNU") = (int32_t)(v5 >> (char)&g89) & (int32_t)&g1;
    unsigned char v6 = *v3; // 0x17f2c
    return ((int32_t)v6 & (int32_t)&g24) << (int32_t)&g95;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17f35 - 0x17f65
// Line range:    3572 - 3591
void extract_ts_section_header(int64_t dst, char * src) {
    int64_t v1 = (int64_t)src;
    unsigned char v2 = *(char *)(v1 + (int64_t)&g25); // 0x17f35
    int64_t v3; // 0x17f35
    *(int32_t *)(dst + (int64_t)&g2) = (int32_t)v2 | (int32_t)v3;
    char * v4 = (char *)(v1 + (int64_t)&g33); // 0x17f42
    unsigned char v5 = *v4; // 0x17f42
    *(int32_t *)(dst + (int64_t)&g7) = (int32_t)(v5 >> (char)&g91);
    unsigned char v6 = *v4; // 0x17f4e
    *(int32_t *)(dst + (int64_t)&g13) = (int32_t)(v6 >> (char)&g86) & (int32_t)&g33;
    unsigned char v7 = *v4; // 0x17f5a
    *(int32_t *)(dst + (int64_t)&g19) = (int32_t)v7 & (int32_t)&g105;
}

// Address range: 0x17f65 - 0x17fd3
int64_t extract_ts_section_header2(int64_t a1, int64_t a2) {
    // 0x17f65
    mcount();
    int64_t v1; // 0x17f65
    *(int32_t *)a1 = (uint32_t)(int32_t)v1 % 256;
    char * v2 = (char *)(a2 + (int64_t)&g1); // 0x17f77
    *(int32_t *)(a1 + (int64_t)&g86) = (int32_t)*v2;
    unsigned char v3 = *v2; // 0x17f83
    *(int32_t *)(a1 + (int64_t)&g95) = (int32_t)(v3 >> (char)&g91) & (int32_t)&g1;
    unsigned char v4 = *v2; // 0x17f8f
    unsigned char v5 = *(char *)(a2 + (int64_t)&g25); // 0x17f95
    *(int32_t *)(a1 + (int64_t)"GNU") = ((int32_t)v4 << (int32_t)&g95 | (int32_t)v5) & (int32_t)&g106;
    unsigned char v6 = *(char *)(a2 + (int64_t)&g33); // 0x17fa7
    unsigned char v7 = *(char *)(a2 + (int64_t)&g86); // 0x17fae
    *(int32_t *)(a1 + (int64_t)&g2) = (int32_t)v6 << (int32_t)&g95 | (int32_t)v7;
    char * v8 = (char *)(a2 + (int64_t)&g89); // 0x17fbb
    unsigned char v9 = *v8; // 0x17fbb
    *(int32_t *)(a1 + (int64_t)&g7) = (int32_t)(v9 >> (char)&g1) & (int32_t)&g24;
    unsigned char v10 = *v8; // 0x17fc6
    *(int32_t *)(a1 + (int64_t)&g13) = (int32_t)v10 & (int32_t)&g1;
    return (int64_t)*(char *)(a2 + (int64_t)&g91);
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x17fd4 - 0x18004
// Line range:    3609 - 3631
char * resync(char * head, char * tail, int32_t unit_size) {
    // 0x17fd4
    bool v1; // 0x17fd4
    int64_t v2 = v1 ? (int64_t)(unsigned char)((char)&g105 + 1) : (int64_t)(unsigned char)(char)&g105; // 0x17fd4
    int64_t v3; // 0x17fd4
    return (char *)((v3 - v2) % 256 | v3 & -256);
}

// Address range: 0x17fda - 0x17fdf
int64_t function_17fda(int64_t a1) {
    // 0x17fda
    int64_t result; // 0x17fda
    *(int32_t *)(a1 + (int64_t)&g26) = (int32_t)result;
    return result;
}

// Address range: 0x18004 - 0x18035
int64_t resync2(int64_t result, int64_t a2, int32_t a3) {
    // 0x18004
    mcount();
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x18045 - 0x18075
// Line range:    3507 - 3524
int32_t check_ts_section_crc(int64_t sect) {
    // 0x18045
    int64_t v1; // 0x18045
    int32_t * v2 = (int32_t *)(v1 + 99); // 0x18045
    uint32_t v3 = *v2; // 0x18045
    *v2 = v3 / 2 | 0x80000000 * v3;
    char v4 = *(char *)(v1 + sect * (int64_t)&g1); // 0x18049
    int64_t v5; // 0x18045
    int32_t result = (int32_t)v5 == (int32_t)&g95 | v4 == 71 ? (int32_t)v1 : 0; // 0x18074
    return result;
}

// Address range: 0x18075 - 0x1809d
int64_t check_ts_section_crc2(int64_t a1) {
    // 0x18075
    mcount();
    return *(int64_t *)(a1 + (int64_t)&g95);
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x1809e - 0x180ce
// Line range:    1486 - 1556
int32_t select_unit_size(int64_t prv) {
    // 0x1809e
    uint64_t v1; // 0x1809e
    uint64_t v2; // 0x1809e
    if (v2 >= v1) {
        // 0x180c4
        int64_t v3; // 0x1809e
        return (int32_t)v3 == 0;
    }
    int64_t v4; // 0x1809e
    uint32_t v5 = (int32_t)v4; // 0x180a9
    int64_t v6; // 0x1809e
    char v7 = *(char *)v6; // 0x180b1
    int32_t v8 = *(int32_t *)((int64_t)(v7 ^ (char)(v5 >> (int32_t)&g13)) * (int64_t)&g86); // 0x180b6
    int64_t v9 = v8 ^ v5 << (int32_t)&g95; // 0x180b9
    int64_t v10 = v6 + (int64_t)&g1; // 0x180bb
    while (v1 > v10) {
        // 0x180a9
        v5 = (int32_t)v9;
        v7 = *(char *)v10;
        v8 = *(int32_t *)((int64_t)(v7 ^ (char)(v5 >> (int32_t)&g13)) * (int64_t)&g86);
        v9 = v8 ^ v5 << (int32_t)&g95;
        v10 += (int64_t)&g1;
    }
    // 0x180c4
    return (int32_t)v9 == 0;
}

// Address range: 0x180ce - 0x18212
int64_t select_unit_size2(int64_t a1) {
    // 0x180ce
    mcount();
    uint64_t v1 = *(int64_t *)(a1 + 0x10630); // 0x180e1
    uint64_t v2 = *(int64_t *)(a1 + 0x10638); // 0x180e8
    int64_t v3; // bp-1288, 0x180ce
    __asm_rep_stosq_memset((char *)&v3, 0, 160);
    int64_t result = v1; // 0x18119
    int64_t v4 = v1; // 0x18119
    if (*(char *)v1 != 71) {
        result++;
        while (v2 > result) {
            // 0x1811d
            v4 = result;
            if (*(char *)result == 71) {
                goto lab_0x18133;
            }
            result++;
        }
        // 0x1812b
        return result;
    }
  lab_0x18133:;
    int64_t v5 = v4 + (int64_t)&g1; // 0x1813c
    int64_t v6; // 0x180ce
    int32_t v7 = v6; // 0x18143
    int64_t v8; // bp-536, 0x180ce
    if (v2 > v5) {
        // 0x18149
        int64_t v9; // bp-8, 0x180ce
        int64_t v10 = (int64_t)&v9 - 1280;
        int64_t v11 = v4 - 187;
        int64_t v12 = v5;
        int64_t v13 = v4; // 0x18153
        int64_t v14; // 0x180ce
        int64_t v15; // 0x180ce
        int64_t v16; // 0x1815b
        int32_t v17; // 0x18165
        int32_t * v18; // 0x181b9
        int64_t v19; // 0x1818f
        int64_t v20; // 0x1817b
        int32_t * v21; // 0x1819d
        if (*(char *)v12 == 71) {
            // 0x18155
            v16 = v12 - v4;
            v17 = v16;
            if (v17 > 187) {
                // 0x181aa
                v13 = v12;
                if (v17 <= 319) {
                    // 0x181b6
                    v18 = (int32_t *)(0x100000000 * v16 / 0x100000000 * (int64_t)&g86 + v10);
                    *v18 = *v18 + (int32_t)&g1;
                    v13 = v12;
                }
            } else {
                // 0x18167
                v13 = v4;
                if (v1 <= v11) {
                    // 0x1816f
                    v14 = v11;
                    v15 = v11;
                    if (*(char *)v11 != 71) {
                        v19 = v15 - (int64_t)&g1;
                        v13 = v4;
                        while (v1 <= v19) {
                            // 0x18176
                            v14 = v19;
                            if (*(char *)v19 == 71) {
                                goto lab_0x1817b;
                            }
                            v19 -= (int64_t)&g1;
                            v13 = v4;
                        }
                    } else {
                        // 0x1817b
                        v20 = (v12 & 0xffffffff) - v14;
                        v13 = v4;
                        if ((int32_t)v20 < 320) {
                            // 0x1819a
                            v21 = (int32_t *)(0x100000000 * v20 / 0x100000000 * (int64_t)&g86 + v10);
                            *v21 = *v21 + (int32_t)&g1;
                            v13 = v12;
                        }
                    }
                }
            }
        }
        int64_t v22 = v12 + (int64_t)&g1; // 0x181c2
        int64_t v23 = v11 + 1; // 0x181cd
        while (v22 != v2) {
            int64_t v24 = v13;
            v11 = v23;
            v12 = v22;
            v13 = v24;
            if (*(char *)v12 == 71) {
                // 0x18155
                v16 = v12 - v24;
                v17 = v16;
                if (v17 > 187) {
                    // 0x181aa
                    v13 = v12;
                    if (v17 <= 319) {
                        // 0x181b6
                        v18 = (int32_t *)(0x100000000 * v16 / 0x100000000 * (int64_t)&g86 + v10);
                        *v18 = *v18 + (int32_t)&g1;
                        v13 = v12;
                    }
                } else {
                    // 0x18167
                    v13 = v24;
                    if (v1 <= v11) {
                        // 0x1816f
                        v14 = v11;
                        v15 = v11;
                        if (*(char *)v11 != 71) {
                            v19 = v15 - (int64_t)&g1;
                            v13 = v24;
                            while (v1 <= v19) {
                                // 0x18176
                                v14 = v19;
                                if (*(char *)v19 == 71) {
                                    goto lab_0x1817b;
                                }
                                v19 -= (int64_t)&g1;
                                v13 = v24;
                            }
                        } else {
                            // 0x1817b
                            v20 = (v12 & 0xffffffff) - v14;
                            v13 = v24;
                            if ((int32_t)v20 < 320) {
                                // 0x1819a
                                v21 = (int32_t *)(0x100000000 * v20 / 0x100000000 * (int64_t)&g86 + v10);
                                *v21 = *v21 + (int32_t)&g1;
                                v13 = v12;
                            }
                        }
                    }
                }
            }
            // 0x181c2
            v22 = v12 + (int64_t)&g1;
            v23 = v11 + 1;
        }
        // 0x181cf
        v7 = *(int32_t *)&v8;
    }
    uint64_t v25 = (int64_t)v7;
    int64_t v26 = (int64_t)&v8 + (int64_t)&g86; // 0x181f8
    int64_t v27 = 189; // 0x181f5
    uint64_t v28 = (int64_t)*(int32_t *)v26; // 0x181e6
    int64_t v29 = v25 < v28 ? v27 : v7 == 0 ? 0 : 188;
    int64_t v30 = v25 < v28 ? v28 : v25;
    int64_t v31 = v27 + 1; // 0x181f5
    int64_t v32 = v29; // 0x18201
    int64_t v33 = v26; // 0x18201
    while ((int32_t)v31 != 320) {
        // 0x18203
        v25 = v30;
        v26 = v33 + (int64_t)&g86;
        v27 = v31 & 0xffffffff;
        v28 = (int64_t)*(int32_t *)v26;
        v29 = v25 < v28 ? v27 : v32;
        v30 = v25 < v28 ? v28 : v25;
        v31 = v27 + 1;
        v32 = v29;
        v33 = v26;
    }
    // 0x18208
    return 0x100000000 * v29 / 0x100000000 * 0x100000000 * v30 / 0x100000000 & 0xffffffff;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x18214 - 0x18244
// Line range:    3526 - 3531
void reset_ts_section(uint64_t sect) {
    // 0x18214
    int64_t v1; // 0x18214
    int64_t v2; // 0x18214
    int64_t v3; // 0x18214
    if ((uint64_t)(v2 - v1 - 0x100000000 * ((int64_t)(uint32_t)((int32_t)v3 >> (uint32_t)(int32_t)&g24) << (uint64_t)(int64_t)&g26 | v3 & 0xffffffff) / (int64_t)(uint32_t)(int32_t)&g95 / 0x100000000) <= sect) {
        // 0x18233
        int64_t v4; // 0x18214
        int64_t v5; // 0x18214
        *(int32_t *)(v4 + (int64_t)&g86) = (int32_t)v5;
    }
}

// Address range: 0x18244 - 0x18254
int64_t reset_ts_section2(int64_t result) {
    // 0x18244
    mcount();
    *(int64_t *)(result + (int64_t)&g95) = result;
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x18254 - 0x18284
// Line range:    2244 - 2291
void setup_pid_map(int64_t prv) {
    // 0x18254
    *(int64_t *)(prv + (int64_t)&g26) = 0;
    *(int64_t *)(prv + (int64_t)&g26 + (int64_t)&g95) = 0;
    *(int64_t *)(prv + (int64_t)&g26 + (int64_t)&g2) = 0;
    *(int64_t *)(prv + (int64_t)&g26 + (int64_t)&g13) = 0;
    *(int32_t *)(prv + 2 * (int64_t)&g26) = 0;
}

// Address range: 0x18284 - 0x182f5
int64_t setup_pid_map2(int64_t a1) {
    // 0x18284
    mcount();
    memset(a1 + 1040, 0, 0x10000);
    int64_t set_mem = memset(a1 + 0x10674, 0, 0x81400); // 0x182c0
    *(char *)(a1 + 0x91a74) = 0;
    return set_mem;
}

// Address range: 0x182f9 - 0x18304
int64_t function_182f9(int64_t a1) {
    // 0x182f9
    int64_t v1; // 0x182f9
    int64_t v2; // 0x182f9
    int64_t result = v2 & -256 | (int64_t)(*(char *)(v1 - 0x76e88b40) + (char)v2); // 0x182f9
    int32_t * v3 = (int32_t *)(result - 125); // 0x182ff
    uint32_t v4 = *v3; // 0x182ff
    *v3 = v4 >> (int32_t)&g19 | 16 * v4;
    return result;
}

// Address range: 0x1830a - 0x18311
int64_t function_1830a(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1830a
    int64_t result; // 0x1830a
    return result;
}

// Address range: 0x18311 - 0x18325
int64_t function_18311(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x18311
    int64_t result; // 0x18311
    char * v1 = (char *)(result * ((int64_t)&g1 + 1)); // 0x18311
    char v2 = result; // 0x18311
    bool v3; // 0x18311
    *v1 = *v1 + v2 + (char)v3;
    int64_t v4; // 0x18311
    char * v5 = (char *)(v4 + 0x9c82); // 0x18314
    *v5 = *v5 + (char)a4;
    int64_t v6; // 0x18311
    char * v7 = (char *)(v6 - 0x76e88b40); // 0x1831a
    *v7 = *v7 + v2;
    int32_t * v8 = (int32_t *)(result - 125); // 0x18320
    uint32_t v9 = *v8; // 0x18320
    *v8 = v9 >> (int32_t)&g19 | 16 * v9;
    return result;
}

// Address range: 0x1832b - 0x18332
int64_t function_1832b(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1832b
    int64_t result; // 0x1832b
    return result;
}

// Address range: 0x18332 - 0x18346
int64_t function_18332(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x18332
    int64_t result; // 0x18332
    char * v1 = (char *)(result * ((int64_t)&g1 + 1)); // 0x18332
    char v2 = result; // 0x18332
    bool v3; // 0x18332
    *v1 = *v1 + v2 + (char)v3;
    int64_t v4; // 0x18332
    char * v5 = (char *)(v4 + 0xa082); // 0x18335
    *v5 = *v5 + (char)a4;
    int64_t v6; // 0x18332
    char * v7 = (char *)(v6 - 0x76e88b40); // 0x1833b
    *v7 = *v7 + v2;
    int32_t * v8 = (int32_t *)(result - 125); // 0x18341
    uint32_t v9 = *v8; // 0x18341
    *v8 = v9 >> (int32_t)&g19 | 16 * v9;
    return result;
}

// Address range: 0x1834c - 0x18353
int64_t function_1834c(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1834c
    int64_t result; // 0x1834c
    return result;
}

// Address range: 0x1839f - 0x183a2
int64_t function_1839f(void) {
    // 0x1839f
    int64_t result; // 0x1839f
    return result;
}

// Address range: 0x183b5 - 0x183b6
int64_t function_183b5(void) {
    // 0x183b5
    int64_t result; // 0x183b5
    return result;
}

// Address range: 0x183c9 - 0x183cb
int64_t function_183c9(void) {
    // 0x183c9
    int64_t v1; // 0x183c9
    int64_t v2; // 0x183c9
    int64_t v3; // 0x183c9
    int64_t v4; // 0x183c9
    return function_183db(v1, v2, v3, v4);
}

// Address range: 0x183cb - 0x183db
int64_t function_183cb(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x183cb
    int64_t v1; // 0x183cb
    char * v2 = (char *)v1; // 0x183cd
    char v3 = *v2 + (char)v1; // 0x183cd
    *v2 = v3;
    int64_t result; // 0x183cb
    if (v3 != 0) {
        result = function_183db(a1, a2, a3, a4);
    }
    // 0x183d1
    int64_t v4; // 0x183cb
    *(int64_t *)((8 * a1 & 0x7fffffff8) + 1040 + v4) = a5;
    return result;
}

// Address range: 0x183db - 0x18408
int64_t function_183db(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t * v1 = (int64_t *)(a3 + 312); // 0x183db
    int64_t v2; // 0x183db
    *(int32_t *)a4 = *(int32_t *)(*v1 + v2);
    int32_t v3 = *(int32_t *)(v2 + 4 + *v1); // 0x183ee
    *(int32_t *)(a4 + (int64_t)&g86) = v3;
    int32_t v4 = *(int32_t *)(a3 + 320); // 0x18400
    int64_t result = v2 + (int64_t)&g95; // 0x18406
    if ((a2 + (int64_t)(int32_t)&g1 & 0xffffffff) < (int64_t)v4) {
        result = function_183b5();
    }
    // 0x18408
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x18409 - 0x18439
// Line range:    1346 - 1389
int32_t get_ContentAvailabilityDescriptor(char * std_b25, int16_t pid, char * databuffer) {
    // 0x18409
    int64_t v1; // 0x18409
    *(char *)(v1 + 0x91a74) = (char)&g1;
    int64_t result; // 0x18409
    return result;
}

// Address range: 0x18439 - 0x18500
int64_t get_ContentAvailabilityDescriptor2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x18439
    mcount();
    int64_t v1 = *(int64_t *)(private_data4(a1) + 1024); // 0x1845f
    int32_t * v2 = (int32_t *)(v1 + 860); // 0x1849f
    uint32_t v3 = *v2; // 0x1849f
    int64_t v4; // 0x18439
    if (v3 != 0) {
        // 0x184a9
        memcpy(a3, v1 + 600, (int64_t)v3, v4);
        return (int64_t)*v2;
    }
    int32_t * v5 = (int32_t *)(v1 + 1388); // 0x184c2
    uint32_t v6 = *v5; // 0x184c2
    if (v6 == 0) {
        // 0x184e5
        return memcpy(a3, v1 + 1656, (int64_t)*(int32_t *)(v1 + 1916), v4);
    }
    // 0x184cc
    memcpy(a3, v1 + 1128, (int64_t)v6, v4);
    return (int64_t)*v5;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x18500 - 0x18530
// Line range:    1302 - 1344
int32_t get_DigitalCopyControlDescriptor(char * std_b25, int16_t pid, char * databuffer) {
    // 0x18500
    int64_t v1; // 0x18500
    return *(int32_t *)(v1 + 1916);
}

// Address range: 0x18530 - 0x185f7
int64_t get_DigitalCopyControlDescriptor2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x18530
    mcount();
    int64_t v1 = *(int64_t *)(private_data4(a1) + 1024); // 0x18556
    int32_t * v2 = (int32_t *)(v1 + 596); // 0x18596
    uint32_t v3 = *v2; // 0x18596
    int64_t v4; // 0x18530
    if (v3 != 0) {
        // 0x185a0
        memcpy(a3, v1 + 336, (int64_t)v3, v4);
        return (int64_t)*v2;
    }
    int32_t * v5 = (int32_t *)(v1 + 1124); // 0x185b9
    uint32_t v6 = *v5; // 0x185b9
    if (v6 == 0) {
        // 0x185dc
        return memcpy(a3, v1 + 1392, (int64_t)*(int32_t *)(v1 + 1652), v4);
    }
    // 0x185c3
    memcpy(a3, v1 + 864, (int64_t)v6, v4);
    return (int64_t)*v5;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x185f7 - 0x18627
// Line range:    1248 - 1260
int32_t get_prognum_ex(char * std_b25, char * prognum) {
    // 0x185f7
    int64_t v1; // 0x185f7
    return *(int32_t *)(v1 + 1652);
}

// Address range: 0x18627 - 0x18648
int64_t get_prognum_ex2(int64_t a1, int64_t a2) {
    // 0x18627
    mcount();
    return private_data4(a1);
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x1864b - 0x1867b
// Line range:    3533 - 3540
void swap_ts_section(int64_t curr, int64_t next) {
    // 0x1864b
    int64_t v1; // 0x1864b
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x1864b
    if (*(char *)(v2 + 0x91a74) != 0) {
        // 0x18656
        int64_t v3; // 0x1864b
        int64_t v4; // 0x1864b
        memcpy(v3, v2 + 0x10674, 0x81400, v4);
    }
}

// Address range: 0x1867b - 0x1873a
int64_t swap_ts_section2(int64_t a1, int64_t a2) {
    // 0x1867b
    mcount();
    int64_t v1 = a1 + 64; // 0x1869c
    int64_t v2 = a1 + 56; // 0x186a4
    int64_t v3 = a1 + 48; // 0x186ac
    int64_t v4 = a1 + 40; // 0x186b3
    *(int64_t *)a1 = a2;
    int64_t v5 = *(int64_t *)(a2 + (int64_t)&g95); // 0x186db
    *(int64_t *)(a1 + (int64_t)&g95) = v5;
    int64_t v6 = *(int64_t *)(a2 + (int64_t)&g2); // 0x186e3
    *(int64_t *)(a1 + (int64_t)&g2) = v6;
    int64_t v7 = *(int64_t *)(a2 + (int64_t)&g13); // 0x186eb
    *(int64_t *)(a1 + (int64_t)&g13) = v7;
    int64_t v8 = *(int64_t *)(a2 + (int64_t)&g26); // 0x186f3
    *(int64_t *)(a1 + (int64_t)&g26) = v8;
    int64_t v9 = a2 + 40; // 0x186fb
    *(int64_t *)v4 = *(int64_t *)v9;
    int64_t v10 = a2 + 48; // 0x18703
    *(int64_t *)v3 = *(int64_t *)v10;
    int64_t v11 = a2 + 56; // 0x1870b
    *(int64_t *)v2 = *(int64_t *)v11;
    int64_t v12 = a2 + 64; // 0x18713
    int64_t result = *(int64_t *)v12; // 0x18713
    *(int64_t *)v1 = result;
    *(int32_t *)v12 = *(int32_t *)v1;
    *(int32_t *)(a2 + 60) = *(int32_t *)(a1 + 60);
    *(int32_t *)v11 = *(int32_t *)v2;
    *(int32_t *)(a2 + 52) = *(int32_t *)(a1 + 52);
    *(int32_t *)v10 = *(int32_t *)v3;
    *(int32_t *)(a2 + 44) = *(int32_t *)(a1 + 44);
    *(int32_t *)v9 = *(int32_t *)v4;
    *(int32_t *)(a2 + 36) = *(int32_t *)(a1 + 36);
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x1873a - 0x1876a
// Line range:    1745 - 1797
int32_t proc_emm(int64_t prv) {
    // 0x1873a
    int64_t v1; // 0x1873a
    int64_t v2; // 0x1873a
    *(int32_t *)(v2 + (int64_t)&g26) = (int32_t)v1;
    int64_t v3; // 0x1873a
    *(int32_t *)(v2 + (int64_t)&g13) = (int32_t)v3;
    int64_t v4; // 0x1873a
    *(int64_t *)(v2 + (int64_t)&g95) = *(int64_t *)(v4 - 56);
    int64_t result = *(int64_t *)(v4 - 48); // 0x1874d
    *(int64_t *)v2 = result;
    return result;
}

// Address range: 0x1876a - 0x18879
int64_t proc_emm2(int64_t a1) {
    // 0x1876a
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 616); // 0x18796
    unsigned char v2 = *(char *)(v1 + 10); // 0x187d1
    unsigned char v3 = *(char *)(v1 + 11); // 0x187d8
    unsigned char v4 = *(char *)(v1 + 12); // 0x187e1
    unsigned char v5 = *(char *)(v1 + 13); // 0x187f3
    int64_t result = 256 * (256 * (256 * (int64_t)v2 | (int64_t)v3) | (int64_t)v4) | (int64_t)v5; // 0x187f7
    if (*(int32_t *)(a1 + 0x10620) != (int32_t)result) {
        // 0x1884a
        *(int32_t *)(a1 + 752) = 0;
        return result;
    }
    int64_t v6 = v1 + 8; // 0x1879d
    unsigned char v7 = *(char *)v6; // 0x187c5
    int64_t v8 = 256 * (int64_t)v7 | (int64_t)*(char *)(v1 + 9); // 0x187cf
    if (*(int32_t *)(a1 + 0x10624) != (int32_t)v8) {
        // 0x1884a
        *(int32_t *)(a1 + 752) = 0;
        return result;
    }
    int64_t v9 = (int64_t)*(char *)(v1 + 14) + 7; // 0x187ef
    memcpy(a1 + 756, v6, v9, v8);
    *(int32_t *)(a1 + 1012) = (int32_t)v9;
    int32_t * v10 = (int32_t *)(a1 + 752); // 0x18823
    *v10 = (int32_t)&g1;
    int64_t v11 = *(int64_t *)(a1 + 0x10618); // 0x1882f
    if ((int32_t)v11 >= 0 || (int32_t)&g1 >= 101) {
        // 0x18865
        return (int32_t)v11 >= 0 ? v11 : 0xfffffff5;
    }
    // 0x1886c
    *v10 = (int32_t)&g1 + 1;
    return (int32_t)&g1 + 1;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x1887c - 0x188ac
// Line range:    1836 - 1931
int32_t proc_sdt(int64_t prv) {
    // 0x1887c
    int64_t v1; // 0x1887c
    int64_t v2 = v1 & -16; // 0x1887c
    unsigned char v3 = *(char *)v2 + (char)v2; // 0x1887e
    char * v4 = (char *)(v1 & -256 | (int64_t)v3); // 0x18880
    *v4 = 2 * v3 + *v4;
    int64_t v5; // 0x1887c
    char * v6 = (char *)(v5 + 99); // 0x18884
    int64_t v7; // 0x1887c
    *v6 = *v6 + (char)v7;
    int64_t v8; // 0x1887c
    __asm_in_623((int16_t)v8);
    return 0;
}

// Address range: 0x188ac - 0x18a54
int64_t proc_sdt2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x188ac
    mcount();
    return *(int64_t *)(a1 + 320) + 11;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x18a54 - 0x18a84
// Line range:    1933 - 2025
int32_t proc_eit(int64_t prv) {
    // 0x18a54
    return 0;
}

// Address range: 0x18a84 - 0x18c28
int64_t proc_eit2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x18a84
    mcount();
    return *(int64_t *)(a1 + 464) + 14;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x18c28 - 0x18c58
// Line range:    3371 - 3380
void release_work_buffer(int64_t buf) {
    // 0x18c28
    return;
}

// Address range: 0x18c58 - 0x18c69
int64_t release_work_buffer2(int64_t a1) {
    // 0x18c58
    return mcount();
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x18c6b - 0x18c6c
// Line range:    3554 - 3558
void release_ts_section(int64_t sect) {
    // 0x18c6b
    return;
}

// Address range: 0x18c6c - 0x18c9b
int64_t function_18c6c(int64_t a1, int64_t a2) {
    // 0x18c6c
    int64_t result; // 0x18c6c
    if (a1 != 0) {
        // 0x18c71
        result = kfree(a1);
    }
    // 0x18c76
    int64_t v1; // 0x18c6c
    *(int64_t *)v1 = 0;
    *(int64_t *)(v1 + (int64_t)&g95) = 0;
    *(int64_t *)(v1 + (int64_t)&g2) = 0;
    *(int32_t *)(v1 + (int64_t)&g13) = 0;
    return result;
}

// Address range: 0x18c9b - 0x18cb1
int64_t release_ts_section2(int64_t a1) {
    // 0x18c9b
    mcount();
    return release_work_buffer2(a1);
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x18cb2 - 0x18ce2
// Line range:    3267 - 3286
void release_program(int64_t pgrm) {
    // 0x18cb2
    int64_t v1; // 0x18cb2
    int64_t v2 = v1 + (int64_t)(uint32_t)(int32_t)&g26 & 0xffffffff; // 0x18cb2
    *(int64_t *)v2 = 0;
    *(int64_t *)(v2 + (int64_t)&g95) = 0;
    *(int64_t *)(v2 + (int64_t)&g2) = 0;
    *(int64_t *)(v2 + (int64_t)&g13) = 0;
    *(int32_t *)(v2 + (int64_t)&g26) = 0;
}

// Address range: 0x18ce2 - 0x18d29
int64_t release_program2(int64_t a1) {
    // 0x18ce2
    mcount();
    release_ts_section2(a1 + (int64_t)&g95);
    release_ts_section2(a1 + 80);
    release_ts_section2(a1 + 168);
    return release_ts_section2(a1 + 240);
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x18d2d - 0x18d5d
// Line range:    2111 - 2170
int32_t proc_pmt(int64_t pgrm) {
    // 0x18d2d
    int64_t v1; // 0x18d2d
    char * v2 = (char *)(v1 - 57); // 0x18d2d
    int64_t v3; // 0x18d2d
    *v2 = *v2 + (char)v3;
    int64_t v4; // 0x18d2d
    int64_t v5 = v4;
    *(char *)v5 = *(char *)&v4 + (char)v5;
    int64_t v6 = v4;
    *(char *)v6 = *(char *)&v4 + (char)v6;
    int64_t v7 = v4;
    *(char *)v7 = *(char *)&v4 + (char)v7;
    int64_t v8; // 0x18d2d
    int64_t * v9 = (int64_t *)(v8 + 328); // 0x18d39
    int64_t v10 = *v9; // 0x18d39
    v4 = v10;
    int32_t result = 0; // 0x18d43
    if (v10 != 0) {
        // 0x18d45
        *v9 = 0;
        result = v4;
    }
    // 0x18d56
    return result;
}

// Address range: 0x18d5d - 0x18fc6
int64_t proc_pmt2(int32_t a1) {
    int64_t v1 = a1;
    mcount();
    int64_t v2 = *(int64_t *)(v1 + (int64_t)&g2); // 0x18d81
    int64_t v3 = v2 + (int64_t)&g95; // 0x18d85
    int32_t v4 = *(int32_t *)(v1 + 52); // 0x18d89
    unsigned char v5 = *(char *)(v2 + (int64_t)&g95 + (int64_t)&g1); // 0x18d98
    unsigned char v6 = *(char *)v3; // 0x18d9c
    uint32_t v7 = ((int32_t)v6 << (int32_t)&g95) % 0x2000 | (int32_t)v5; // 0x18da4
    *(int32_t *)(v1 + 156) = v7;
    int64_t v8 = v2 + (int64_t)"GNU"; // 0x18db0
    unsigned char v9 = *(char *)(v2 + (int64_t)&g95 + (int64_t)&g25); // 0x18db4
    unsigned char v10 = *(char *)(v2 + (int64_t)&g95 + (int64_t)&g33); // 0x18dbd
    uint64_t v11 = (int64_t)(((int32_t)v9 << (int32_t)&g95 | (int32_t)v10) & (int32_t)&g106) * (int64_t)&g1 + v8; // 0x18dcb
    int64_t v12 = v2 + (int64_t)"GNU" + (int64_t)&g1; // 0x18dd9
    int64_t v13 = v7; // 0x18de0
    if (v11 > v12) {
        int64_t v14 = v5; // 0x18d98
        int64_t v15 = v1 + 600; // 0x18e07
        int32_t * v16 = (int32_t *)(v1 + 160);
        unsigned char v17 = *(char *)v8; // 0x18e1e
        unsigned char v18 = *(char *)v12; // 0x18e23
        int64_t v19 = v18; // 0x18e23
        int64_t v20 = v8 + (int64_t)&g25; // 0x18e26
        int64_t v21 = v15; // 0x18e2e
        unsigned char v22; // 0x18e41
        unsigned char v23; // 0x18e4b
        int32_t v24; // 0x18e54
        if ((int32_t)v17 == (int32_t)&g97 == (int32_t)v18 > (int32_t)&g33) {
            // 0x18e35
            v21 = v15;
            if (v11 >= v19 * (int64_t)&g1 + v20) {
                // 0x18e41
                v22 = *(char *)(v8 + 2 * (int64_t)&g25);
                v23 = *(char *)(v8 + (int64_t)&g25 + (int64_t)&g33);
                v24 = ((int32_t)v22 << (int32_t)&g95) % 0x2000 | (int32_t)v23;
                if (v24 != *v16) {
                    // 0x18e68
                    reset_ts_section2(v1 + 168);
                    reset_ts_section2(v1 + 240);
                }
                // 0x18e7a
                *v16 = v24;
                v21 = v1;
            }
        }
        int64_t v25 = v21;
        int64_t v26; // 0x18d5d
        int64_t v27; // 0x18d5d
        int64_t v28; // 0x18d5d
        int64_t v29; // 0x18d5d
        int64_t v30; // 0x18ea5
        int64_t v31; // 0x18ee0
        if (v17 == -63 == (v18 != 0)) {
            // 0x18e99
            v28 = v19 * (int64_t)&g1 + v20;
            v26 = v28;
            v27 = v25;
            if (v11 >= v28) {
                // 0x18ea5
                v30 = v19 + (int64_t)(int32_t)&g25;
                memcpy(v1 + 336, v8, v30 & 0xffffffff, v14);
                *(int32_t *)(v1 + 596) = (int32_t)v30;
                v26 = v28;
                v27 = v1;
            }
        } else {
            // 0x18ec6
            v29 = v19 * (int64_t)&g1 + v20;
            v26 = v29;
            v27 = v25;
            if (v11 >= v29 && v17 == -34 == (v18 != 0)) {
                // 0x18ee0
                v31 = v19 + (int64_t)(int32_t)&g25;
                memcpy(v15, v8, v31 & 0xffffffff, v14);
                *(int32_t *)(v1 + 860) = (int32_t)v31;
                v26 = v29;
                v27 = v1;
            }
        }
        int64_t v32 = v27;
        int64_t v33 = v26;
        int64_t v34 = v33 + (int64_t)&g1; // 0x18f04
        v13 = v32;
        while (v11 > v34) {
            int64_t v35 = v33;
            int64_t v36 = v32;
            v17 = *(char *)v35;
            v18 = *(char *)v34;
            v19 = v18;
            v20 = v35 + (int64_t)&g25;
            v21 = v36;
            if ((int32_t)v17 == (int32_t)&g97 == (int32_t)v18 > (int32_t)&g33) {
                // 0x18e35
                v21 = v36;
                if (v11 >= v19 * (int64_t)&g1 + v20) {
                    // 0x18e41
                    v22 = *(char *)(v35 + 2 * (int64_t)&g25);
                    v23 = *(char *)(v35 + (int64_t)&g25 + (int64_t)&g33);
                    v24 = ((int32_t)v22 << (int32_t)&g95) % 0x2000 | (int32_t)v23;
                    if (v24 != *v16) {
                        // 0x18e68
                        reset_ts_section2(v1 + 168);
                        reset_ts_section2(v1 + 240);
                    }
                    // 0x18e7a
                    *v16 = v24;
                    v21 = v1;
                }
            }
            // 0x18e85
            v25 = v21;
            if (v17 == -63 == (v18 != 0)) {
                // 0x18e99
                v28 = v19 * (int64_t)&g1 + v20;
                v26 = v28;
                v27 = v25;
                if (v11 >= v28) {
                    // 0x18ea5
                    v30 = v19 + (int64_t)(int32_t)&g25;
                    memcpy(v1 + 336, v35, v30 & 0xffffffff, v14);
                    *(int32_t *)(v1 + 596) = (int32_t)v30;
                    v26 = v28;
                    v27 = v1;
                }
            } else {
                // 0x18ec6
                v29 = v19 * (int64_t)&g1 + v20;
                v26 = v29;
                v27 = v25;
                if (v11 >= v29 && v17 == -34 == (v18 != 0)) {
                    // 0x18ee0
                    v31 = v19 + (int64_t)(int32_t)&g25;
                    memcpy(v15, v35, v31 & 0xffffffff, v14);
                    *(int32_t *)(v1 + 860) = (int32_t)v31;
                    v26 = v29;
                    v27 = v1;
                }
            }
            // 0x18efe
            v32 = v27;
            v33 = v26;
            v34 = v33 + (int64_t)&g1;
            v13 = v32;
        }
    }
    uint64_t v37 = (int64_t)(v4 - (int32_t)&g97) * (int64_t)&g1 + v3; // 0x18d94
    int64_t v38 = v11; // 0x18f2b
    int32_t v39 = 0; // 0x18f2b
    int64_t v40 = v13; // 0x18f2b
    if (v37 > v11 + (int64_t)&g86) {
        int64_t v41 = &g1; // 0x18f33
        unsigned char v42 = *(char *)(v38 + (int64_t)&g33); // 0x18f36
        unsigned char v43 = *(char *)v40; // 0x18f3d
        v38 = v38 + (int64_t)&g89 + (int64_t)(((int32_t)v42 << (int32_t)&g95 | (int32_t)v43) & (int32_t)&g106) * (int64_t)&g1;
        v40 = v38 + (int64_t)&g86;
        int64_t v44 = v41 & 0xffffffff; // 0x18f56
        while (v37 > v40) {
            // 0x18f33
            v41 = v44 + (int64_t)(int32_t)&g1;
            v42 = *(char *)(v38 + (int64_t)&g33);
            v43 = *(char *)v40;
            v38 = v38 + (int64_t)&g89 + (int64_t)(((int32_t)v42 << (int32_t)&g95 | (int32_t)v43) & (int32_t)&g106) * (int64_t)&g1;
            v40 = v38 + (int64_t)&g86;
            v44 = v41 & 0xffffffff;
        }
        // 0x18f58
        v39 = v41;
    }
    int32_t * v45 = (int32_t *)(v1 + 320); // 0x18f58
    *v45 = v39;
    int64_t * v46 = (int64_t *)(v1 + 312); // 0x18f5e
    int64_t v47 = *v46; // 0x18f5e
    int32_t v48 = v39; // 0x18f68
    if (v47 != 0) {
        // 0x18f6a
        kfree(v47);
        *v46 = 0;
        v48 = *v45;
    }
    int64_t v49 = __kmalloc(8 * (int64_t)v48, (int64_t *)&g26, v40); // 0x18f8a
    *v46 = v49;
    memset(v49, 0, 8 * (int64_t)*v45);
    return 0;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x19011 - 0x19041
// Line range:    1435 - 1484
void teardown(int64_t prv) {
    // 0x19011
    return;
}

// Address range: 0x19041 - 0x19188
int64_t teardown2(int64_t a1) {
    // 0x19041
    mcount();
    *(int32_t *)(a1 + (int64_t)&g86) = 0;
    *(int32_t *)(a1 + (int64_t)&g95) = 0;
    *(int32_t *)(a1 + (int64_t)"GNU") = 0;
    *(int32_t *)(a1 + (int64_t)&g2) = 0;
    release_ts_section2(a1 + (int64_t)&g13);
    release_ts_section2(a1 + 96);
    release_ts_section2(a1 + 168);
    release_ts_section2(a1 + 240);
    release_ts_section2(a1 + 312);
    release_ts_section2(a1 + 384);
    release_ts_section2(a1 + 456);
    release_ts_section2(a1 + 528);
    *(int32_t *)(a1 + 752) = 0;
    *(char *)(a1 + 1032) = 0;
    *(char *)(a1 + 0x10670) = 0;
    *(char *)(a1 + 0x10671) = 0;
    *(char *)(a1 + 0x10672) = 0;
    release_ts_section2(a1 + 608);
    release_ts_section2(a1 + 680);
    int64_t * v1 = (int64_t *)(a1 + 1024); // 0x19104
    int64_t v2 = *v1; // 0x19104
    int32_t * v3 = (int32_t *)(a1 + 1016);
    if (v2 == 0) {
        // 0x19161
        *v3 = 0;
        return memset(a1 + 1040, 0, 0x10000);
    }
    int64_t v4 = 0; // 0x19115
    int64_t v5 = v2; // 0x19115
    if (*v3 >= 1) {
        release_program2(0x100000000 * v4 / 0x100000000 * ((1 << (int64_t)&g99) - (1 << (int64_t)&g94)) + v2);
        v4 = v4 + (int64_t)(int32_t)&g1 & 0xffffffff;
        int64_t v6 = *v1;
        v5 = v6;
        while (v4 < (int64_t)*v3) {
            // 0x1911d
            release_program2(0x100000000 * v4 / 0x100000000 * ((1 << (int64_t)&g99) - (1 << (int64_t)&g94)) + v6);
            v4 = v4 + (int64_t)(int32_t)&g1 & 0xffffffff;
            v6 = *v1;
            v5 = v6;
        }
    }
    // 0x1914a
    kfree(v5);
    *v1 = 0;
    // 0x19161
    *v3 = 0;
    return memset(a1 + 1040, 0, 0x10000);
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x1918b - 0x191bb
// Line range:    545 - 560
int32_t reset_arib_std_b25(char * std_b25) {
    // 0x1918b
    int64_t v1; // 0x1918b
    *(char *)v1 = (char)v1;
    int64_t v2; // 0x1918b
    memset((int64_t)std_b25, 0, v2);
    int64_t v3; // 0x1918b
    *(char *)(v3 + 0x91a74) = 0;
    release_work_buffer2(v3 + 0x10628);
    return release_work_buffer2(v3 + 0x10648);
}

// Address range: 0x191bb - 0x191de
int64_t reset_arib_std_b25_(void) {
    // 0x191bb
    mcount();
    int64_t v1; // 0x191bb
    private_data4(v1);
    return 0xffffffff;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x191e0 - 0x19210
// Line range:    492 - 503
void release_arib_std_b25(char * std_b25) {
    // 0x191e0
    return;
}

// Address range: 0x191e2 - 0x19209
int64_t function_191e2(int64_t a1, int64_t a2) {
    // 0x191e2
    int64_t v1; // 0x191e2
    bool v2; // 0x191e2
    *(int32_t *)v1 = (int32_t)v1 + (int32_t)&g91 + (int32_t)v2;
    int64_t v3; // 0x191e2
    int64_t v4 = v3;
    *(int32_t *)v4 = *(int32_t *)&v3 + (int32_t)v4;
    char v5 = *(char *)&v3; // 0x191e9
    uint64_t v6; // 0x191e2
    *(char *)v3 = v5 + (char)(v6 >> (int64_t)&g95);
    *(int16_t *)(v6 + 0x10410 + v3) = 0;
    int64_t v7 = v3; // 0x191f9
    int64_t v8 = v7 + 2; // 0x191f9
    v3 = v8;
    while (v7 != 510) {
        // 0x191ef
        *(int16_t *)(v6 + 0x10410 + v8) = 0;
        v7 = v3;
        v8 = v7 + 2;
        v3 = v8;
    }
    // 0x19205
    return v8 & -0x10000;
}

// Address range: 0x19210 - 0x19211
int64_t release_arib_std_b25_(void) {
    // 0x19210
    int64_t result; // 0x19210
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x19212 - 0x19242
// Line range:    2387 - 2461
int32_t setup_multi2(int64_t prv) {
    // 0x19212
    mcount();
    int64_t v1 = private_data4(prv); // 0x1921e
    int32_t result = 0; // 0x19229
    if (v1 != 0) {
        // 0x1922b
        teardown2(v1);
        result = kfree(v1);
    }
    // 0x1923b
    return result;
}

// Address range: 0x19242 - 0x193a3
int64_t setup_multi2_(int64_t a1) {
    // 0x19242
    mcount();
    __readgsqword(40);
    int64_t result = *(int64_t *)(a1 + 1024); // 0x192ab
    uint32_t v1 = *(int32_t *)(result + 160); // 0x192b2
    if (v1 == 0) {
        // 0x19305
        return 0;
    }
    int64_t v2 = *(int64_t *)(a1 + 1040 + 8 * (int64_t)v1); // 0x192c4
    if (v2 == 0) {
        // 0x19305
        return 0;
    }
    if (result != v2) {
        int64_t * v3 = (int64_t *)(v2 + 328); // 0x192da
        *(int64_t *)(result + 328) = *v3;
        // 0x19305
        return *v3;
    }
    int64_t * v4 = (int64_t *)(a1 + 0x10618); // 0x192fb
    if (*v4 == 0) {
        // 0x19305
        return result;
    }
    int64_t * v5 = (int64_t *)(result + 328); // 0x19310
    int64_t result2 = *v5; // 0x19310
    if (result2 != 0) {
        // 0x19305
        return result2;
    }
    int64_t result3 = create_multi2_(); // 0x1932a
    *v5 = result3;
    if (result3 == 0) {
        // 0x19305
        return result3;
    }
    int64_t v6 = *v4; // 0x19344
    return (int32_t)v6 >= 0 ? result3 : v6;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x193a9 - 0x193d9
// Line range:    2463 - 2512
int32_t proc_ecm(int64_t pgrm, int64_t bcas) {
    // 0x193a9
    int64_t v1; // 0x193a9
    int64_t v2; // 0x193a9
    *(char *)pgrm = (char)v2 + (char)v1;
    int64_t result; // 0x193a9
    return result;
}

// Address range: 0x193d9 - 0x19492
int64_t proc_ecm2(int64_t a1, int64_t a2) {
    // 0x193d9
    mcount();
    __readgsqword(40);
    int64_t * v1 = (int64_t *)(a1 + 328); // 0x19418
    int64_t result = 0xfffffff9; // 0x19420
    if (*v1 == 0) {
        // 0x19422
        result = create_multi2_();
        *v1 = result;
    }
    // 0x19482
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x19494 - 0x194c4
// Line range:    3542 - 3552
int32_t compare_ts_section(int64_t curr, int64_t next) {
    // 0x19494
    int64_t result; // 0x19494
    return result;
}

// Address range: 0x19497 - 0x194a2
int64_t function_19497(void) {
    // 0x19497
    int64_t result; // 0x19497
    return result;
}

// Address range: 0x194c4 - 0x194d0
int64_t compare_ts_section2(int64_t a1) {
    // 0x194c4
    return mcount();
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x194d0 - 0x19500
// Line range:    384 - 436
int64_t create_arib_std_b25(void) {
    // 0x194d0
    int64_t v1; // 0x194d0
    int64_t v2; // 0x194d0
    if (*(int32_t *)(v1 + 44) != (int32_t)v2) {
        // 0x194fe
        return &g1;
    }
    int64_t v3 = 0x100000000 * (v2 + (int64_t)(int32_t)&g33);
    bool v4; // 0x194d0
    int64_t result; // 0x194d0
    if (v3 == 0) {
        // ._crit_edge
        v4 = false;
        result = (int64_t)((true | v4) != (bool)&g1) - (int64_t)v4;
        // 0x194fe
        return result;
    }
    // .lr.ph
    bool v5; // 0x194d0
    int64_t v6 = v5 ? -1 : (int64_t)&g1; // 0x194f1
    int64_t v7 = *(int64_t *)(v1 + (int64_t)&g95); // 0x194d0
    int64_t v8; // 0x194d0
    int64_t v9 = *(int64_t *)(v8 + (int64_t)&g95); // 0x194d0
    int64_t v10 = v3 / 0x100000000; // 0x194f1
    unsigned char v11 = *(char *)v9; // 0x194f1
    char v12 = *(char *)v7; // 0x194f1
    char v13 = v12; // 0x194f1
    bool v14 = false; // 0x194f1
    while (v11 == v12) {
        v10 -= (int64_t)&g1;
        v7 += v6;
        v9 += v6;
        v13 = v11;
        v14 = true;
        if (v10 == 0) {
            // break -> ._crit_edge.loopexit
            break;
        }
        v11 = *(char *)v9;
        v12 = *(char *)v7;
        v13 = v12;
        v14 = false;
    }
    // ._crit_edge
    v4 = v11 < v13;
    result = (int64_t)((v14 | v4) != (bool)&g1) - (int64_t)v4;
    // 0x194fe
    return result;
}

// Address range: 0x19500 - 0x1965e
int64_t create_arib_std_b25_(void) {
    // 0x19500
    mcount();
    int64_t v1 = *(int64_t *)0x3ee48; // 0x19520
    int64_t v2 = kmem_cache_alloc_notrace(v1, (int64_t *)&g26); // 0x1952f
    slab_buffer_size(v1);
    if (g84 != 0) {
        // 0x19552
        if (g85 != 0) {
            int64_t v3 = g85 + (int64_t)&g95; // 0x19575
            int64_t v4 = v3; // 0x1957d
            while (*(int64_t *)v3 != 0) {
                // 0x1955e
                v3 = v4 + (int64_t)&g95;
                v4 = v3;
            }
        }
    }
    // 0x1957f
    memset(v2, 0, 0x91b28);
    *(int32_t *)v2 = (int32_t)&g86;
    *(char *)(v2 + 0x10670) = 0;
    *(char *)(v2 + 0x10671) = 0;
    *(char *)(v2 + 0x10672) = 0;
    int64_t result = v2 + 0x91a78; // 0x195c2
    *(int64_t *)result = v2;
    *(int64_t *)(v2 + 0x91a88) = 0;
    *(int64_t *)(v2 + 0x91a90) = 0;
    *(int64_t *)(v2 + 0x91a98) = 0;
    *(int64_t *)(v2 + 0x91aa0) = 0;
    *(int64_t *)(v2 + 0x91aa8) = 0;
    *(int64_t *)(v2 + 0x91ab0) = 0;
    *(int64_t *)(v2 + 0x91ab8) = 0;
    *(int64_t *)(v2 + 0x91ac0) = 0;
    *(int64_t *)(v2 + 0x91ac8) = 0;
    *(int64_t *)(v2 + 0x91ad0) = 0;
    *(int64_t *)(v2 + 0x91ad8) = 0;
    *(int64_t *)(v2 + 0x91ae0) = 0;
    *(int64_t *)(v2 + 0x91ae8) = 0;
    *(int64_t *)(v2 + 0x91af0) = 0;
    *(int64_t *)(v2 + 0x91af8) = 0;
    *(int64_t *)(v2 + 0x91b00) = 0;
    *(int64_t *)(v2 + 0x91b08) = 0;
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x19664 - 0x19694
// Line range:    1643 - 1707
int32_t proc_pat(int64_t prv) {
    // 0x19664
    int64_t v1; // 0x19664
    *(char *)v1 = 2 * (char)v1;
    int64_t result; // 0x19664
    int64_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    char * v3 = (char *)(result - 57); // 0x19668
    int64_t v4; // 0x19664
    *v3 = *v3 + (char)v4;
    *(char *)result = *(char *)&result;
    int64_t v5 = result;
    *(char *)v5 = *(char *)&result + (char)v5;
    *(int64_t *)(result + 160) = 0;
    return result;
}

// Address range: 0x19694 - 0x197ad
int64_t proc_pat2(int64_t a1) {
    // 0x19694
    mcount();
    int32_t v1 = *(int32_t *)(a1 + 68) - (int32_t)&g97; // 0x196ab
    int32_t v2 = v1 >= 0 ? v1 : v1 + (int32_t)&g33; // 0x196b6
    int64_t v3 = v2 >> (int32_t)&g25; // 0x196bd
    int64_t v4 = v3 * ((1 << (int64_t)&g99) - (1 << (int64_t)&g94)); // 0x196cd
    memset(__kmalloc(v4, (int64_t *)&g26, v3 << (int64_t)&g94), 0, v4);
    int64_t * v5 = (int64_t *)(a1 + 1024); // 0x196fe
    int64_t v6 = *v5; // 0x196fe
    int32_t * v7 = (int32_t *)(a1 + 1016);
    int64_t v8; // 0x1977b
    if (v6 == 0) {
        // 0x1975b
        *v7 = 0;
        memset(a1 + 1040, 0, 0x10000);
        v8 = *(int64_t *)(a1 + (int64_t)&g26);
        return v8 + (int64_t)&g105;
    }
    int64_t v9 = 0; // 0x1970f
    int64_t v10 = v6; // 0x1970f
    if (*v7 >= 1) {
        release_program2(0x100000000 * v9 / 0x100000000 * ((1 << (int64_t)&g99) - (1 << (int64_t)&g94)) + v6);
        v9 = v9 + (int64_t)(int32_t)&g1 & 0xffffffff;
        int64_t v11 = *v5;
        v10 = v11;
        while (v9 < (int64_t)*v7) {
            // 0x19717
            release_program2(0x100000000 * v9 / 0x100000000 * ((1 << (int64_t)&g99) - (1 << (int64_t)&g94)) + v11);
            v9 = v9 + (int64_t)(int32_t)&g1 & 0xffffffff;
            v11 = *v5;
            v10 = v11;
        }
    }
    // 0x19744
    kfree(v10);
    *v5 = 0;
    // 0x1975b
    *v7 = 0;
    memset(a1 + 1040, 0, 0x10000);
    v8 = *(int64_t *)(a1 + (int64_t)&g26);
    return v8 + (int64_t)&g105;
}

// Address range: 0x197c2 - 0x197c5
int64_t function_197c2(int64_t a1) {
    // 0x197c2
    int64_t result; // 0x197c2
    return result;
}

// Address range: 0x197df - 0x197e2
int64_t function_197df(void) {
    // 0x197df
    int64_t result; // 0x197df
    return result;
}

// Address range: 0x197e7 - 0x197f6
int64_t function_197e7(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x197e7
    int64_t v1; // 0x197e7
    char * v2 = (char *)(v1 - 115); // 0x197ea
    unsigned char v3 = *v2; // 0x197ea
    *v2 = v3 / 2 | v3;
    int64_t v4; // 0x197e7
    return v4 - 0x48f0bc00;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x19818 - 0x19848
// Line range:    3288 - 3338
int32_t reserve_work_buffer(int64_t buf, int32_t size) {
    // 0x19818
    int64_t v1; // 0x19818
    *(int32_t *)v1 = 2 * (int32_t)v1;
    int64_t v2; // 0x19818
    char * v3 = (char *)(v2 + 0x10610); // 0x1981a
    *v3 = *v3 + 1;
    *(int32_t *)(v2 + 1016) = (int32_t)buf;
    return 0;
}

// Address range: 0x19848 - 0x198fd
int64_t reserve_work_buffer2(int64_t a1, int32_t a2) {
    int64_t v1 = a2;
    mcount();
    uint32_t v2 = *(int32_t *)(a1 + (int64_t)&g13); // 0x1986b
    int32_t v3 = v2 - 511; // 0x1987e
    int64_t v4 = v3 == 0 | v3 < 0 != (510 - v2 & v2) < 0 ? (int64_t)(int32_t)((int64_t)&g1 & -0x10000 | 512) : (int64_t)(v2 * (int32_t)((int64_t)&g1 + 1)); // 0x19888
    int64_t v5 = v4; // 0x1988d
    int64_t v6 = v4; // 0x1988d
    if (v4 < v1) {
        v5 = 2 * v5 & 0xfffffffe;
        v6 = v5;
        while (v5 < v1) {
            // 0x1988f
            v5 = 2 * v5 & 0xfffffffe;
            v6 = v5;
        }
    }
    int64_t v7 = 0x100000000 * v6 / 0x100000000; // 0x19895
    int64_t v8 = __kmalloc(v7, (int64_t *)&g26, (int64_t)v2); // 0x198a0
    int64_t set_mem = memset(v8, 0, v7); // 0x198cd
    if (v8 == 0) {
        // 0x198fd
        return set_mem;
    }
    int64_t v9 = *(int64_t *)(a1 + (int64_t)&g95); // 0x198cf
    int64_t v10 = *(int64_t *)(a1 + (int64_t)&g2) - v9; // 0x198d9
    if ((int32_t)v10 >= 1) {
        // 0x198e1
        int64_t v11; // 0x19848
        memcpy(v8, v9, 0x100000000 * v10 / 0x100000000, v11);
    }
    int64_t result = kfree(v8); // 0x198f0
    *(int64_t *)a1 = 0;
    // 0x198fd
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x19900 - 0x19930
// Line range:    3340 - 3363
int32_t append_work_buffer(int64_t buf, char * data, int32_t size) {
    // 0x19900
    int64_t v1; // 0x19900
    int64_t v2; // 0x19900
    int64_t v3; // 0x19900
    *(int64_t *)(v3 + (int64_t)&g2) = 0x100000000 * v1 / 0x100000000 + v2;
    int64_t v4; // 0x19900
    *(int32_t *)(v3 + (int64_t)&g13) = (int32_t)v4;
    return &g1;
}

// Address range: 0x19930 - 0x1996f
int64_t append_work_buffer2(int64_t a1, int64_t a2, int32_t a3) {
    // 0x19930
    mcount();
    int64_t v1 = *(int64_t *)(a1 + (int64_t)&g2); // 0x1995b
    int64_t v2; // 0x19930
    return reserve_work_buffer2(a1, a3 - (int32_t)v2 + (int32_t)v1);
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x19971 - 0x199a1
// Line range:    3382 - 3418
int32_t set_ts_section_data(int64_t sect, int64_t hdr, char * data, int32_t size) {
    // 0x19971
    int64_t v1; // 0x19971
    char v2 = v1;
    *(char *)v1 = 2 * v2;
    int64_t v3; // 0x19971
    char * v4 = (char *)(v3 + 0x4d1b74d2); // 0x19973
    *v4 = *v4 + v2;
    int64_t v5; // 0x19971
    int64_t * v6 = (int64_t *)(v5 + (int64_t)&g2); // 0x1997b
    int64_t v7; // 0x19971
    int64_t v8; // 0x19971
    memcpy(*v6, v7, v8, (int64_t)size);
    *v6 = *v6 + v8;
    return &g1;
}

// Address range: 0x199a1 - 0x19a1e
int64_t set_ts_section_data2(int64_t a1, int64_t * a2, int64_t a3, int32_t a4) {
    // 0x199a1
    mcount();
    int64_t * v1 = (int64_t *)(a1 + (int64_t)&g2); // 0x199c3
    uint64_t v2 = *v1; // 0x199c3
    if (*(int32_t *)((int64_t)a2 + (int64_t)&g95) == 0) {
        // 0x199f8
        if ((int32_t)(v2 - *(int64_t *)(a1 + (int64_t)&g95)) >= 1) {
            // 0x19a02
            append_work_buffer2(a1, a3, a4);
        }
    } else {
        // 0x199d1
        reset_ts_section2(a1);
        int64_t v3 = v2 % 256 + (int64_t)(int32_t)&g1; // 0x199db
        int64_t result = append_work_buffer2(a1, 0x100000000 * v3 / 0x100000000 * (int64_t)&g1 + a3, a4 - (int32_t)v3); // 0x199ed
        if ((int32_t)result == 0) {
            // 0x199f6
            return result;
        }
    }
    // 0x19a10
    return *v1;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x19a1f - 0x19a4f
// Line range:    2027 - 2109
int32_t find_pmt(int64_t prv) {
    // 0x19a1f
    int64_t result; // 0x19a1f
    return result;
}

// Address range: 0x19a4f - 0x19bbb
int64_t find_pmt2(int64_t a1) {
    // 0x19a4f
    mcount();
    int32_t v1 = *(int32_t *)(a1 + (int64_t)&g86); // 0x19a68
    int32_t * v2 = (int32_t *)(a1 + (int64_t)&g95); // 0x19a6e
    int64_t v3 = a1 + 0x10630; // 0x19a72
    int64_t v4 = *(int64_t *)v3 + (int64_t)*v2; // 0x19a72
    uint64_t v5 = *(int64_t *)(a1 + 0x10638); // 0x19a79
    int64_t v6 = v1; // 0x19a8a
    if (v5 < v4 + v6) {
        // 0x19b95
        *v2 = (int32_t)v4 - *(int32_t *)v3;
        return check_pmt_complete2(a1);
    }
    int64_t v7 = v4;
    int64_t v8; // 0x19a4f
    int64_t v9; // 0x19a4f
    while (true) {
      lab_0x19a93:;
        int64_t v10 = v7;
        int64_t v11 = v10; // 0x19a96
        if (*(char *)v10 != 71) {
            // 0x19a98
            v11 = resync2(v10, v5, v1);
            v9 = v10;
            if (v11 == 0) {
                // break -> 0x19b95
                break;
            }
        }
        // 0x19ab3
        v8 = v11;
        int64_t v12; // bp-88, 0x19a4f
        extract_ts_header2(&v12, v8);
        int32_t v13; // 0x19a4f
        int64_t v14 = *(int64_t *)(a1 + 1040 + 8 * (int64_t)v13); // 0x19ac3
        if (v14 == 0) {
            goto lab_0x19b83;
        } else {
            int64_t v15 = v14 + 8; // 0x19ad4
            if ((int32_t)check_ts_section2(v15) != 0) {
                goto lab_0x19b83;
            } else {
                int64_t v16 = v8 + (int64_t)&g86; // 0x19aed
                int64_t v17 = v16; // 0x19af5
                char v18; // 0x19a4f
                if ((v18 & (char)&g25) != 0) {
                    unsigned char v19 = *(char *)v16; // 0x19af7
                    v17 = v8 + (int64_t)&g86 + (int64_t)&g1 + (int64_t)v19 * (int64_t)&g1;
                }
                int64_t v20 = v17;
                int64_t v21 = v14 + 80; // 0x19aff
                int64_t v22 = set_ts_section_data2(v21, &v12, v20, (int32_t)v8 + 188 - (int32_t)v20); // 0x19b19
                v9 = v8;
                if ((int32_t)v22 < 0) {
                    // break -> 0x19b95
                    break;
                }
                // 0x19b25
                if ((int32_t)check_ts_section2(v21) == 0) {
                    goto lab_0x19b83;
                } else {
                    // 0x19b32
                    if ((int32_t)check_ts_section_crc2(v21) == 0) {
                        // 0x19b4a
                        reset_ts_section2(v21);
                        goto lab_0x19b83;
                    } else {
                        // 0x19b3f
                        if (*(int32_t *)(v14 + 136) != 0) {
                            // 0x19b58
                            swap_ts_section2(v15, v21);
                            reset_ts_section2(v21);
                            if ((int32_t)check_pmt_complete2(a1) != 0) {
                                // 0x19b7a
                                v9 = v8 + v6;
                                goto lab_0x19b95_2;
                            }
                            goto lab_0x19b83;
                        } else {
                            // 0x19b4a
                            reset_ts_section2(v21);
                            goto lab_0x19b83;
                        }
                    }
                }
            }
        }
    }
  lab_0x19b95_2:
    // 0x19b95
    *v2 = (int32_t)v9 - *(int32_t *)v3;
    return check_pmt_complete2(a1);
  lab_0x19b83:
    // 0x19b83
    v7 = v8 + v6;
    v9 = v7;
    if (v5 < v7 + v6) {
        // break -> 0x19b95
        goto lab_0x19b95_2;
    }
    goto lab_0x19a93;
}

// Address range: 0x19bbd - 0x19bbe
int64_t function_19bbd(void) {
    // 0x19bbd
    int64_t result; // 0x19bbd
    return result;
}

// Address range: 0x19bc0 - 0x19bc3
int64_t function_19bc0(void) {
    // 0x19bc0
    int64_t result; // 0x19bc0
    return result;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x19bd0 - 0x19c00
// Line range:    3420 - 3449
int32_t set_ts_section_data_for_remaining_payload_data(int64_t sect, int64_t hdr, char * data, int32_t size) {
    // 0x19bd0
    return proc_pmt2(*(int32_t *)(hdr + 1024) + (int32_t)sect);
}

// Address range: 0x19c00 - 0x19c44
int64_t set_ts_section_data_for_remaining_payload_data2(int64_t a1, int64_t * a2, int64_t a3) {
    int64_t v1 = (int64_t)a2;
    mcount();
    int64_t result = *(int64_t *)(a1 + (int64_t)&g95); // 0x19c15
    if (*(int32_t *)(v1 + (int64_t)&g95) == 0) {
        // 0x19c44
        return result;
    }
    char v2 = *(char *)(v1 + (int64_t)&g13); // 0x19c1f
    if ((v2 & (char)&g1) == 0) {
        // 0x19c44
        return result;
    }
    int64_t result2 = result; // 0x19c29
    if ((int32_t)(*(int64_t *)(a1 + (int64_t)&g2) - result) >= 1) {
        // 0x19c2b
        append_work_buffer2(a1, a3 + (int64_t)&g1, (int32_t)a3 % 256);
        result2 = 0xfffffffe;
    }
    // 0x19c44
    return result2;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x19c45 - 0x19c75
// Line range:    2514 - 3265
int32_t proc_arib_std_b25(int64_t prv, char * std_b25) {
    // 0x19c45
    bool v1; // 0x19c45
    if (!v1) {
        // 0x19c73
        int64_t result; // 0x19c45
        return result;
    }
    // 0x19c47
    int64_t v2; // 0x19c45
    char * v3 = (char *)(v2 + (int64_t)&g24); // 0x19c47
    uint64_t v4; // 0x19c45
    *v3 = *v3 + (char)(v4 >> (int64_t)&g95);
    int64_t v5; // 0x19c45
    int64_t v6 = *(int64_t *)(v5 + (int64_t)&g95); // 0x19c4a
    int64_t v7 = *(int64_t *)(v5 + (int64_t)&g2); // 0x19c4e
    if ((int32_t)v7 - (int32_t)v6 > (int32_t)&g95) {
        // 0x19c59
        extract_ts_section_header2(v5 + (int64_t)&g26, v6);
    }
    // 0x19c73
    return 0;
}

// Address range: 0x19c75 - 0x1a86e
int64_t proc_arib_std_b25_(int64_t a1) {
    // 0x19c75
    mcount();
    __readgsqword(40);
    int32_t v1 = *(int32_t *)(a1 + (int64_t)&g86); // 0x19ca0
    int64_t * v2 = (int64_t *)(a1 + 0x10630); // 0x19ca9
    int64_t v3 = *v2; // 0x19ca9
    int64_t * v4 = (int64_t *)(a1 + 0x10638); // 0x19cb0
    uint64_t v5 = *v4; // 0x19cb0
    int32_t v6 = v5 - v3; // 0x19cc1
    int64_t v7 = a1 + 0x10648; // 0x19cc7
    int64_t v8 = *(int64_t *)(a1 + 0x10658); // 0x19cd5
    int32_t v9 = *(int32_t *)(a1 + 0x10650); // 0x19cdc
    int32_t result = -2; // 0x19cee
    int64_t v10; // 0x19c75
    int64_t v11; // 0x19c75
    int64_t v12; // 0x19c75
    int64_t v13; // 0x19c75
    int64_t v14; // bp-1192, 0x19c75
    int32_t v15; // 0x19c75
    int32_t v16; // 0x19c75
    int32_t v17; // 0x19c75
    int32_t v18; // 0x19c75
    int64_t v19; // 0x1a54b
    int64_t v20; // 0x1a6bf
    int64_t v21; // 0x19d8e
    int64_t v22; // 0x1a822
    int64_t v23; // 0x19d0c
    int64_t v24; // 0x19d1b
    int64_t v25; // 0x19d48
    int64_t v26; // 0x19d57
    int64_t v27; // 0x19d66
    int64_t v28; // 0x19d75
    uint32_t v29; // 0x19c75
    int32_t * v30; // 0x19c75
    int32_t * v31; // 0x19c75
    int32_t * v32; // 0x19c75
    int32_t * v33; // 0x19c75
    uint32_t v34; // 0x19e55
    int16_t * v35; // 0x19c75
    int64_t v36; // 0x1a2ed
    if ((int32_t)reserve_work_buffer2(v7, (int32_t)v8 - v9 + v6) != 0) {
        // 0x19cf4
        v21 = v1;
        v22 = v21 * (int64_t)&g1;
        result = 0;
        if (v5 >= v22 + v3) {
            int64_t v37 = a1 + 96; // 0x19cf4
            int64_t v38 = a1 + (int64_t)&g13; // 0x19d00
            v23 = a1 + 680;
            v24 = a1 + 608;
            int64_t v39 = a1 + 240; // 0x19d2a
            int64_t v40 = a1 + 168; // 0x19d39
            v25 = a1 + 384;
            v26 = a1 + 312;
            v27 = a1 + 528;
            v28 = a1 + 456;
            int64_t * v41 = (int64_t *)(a1 + 1024);
            int64_t * v42 = (int64_t *)(a1 + 0x10618);
            int32_t v43; // 0x19c75
            char v44 = v43;
            v30 = (int32_t *)(a1 + 736);
            v31 = (int32_t *)(a1 + 640);
            v32 = (int32_t *)(a1 + 440);
            v33 = (int32_t *)(a1 + 584);
            v11 = v3;
            v18 = v6;
            v15 = 0;
            while (true) {
              lab_0x19de0:;
                int32_t v45 = v15;
                int64_t v46 = v11;
                int64_t v47 = v46; // 0x19de4
                if (*(char *)v46 != 71) {
                    // 0x19de6
                    v47 = resync2(v46, v5, v1);
                    result = v45;
                    if (v47 == 0) {
                        // break -> 0x1a84b
                        break;
                    }
                }
                // 0x19e07
                v10 = v47;
                extract_ts_header2(&v14, v10);
                int64_t v48 = *(int64_t *)(a1 + 1040 + 8 * (int64_t)v29); // 0x19e2a
                int64_t v49 = v48; // 0x19e35
                if (v48 == 0) {
                    // 0x19e37
                    v49 = *v41;
                }
                // 0x19e3f
                if (*(char *)(a1 + 0x1066c) != 0) {
                    // 0x19e55
                    v34 = *(int32_t *)(a1 + 1016);
                    if (v34 < 1) {
                        // 0x1a865
                        return (int64_t)*(int16_t *)(a1 + 0x1066e);
                    }
                    // 0x19e66
                    v35 = (int16_t *)(a1 + 0x1066e);
                    v13 = *v41;
                    v12 = 0;
                    goto lab_0x19e74;
                }
                int64_t v50 = v49;
                int64_t v51 = *(int64_t *)*v42; // 0x19ef1
                if (*(char *)(v51 + 84) != 0) {
                    // 0x19f01
                    if (*(char *)(v51 + 85) == 0) {
                        // 0x19f07
                        if (*(int64_t *)(v50 + 328) != 0) {
                            // 0x19f11
                            *(char *)(0x1000000000000 * v51 / 0x1000000000000 + 85) = (char)&g1;
                        }
                    }
                }
                char * v52 = (char *)(0x1000000000000 * v51 / 0x1000000000000 + 604); // 0x19f58
                if (*v52 != 0) {
                    // 0x19f61
                    if (*(int64_t *)(v50 + 328) != 0) {
                        // 0x19f8e
                        *v52 = 0;
                    }
                }
                int64_t v53 = v10 + (int64_t)&g86; // 0x19fb9
                int16_t v54 = v53; // 0x19fbd
                int32_t v55 = v45; // 0x19fcc
                int32_t v56 = v18; // 0x19fcc
                int16_t v57 = v54; // 0x19fcc
                if ((v44 & (char)&g1) != 0) {
                    int16_t v58 = v54; // 0x19fd4
                    if ((v44 & (char)&g25) != 0) {
                        unsigned char v59 = *(char *)v53; // 0x19fd6
                        v58 = v10 + (int64_t)&g86 + (int64_t)&g1 + (int64_t)v59 * (int64_t)&g1;
                    }
                    int16_t v60 = v58;
                    int32_t v61 = (int32_t)v10 - (int32_t)v60 + 188; // 0x19fee
                    v55 = v45;
                    v56 = v61;
                    v57 = v60;
                    int32_t v62; // 0x19c75
                    if (v62 != 0) {
                        // 0x1a002
                        *(char *)(a1 + 0x10670) = (char)&g1;
                        int64_t v63 = *(int64_t *)(v50 + 328); // 0x1a00b
                        v55 = v45;
                        v56 = v61;
                        v57 = v60;
                        if (v63 != 0) {
                            // 0x1a017
                            v55 = -10;
                            v56 = v61;
                            v57 = v60;
                            if ((int32_t)v63 >= 0) {
                                // 0x1a062
                                int32_t v64; // 0x19c75
                                int32_t v65 = v64 != (int32_t)&g1 ? v45 : 0; // 0x1a023
                                char * v66 = (char *)(v10 + (int64_t)&g33); // 0x1a062
                                *v66 = *v66 % 64;
                                v55 = v65;
                                v56 = v61;
                                v57 = v60;
                            }
                        }
                    }
                }
                // 0x1a067
                result = -2;
                if ((int32_t)append_work_buffer2(v7, v10, 188) == 0) {
                    // break -> 0x1a84b
                    break;
                }
                int16_t v67 = v57;
                v17 = v56;
                if (v29 != 0) {
                    // 0x1a154
                    if (*(int32_t *)(v50 + 160) != v29) {
                        // 0x1a213
                        if (*(int32_t *)v50 != v29) {
                            // 0x1a2d9
                            if (*(int32_t *)(a1 + 600) != v29) {
                                if (v29 != (int32_t)&g1) {
                                    if (v29 != (int32_t)&g3) {
                                        // 0x1a6b0
                                        v16 = v55;
                                        if (v29 != (int32_t)&g4) {
                                            goto lab_0x1a81b;
                                        } else {
                                            // 0x1a6b9
                                            v20 = v67;
                                            set_ts_section_data_for_remaining_payload_data2(v27, &v14, v20);
                                            if ((int32_t)check_ts_section2(v27) == 0) {
                                                goto lab_0x1a75e;
                                            } else {
                                                // 0x1a6e9
                                                if ((int32_t)check_ts_section_crc2(v27) == 0) {
                                                    // 0x1a71b
                                                    reset_ts_section2(v27);
                                                    goto lab_0x1a75e;
                                                } else {
                                                    // 0x1a6f9
                                                    if (*v33 == 0) {
                                                        // 0x1a71b
                                                        reset_ts_section2(v27);
                                                        goto lab_0x1a75e;
                                                    } else {
                                                        // 0x1a704
                                                        if ((int32_t)compare_ts_section2(v28) != 0) {
                                                            // 0x1a729
                                                            swap_ts_section2(v28, v27);
                                                            reset_ts_section2(v27);
                                                            int32_t v68 = proc_eit2(a1, v27, v20);
                                                            result = v68;
                                                            if (v68 < 0) {
                                                                // break -> 0x1a84b
                                                                break;
                                                            }
                                                            goto lab_0x1a75e;
                                                        } else {
                                                            // 0x1a71b
                                                            reset_ts_section2(v27);
                                                            goto lab_0x1a75e;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        // 0x1a545
                                        v19 = v67;
                                        set_ts_section_data_for_remaining_payload_data2(v25, &v14, v19);
                                        if ((int32_t)check_ts_section2(v25) == 0) {
                                            goto lab_0x1a5ea;
                                        } else {
                                            // 0x1a575
                                            if ((int32_t)check_ts_section_crc2(v25) == 0) {
                                                // 0x1a5a7
                                                reset_ts_section2(v25);
                                                goto lab_0x1a5ea;
                                            } else {
                                                // 0x1a585
                                                if (*v32 == 0) {
                                                    // 0x1a5a7
                                                    reset_ts_section2(v25);
                                                    goto lab_0x1a5ea;
                                                } else {
                                                    // 0x1a590
                                                    if ((int32_t)compare_ts_section2(v26) != 0) {
                                                        // 0x1a5b5
                                                        swap_ts_section2(v26, v25);
                                                        reset_ts_section2(v25);
                                                        int32_t v69 = proc_sdt2(a1, v25, v19);
                                                        result = v69;
                                                        if (v69 < 0) {
                                                            // break -> 0x1a84b
                                                            break;
                                                        }
                                                        goto lab_0x1a5ea;
                                                    } else {
                                                        // 0x1a5a7
                                                        reset_ts_section2(v25);
                                                        goto lab_0x1a5ea;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    int64_t v70 = set_ts_section_data2(v39, &v14, (int64_t)v67, v17); // 0x1a491
                                    int32_t v71 = v70;
                                    result = v71;
                                    if (v71 < 0) {
                                        // break -> 0x1a84b
                                        break;
                                    }
                                    // 0x1a4a4
                                    v16 = v71;
                                    if ((int32_t)check_ts_section2(v39) == 0) {
                                        goto lab_0x1a81b;
                                    } else {
                                        // 0x1a4b8
                                        if ((int32_t)check_ts_section_crc2(v39) == 0) {
                                            // 0x1a4ea
                                            reset_ts_section2(v39);
                                            v16 = v71;
                                            goto lab_0x1a81b;
                                        } else {
                                            // 0x1a4c8
                                            if (*(int32_t *)(a1 + 296) == 0) {
                                                // 0x1a4ea
                                                reset_ts_section2(v39);
                                                v16 = v71;
                                                goto lab_0x1a81b;
                                            } else {
                                                // 0x1a4d3
                                                if ((int32_t)compare_ts_section2(v40) != 0) {
                                                    // 0x1a502
                                                    swap_ts_section2(v40, v39);
                                                    reset_ts_section2(v39);
                                                    int32_t v72 = proc_cat2(a1);
                                                    v16 = v72;
                                                    result = v72;
                                                    if (v72 < 0) {
                                                        // break -> 0x1a84b
                                                        break;
                                                    }
                                                    goto lab_0x1a81b;
                                                } else {
                                                    // 0x1a4ea
                                                    reset_ts_section2(v39);
                                                    v16 = v71;
                                                    goto lab_0x1a81b;
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                // 0x1a2e7
                                v36 = v67;
                                int64_t v73 = set_ts_section_data_for_remaining_payload_data2(v23, &v14, v36); // 0x1a302
                                if ((int32_t)check_ts_section2(v23) == 0) {
                                    goto lab_0x1a3a3;
                                } else {
                                    // 0x1a321
                                    if ((int32_t)check_ts_section_crc2(v23) == 0) {
                                        // 0x1a353
                                        reset_ts_section2(v23);
                                        goto lab_0x1a3a3;
                                    } else {
                                        // 0x1a331
                                        if (*v30 == 0) {
                                            // 0x1a353
                                            reset_ts_section2(v23);
                                            goto lab_0x1a3a3;
                                        } else {
                                            // 0x1a33c
                                            if ((int32_t)compare_ts_section2(v24) != 0) {
                                                // 0x1a361
                                                swap_ts_section2(v24, v23);
                                                reset_ts_section2(v23);
                                                if (*v31 == 132) {
                                                    int32_t v74 = v73;
                                                    proc_emm2(a1);
                                                    result = v74;
                                                    if (v74 < 0) {
                                                        // break -> 0x1a84b
                                                        break;
                                                    }
                                                }
                                                goto lab_0x1a3a3;
                                            } else {
                                                // 0x1a353
                                                reset_ts_section2(v23);
                                                goto lab_0x1a3a3;
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            int64_t v75 = v50 + 80; // 0x1a21d
                            int64_t v76 = set_ts_section_data2(v75, &v14, (int64_t)v67, v17); // 0x1a238
                            int32_t v77 = v76;
                            result = v77;
                            if (v77 < 0) {
                                // break -> 0x1a84b
                                break;
                            }
                            // 0x1a24b
                            v16 = v77;
                            if ((int32_t)check_ts_section2(v75) == 0) {
                                goto lab_0x1a81b;
                            } else {
                                // 0x1a25b
                                if ((int32_t)check_ts_section_crc2(v75) == 0) {
                                    // 0x1a28b
                                    reset_ts_section2(v75);
                                    v16 = v77;
                                    goto lab_0x1a81b;
                                } else {
                                    // 0x1a267
                                    if (*(int32_t *)(v50 + 136) == 0) {
                                        // 0x1a28b
                                        reset_ts_section2(v75);
                                        v16 = v77;
                                        goto lab_0x1a81b;
                                    } else {
                                        int64_t v78 = v50 + 8; // 0x1a271
                                        if ((int32_t)compare_ts_section2(v78) != 0) {
                                            // 0x1a29f
                                            swap_ts_section2(0x100000000000000 * v78 / 0x100000000000000, v75);
                                            reset_ts_section2(v75);
                                            int32_t v79 = proc_pmt2((int32_t)v50);
                                            result = v79;
                                            if (v79 < 0) {
                                                // break -> 0x1a84b
                                                break;
                                            }
                                            // 0x1a2cc
                                            setup_pid_map2(a1);
                                            v16 = v79;
                                            goto lab_0x1a81b;
                                        } else {
                                            // 0x1a28b
                                            reset_ts_section2(v75);
                                            v16 = v77;
                                            goto lab_0x1a81b;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        int64_t v80 = v50 + 240; // 0x1a16e
                        int64_t v81 = set_ts_section_data2(v80, &v14, (int64_t)v67, v17); // 0x1a18c
                        int32_t v82 = v81;
                        result = v82;
                        if (v82 < 0) {
                            // break -> 0x1a84b
                            break;
                        }
                        // 0x1a19f
                        v16 = v82;
                        if ((int32_t)check_ts_section2(v80) == 0) {
                            goto lab_0x1a81b;
                        } else {
                            // 0x1a1af
                            if ((int32_t)check_ts_section_crc2(v80) == 0) {
                                // 0x1a1c5
                                reset_ts_section2(v80);
                                v16 = v82;
                                goto lab_0x1a81b;
                            } else {
                                // 0x1a1bb
                                if (*(int32_t *)(v50 + 296) != 0) {
                                    // 0x1a1d9
                                    swap_ts_section2(v50 + 168, v80);
                                    reset_ts_section2(v80);
                                    int32_t v83 = proc_ecm2(v50, *v42);
                                    v16 = v83;
                                    result = v83;
                                    if (v83 < 0) {
                                        // break -> 0x1a84b
                                        break;
                                    }
                                    goto lab_0x1a81b;
                                } else {
                                    // 0x1a1c5
                                    reset_ts_section2(v80);
                                    v16 = v82;
                                    goto lab_0x1a81b;
                                }
                            }
                        }
                    }
                } else {
                    int64_t v84 = set_ts_section_data2(v37, &v14, (int64_t)v67, v17); // 0x1a0b1
                    int32_t v85 = v84;
                    result = v85;
                    if (v85 < 0) {
                        // break -> 0x1a84b
                        break;
                    }
                    // 0x1a0c4
                    v16 = v85;
                    if ((int32_t)check_ts_section2(v37) != 0) {
                        // 0x1a0d8
                        if ((int32_t)check_ts_section_crc2(v37) != 0) {
                            // 0x1a0e8
                            if (*(int32_t *)(a1 + 152) != 0) {
                                // 0x1a0f3
                                if ((int32_t)compare_ts_section2(v38) != 0) {
                                    // 0x1a122
                                    swap_ts_section2(v38, v37);
                                    reset_ts_section2(v37);
                                    result = proc_pat2(a1);
                                    goto lab_0x1a84b_7;
                                }
                            }
                        }
                        // 0x1a10a
                        reset_ts_section2(v37);
                        v16 = v85;
                    }
                    goto lab_0x1a81b;
                }
            }
        }
    }
    goto lab_0x1a84b_7;
  lab_0x1a81b:;
    int64_t v96 = v10 + v21;
    v11 = v96;
    v18 = v17;
    v15 = v16;
    result = v16;
    if (v5 < v96 + v22) {
        // break -> 0x1a84b
        goto lab_0x1a84b_7;
    }
    goto lab_0x19de0;
  lab_0x1a3a3:;
    int32_t v97 = set_ts_section_data2(v23, &v14, v36, v17);
    result = v97;
    if (v97 < 0) {
        // break -> 0x1a84b
        goto lab_0x1a84b_7;
    }
    // 0x1a3d1
    v16 = v97;
    if ((int32_t)check_ts_section2(v23) == 0) {
        goto lab_0x1a81b;
    } else {
        // 0x1a3e5
        if ((int32_t)check_ts_section_crc2(v23) == 0) {
            // 0x1a417
            reset_ts_section2(v23);
            v16 = v97;
            goto lab_0x1a81b;
        } else {
            // 0x1a3f5
            if (*v30 == 0) {
                // 0x1a417
                reset_ts_section2(v23);
                v16 = v97;
                goto lab_0x1a81b;
            } else {
                // 0x1a400
                if ((int32_t)compare_ts_section2(v24) != 0) {
                    // 0x1a42f
                    swap_ts_section2(v24, v23);
                    reset_ts_section2(v23);
                    v16 = v97;
                    if (*v31 == 132) {
                        // 0x1a460
                        proc_emm2(a1);
                        v16 = v97;
                    }
                    goto lab_0x1a81b;
                } else {
                    // 0x1a417
                    reset_ts_section2(v23);
                    v16 = v97;
                    goto lab_0x1a81b;
                }
            }
        }
    }
  lab_0x1a5ea:;
    int32_t v98 = set_ts_section_data2(v25, &v14, v19, v17);
    result = v98;
    if (v98 < 0) {
        // break -> 0x1a84b
        goto lab_0x1a84b_7;
    }
    // 0x1a618
    v16 = v98;
    if ((int32_t)check_ts_section2(v25) == 0) {
        goto lab_0x1a81b;
    } else {
        // 0x1a62c
        if ((int32_t)check_ts_section_crc2(v25) == 0) {
            // 0x1a65e
            reset_ts_section2(v25);
            v16 = v98;
            goto lab_0x1a81b;
        } else {
            // 0x1a63c
            if (*v32 == 0) {
                // 0x1a65e
                reset_ts_section2(v25);
                v16 = v98;
                goto lab_0x1a81b;
            } else {
                // 0x1a647
                if ((int32_t)compare_ts_section2(v26) != 0) {
                    // 0x1a676
                    swap_ts_section2(v26, v25);
                    reset_ts_section2(v25);
                    int32_t v99 = proc_sdt2(a1, v25, v19);
                    v16 = v99;
                    result = v99;
                    if (v99 < 0) {
                        // break -> 0x1a84b
                        goto lab_0x1a84b_7;
                    }
                    goto lab_0x1a81b;
                } else {
                    // 0x1a65e
                    reset_ts_section2(v25);
                    v16 = v98;
                    goto lab_0x1a81b;
                }
            }
        }
    }
  lab_0x1a75e:;
    int32_t v100 = set_ts_section_data2(v27, &v14, v20, v17);
    result = v100;
    if (v100 < 0) {
        // break -> 0x1a84b
        goto lab_0x1a84b_7;
    }
    // 0x1a78c
    v16 = v100;
    if ((int32_t)check_ts_section2(v27) == 0) {
        goto lab_0x1a81b;
    } else {
        // 0x1a79c
        if ((int32_t)check_ts_section_crc2(v27) == 0) {
            // 0x1a7ce
            reset_ts_section2(v27);
            v16 = v100;
            goto lab_0x1a81b;
        } else {
            // 0x1a7ac
            if (*v33 == 0) {
                // 0x1a7ce
                reset_ts_section2(v27);
                v16 = v100;
                goto lab_0x1a81b;
            } else {
                // 0x1a7b7
                if ((int32_t)compare_ts_section2(v28) != 0) {
                    // 0x1a7e3
                    swap_ts_section2(v28, v27);
                    reset_ts_section2(v27);
                    int32_t v101 = proc_eit2(a1, v27, v20);
                    v16 = v101;
                    result = v101;
                    if (v101 < 0) {
                        // break -> 0x1a84b
                        goto lab_0x1a84b_7;
                    }
                    goto lab_0x1a81b;
                } else {
                    // 0x1a7ce
                    reset_ts_section2(v27);
                    v16 = v100;
                    goto lab_0x1a81b;
                }
            }
        }
    }
  lab_0x1a84b_7:;
    int64_t v86 = *(int64_t *)(a1 + 0x10628);
    *v4 = v86;
    *v2 = v86;
    __readgsqword(40);
    return result;
  lab_0x19e74:;
    int64_t v87 = v13;
    int64_t v88; // 0x19c75
    int64_t v89; // 0x19c75
    int64_t v90; // 0x19c75
    uint32_t v91; // 0x19e8d
    if (v87 == 0) {
        goto lab_0x19ed4;
    } else {
        // 0x19e7c
        if (*(int32_t *)(v87 + 152) != (int32_t)*v35) {
            goto lab_0x19ed4;
        } else {
            // 0x19e8d
            v91 = *(int32_t *)(v87 + 320);
            v89 = 0;
            if (v91 < 1) {
                goto lab_0x19ec0;
            } else {
                int64_t v92 = *(int64_t *)(v87 + 312); // 0x19e9a
                v88 = 0;
                v90 = v92;
                if (*(int32_t *)v92 == v29) {
                    // 0x1a865
                    return (int64_t)*v35;
                }
                goto lab_0x19eb9;
            }
        }
    }
  lab_0x19ed4:;
    int64_t v93 = v12 + (int64_t)(int32_t)&g1 & 0xffffffff; // 0x19ed4
    v13 = v87 + 1920;
    v12 = v93;
    if (v93 >= (int64_t)v34) {
        // 0x1a865
        return (int64_t)*v35;
    }
    goto lab_0x19e74;
  lab_0x19ec0:
    // 0x19ec0
    if (v91 != (int32_t)v89 || *(int32_t *)(v87 + 160) == v29) {
        // 0x1a865
        return (int64_t)*v35;
    }
    goto lab_0x19ed4;
  lab_0x19eb9:;
    int64_t v94 = v88 + (int64_t)(int32_t)&g1 & 0xffffffff; // 0x19eb9
    v89 = v94;
    if (v94 < (int64_t)v91) {
        int64_t v95 = v90 + 8; // 0x19eaa
        v88 = v94;
        v90 = v95;
        if (*(int32_t *)v95 == v29) {
            // 0x1a865
            return (int64_t)*v35;
        }
        goto lab_0x19eb9;
    } else {
        goto lab_0x19ec0;
    }
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x1a86e - 0x1a89e
// Line range:    982 - 2382
int32_t put_arib_std_b25(char * std_b25, int64_t buf) {
    // 0x1a86e
    int64_t v1; // 0x1a86e
    int32_t result = v1; // 0x1a86e
    int64_t v2; // 0x1a86e
    int64_t v3; // 0x1a86e
    *(char *)(v3 - 1200) = (char)(*(int32_t *)(v2 + 152) == result);
    return result;
}

// Address range: 0x1a89e - 0x1aedc
int64_t put_arib_std_b25_(int64_t a1, int64_t a2) {
    // 0x1a89e
    mcount();
    int64_t result = private_data4(a1); // 0x1a8c5
    if (a2 != 0 != result != 0) {
        // 0x1a8d7
        return result;
    }
    int64_t v1 = result + 0x10628; // 0x1a8e7
    int64_t result2 = append_work_buffer2(v1, a2, *(int32_t *)(a2 + (int64_t)&g95)); // 0x1a8f2
    if ((int32_t)result2 == 0) {
        // 0x1a8d7
        return result2;
    }
    int32_t * v2 = (int32_t *)(result + (int64_t)&g86); // 0x1a8ff
    int32_t v3 = *v2; // 0x1a8ff
    int32_t v4 = v3; // 0x1a906
    if (v3 > 187) {
        goto lab_0x1a928;
    } else {
        // 0x1a908
        if ((int32_t)select_unit_size2(result) < 0) {
            goto lab_0x1ae6e;
        } else {
            // 0x1a91b
            v4 = *v2;
            if (v4 < 188) {
                goto lab_0x1ae6e;
            } else {
                goto lab_0x1a928;
            }
        }
    }
  lab_0x1adde:;
    // 0x1adde
    int64_t v5; // 0x1a89e
    int64_t v6; // 0x1acad
    int64_t v7 = v5 + v6;
    int64_t v8 = v7; // 0x1adee
    int64_t v9; // 0x1a89e
    int64_t v10 = v9; // 0x1adee
    int64_t v11 = v9; // 0x1adee
    int64_t v12 = v7; // 0x1adee
    uint64_t v13; // 0x1adea
    if (v7 + v6 > v13) {
        // break -> 0x1adf4
        goto lab_0x1adf4;
    }
    goto lab_0x1acc0;
  lab_0x1a928:;
    int32_t * v33 = (int32_t *)(result + 1016); // 0x1a928
    int32_t v34 = *v33; // 0x1a928
    int64_t v35; // 0x1a89e
    int64_t v36; // 0x1a89e
    int64_t v37; // 0x1a89e
    int64_t v38; // 0x1a89e
    int64_t v18; // bp-88, 0x1a89e
    int32_t * v39; // 0x1a93b
    int64_t v40; // 0x1a93f
    char v24; // 0x1a89e
    int32_t v20; // 0x1a89e
    if (v34 >= 0 == (v34 != 0)) {
        goto lab_0x1aa82;
    } else {
        // 0x1a935
        v39 = (int32_t *)(result + (int64_t)&g95);
        v40 = result + 0x10630;
        int64_t v41 = *(int64_t *)v40 + (int64_t)*v39; // 0x1a93f
        uint64_t v42 = *(int64_t *)(result + 0x10638); // 0x1a946
        int64_t v43 = v4; // 0x1a95f
        int64_t v44 = 0; // 0x1aa28
        int64_t v45 = v41; // 0x1aa28
        int64_t v46; // 0x1a89e
        if (v42 >= v41 + v43) {
            int64_t v47 = (0x1000000000000 * result + 0x60000000000000) / 0x1000000000000;
            int64_t v48 = v41; // 0x1a96c
            if (*(char *)v41 != 71) {
                // 0x1a96e
                v48 = resync2(v41, v42, v4);
                if (v48 == 0) {
                    // break -> 0x1aa2e
                    break;
                }
            }
            int64_t v49 = v48;
            extract_ts_header2(&v18, v49);
            int64_t v50; // 0x1a89e
            int64_t v51 = v50; // 0x1a999
            int64_t v52 = 0; // 0x1a999
            int64_t v53; // 0x1a89e
            int64_t v54; // 0x1a89e
            int64_t v55; // 0x1a99b
            int64_t v56; // 0x1a9b2
            int64_t v57; // 0x1a9b2
            int64_t v58; // 0x1a9c0
            int64_t v59; // 0x1a9c5
            unsigned char v60; // 0x1a9a5
            if (v20 == 0) {
                // 0x1a99b
                v55 = v49 + (int64_t)&g86;
                v53 = v55;
                if ((v24 & (char)&g25) != 0) {
                    // 0x1a9a5
                    v60 = *(char *)v55;
                    v53 = v49 + (int64_t)&g86 + (int64_t)&g1 + (int64_t)v60 * (int64_t)&g1;
                }
                // 0x1a9ad
                v56 = v49 - v53 + 188;
                v57 = v56 & 0xffffffff;
                v58 = set_ts_section_data2(v47, &v18, v53, (int32_t)v56);
                v59 = v58 & 0xffffffff;
                if ((int32_t)v58 < 0) {
                    // break -> 0x1aa2e
                    break;
                }
                // 0x1a9cc
                v51 = v57;
                v52 = v59;
                if ((int32_t)check_ts_section2(v47) != 0) {
                    // 0x1a9d9
                    if ((int32_t)check_ts_section_crc2(v47) != 0) {
                        // 0x1a9e6
                        if (*(int32_t *)(result + 152) != 0) {
                            // 0x1a9fd
                            v54 = result + (int64_t)&g13;
                            swap_ts_section2(v54, v47);
                            reset_ts_section2(v47);
                            v35 = v54;
                            v38 = v57;
                            v36 = v59;
                            v37 = v49 + v43;
                            goto lab_0x1aa2e;
                        }
                    }
                    // 0x1a9ef
                    reset_ts_section2(v47);
                    v51 = v57;
                    v52 = v59;
                }
            }
            int64_t v61 = v52;
            int64_t v62 = v49 + v43;
            v46 = v51;
            v44 = v61;
            v45 = v62;
            while (v42 >= v62 + v43) {
                int64_t v63 = v51;
                int64_t v64 = v61;
                int64_t v65 = v62;
                v48 = v65;
                if (*(char *)v65 != 71) {
                    // 0x1a96e
                    v48 = resync2(v65, v42, v4);
                    v46 = v63;
                    v44 = v64;
                    v45 = v65;
                    if (v48 == 0) {
                        // break -> 0x1aa2e
                        break;
                    }
                }
                // 0x1a989
                v49 = v48;
                extract_ts_header2(&v18, v49);
                v51 = v63;
                v52 = v64;
                if (v20 == 0) {
                    // 0x1a99b
                    v55 = v49 + (int64_t)&g86;
                    v53 = v55;
                    if ((v24 & (char)&g25) != 0) {
                        // 0x1a9a5
                        v60 = *(char *)v55;
                        v53 = v49 + (int64_t)&g86 + (int64_t)&g1 + (int64_t)v60 * (int64_t)&g1;
                    }
                    // 0x1a9ad
                    v56 = v49 - v53 + 188;
                    v57 = v56 & 0xffffffff;
                    v58 = set_ts_section_data2(v47, &v18, v53, (int32_t)v56);
                    v59 = v58 & 0xffffffff;
                    v46 = v57;
                    v44 = v59;
                    v45 = v49;
                    if ((int32_t)v58 < 0) {
                        // break -> 0x1aa2e
                        break;
                    }
                    // 0x1a9cc
                    v51 = v57;
                    v52 = v59;
                    if ((int32_t)check_ts_section2(v47) != 0) {
                        // 0x1a9d9
                        if ((int32_t)check_ts_section_crc2(v47) != 0) {
                            // 0x1a9e6
                            if (*(int32_t *)(result + 152) != 0) {
                                // 0x1a9fd
                                v54 = result + (int64_t)&g13;
                                swap_ts_section2(v54, v47);
                                reset_ts_section2(v47);
                                v35 = v54;
                                v38 = v57;
                                v36 = v59;
                                v37 = v49 + v43;
                                goto lab_0x1aa2e;
                            }
                        }
                        // 0x1a9ef
                        reset_ts_section2(v47);
                        v51 = v57;
                        v52 = v59;
                    }
                }
                // 0x1aa1c
                v61 = v52;
                v62 = v49 + v43;
                v46 = v51;
                v44 = v61;
                v45 = v62;
            }
        }
        // 0x1aa2e
        v35 = result + (int64_t)&g13;
        v38 = v46;
        v36 = v44;
        v37 = v45;
        goto lab_0x1aa2e;
    }
  lab_0x1aa82:;
    // 0x1aa82
    int64_t v66; // 0x1a89e
    if ((int32_t)check_pmt_complete2(result) != 0) {
        goto lab_0x1ac7b;
    } else {
        // 0x1aa92
        if ((int32_t)find_pmt2(result) < 0) {
            goto lab_0x1ae6e;
        } else {
            int64_t v67 = check_pmt_complete2(result); // 0x1aaa8
            int32_t * v68 = (int32_t *)(result + (int64_t)&g95);
            if ((int32_t)v67 != 0) {
                // 0x1ac6c
                *v68 = 0;
                setup_pid_map2(result);
                goto lab_0x1ac7b;
            } else {
                int32_t v69 = *v68; // 0x1aab5
                if (v69 > 0x1ffffff) {
                    goto lab_0x1ae6e;
                } else {
                    int32_t * v70 = (int32_t *)(result + (int64_t)"GNU"); // 0x1aac9
                    int32_t v71 = *v70 + v69; // 0x1aac9
                    *v70 = v71;
                    if (v71 < 0x500001) {
                        goto lab_0x1ae6e;
                    } else {
                        int64_t v72 = (int64_t)*v33; // 0x1aada
                        int64_t v73 = __kmalloc(1920 * v72, (int64_t *)&g26, 128 * v72); // 0x1aaf7
                        int64_t * v74 = (int64_t *)(result + 1024);
                        int64_t v75 = v66; // 0x1ab13
                        int64_t v76 = 0; // 0x1ab13
                        if (*v33 >= 1) {
                            // 0x1ab36
                            bool v77; // 0x1a89e
                            int64_t v78 = v77 ? -8 : (int64_t)&g95;
                            int64_t v79 = 0; // 0x1a89e
                            int64_t v80 = 0;
                            int64_t v81 = *v74; // 0x1ab4a
                            int64_t v82 = 0x100000000 * v79 / 0x100000000 * ((1 << (int64_t)&g99) - (1 << (int64_t)&g94)) + v81; // 0x1ab4a
                            char v83; // 0x1a89e
                            char v84; // 0x1a89e
                            int64_t v85; // 0x1a89e
                            int64_t v86; // 0x1a89e
                            int64_t v87; // 0x1a89e
                            int64_t v88; // 0x1a89e
                            int64_t v89; // 0x1a89e
                            int64_t v90; // 0x1a89e
                            int64_t v91; // 0x1a89e
                            int64_t v92; // 0x1a89e
                            int64_t v93; // 0x1a89e
                            int64_t v94; // 0x1a89e
                            int64_t v95; // 0x1a89e
                            int64_t v96; // 0x1a89e
                            int64_t v97; // 0x1a89e
                            int64_t v98; // 0x1a89e
                            int64_t v99; // 0x1a89e
                            int64_t v100; // 0x1a89e
                            int64_t v101; // 0x1a89e
                            int64_t v102; // 0x1ab96
                            int64_t v103; // 0x1abad
                            int64_t v104; // 0x1abd2
                            char v105; // 0x1abdc
                            int64_t v106; // 0x1abec
                            int64_t v107; // 0x1ab80
                            char v108; // 0x1a89e
                            if ((int32_t)check_ts_section2(v82 + 8) != 0) {
                                // 0x1ab6b
                                v107 = 0x100000000 * v80 / 0x100000000 * ((1 << (int64_t)&g99) - (1 << (int64_t)&g94)) + v73;
                                v108 = v107;
                                v84 = v108;
                                v86 = 1920;
                                v97 = v82;
                                v102 = v107;
                                if ((v108 & (char)&g1) != 0) {
                                    // 0x1ab91
                                    *(char *)v107 = *(char *)v82;
                                    v102 = v107 + (int64_t)&g1;
                                    v84 = v102;
                                    v86 = (int32_t)((int64_t)&g86 & -0x10000 | 1920) - 1;
                                    v97 = v82 + 1;
                                }
                                // 0x1aba1
                                v93 = v102;
                                v98 = v97;
                                v87 = v86;
                                v83 = v84;
                                v88 = v87;
                                v99 = v98;
                                v103 = v93;
                                if ((v84 & (char)&g25) != 0) {
                                    // 0x1aba7
                                    *(int16_t *)v93 = *(int16_t *)v98;
                                    v103 = v93 + (int64_t)&g25;
                                    v83 = v103;
                                    v88 = v87 + 0xfffffffe & 0xffffffff;
                                    v99 = v98 + 2;
                                }
                                // 0x1abb8
                                v94 = v103;
                                v100 = v99;
                                v89 = v88;
                                v90 = v89;
                                v101 = v100;
                                v95 = v94;
                                if ((v83 & (char)&g86) != 0) {
                                    // 0x1abbe
                                    *(int32_t *)v94 = *(int32_t *)v100;
                                    v90 = v89 + 0xfffffffc & 0xffffffff;
                                    v101 = v100 + 4;
                                    v95 = v94 + (int64_t)&g86;
                                }
                                // 0x1abcd
                                v96 = v95;
                                v104 = (int32_t)v90 >> (int32_t)&g33;
                                __asm_rep_movsq_memcpy((char *)v96, (char *)v101, v104);
                                v105 = v90;
                                v91 = 0;
                                if ((v105 & (char)&g25) != 0) {
                                    // 0x1abec
                                    v106 = (v105 & (char)&g86) == 0 ? 0 : (int64_t)(int16_t)&g86 * (int64_t)&g1;
                                    v91 = (int64_t)*(int16_t *)(v78 * v104 + v96 + v106);
                                }
                                // 0x1abf8
                                v92 = v91;
                                v85 = v80 + (int64_t)(int32_t)&g1 & 0xffffffff;
                            } else {
                                // 0x1ab5e
                                release_program2(v82);
                                v92 = v66;
                                v85 = v80;
                            }
                            int64_t v109 = v85;
                            int64_t v110 = v79 + (int64_t)(int32_t)&g1; // 0x1ac07
                            int64_t v111 = v92; // 0x1ac12
                            v79 = v110 & 0xffffffff;
                            v75 = v92;
                            v76 = v109;
                            while (*v33 > (int32_t)v110) {
                                // 0x1ab36
                                v80 = v109;
                                v81 = *v74;
                                v82 = 0x100000000 * v79 / 0x100000000 * ((1 << (int64_t)&g99) - (1 << (int64_t)&g94)) + v81;
                                if ((int32_t)check_ts_section2(v82 + 8) != 0) {
                                    // 0x1ab6b
                                    v107 = 0x100000000 * v80 / 0x100000000 * ((1 << (int64_t)&g99) - (1 << (int64_t)&g94)) + v73;
                                    v108 = v107;
                                    v84 = v108;
                                    v86 = 1920;
                                    v97 = v82;
                                    v102 = v107;
                                    if ((v108 & (char)&g1) != 0) {
                                        // 0x1ab91
                                        *(char *)v107 = *(char *)v82;
                                        v102 = v107 + (int64_t)&g1;
                                        v84 = v102;
                                        v86 = (int32_t)((int64_t)&g86 & -0x10000 | 1920) - 1;
                                        v97 = v82 + 1;
                                    }
                                    // 0x1aba1
                                    v93 = v102;
                                    v98 = v97;
                                    v87 = v86;
                                    v83 = v84;
                                    v88 = v87;
                                    v99 = v98;
                                    v103 = v93;
                                    if ((v84 & (char)&g25) != 0) {
                                        // 0x1aba7
                                        *(int16_t *)v93 = *(int16_t *)v98;
                                        v103 = v93 + (int64_t)&g25;
                                        v83 = v103;
                                        v88 = v87 + 0xfffffffe & 0xffffffff;
                                        v99 = v98 + 2;
                                    }
                                    // 0x1abb8
                                    v94 = v103;
                                    v100 = v99;
                                    v89 = v88;
                                    v90 = v89;
                                    v101 = v100;
                                    v95 = v94;
                                    if ((v83 & (char)&g86) != 0) {
                                        // 0x1abbe
                                        *(int32_t *)v94 = *(int32_t *)v100;
                                        v90 = v89 + 0xfffffffc & 0xffffffff;
                                        v101 = v100 + 4;
                                        v95 = v94 + (int64_t)&g86;
                                    }
                                    // 0x1abcd
                                    v96 = v95;
                                    v104 = (int32_t)v90 >> (int32_t)&g33;
                                    __asm_rep_movsq_memcpy((char *)v96, (char *)v101, v104);
                                    v105 = v90;
                                    v91 = 0;
                                    if ((v105 & (char)&g25) != 0) {
                                        // 0x1abec
                                        v106 = (v105 & (char)&g86) == 0 ? 0 : (int64_t)(int16_t)&g86 * (int64_t)&g1;
                                        v91 = (int64_t)*(int16_t *)(v78 * v104 + v96 + v106);
                                    }
                                    // 0x1abf8
                                    v92 = v91;
                                    v85 = v80 + (int64_t)(int32_t)&g1 & 0xffffffff;
                                } else {
                                    // 0x1ab5e
                                    release_program2(v82);
                                    v92 = v111;
                                    v85 = v80;
                                }
                                // 0x1ac07
                                v109 = v85;
                                v110 = v79 + (int64_t)(int32_t)&g1;
                                v111 = v92;
                                v79 = v110 & 0xffffffff;
                                v75 = v92;
                                v76 = v109;
                            }
                        }
                        // 0x1ac1e
                        *v33 = (int32_t)v76;
                        int64_t v112 = *v74; // 0x1ac25
                        memcpy(v112, v73, 0x100000000 * v76 / 0x100000000 * ((1 << (int64_t)&g99) - (1 << (int64_t)&g94)), v75);
                        kfree(v73);
                        *v70 = 0;
                        if ((int32_t)find_pmt2(result) < 0) {
                            goto lab_0x1ae6e;
                        } else {
                            // 0x1ac6c
                            *v68 = 0;
                            setup_pid_map2(result);
                            goto lab_0x1ac7b;
                        }
                    }
                }
            }
        }
    }
  lab_0x1ae6e:
    // 0x1ae6e
    *(int32_t *)(result + (int64_t)&g95) = 0;
    int64_t * v113 = (int64_t *)(result + 0x10638); // 0x1ae75
    int64_t v114 = result + 0x10630; // 0x1ae7c
    int32_t v115 = (int32_t)*v113 - *(int32_t *)v114; // 0x1ae7c
    int64_t v116 = result + 0x10648; // 0x1ae83
    int64_t v117 = *(int64_t *)(result + 0x10658); // 0x1ae8a
    int32_t v118 = *(int32_t *)(result + 0x10650); // 0x1ae91
    int64_t result3 = reserve_work_buffer2(v116, v115 - v118 + (int32_t)v117); // 0x1ae9f
    if ((int32_t)result3 == 0) {
        // 0x1a8d7
        return result3;
    }
    int64_t * v119 = (int64_t *)v114; // 0x1aea8
    append_work_buffer2(v116, *v119, v115);
    int64_t result4 = *(int64_t *)v1; // 0x1aec5
    *v113 = result4;
    *v119 = result4;
    return result4;
  lab_0x1ac7b:
    // 0x1ac7b
    if ((int32_t)check_ecm_complete2(result) != 0) {
        // 0x1ae58
        return proc_arib_std_b25_(result);
    }
    int32_t v17 = *v2; // 0x1ac8b
    int32_t * v32 = (int32_t *)(result + (int64_t)&g95); // 0x1ac91
    int64_t v31 = result + 0x10630; // 0x1ac95
    int64_t v120 = *(int64_t *)v31 + (int64_t)*v32; // 0x1ac95
    v6 = v17;
    v13 = 0x1000000000000 * *(int64_t *)(result + 0x10638) / 0x1000000000000;
    v11 = 0;
    v12 = v120;
    if (v120 + v6 <= v13) {
        // 0x1acc0
        v8 = v120;
        v10 = 0;
        while (true) {
          lab_0x1acc0:;
            int64_t v14 = v10;
            int64_t v15 = v8;
            int64_t v16 = v15; // 0x1acc4
            if (*(char *)v15 != 71) {
                // 0x1acc6
                v16 = resync2(v15, v13, v17);
                v11 = v14;
                v12 = v15;
                if (v16 == 0) {
                    // break -> 0x1adf4
                    break;
                }
            }
            // 0x1ace1
            v5 = v16;
            extract_ts_header2(&v18, v5);
            int64_t v19 = *(int64_t *)(8 * (int64_t)v20 + 1040 + result); // 0x1acf3
            v9 = v14;
            if (v19 == 0) {
                goto lab_0x1adde;
            } else {
                // 0x1ad04
                v9 = v14;
                if (*(int32_t *)(v19 + 160) != v20) {
                    goto lab_0x1adde;
                } else {
                    int64_t v21 = v19 + 168; // 0x1ad12
                    v9 = v14;
                    if ((int32_t)check_ts_section2(v21) != 0) {
                        goto lab_0x1adde;
                    } else {
                        int64_t v22 = v5 + (int64_t)&g86; // 0x1ad2e
                        int64_t v23 = v22; // 0x1ad36
                        if ((v24 & (char)&g25) != 0) {
                            unsigned char v25 = *(char *)v22; // 0x1ad38
                            v23 = v5 + (int64_t)&g86 + (int64_t)&g1 + (int64_t)v25 * (int64_t)&g1;
                        }
                        int64_t v26 = v23;
                        int64_t v27 = v19 + 240; // 0x1ad40
                        int64_t v28 = set_ts_section_data2(v27, &v18, v26, (int32_t)v5 + 188 - (int32_t)v26); // 0x1ad5e
                        int64_t v29 = v28 & 0xffffffff; // 0x1ad63
                        v9 = v29;
                        if ((int32_t)check_ts_section2(v27) == 0) {
                            goto lab_0x1adde;
                        } else {
                            // 0x1ad7b
                            if ((int32_t)check_ts_section_crc2(v27) == 0) {
                                // 0x1ad93
                                reset_ts_section2(v27);
                                v9 = v29;
                                goto lab_0x1adde;
                            } else {
                                // 0x1ad88
                                if (*(int32_t *)(v19 + 296) != 0) {
                                    // 0x1ada2
                                    swap_ts_section2(v21, v27);
                                    reset_ts_section2(v27);
                                    v9 = v29;
                                    if ((int32_t)check_ecm_complete2(result) != 0) {
                                        int32_t v30 = *(int32_t *)v31; // 0x1adcf
                                        *v32 = (int32_t)(v5 + v6 * (int64_t)&g1) - v30;
                                        goto lab_0x1ae0a;
                                    }
                                    goto lab_0x1adde;
                                } else {
                                    // 0x1ad93
                                    reset_ts_section2(v27);
                                    v9 = v29;
                                    goto lab_0x1adde;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x1adf4:
    // 0x1adf4
    *v32 = (int32_t)v12 - *(int32_t *)v31;
    if ((int32_t)v11 < 0) {
        goto lab_0x1ae6e;
    } else {
        goto lab_0x1ae0a;
    }
  lab_0x1aa2e:
    // 0x1aa2e
    *v39 = (int32_t)v37 - *(int32_t *)v40;
    int64_t v121 = v36; // 0x1aa44
    if ((int32_t)check_ts_section2(v35) != 0) {
        // 0x1aa46
        v121 = proc_pat2(result) & 0xffffffff;
    }
    // 0x1aa51
    if ((int32_t)v121 < 0) {
        goto lab_0x1ae6e;
    } else {
        int32_t v122 = *v33; // 0x1aa5a
        if (v122 >= 0 == (v122 != 0)) {
            // 0x1aa7b
            *v39 = 0;
            v66 = v38;
            goto lab_0x1aa82;
        } else {
            goto lab_0x1ae6e;
        }
    }
  lab_0x1ae0a:
    // 0x1ae0a
    if ((int32_t)check_ecm_complete2(result) != 0) {
        // 0x1ae49
        *v32 = 0;
        setup_multi2_(result);
        // 0x1ae58
        return proc_arib_std_b25_(result);
    }
    uint32_t v123 = *v32; // 0x1ae16
    if (v123 <= 0x1ffffff) {
        int32_t * v124 = (int32_t *)(result + (int64_t)&g2); // 0x1ae26
        uint32_t v125 = *v124 + v123; // 0x1ae26
        *v124 = v125;
        if (v125 >= 0x100001) {
            // 0x1ae33
            *v124 = 0;
            *(char *)(result + 0x10672) = (char)&g1;
        }
    }
    goto lab_0x1ae6e;
}

// From module:   /root/asv5220\arib_std_b25.c
// Address range: 0x1aede - 0x1af0e
// Line range:    562 - 956
int32_t flush_arib_std_b25(char * std_b25) {
    // 0x1aede
    int64_t result; // 0x1aede
    return result;
}

// Address range: 0x1af0e - 0x1b9a5
int64_t flush_arib_std_b25_(int64_t a1) {
    // 0x1af0e
    mcount();
    int64_t v1 = private_data4(a1); // 0x1af2a
    proc_arib_std_b25_(v1);
    int32_t * v2 = (int32_t *)(v1 + (int64_t)&g86); // 0x1af57
    uint32_t v3 = *v2; // 0x1af57
    int32_t v4 = v3; // 0x1af5f
    if (v3 <= 187) {
        // 0x1af61
        select_unit_size2(v1);
        v4 = *v2;
    }
    int64_t * v5 = (int64_t *)(v1 + 0x10630); // 0x1af7e
    int64_t v6 = *v5; // 0x1af7e
    uint64_t v7 = *(int64_t *)(v1 + 0x10638); // 0x1af85
    int32_t v8 = v7 - v6; // 0x1af99
    int64_t v9 = v1 + 0x10648; // 0x1af9c
    int32_t v10 = *(int32_t *)(v1 + 0x10650); // 0x1afb1
    reserve_work_buffer2(v9, (int32_t)*(int64_t *)(v1 + 0x10658) - v10 + v8);
    int64_t v11 = v6; // 0x1b905
    int64_t v12; // 0x1af0e
    int64_t v13; // 0x1af0e
    int32_t v14; // 0x1af0e
    int32_t v15; // 0x1af0e
    int64_t v16; // bp-88, 0x1af0e
    int64_t v17; // 0x1afd0
    int64_t v18; // 0x1afde
    int64_t v19; // 0x1b008
    int64_t v20; // 0x1b016
    int64_t v21; // 0x1b024
    int64_t v22; // 0x1b02f
    int64_t v23; // 0x1b064
    int32_t * v24; // 0x1af0e
    int32_t * v25; // 0x1af0e
    int32_t * v26; // 0x1af0e
    int32_t * v27; // 0x1af0e
    int64_t v28; // 0x1b392
    int64_t v29; // 0x1b5bc
    int64_t v30; // 0x1b714
    if (v7 >= v6 + 188) {
        // 0x1b093
        v17 = v1 + 680;
        v18 = v1 + 608;
        int64_t v31 = v1 + 240; // 0x1afec
        int64_t v32 = v1 + 168; // 0x1affa
        v19 = v1 + 384;
        v20 = v1 + 312;
        v21 = v1 + 528;
        v22 = v1 + 456;
        int64_t v33 = v1 + 96; // 0x1b03d
        int64_t v34 = v1 + (int64_t)&g13; // 0x1b048
        uint64_t v35 = v7 - 188; // 0x1b05d
        v23 = v4;
        int64_t v36 = v4; // 0x1b07a
        int64_t v37 = (int64_t)(v4 + (int32_t)&g1) * (int64_t)&g1;
        int32_t v38; // 0x1af0e
        char v39 = v38;
        v24 = (int32_t *)(v1 + 736);
        v25 = (int32_t *)(v1 + 640);
        v26 = (int32_t *)(v1 + 440);
        v27 = (int32_t *)(v1 + 584);
        v13 = v6;
        v15 = v8;
        while (true) {
          lab_0x1b093:;
            int64_t v40 = v13;
            int64_t v41 = v40; // 0x1b098
            if (*(char *)v40 != 71) {
                // 0x1b09e
                v11 = v40;
                if (v40 > v35) {
                    // break -> 0x1b957
                    break;
                }
                int64_t v42 = v40 + (int64_t)&g1; // 0x1b121
                v11 = v40;
                if (v35 < v42) {
                    // break -> 0x1b957
                    break;
                }
                int64_t v43 = v42; // 0x1b121
                int64_t v44 = v7 - (int64_t)(int32_t)&g1 - v40; // 0x1af0e
                int64_t v45 = v40 + v37; // 0x1af0e
                int64_t v46; // 0x1af0e
                while (true) {
                    int64_t v47 = v45;
                    int64_t v48 = v44;
                    v46 = v43;
                    int64_t v49 = v48 & 0xffffffff;
                    if (*(char *)v46 == 71) {
                        int64_t v50 = ((int64_t)((int32_t)v48 >> (int32_t)&g24) << (int64_t)&g26 | v49) / v36; // 0x1b0e0
                        int32_t v51 = v50; // 0x1b0e3
                        if (v51 == 0) {
                            // break -> 0x1b133
                            break;
                        }
                        int64_t v52 = &g1; // 0x1b0ea
                        if (v51 > (int32_t)&g1) {
                            uint64_t v53 = v50 & 0xffffffff; // 0x1b0e0
                            int64_t v54 = &g1; // 0x1b0f7
                            int64_t v55 = 2 * v4; // 0x1b0f7
                            v52 = &g1;
                            if (*(char *)v47 == 71) {
                                int64_t v56 = v54 + (int64_t)(int32_t)&g1 & 0xffffffff; // 0x1b108
                                v52 = v56;
                                while (v53 > v56) {
                                    char v57 = *(char *)(0x100000000 * v55 / 0x100000000 * (int64_t)&g1 + v46); // 0x1b101
                                    v54 = v56;
                                    v55 = v55 + v36 & 0xffffffff;
                                    v52 = v56;
                                    if (v57 != 71) {
                                        // break -> 0x1b116
                                        break;
                                    }
                                    v56 = v54 + (int64_t)(int32_t)&g1 & 0xffffffff;
                                    v52 = v56;
                                }
                            }
                        }
                        // 0x1b116
                        if (v51 == (int32_t)v52) {
                            // break -> 0x1b133
                            break;
                        }
                    }
                    // 0x1b11a
                    v43 = v46 + (int64_t)&g1;
                    v44 = v49 - (int64_t)(int32_t)&g1;
                    v45 = v47 + (int64_t)&g1;
                    v11 = v40;
                    if (v35 < v43) {
                        // break (via goto) -> 0x1b957
                        goto lab_0x1b957_7;
                    }
                }
                // 0x1b133
                v41 = v46;
                v11 = v40;
                if (v46 == 0) {
                    // break -> 0x1b957
                    break;
                }
            }
            // 0x1b13f
            v12 = v41;
            extract_ts_header2(&v16, v12);
            uint32_t v58; // 0x1af0e
            int64_t v59 = *(int64_t *)(8 * (int64_t)v58 + 1040 + v1); // 0x1b155
            int64_t v60 = v59; // 0x1b164
            if (v59 == 0) {
                // 0x1b166
                v60 = *(int64_t *)(v1 + 1024);
            }
            int64_t v61 = v60;
            int64_t v62 = v12 + (int64_t)&g86; // 0x1b171
            int16_t v63 = v62; // 0x1b176
            int32_t v64 = v15; // 0x1b17f
            int16_t v65 = v63; // 0x1b17f
            if ((v39 & (char)&g1) != 0) {
                int16_t v66 = v63; // 0x1b183
                if ((v39 & (char)&g25) != 0) {
                    unsigned char v67 = *(char *)v62; // 0x1b185
                    v66 = v12 + (int64_t)&g86 + (int64_t)&g1 + (int64_t)v67 * (int64_t)&g1;
                }
                int16_t v68 = v66;
                int32_t v69 = (int32_t)v12 - (int32_t)v68 + 188; // 0x1b197
                v64 = v69;
                v65 = v68;
                int32_t v70; // 0x1af0e
                if (v70 != 0) {
                    int64_t v71 = *(int64_t *)(v61 + 328); // 0x1b1a7
                    v64 = v69;
                    v65 = v68;
                    if (v71 != 0) {
                        // 0x1b1b3
                        v11 = v12;
                        if ((int32_t)v71 < 0) {
                            // break -> 0x1b957
                            break;
                        }
                        char * v72 = (char *)(v12 + (int64_t)&g33); // 0x1b1cf
                        *v72 = *v72 % 64;
                        v64 = v69;
                        v65 = v68;
                    }
                }
            }
            int64_t v73 = append_work_buffer2(v9, v12, 188); // 0x1b1e4
            v11 = v12;
            if ((int32_t)v73 == 0) {
                // break -> 0x1b957
                break;
            }
            int16_t v74 = v65;
            v14 = v64;
            if (*(int32_t *)(v61 + 160) != v58) {
                // 0x1b2bc
                if (*(int32_t *)v61 != v58) {
                    // 0x1b382
                    if (*(int32_t *)(v1 + 600) != v58) {
                        if (v58 != (int32_t)&g1) {
                            if (v58 != (int32_t)&g3) {
                                if (v58 != (int32_t)&g4) {
                                    if (v58 == 0) {
                                        int64_t v75 = set_ts_section_data2(v33, &v16, (int64_t)v74, v14); // 0x1b850
                                        v11 = v12;
                                        if ((int32_t)v75 < 0) {
                                            // break -> 0x1b957
                                            break;
                                        }
                                        // 0x1b860
                                        if ((int32_t)check_ts_section2(v33) != 0) {
                                            // 0x1b874
                                            if ((int32_t)check_ts_section_crc2(v33) != 0) {
                                                // 0x1b884
                                                if (*(int32_t *)(v1 + 152) != 0) {
                                                    // 0x1b88e
                                                    if ((int32_t)compare_ts_section2(v34) != 0) {
                                                        // 0x1b8b7
                                                        swap_ts_section2(v34, v33);
                                                        reset_ts_section2(v33);
                                                        v11 = v12;
                                                        if ((int32_t)proc_pat2(v1) < 0) {
                                                            goto lab_0x1b957_7;
                                                        } else {
                                                            // 0x1b8e8
                                                            v11 = v12 + v23 * (int64_t)&g1;
                                                            goto lab_0x1b957_7;
                                                        }
                                                    }
                                                }
                                            }
                                            // 0x1b8a5
                                            reset_ts_section2(v33);
                                        }
                                    }
                                    goto lab_0x1b8f9;
                                } else {
                                    // 0x1b711
                                    v30 = v74;
                                    set_ts_section_data_for_remaining_payload_data2(v21, &v16, v30);
                                    if ((int32_t)check_ts_section2(v21) == 0) {
                                        goto lab_0x1b794;
                                    } else {
                                        // 0x1b732
                                        if ((int32_t)check_ts_section_crc2(v21) == 0) {
                                            // 0x1b75d
                                            reset_ts_section2(v21);
                                            goto lab_0x1b794;
                                        } else {
                                            // 0x1b73f
                                            if (*v27 == 0) {
                                                // 0x1b75d
                                                reset_ts_section2(v21);
                                                goto lab_0x1b794;
                                            } else {
                                                // 0x1b749
                                                if ((int32_t)compare_ts_section2(v22) != 0) {
                                                    // 0x1b768
                                                    swap_ts_section2(v22, v21);
                                                    reset_ts_section2(v21);
                                                    v11 = v12;
                                                    if ((int32_t)proc_eit2(v1, v21, v30) < 0) {
                                                        // break -> 0x1b957
                                                        break;
                                                    }
                                                    goto lab_0x1b794;
                                                } else {
                                                    // 0x1b75d
                                                    reset_ts_section2(v21);
                                                    goto lab_0x1b794;
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                // 0x1b5b9
                                v29 = v74;
                                set_ts_section_data_for_remaining_payload_data2(v19, &v16, v29);
                                if ((int32_t)check_ts_section2(v19) == 0) {
                                    goto lab_0x1b651;
                                } else {
                                    // 0x1b5e0
                                    if ((int32_t)check_ts_section_crc2(v19) == 0) {
                                        // 0x1b611
                                        reset_ts_section2(v19);
                                        goto lab_0x1b651;
                                    } else {
                                        // 0x1b5f0
                                        if (*v26 == 0) {
                                            // 0x1b611
                                            reset_ts_section2(v19);
                                            goto lab_0x1b651;
                                        } else {
                                            // 0x1b5fa
                                            if ((int32_t)compare_ts_section2(v20) != 0) {
                                                // 0x1b61f
                                                swap_ts_section2(v20, v19);
                                                reset_ts_section2(v19);
                                                v11 = v12;
                                                if ((int32_t)proc_sdt2(v1, v19, v29) < 0) {
                                                    // break -> 0x1b957
                                                    break;
                                                }
                                                goto lab_0x1b651;
                                            } else {
                                                // 0x1b611
                                                reset_ts_section2(v19);
                                                goto lab_0x1b651;
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            int64_t v76 = set_ts_section_data2(v31, &v16, (int64_t)v74, v14); // 0x1b50b
                            v11 = v12;
                            if ((int32_t)v76 < 0) {
                                // break -> 0x1b957
                                break;
                            }
                            // 0x1b51b
                            if ((int32_t)check_ts_section2(v31) == 0) {
                                goto lab_0x1b8f9;
                            } else {
                                // 0x1b52f
                                if ((int32_t)check_ts_section_crc2(v31) == 0) {
                                    // 0x1b560
                                    reset_ts_section2(v31);
                                    goto lab_0x1b8f9;
                                } else {
                                    // 0x1b53f
                                    if (*(int32_t *)(v1 + 296) == 0) {
                                        // 0x1b560
                                        reset_ts_section2(v31);
                                        goto lab_0x1b8f9;
                                    } else {
                                        // 0x1b549
                                        if ((int32_t)compare_ts_section2(v32) != 0) {
                                            // 0x1b575
                                            swap_ts_section2(v32, v31);
                                            reset_ts_section2(v31);
                                            v11 = v12;
                                            if ((int32_t)proc_cat2(v1) < 0) {
                                                // break -> 0x1b957
                                                break;
                                            }
                                            goto lab_0x1b8f9;
                                        } else {
                                            // 0x1b560
                                            reset_ts_section2(v31);
                                            goto lab_0x1b8f9;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // 0x1b38f
                        v28 = v74;
                        int64_t v77 = set_ts_section_data_for_remaining_payload_data2(v17, &v16, v28); // 0x1b3a1
                        if ((int32_t)check_ts_section2(v17) == 0) {
                            goto lab_0x1b436;
                        } else {
                            // 0x1b3b9
                            if ((int32_t)check_ts_section_crc2(v17) == 0) {
                                // 0x1b3ea
                                reset_ts_section2(v17);
                                goto lab_0x1b436;
                            } else {
                                // 0x1b3c9
                                if (*v24 == 0) {
                                    // 0x1b3ea
                                    reset_ts_section2(v17);
                                    goto lab_0x1b436;
                                } else {
                                    // 0x1b3d3
                                    if ((int32_t)compare_ts_section2(v18) != 0) {
                                        // 0x1b3f8
                                        swap_ts_section2(v18, v17);
                                        reset_ts_section2(v17);
                                        if (*v25 == 132) {
                                            // 0x1b424
                                            proc_emm2(v1);
                                            v11 = v12;
                                            if ((int32_t)v77 < 0) {
                                                // break -> 0x1b957
                                                break;
                                            }
                                        }
                                        goto lab_0x1b436;
                                    } else {
                                        // 0x1b3ea
                                        reset_ts_section2(v17);
                                        goto lab_0x1b436;
                                    }
                                }
                            }
                        }
                    }
                } else {
                    int64_t v78 = v61 + 80; // 0x1b2cc
                    int64_t v79 = set_ts_section_data2(v78, &v16, (int64_t)v74, v14); // 0x1b2de
                    v11 = v12;
                    if ((int32_t)v79 < 0) {
                        // break -> 0x1b957
                        break;
                    }
                    // 0x1b2ee
                    if ((int32_t)check_ts_section2(v78) != 0) {
                        // 0x1b2fe
                        if ((int32_t)check_ts_section_crc2(v78) != 0) {
                            // 0x1b30a
                            if (*(int32_t *)(v61 + 136) != 0) {
                                int64_t v80 = v61 + 8; // 0x1b317
                                if ((int32_t)compare_ts_section2(v80) != 0) {
                                    // 0x1b33f
                                    swap_ts_section2(0x1000000000000 * v80 / 0x1000000000000, v78);
                                    reset_ts_section2(v78);
                                    v11 = v12;
                                    if ((int32_t)proc_pmt2((int32_t)v61) < 0) {
                                        goto lab_0x1b957_7;
                                    } else {
                                        // 0x1b36a
                                        setup_pid_map2(v1);
                                        v11 = v12 + v23 * (int64_t)&g1;
                                        goto lab_0x1b957_7;
                                    }
                                }
                            }
                        }
                        // 0x1b32e
                        reset_ts_section2(v78);
                    }
                    goto lab_0x1b8f9;
                }
            } else {
                int64_t v81 = v61 + 240; // 0x1b20c
                int64_t v82 = set_ts_section_data2(v81, &v16, (int64_t)v74, v14); // 0x1b221
                v11 = v12;
                if ((int32_t)v82 < 0) {
                    // break -> 0x1b957
                    break;
                }
                // 0x1b231
                if ((int32_t)check_ts_section2(v81) == 0) {
                    goto lab_0x1b8f9;
                } else {
                    // 0x1b241
                    if ((int32_t)check_ts_section_crc2(v81) == 0) {
                        // 0x1b274
                        reset_ts_section2(v81);
                        goto lab_0x1b8f9;
                    } else {
                        // 0x1b24d
                        if (*(int32_t *)(v61 + 296) == 0) {
                            // 0x1b274
                            reset_ts_section2(v81);
                            goto lab_0x1b8f9;
                        } else {
                            int64_t v83 = v61 + 168; // 0x1b25a
                            if ((int32_t)compare_ts_section2(v83) != 0) {
                                // 0x1b285
                                swap_ts_section2(0x1000000000000 * v83 / 0x1000000000000, v81);
                                reset_ts_section2(v81);
                                v11 = v12;
                                if ((int32_t)proc_ecm2(v61, *(int64_t *)(v1 + 0x10618)) < 0) {
                                    // break -> 0x1b957
                                    break;
                                }
                                goto lab_0x1b8f9;
                            } else {
                                // 0x1b274
                                reset_ts_section2(v81);
                                goto lab_0x1b8f9;
                            }
                        }
                    }
                }
            }
        }
    }
    goto lab_0x1b957_7;
  lab_0x1b957_7:;
    int64_t v84 = *v5; // 0x1b95a
    int32_t v85 = (int32_t)v7 - (int32_t)v11; // 0x1b967
    int64_t v86 = v85 < 1024 ? v84 : v11 - v84 & 0xffffffff;
    return memcpy(*(int64_t *)(v1 + 0x10628), v11, (int64_t)v85, v86);
  lab_0x1b8f9:;
    int64_t v87 = v12 + v23;
    v13 = v87;
    v15 = v14;
    v11 = v87;
    if (v7 < v87 + 188) {
        // break -> 0x1b957
        goto lab_0x1b957_7;
    }
    goto lab_0x1b093;
  lab_0x1b436:;
    int64_t v88 = set_ts_section_data2(v17, &v16, v28, v14); // 0x1b448
    v11 = v12;
    if ((int32_t)v88 < 0) {
        // break -> 0x1b957
        goto lab_0x1b957_7;
    }
    // 0x1b458
    if ((int32_t)check_ts_section2(v17) == 0) {
        goto lab_0x1b8f9;
    } else {
        // 0x1b46c
        if ((int32_t)check_ts_section_crc2(v17) == 0) {
            // 0x1b49d
            reset_ts_section2(v17);
            goto lab_0x1b8f9;
        } else {
            // 0x1b47c
            if (*v24 == 0) {
                // 0x1b49d
                reset_ts_section2(v17);
                goto lab_0x1b8f9;
            } else {
                // 0x1b486
                if ((int32_t)compare_ts_section2(v18) != 0) {
                    // 0x1b4b2
                    swap_ts_section2(v18, v17);
                    reset_ts_section2(v17);
                    if (*v25 == 132) {
                        // 0x1b4e2
                        proc_emm2(v1);
                    }
                    goto lab_0x1b8f9;
                } else {
                    // 0x1b49d
                    reset_ts_section2(v17);
                    goto lab_0x1b8f9;
                }
            }
        }
    }
  lab_0x1b651:;
    int64_t v89 = set_ts_section_data2(v19, &v16, v29, v14); // 0x1b663
    v11 = v12;
    if ((int32_t)v89 < 0) {
        // break -> 0x1b957
        goto lab_0x1b957_7;
    }
    // 0x1b673
    if ((int32_t)check_ts_section2(v19) == 0) {
        goto lab_0x1b8f9;
    } else {
        // 0x1b687
        if ((int32_t)check_ts_section_crc2(v19) == 0) {
            // 0x1b6b8
            reset_ts_section2(v19);
            goto lab_0x1b8f9;
        } else {
            // 0x1b697
            if (*v26 == 0) {
                // 0x1b6b8
                reset_ts_section2(v19);
                goto lab_0x1b8f9;
            } else {
                // 0x1b6a1
                if ((int32_t)compare_ts_section2(v20) != 0) {
                    // 0x1b6cd
                    swap_ts_section2(v20, v19);
                    reset_ts_section2(v19);
                    v11 = v12;
                    if ((int32_t)proc_sdt2(v1, v19, v29) < 0) {
                        // break -> 0x1b957
                        goto lab_0x1b957_7;
                    }
                    goto lab_0x1b8f9;
                } else {
                    // 0x1b6b8
                    reset_ts_section2(v19);
                    goto lab_0x1b8f9;
                }
            }
        }
    }
  lab_0x1b794:;
    int64_t v90 = set_ts_section_data2(v21, &v16, v30, v14); // 0x1b7a3
    v11 = v12;
    if ((int32_t)v90 < 0) {
        // break -> 0x1b957
        goto lab_0x1b957_7;
    }
    // 0x1b7b3
    if ((int32_t)check_ts_section2(v21) == 0) {
        goto lab_0x1b8f9;
    } else {
        // 0x1b7c4
        if ((int32_t)check_ts_section_crc2(v21) == 0) {
            // 0x1b7ef
            reset_ts_section2(v21);
            goto lab_0x1b8f9;
        } else {
            // 0x1b7d1
            if (*v27 == 0) {
                // 0x1b7ef
                reset_ts_section2(v21);
                goto lab_0x1b8f9;
            } else {
                // 0x1b7db
                if ((int32_t)compare_ts_section2(v22) != 0) {
                    // 0x1b801
                    swap_ts_section2(v22, v21);
                    reset_ts_section2(v21);
                    v11 = v12;
                    if ((int32_t)proc_eit2(v1, v21, v30) < 0) {
                        // break -> 0x1b957
                        goto lab_0x1b957_7;
                    }
                    goto lab_0x1b8f9;
                } else {
                    // 0x1b7ef
                    reset_ts_section2(v21);
                    goto lab_0x1b8f9;
                }
            }
        }
    }
}

// From module:   /root/asv5220\aes_cipher.c
// Address range: 0x1b9a8 - 0x1b9d5
// Line range:    30 - 45
void Set_Key(char * EncSeed, int64_t skeyPackage, int64_t pTable) {
    // 0x1b9a8
    int64_t v1; // 0x1b9a8
    int64_t v2; // 0x1b9a8
    *(char *)skeyPackage = (char)(v2 ^ v1);
    int64_t v3; // 0x1b9a8
    int64_t v4 = v3;
    *(int32_t *)v4 = *(int32_t *)&v3 + (int32_t)v4;
    int64_t v5; // 0x1b9a8
    int64_t v6; // 0x1b9a8
    int64_t v7; // 0x1b9a8
    *(int64_t *)(v6 + 0x10638) = v7 * (int64_t)&g1 + v5;
}

// Address range: 0x1b9d8 - 0x1ba8c
int64_t Set_Key2(int64_t a1, int64_t * a2, int64_t a3) {
    // 0x1b9d8
    mcount();
    __readgsqword(40);
    int64_t v1; // bp-136, 0x1b9d8
    __asm_rep_stosq_memset((char *)&v1, 0, (int64_t)&g95);
    int64_t str = &v1; // 0x1ba1d
    int64_t v2 = a1; // 0x1ba1d
    int64_t v3; // 0x1b9d8
    int64_t v4; // 0x1b9d8
    sprintf(str, 0, (int64_t)*(char *)v2, 0, v4, v3);
    str += (int64_t)&g25;
    v2 += (int64_t)&g1;
    int64_t v5; // bp-104, 0x1b9d8
    while (str != (int64_t)&v5) {
        // 0x1ba24
        sprintf(str, 0, (int64_t)*(char *)v2, 0, v4, v3);
        str += (int64_t)&g25;
        v2 += (int64_t)&g1;
    }
    int64_t v6 = (int64_t)a2;
    makeKey2((int64_t *)(v6 + 756), 0, 128, &v1, a3);
    int64_t result = makeKey2((int64_t *)(v6 + (int64_t)&g7), (int64_t)&g1, 128, &v1, a3); // 0x1ba82
    return result;
}

// From module:   /root/asv5220\aes_cipher.c
// Address range: 0x1ba8c - 0x1babc
// Line range:    56 - 63
void DecryptBlock(char * cipherkey, char * input, char * output, int64_t pTable) {
    // 0x1ba8c
    int64_t v1; // 0x1ba8c
    cipherInit2(v1, (int64_t *)&g1, (int64_t)output);
    int64_t v2; // 0x1ba8c
    if (*(int64_t *)(v2 - 56) != __readgsqword(40)) {
        // 0x1baa8
        __stack_chk_fail();
    }
}

// Address range: 0x1babc - 0x1bb1d
int64_t DecryptBlock2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1babc
    mcount();
    __readgsqword(40);
    int64_t v1; // bp-1544, 0x1babc
    return Set_Key2(a1, &v1, a4);
}

// From module:   /root/asv5220\aes_cipher.c
// Address range: 0x1bb1e - 0x1bb4e
// Line range:    47 - 54
void EncryptBlock(char * cipherkey, char * input, char * output, int64_t pTable) {
    int64_t v1 = (int64_t)input;
    int64_t v2; // 0x1bb1e
    int64_t v3; // 0x1bb1e
    int64_t v4; // 0x1bb1e
    cipherUpdateRounds2(v4, v1, v1 & 0xffffffff, (int64_t *)pTable, v3, (int32_t)v2, (int64_t)&g107);
    int64_t v5; // 0x1bb1e
    if (*(int64_t *)(v5 - 40) != __readgsqword(40)) {
        // 0x1bb37
        __stack_chk_fail();
    }
}

// Address range: 0x1bb4e - 0x1bbb2
int64_t EncryptBlock2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1bb4e
    mcount();
    __readgsqword(40);
    int64_t v1; // bp-1544, 0x1bb4e
    return Set_Key2(a1, &v1, a4);
}

// From module:   /root/asv5220\des.c
// Address range: 0x1bbb4 - 0x1bbe3
// Line range:    290 - 357
void des_setkey(int64_t * SK, char * key, int64_t pTable) {
    // 0x1bbb4
    int64_t v1; // 0x1bbb4
    int64_t v2; // 0x1bbb4
    int64_t v3; // 0x1bbb4
    int64_t v4; // 0x1bbb4
    cipherUpdateRounds2(v3, (int64_t)key, pTable, (int64_t *)v4, v2, (int32_t)v1, (int64_t)&g107);
    int64_t v5; // 0x1bbb4
    if (*(int64_t *)(v5 - 40) != __readgsqword(40)) {
        // 0x1bbcc
        __stack_chk_fail();
    }
}

// Address range: 0x1bbe4 - 0x1c0db
int64_t des_setkey2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1bbe4
    mcount();
    unsigned char v1 = *(char *)(a2 + (int64_t)&g33); // 0x1bbee
    unsigned char v2 = *(char *)(a2 + (int64_t)&g1); // 0x1bbfc
    unsigned char v3 = *(char *)(a2 + (int64_t)&g25); // 0x1bc07
    uint64_t v4; // 0x1bbe4
    uint64_t v5 = v4 % 256 << (int64_t)&g13 | (int64_t)v1 | (int64_t)v2 << (int64_t)&g2 | (int64_t)v3 << (int64_t)&g95; // 0x1bc0f
    unsigned char v6 = *(char *)(a2 + (int64_t)&g86); // 0x1bc12
    unsigned char v7 = *(char *)(a2 + (int64_t)&g89); // 0x1bc1a
    unsigned char v8 = *(char *)(a2 + (int64_t)&g94); // 0x1bc25
    unsigned char v9 = *(char *)(a2 + (int64_t)&g91); // 0x1bc2c
    uint64_t v10 = (int64_t)v7 << (int64_t)&g2 | (int64_t)v6 << (int64_t)&g13 | (int64_t)v8 | (int64_t)v9 << (int64_t)&g95; // 0x1bc34
    int64_t v11 = (v10 >> (int64_t)&g86 ^ v5) & 0xf0f0f0f; // 0x1bc41
    uint64_t v12 = v11 ^ v5; // 0x1bc47
    uint64_t v13 = (16 * v11 ^ v10) & -0x10101011 | v5 & 0x10101010; // 0x1bc60
    int64_t v14 = a3 + 0x1000; // 0x1bc73
    int64_t v15 = *(int64_t *)((8 * v12 & 120) + v14); // 0x1bc73
    int64_t v16 = *(int64_t *)((v12 / 0x200000 & 120) + v14); // 0x1bc7f
    int64_t v17 = *(int64_t *)((v12 / 32 & 120) + v14); // 0x1bc91
    int64_t v18 = *(int64_t *)((v12 / 0x2000 & 120) + v14); // 0x1bcaa
    int64_t v19 = *(int64_t *)((v12 / 4 & 120) + v14); // 0x1bcc2
    int64_t v20 = *(int64_t *)((v12 / 1024 & 120) + v14); // 0x1bcdb
    int64_t v21 = *(int64_t *)((v12 / 0x40000 & 120) + v14); // 0x1bcf4
    int64_t v22 = *(int64_t *)(8 * v5 / 0x20000000 + v14); // 0x1bd07
    int64_t v23 = a3 + 0x1080; // 0x1bd1f
    int64_t v24 = *(int64_t *)((4 * v13 & 120) + v23); // 0x1bd1f
    int64_t v25 = *(int64_t *)((v13 / 64 & 120) + v23); // 0x1bd35
    int64_t v26 = *(int64_t *)((v13 / 0x400000 & 120) + v23); // 0x1bd4e
    int64_t v27 = *(int64_t *)((v13 / 0x4000 & 120) + v23); // 0x1bd60
    int64_t v28 = *(int64_t *)((v13 / 2 & 120) + v23); // 0x1bd78
    int64_t v29 = *(int64_t *)((v13 / 512 & 120) + v23); // 0x1bd91
    int64_t v30 = *(int64_t *)((v13 / 0x20000 & 120) + v23); // 0x1bdaa
    int64_t v31 = *(int64_t *)(8 * v13 / 0x10000000 + v23); // 0x1bdbd
    uint64_t v32 = (8 * v15 | v16 | 4 * v17 | 2 * v18 | 128 * v19 | 64 * v20 | 32 * v21 | 16 * v22) % 0x10000000; // 0x1bdcf
    uint64_t v33 = (4 * v25 | 8 * v24 | v26 | 2 * v27 | 128 * v28 | 64 * v29 | 32 * v30 | 16 * v31) % 0x10000000; // 0x1bdd5
    int64_t v34; // 0x1bbe4
    int64_t v35; // 0x1bbe4
    if ((int32_t)&g1 >= 0) {
        // 0x1bdee
        v34 = 2 * v32 & 0xffffffe | v32 / 0x8000000;
        v35 = 2 * v33 | v33 / 0x8000000;
    } else {
        // 0x1be15
        v34 = 4 * v32 & 0xffffffc | v32 / 0x4000000;
        v35 = 4 * v33 | v33 / 0x4000000;
    }
    uint64_t v36 = v35;
    uint64_t v37 = v34;
    uint64_t result = v36 % 0x10000000;
    *(int64_t *)a1 = 0x10000000 * v37 & 0x10000000 | 16 * v37 & 0x24000000 | v36 & 256 | 0x4000 * v37 & 0x8000000 | 0x40000 * v37 & 0x2080000 | 64 * v37 & 0x1000000 | 512 * v37 & 0x200000 | v37 / 2 & 0x100000 | 1024 * v37 & 0x40000 | 4 * v37 & 0x20000 | v37 / 1024 & 0x10000 | v36 / 0x2000 & 0x2000 | v36 / 16 & 0x1000 | v36 / 2 & 1024 | v36 / 0x4000 & 512 | v36 / 32 & 32 | v36 / 1024 & 16 | v36 / 8 & 8 | v36 / 0x40000 & 4 | v36 / 0x4000000 & 2 | v36 / 0x1000000 % 2 | 64 * result & 2048;
    return result;
}

// From module:   /root/asv5220\des.c
// Address range: 0x1c0e0 - 0x1c0f1
// Line range:    362 - 365
void des_setkey_enc(int64_t ctx, char * key, int64_t pTable) {
    // 0x1c0e0
    int64_t v1; // 0x1c0e0
    char v2 = v1;
    *(char *)v1 = 2 * v2;
    int64_t v3; // 0x1c0e0
    char * v4 = (char *)(v3 - 125); // 0x1c0e2
    *v4 = *v4 + v2;
}

// From module:   /root/asv5220\des.c
// Address range: 0x1c0f4 - 0x1c110
// Line range:    370 - 381
void des_setkey_dec(int64_t ctx, char * key, int64_t pTable) {
    // 0x1c0f4
    *(int64_t *)(ctx + (int64_t)&g95) = (int64_t)key;
}

// Address range: 0x1c110 - 0x1c124
int64_t des_setkey_enc2(int64_t a1) {
    // 0x1c110
    mcount();
    int64_t v1; // 0x1c110
    int64_t v2; // 0x1c110
    return des_setkey2(a1 + (int64_t)&g95, v1, v2);
}

// Address range: 0x1c124 - 0x1c152
int64_t des_setkey_dec2(int64_t a1) {
    // 0x1c124
    mcount();
    int64_t v1 = a1 + (int64_t)&g95; // 0x1c131
    int64_t v2; // 0x1c124
    int64_t v3; // 0x1c124
    des_setkey2(v1, v2, v3);
    *(int64_t *)v1 = *(int64_t *)(a1 + 248);
    return 0;
}

// From module:   /root/asv5220\des.c
// Address range: 0x1c153 - 0x1c183
// Line range:    395 - 441
void des_crypt_ecb(int64_t ctx, char * input, char * output, int64_t pTable) {
    // 0x1c153
    int64_t v1; // 0x1c153
    int64_t v2; // 0x1c153
    int64_t v3 = v2 + v1;
    *(int32_t *)(v3 + 248) = (int32_t)pTable;
    int64_t * v4 = (int64_t *)((int64_t)output + (int64_t)&g2); // 0x1c15a
    int64_t * v5 = (int64_t *)(v3 + 256); // 0x1c15e
    *v4 = *v5;
    *v5 = *v4;
}

// Address range: 0x1c183 - 0x1c4a9
int64_t des_crypt_ecb2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1c183
    mcount();
    unsigned char v1 = *(char *)(a2 + (int64_t)&g33); // 0x1c19b
    unsigned char v2 = *(char *)(a2 + (int64_t)&g25); // 0x1c19e
    uint64_t v3 = (int64_t)v2 << (int64_t)&g95; // 0x1c1a2
    unsigned char v4 = *(char *)(a2 + (int64_t)&g1); // 0x1c1a4
    uint64_t v5 = (int64_t)v4 << (int64_t)&g2; // 0x1c1a8
    int64_t v6 = v3 < 0xffffffff00010000 ? v3 : v3 + 0xffff0000;
    int64_t v7 = v5 < 0xffffffff01000000 ? v5 : v5 + 0xff000000;
    uint64_t v8; // 0x1c183
    uint64_t v9 = v8 % 256 << (int64_t)&g13 | (int64_t)v1 | v6 | v7; // 0x1c1c9
    unsigned char v10 = *(char *)(a2 + (int64_t)&g94); // 0x1c1d1
    unsigned char v11 = *(char *)(a2 + (int64_t)&g91); // 0x1c1d4
    uint64_t v12 = (int64_t)v11 << (int64_t)&g95; // 0x1c1dc
    unsigned char v13 = *(char *)(a2 + (int64_t)&g89); // 0x1c1de
    uint64_t v14 = (int64_t)v13 << (int64_t)&g2; // 0x1c1e3
    int64_t v15 = v12 < 0xffffffff00010000 ? v12 : v12 + 0xffff0000;
    unsigned char v16 = *(char *)(a2 + (int64_t)&g86); // 0x1c1f1
    int64_t v17 = v14 < 0xffffffff01000000 ? v14 : v14 + 0xff000000;
    int64_t v18 = v15 | (int64_t)v10 | v17 | (int64_t)v16 << (int64_t)&g13; // 0x1c1fc
    int64_t v19 = (v18 ^ v9 >> (int64_t)&g86) & 0xf0f0f0f; // 0x1c209
    int64_t v20 = v19 ^ v18; // 0x1c20f
    uint64_t v21 = 16 * v19 ^ v9; // 0x1c216
    uint64_t v22 = (v21 / 0x10000 ^ v20) % 0x10000; // 0x1c223
    uint64_t v23 = v22 ^ v20; // 0x1c229
    int64_t v24 = 0x10000 * v22 ^ v21; // 0x1c230
    int64_t v25 = (v23 / 4 ^ v24) & 0x33333333; // 0x1c23d
    int64_t v26 = v25 ^ v24; // 0x1c243
    uint64_t v27 = 4 * v25 ^ v23; // 0x1c24a
    int64_t v28 = (v27 / 256 ^ v26) & 0xff00ff; // 0x1c257
    int64_t v29 = v28 ^ v26; // 0x1c25d
    uint64_t v30 = v28 << (int64_t)&g95 ^ v27; // 0x1c264
    int64_t v31 = v30 >> (int64_t)&g24 | 2 * v30; // 0x1c271
    int64_t v32 = (v31 ^ v29) & 0xaaaaaaaa; // 0x1c27e
    uint64_t v33 = v32 ^ v29; // 0x1c287
    int64_t v34 = a4 + 3584; // 0x1c2c3
    int64_t v35 = a4 + 2560; // 0x1c2d6
    int64_t v36 = a4 + 1536; // 0x1c2e9
    int64_t v37 = a4 + 512; // 0x1c2f9
    int64_t v38 = a4 + 3072; // 0x1c308
    int64_t v39 = a4 + 2048; // 0x1c31b
    int64_t v40 = a4 + 1024; // 0x1c32e
    int64_t v41 = (v33 >> (int64_t)&g24 | 2 * v33) & 0xffffffff; // 0x1c29a
    int64_t v42 = 0; // 0x1c29a
    uint64_t v43 = v32 ^ v31 & 0xffffffff;
    int64_t v44 = v42 * (int64_t)&g1 + a1;
    uint64_t v45 = *(int64_t *)(v44 + (int64_t)&g95) ^ v43; // 0x1c2a2
    int64_t v46 = *(int64_t *)(v44 + 2 * (int64_t)&g95); // 0x1c2b7
    uint64_t v47 = (v43 << (int64_t)&g19 | v43 >> (int64_t)&g86) ^ v46; // 0x1c2b7
    int64_t v48 = *(int64_t *)((8 * v45 & 504) + v34); // 0x1c2c3
    int64_t v49 = *(int64_t *)((8 * (v45 >> (int64_t)&g95) & 504) + v35); // 0x1c2d6
    int64_t v50 = *(int64_t *)((8 * (v45 >> (int64_t)&g2) & 504) + v36); // 0x1c2e9
    int64_t v51 = *(int64_t *)((8 * (v45 >> (int64_t)&g13) & 504) + v37); // 0x1c2f9
    int64_t v52 = *(int64_t *)((8 * v47 & 504) + v38); // 0x1c308
    int64_t v53 = *(int64_t *)((8 * (v47 >> (int64_t)&g95) & 504) + v39); // 0x1c31b
    int64_t v54 = *(int64_t *)((8 * (v47 >> (int64_t)&g2) & 504) + v40); // 0x1c32e
    int64_t v55 = *(int64_t *)((v47 >> (int64_t)&g13) % 64 * (int64_t)&g95 + a4); // 0x1c33e
    v41 = v48 ^ v41 ^ v49 ^ v50 ^ v51 ^ v52 ^ v53 ^ v54 ^ v55;
    int64_t v56 = *(int64_t *)(v44 + (int64_t)&g95 + (int64_t)&g2); // 0x1c345
    uint64_t v57 = v56 ^ v41; // 0x1c345
    int64_t v58 = *(int64_t *)(v44 + (int64_t)&g95 + (int64_t)&g13); // 0x1c35b
    uint64_t v59 = (v41 << (int64_t)&g19 | v41 >> (int64_t)&g86) ^ v58; // 0x1c35b
    int64_t v60 = *(int64_t *)((8 * v57 & 504) + v34); // 0x1c367
    int64_t v61 = *(int64_t *)((8 * (v57 >> (int64_t)&g95) & 504) + v35); // 0x1c37a
    int64_t v62 = *(int64_t *)((8 * (v57 >> (int64_t)&g2) & 504) + v36); // 0x1c38d
    int64_t v63 = *(int64_t *)((8 * (v57 >> (int64_t)&g13) & 504) + v37); // 0x1c39d
    int64_t v64 = *(int64_t *)((8 * v59 & 504) + v38); // 0x1c3ac
    int64_t v65 = *(int64_t *)((8 * (v59 >> (int64_t)&g95) & 504) + v39); // 0x1c3bf
    int64_t v66 = *(int64_t *)((8 * (v59 >> (int64_t)&g2) & 504) + v40); // 0x1c3d2
    int64_t v67 = *(int64_t *)((v59 >> (int64_t)&g13) % 64 * (int64_t)&g95 + a4); // 0x1c3e2
    int64_t v68 = v60 ^ v43 ^ v61 ^ v62 ^ v63 ^ v64 ^ v65 ^ v66 ^ v67; // 0x1c3e2
    while (v42 != 256 - (int64_t)&g26) {
        // 0x1c29f
        v42 += (int64_t)&g26;
        v43 = v68;
        v44 = v42 * (int64_t)&g1 + a1;
        v45 = *(int64_t *)(v44 + (int64_t)&g95) ^ v43;
        v46 = *(int64_t *)(v44 + 2 * (int64_t)&g95);
        v47 = (v43 << (int64_t)&g19 | v43 >> (int64_t)&g86) ^ v46;
        v48 = *(int64_t *)((8 * v45 & 504) + v34);
        v49 = *(int64_t *)((8 * (v45 >> (int64_t)&g95) & 504) + v35);
        v50 = *(int64_t *)((8 * (v45 >> (int64_t)&g2) & 504) + v36);
        v51 = *(int64_t *)((8 * (v45 >> (int64_t)&g13) & 504) + v37);
        v52 = *(int64_t *)((8 * v47 & 504) + v38);
        v53 = *(int64_t *)((8 * (v47 >> (int64_t)&g95) & 504) + v39);
        v54 = *(int64_t *)((8 * (v47 >> (int64_t)&g2) & 504) + v40);
        v55 = *(int64_t *)((v47 >> (int64_t)&g13) % 64 * (int64_t)&g95 + a4);
        v41 = v48 ^ v41 ^ v49 ^ v50 ^ v51 ^ v52 ^ v53 ^ v54 ^ v55;
        v56 = *(int64_t *)(v44 + (int64_t)&g95 + (int64_t)&g2);
        v57 = v56 ^ v41;
        v58 = *(int64_t *)(v44 + (int64_t)&g95 + (int64_t)&g13);
        v59 = (v41 << (int64_t)&g19 | v41 >> (int64_t)&g86) ^ v58;
        v60 = *(int64_t *)((8 * v57 & 504) + v34);
        v61 = *(int64_t *)((8 * (v57 >> (int64_t)&g95) & 504) + v35);
        v62 = *(int64_t *)((8 * (v57 >> (int64_t)&g2) & 504) + v36);
        v63 = *(int64_t *)((8 * (v57 >> (int64_t)&g13) & 504) + v37);
        v64 = *(int64_t *)((8 * v59 & 504) + v38);
        v65 = *(int64_t *)((8 * (v59 >> (int64_t)&g95) & 504) + v39);
        v66 = *(int64_t *)((8 * (v59 >> (int64_t)&g2) & 504) + v40);
        v67 = *(int64_t *)((v59 >> (int64_t)&g13) % 64 * (int64_t)&g95 + a4);
        v68 = v60 ^ v43 ^ v61 ^ v62 ^ v63 ^ v64 ^ v65 ^ v66 ^ v67;
    }
    int64_t v69 = v68 >> (int64_t)&g1 | v68 << (int64_t)&g24; // 0x1c400
    int64_t v70 = (v69 ^ v41) & 0xaaaaaaaa; // 0x1c40c
    int64_t v71 = v70 ^ v69 & 0xffffffff; // 0x1c411
    uint64_t v72 = v70 ^ v41; // 0x1c414
    uint64_t v73 = (v72 << (int64_t)&g24 | v72 >> (int64_t)&g1) & 0xffffffff; // 0x1c427
    int64_t v74 = (v73 >> (int64_t)&g95 ^ v71) & 0xff00ff; // 0x1c434
    int64_t v75 = v74 ^ v71; // 0x1c43a
    uint64_t v76 = 256 * v74 ^ v73; // 0x1c441
    int64_t v77 = (v76 / 4 ^ v75) & 0x33333333; // 0x1c44e
    uint64_t v78 = v77 ^ v75; // 0x1c453
    uint64_t v79 = 4 * v77 ^ v76; // 0x1c45a
    int64_t v80 = v79 % 0x10000 ^ v78 / 0x10000; // 0x1c467
    uint64_t v81 = 0x10000 * v80 ^ v78; // 0x1c474
    int64_t result = (v80 ^ v79 ^ v81 / 16) & 0xf0f0f0f; // 0x1c481
    uint64_t v82 = 16 * result ^ v81; // 0x1c48d
    *(char *)(a3 + (int64_t)&g33) = (char)v82;
    *(char *)(a3 + (int64_t)&g25) = (char)(v82 / 256);
    *(char *)(a3 + (int64_t)&g1) = (char)(v82 / 0x10000);
    return result;
}

// From module:   /root/asv5220\des.c
// Address range: 0x1c4ab - 0x1c4b0
// Line range:    443 - 496
void des_crypt_ecb_Multi(int64_t ctx, char * input, char * output, int64_t pTable, int32_t BlockNum) {
    // 0x1c4ab
    function_c8a05c8();
}

// Address range: 0x1c4b0 - 0x1c4db
int64_t function_1c4b0(int64_t a1, int64_t a2) {
    // 0x1c4b0
    int64_t v1; // 0x1c4b0
    int64_t v2; // 0x1c4b0
    uint64_t v3 = v2 & 0xffffff48 ^ v1 & 0xffffffff; // 0x1c4b2
    int64_t v4; // 0x1c4b0
    *(char *)(v4 + (int64_t)&g94) = (char)v3;
    *(char *)(v4 + (int64_t)&g91) = (char)(v3 / 256);
    *(char *)(v4 + (int64_t)&g89) = (char)(v3 / 0x10000);
    uint64_t result = v3 / 0x1000000; // 0x1c4cd
    *(char *)(v4 + (int64_t)&g86) = (char)result;
    return result;
}

// Address range: 0x1c4db - 0x1c50b
int64_t des_crypt_ecb_Multi2(int64_t a1, int64_t * a2, int64_t a3, int64_t a4, int64_t * a5) {
    // 0x1c4db
    return mcount();
}

// Address range: 0x1c5b5 - 0x1c5b9
int64_t function_1c5b5(int64_t a1) {
    // 0x1c5b5
    int64_t result; // 0x1c5b5
    int32_t * v1 = (int32_t *)(result + (int64_t)&g28); // 0x1c5b5
    *v1 = *v1 - (int32_t)&g1;
    return result;
}

// Address range: 0x1c5d3 - 0x1c5d7
int64_t function_1c5d3(int64_t a1, int64_t a2) {
    // 0x1c5d3
    int64_t result; // 0x1c5d3
    return result;
}

// Address range: 0x1c612 - 0x1c613
int64_t function_1c612(void) {
    // 0x1c612
    int64_t result; // 0x1c612
    return result;
}

// Address range: 0x1c643 - 0x1c644
int64_t function_1c643(void) {
    // 0x1c643
    int64_t result; // 0x1c643
    return result;
}

// Address range: 0x1c64c - 0x1c653
int64_t function_1c64c(void) {
    // 0x1c64c
    int64_t result; // 0x1c64c
    float80_t v1; // 0x1c64c
    *(int16_t *)(result + 49) = (int16_t)v1;
    return result;
}

// Address range: 0x1c655 - 0x1c8ab
int64_t function_1c655(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1c655
    int64_t v1; // 0x1c655
    if (v1 != 256 - (int64_t)&g26) {
        // 0x1c66b
        return v1 + (int64_t)&g26;
    }
    int64_t v2 = (uint32_t)((uint32_t)(int32_t)a1 >> (uint32_t)(int32_t)&g86); // 0x1c676
    int64_t v3 = v1 * (int64_t)&g1 + a6;
    int64_t v4 = *(int64_t *)(v3 + (int64_t)&g95); // 0x1c683
    int64_t v5; // 0x1c655
    uint64_t v6 = v4 ^ (v5 | v2 << (int64_t)&g19); // 0x1c683
    int64_t v7 = a4 + 3584; // 0x1c68f
    uint64_t v8; // 0x1c655
    int64_t v9 = *(int64_t *)((8 * v8 & 504) + v7); // 0x1c68f
    int64_t v10 = a4 + 2560; // 0x1c6a2
    int64_t v11 = *(int64_t *)((8 * (v8 >> (int64_t)&g95) & 504) + v10); // 0x1c6a2
    int64_t v12 = a4 + 1536; // 0x1c6b5
    int64_t v13 = *(int64_t *)((8 * (v8 >> (int64_t)&g2) & 504) + v12); // 0x1c6b5
    int64_t v14 = a4 + 512; // 0x1c6c5
    int64_t v15 = *(int64_t *)((8 * (v8 >> (int64_t)&g13) & 504) + v14); // 0x1c6c5
    int64_t v16 = a4 + 3072; // 0x1c6d4
    int64_t v17 = *(int64_t *)((8 * v6 & 504) + v16); // 0x1c6d4
    int64_t v18 = a4 + 2048; // 0x1c6e7
    int64_t v19 = *(int64_t *)((8 * (v6 >> (int64_t)&g95) & 504) + v18); // 0x1c6e7
    int64_t v20 = a4 + 1024; // 0x1c6fa
    int64_t v21 = *(int64_t *)((8 * (v6 >> (int64_t)&g2) & 504) + v20); // 0x1c6fa
    int64_t v22 = *(int64_t *)((v6 >> (int64_t)&g13) % 64 * (int64_t)&g95 + a4); // 0x1c70a
    int64_t v23; // 0x1c655
    uint64_t v24 = v9 ^ v23 ^ v11 ^ v13 ^ v15 ^ v17 ^ v19 ^ v21 ^ v22; // 0x1c70a
    uint64_t v25 = v24 ^ *(int64_t *)(v3 + (int64_t)&g2); // 0x1c711
    int64_t v26 = *(int64_t *)(v3 + (int64_t)&g13); // 0x1c727
    uint64_t v27 = (v24 << (int64_t)&g19 | v24 >> (int64_t)&g86) ^ v26; // 0x1c727
    int64_t v28 = *(int64_t *)((8 * v25 & 504) + v7); // 0x1c733
    int64_t v29 = *(int64_t *)((8 * (v25 >> (int64_t)&g95) & 504) + v10); // 0x1c746
    int64_t v30 = *(int64_t *)((8 * (v25 >> (int64_t)&g2) & 504) + v12); // 0x1c759
    int64_t v31 = *(int64_t *)((8 * (v25 >> (int64_t)&g13) & 504) + v14); // 0x1c769
    int64_t v32 = *(int64_t *)((8 * v27 & 504) + v16); // 0x1c778
    int64_t v33 = *(int64_t *)((8 * (v27 >> (int64_t)&g95) & 504) + v18); // 0x1c78b
    int64_t v34 = *(int64_t *)((8 * (v27 >> (int64_t)&g2) & 504) + v20); // 0x1c79e
    int64_t v35 = *(int64_t *)((v27 >> (int64_t)&g13) % 64 * (int64_t)&g95 + a4); // 0x1c7ae
    uint64_t v36 = v28 ^ v2 ^ v29 ^ v30 ^ v31 ^ v32 ^ v33 ^ v34 ^ v35; // 0x1c7ae
    int64_t v37 = v36 << (int64_t)&g24 | v36 >> (int64_t)&g1; // 0x1c7cf
    int64_t v38 = (v37 ^ v24) & 0xaaaaaaaa; // 0x1c7db
    int64_t v39 = v38 ^ v37 & 0xffffffff; // 0x1c7e2
    uint64_t v40 = v38 ^ v24; // 0x1c7e5
    uint64_t v41 = (v40 << (int64_t)&g24 | v40 >> (int64_t)&g1) & 0xffffffff; // 0x1c7f8
    int64_t v42 = (v41 >> (int64_t)&g95 ^ v39) & 0xff00ff; // 0x1c806
    int64_t v43 = v42 ^ v39; // 0x1c80e
    uint64_t v44 = 256 * v42 ^ v41; // 0x1c815
    int64_t v45 = (v44 / 4 ^ v43) & 0x33333333; // 0x1c822
    uint64_t v46 = v45 ^ v43; // 0x1c828
    uint64_t v47 = 4 * v45 ^ v44; // 0x1c82f
    int64_t v48 = v47 % 0x10000 ^ v46 / 0x10000; // 0x1c83c
    int64_t v49 = v48 ^ v47; // 0x1c843
    uint64_t v50 = 0x10000 * v48 ^ v46; // 0x1c84a
    int64_t v51 = (v50 / 16 ^ v49) & 0xf0f0f0f; // 0x1c857
    uint64_t v52 = 16 * v51 ^ v50; // 0x1c864
    int64_t v53; // 0x1c655
    int64_t v54 = *(int64_t *)(v53 - 80); // 0x1c867
    *(char *)(v54 * (int64_t)&g1 + a3) = (char)v52;
    int64_t v55; // 0x1c655
    *(char *)(v55 * (int64_t)&g1 + a3) = (char)(v52 / 256);
    int64_t v56 = *(int64_t *)(v53 - 72); // 0x1c87c
    *(char *)(v56 * (int64_t)&g1 + a3) = (char)(v52 / 0x10000);
    int64_t v57; // 0x1c655
    *(char *)(v57 * (int64_t)&g1 + a3) = (char)(v52 / 0x1000000);
    uint64_t result = v51 ^ v49; // 0x1c88f
    int64_t v58 = *(int64_t *)(v53 - 64); // 0x1c892
    *(char *)(v58 * (int64_t)&g1 + a3) = (char)result;
    int64_t v59; // 0x1c655
    *(char *)(v59 * (int64_t)&g1 + a3) = (char)(result / 256);
    return result;
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1c8ac - 0x1c8ba
// Line range:    365 - 368
int64_t Tnim_PollingThreadDelayTime(void) {
    // 0x1c8ac
    uint64_t v1; // 0x1c8ac
    int64_t v2; // 0x1c8ac
    int64_t v3; // 0x1c8ac
    *(char *)(v3 * (int64_t)&g1 + v2) = (char)(v1 >> (uint64_t)(int64_t)&g95);
    int64_t result; // 0x1c8ac
    return result;
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1c8bc - 0x1c8cc
// Line range:    351 - 359
char Tnim_PollingThreadOnlyCallOnce(char * DevExt, char * StartPolling, char Total_Tuner_Num, char * tuner_globe_data) {
    // 0x1c8bc
    int64_t result; // 0x1c8bc
    return result;
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1c8cf - 0x1c8db
// Line range:    341 - 349
char Tnim_PollingThread(char * DevExt, char Tuner_Num) {
    // 0x1c8cf
    int64_t v1; // 0x1c8cf
    char * v2 = (char *)(v1 + 65); // 0x1c8cf
    *v2 = *v2 ^ (char)v1;
    int64_t result; // 0x1c8cf
    return result;
}

// Address range: 0x1c8dc - 0x1c8ec
int64_t Tnim_PollingThreadDelayTime2(void) {
    // 0x1c8dc
    mcount();
    int64_t v1; // 0x1c8dc
    int64_t v2; // 0x1c8dc
    int64_t v3; // 0x1c8dc
    int64_t v4; // 0x1c8dc
    TC_PowerTunerDemod((char *)v1, (char)v2, (char)v3, (char *)v4);
    return &g107;
}

// Address range: 0x1c8ec - 0x1c8f5
int64_t Tnim_PollingThreadOnlyCallOnce2(int64_t a1, int64_t a2, int64_t * a3, int64_t a4) {
    // 0x1c8ec
    return mcount();
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1c8f7 - 0x1c8ff
// Line range:    328 - 335
char Tnim_IsLocked(int64_t psTnim) {
    // 0x1c8f7
    int64_t result; // 0x1c8f7
    return result;
}

// Address range: 0x1c8ff - 0x1c927
int64_t Tnim_PollingThread2(int64_t a1, uint64_t a2) {
    // 0x1c8ff
    mcount();
    int64_t v1; // 0x1c8ff
    char result = TC_CurrentTSIDRead((char *)a1, (char)a2, (int32_t *)(a1 + 0x5960 + a2 % 256 * ((int64_t)&g86 + 1 << (uint64_t)(int64_t)&g86)), (char *)v1); // 0x1c920
    return result;
}

// Address range: 0x1c927 - 0x1c930
int64_t Tnim_IsLocked2(void) {
    // 0x1c927
    return mcount();
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1c930 - 0x1c960
// Line range:    313 - 320
char Tnim_ReadSNRx8(int64_t psTnim) {
    int64_t v1 = *(int64_t *)(psTnim + 0x1d38); // 0x1c933
    int64_t v2 = (int64_t)*(char *)(psTnim + 0x1d30); // 0x1c941
    return TC_IsLocked2(v1, v2, v1 + 0x5960 + 80 * v2);
}

// Address range: 0x1c960 - 0x1c969
int64_t Tnim_ReadSNRx8_(void) {
    // 0x1c960
    return mcount();
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1c969 - 0x1c999
// Line range:    299 - 306
char Tnim_AcqInit(int64_t psTnim) {
    int64_t v1 = *(int64_t *)(psTnim + 0x1d38); // 0x1c96c
    int64_t v2 = (int64_t)*(char *)(psTnim + 0x1d30); // 0x1c97a
    return TC_ReadSNR2(v1, v2, v1 + 0x5960 + 80 * v2);
}

// Address range: 0x1c999 - 0x1c9a2
int64_t Tnim_AcqInit2(int64_t a1) {
    // 0x1c999
    return mcount();
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1c9a2 - 0x1c9d2
// Line range:    271 - 292
char Tnim_AcquireFrequency(int64_t psTnim, int64_t dwFreqkHz, char ucBW) {
    // 0x1c9a2
    return TC_PollingThreadDelayTime();
}

// Address range: 0x1c9d2 - 0x1ca20
int64_t Tnim_AcquireFrequency2(int64_t a1, int64_t result, int64_t a3) {
    // 0x1c9d2
    mcount();
    return result;
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1ca24 - 0x1ca54
// Line range:    218 - 265
char Tnim_Initialise(int64_t pTuner) {
    // 0x1ca24
    int64_t v1; // 0x1ca24
    *(char *)v1 = (char)v1;
    int64_t v2; // 0x1ca24
    int64_t v3 = (int64_t)*(char *)(v2 + 0x1d30); // 0x1ca2f
    uint64_t v4; // 0x1ca24
    return TC_SetFrequency2(pTuner, v3, v1, v4 % 256, pTuner + 0x5960 + 80 * v3);
}

// Address range: 0x1ca54 - 0x1cad1
int64_t Tnim_Initialise2(int64_t a1) {
    // 0x1ca54
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 0x1d38); // 0x1ca67
    char * v2 = (char *)(a1 + 0x1d30); // 0x1ca6e
    char v3 = (char)(*v2 == 0) - (char)&g105; // bp-25, 0x1ca7a
    int64_t v4 = (int64_t)*v2; // 0x1ca84
    int64_t result = TC_Initialise2(v1, v4, &v3, v1 + 0x5960 + 80 * v4); // 0x1caa3
    *(char *)a1 = v3 & (char)&g1;
    *(char *)(a1 + 0x15e9) = (char)((v3 & (char)&g25) != 0);
    *(char *)(a1 + 0x15ea) = (char)((v3 & (char)&g95) != 0);
    return result;
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1cad2 - 0x1cb02
// Line range:    203 - 213
int64_t Tnim_SignalLevel(int64_t psTnim) {
    // 0x1cad2
    int64_t v1; // 0x1cad2
    *(char *)(v1 + (int64_t)&g49) = (char)&g1;
    if (*(char *)(v1 + 0x15eb) == 22) {
        // 0x1cae2
        *(char *)(v1 + 0x8f475) = (char)&g1;
    }
    // 0x1caf9
    int64_t result; // 0x1cad2
    return result;
}

// Address range: 0x1cb02 - 0x1cb0b
int64_t Tnim_SignalLevel2(int64_t a1) {
    // 0x1cb02
    return mcount();
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1cb0b - 0x1cb24
// Line range:    175 - 180
char TLIB_GetGPIOEx(char * DevExt) {
    // 0x1cb0b
    return 5 * *(char *)((int64_t)DevExt + 0x1d30);
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1cb27 - 0x1cb3b
// Line range:    170 - 173
void TLIB_SetGPIOEx(char * DevExt, unsigned char Data, char MaskData) {
    int64_t v1 = (int64_t)DevExt;
    int64_t v2; // 0x1cb27
    TC_GetSignaLevel2(v1, (int64_t)Data, v1 + 0x5960 + ((v2 + 72) % 256 | v2 & 0xffffff00) & 0xffffffff);
}

// Address range: 0x1cb3b - 0x1cb3c
int64_t TLIB_GetGPIOEx2(void) {
    // 0x1cb3b
    int64_t result; // 0x1cb3b
    return result;
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1cb3e - 0x1cb57
// Line range:    163 - 168
char TLIB_GetGPIO(char * DevExt) {
    // 0x1cb3e
    __asm_in_624(72);
    mcount();
    int64_t v1; // 0x1cb3e
    int64_t v2 = v1 - 1; // 0x1cb48
    FUSBDTV_Cmd_Get_GPIO_Ex2((int64_t)DevExt, v2);
    return *(char *)v2;
}

// Address range: 0x1cb57 - 0x1cb58
int64_t TLIB_SetGPIOEx2(int64_t a1, int64_t * a2, int64_t * a3) {
    // 0x1cb57
    int64_t result; // 0x1cb57
    return result;
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1cb5a - 0x1cb6e
// Line range:    158 - 161
void TLIB_SetGPIO(char * DevExt, unsigned char Data, char MaskData) {
    int64_t v1 = MaskData;
    int64_t v2; // 0x1cb5a
    *(char *)v1 = (char)__asm_in_624(232) & (char)v2;
    int64_t v3; // 0x1cb5a
    int64_t v4; // 0x1cb5a
    *DevExt = *(char *)&v3 + (char)v4;
    FUSBDTV_Cmd_Set_GPIO_Ex2((int64_t)DevExt, (int64_t)Data, (int64_t *)(v1 & -0xff01 | 0xd200));
}

// Address range: 0x1cb6e - 0x1cb6f
int64_t TLIB_GetGPIO2(void) {
    // 0x1cb6e
    int64_t result; // 0x1cb6e
    return result;
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1cb71 - 0x1cb7f
// Line range:    48 - 52
void TLIB_Delay(int64_t ms) {
    // 0x1cb71
    __asm_in_624(72);
    mcount();
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1cb81 - 0x1cb82
// Line range:    127 - 147
char TLIB_I2C_WriteAndRead(char * DevExt, char slave_addr, char * Write_buffer, char Write_size, char * Read_buffer, char Read_size, char mode) {
    // 0x1cb81
    return (int64_t)Write_buffer;
}

// Address range: 0x1cb83 - 0x1cb8a
int64_t function_1cb83(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1cb83
    int64_t v1; // 0x1cb83
    *(int32_t *)a1 = (int32_t)v1 - (int32_t)&g1;
    int64_t result; // 0x1cb83
    return result;
}

// Address range: 0x1cb8a - 0x1cba1
int64_t TLIB_SetGPIO2(int64_t a1, int64_t * a2, int64_t * a3) {
    // 0x1cb8a
    mcount();
    return FUSBDTV_Cmd_Set_GPIO2(a1, a2, (uint64_t)(int64_t)a3 % 256);
}

// Address range: 0x1cba1 - 0x1cbb1
int64_t TLIB_Delay2(int64_t * a1) {
    // 0x1cba1
    mcount();
    return vUSB_Wait2((int64_t)a1);
}

// Address range: 0x1cbb1 - 0x1cc2d
int64_t TLIB_I2C_WriteAndRead2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, char a7) {
    // 0x1cbb1
    mcount();
    int64_t v1 = a1 + 320; // 0x1cbe1
    down(v1, a2);
    *(int64_t *)(a1 + 0x5678) = (int64_t)&g1;
    return up(v1);
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1cc30 - 0x1cc60
// Line range:    95 - 115
char TLIB_I2C_Read(char * DevExt, char I2C_Addr, char byReg, char * pBuffer, char byCount, char I2C_Mode) {
    // 0x1cc30
    int64_t result; // 0x1cc30
    return result;
}

// Address range: 0x1cc32 - 0x1cc4c
int64_t function_1cc32(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x1cc32
    int64_t v1; // 0x1cc32
    *(int64_t *)(v1 + 0x5678) = 0;
    int64_t result; // 0x1cc32
    return result;
}

// Address range: 0x1cc60 - 0x1ccce
int64_t TLIB_I2C_Read2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4, int64_t * a5, int64_t a6) {
    // 0x1cc60
    mcount();
    int64_t v1 = a1 + 320; // 0x1cc8a
    down(v1, a2);
    *(int64_t *)(a1 + 0x5678) = (int64_t)&g1;
    return up(v1);
}

// From module:   /root/asv5220\Tunerlib.c
// Address range: 0x1ccd1 - 0x1cd01
// Line range:    54 - 92
char TLIB_I2C_Write(char * DevExt, char I2C_Addr, char byReg, char * pBuffer, char byCount, char I2C_Mode) {
    // 0x1ccd1
    int64_t result; // 0x1ccd1
    return result;
}

// Address range: 0x1ccd3 - 0x1cced
int64_t function_1ccd3(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x1ccd3
    int64_t v1; // 0x1ccd3
    *(int64_t *)(v1 + 0x5678) = 0;
    int64_t result; // 0x1ccd3
    return result;
}

// Address range: 0x1cd01 - 0x1cd9a
int64_t TLIB_I2C_Write2(int64_t a1, uint64_t a2, uint64_t a3, int64_t a4, uint64_t a5, uint64_t a6) {
    // 0x1cd01
    mcount();
    int64_t v1 = a1 + 320; // 0x1cd2b
    down(v1, a2);
    int64_t * v2 = (int64_t *)(a1 + 0x5678); // 0x1cd3a
    if (*v2 != 0) {
        up(v1);
        vUSB_Wait2((int64_t)&g1);
        down(v1, a2);
        while (*v2 != 0) {
            // 0x1cd5f
            up(v1);
            vUSB_Wait2((int64_t)&g1);
            down(v1, a2);
        }
    }
    // 0x1cd44
    *v2 = (int64_t)&g1;
    int64_t result = up(v1); // 0x1cd52
    if ((char)a6 > (char)&g1) {
        // 0x1cd92
        return result;
    }
    // 0x1cd73
    return USB_I2C_Write2(a1, a2 % 256, a3 % 256, a4, a5 % 256, (int64_t *)(a6 % 256));
}

// From module:   /root/asv5220\smiInterrupt.c
// Address range: 0x1cd9c - 0x1cdc9
// Line range:    504 - 534
char smi_clear_interrupt(int64_t pFdoData) {
    // 0x1cd9c
    int64_t v1; // 0x1cd9c
    unsigned char v2 = *(char *)(v1 - 57); // 0x1cd9e
    int64_t v3 = *(int64_t *)(v1 - 56); // 0x1cda3
    int64_t v4; // 0x1cd9c
    int64_t v5; // 0x1cd9c
    int64_t v6; // 0x1cd9c
    int64_t v7; // 0x1cd9c
    int64_t result = USB_I2C_Write2(v6, v5, v7 & -0xff01 | 0xcd00, v3, (int64_t)v2, (int64_t *)v4); // 0x1cdaa
    *(int64_t *)(v6 + 0x5678) = 0;
    return result;
}

// Address range: 0x1cdcc - 0x1cde4
int64_t smi_clear_interrupt2(int64_t a1) {
    // 0x1cdcc
    mcount();
    return (int64_t)*(int32_t *)(*(int64_t *)(a1 + 0x57f8) + 2056);
}

// From module:   /root/asv5220\smiInterrupt.c
// Address range: 0x1cdea - 0x1cdf0
// Line range:    537 - 568
char smi_disable_interrupt(int64_t pFdoData, int64_t interrupt) {
    // 0x1cdea
    int64_t result; // 0x1cdea
    char * v1 = (char *)(result - 127); // 0x1cdea
    int64_t v2; // 0x1cdea
    *v1 = *v1 + (char)v2;
    return result;
}

// Address range: 0x1ce09 - 0x1ce0f
int64_t function_1ce09(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1ce09
    int64_t result; // 0x1ce09
    char * v1 = (char *)(result - 127); // 0x1ce09
    *v1 = *v1 + (char)a4;
    return result;
}

// From module:   /root/asv5220\smiInterrupt.c
// Address range: 0x1ce18 - 0x1ce1a
// Line range:    570 - 600
char smi_enable_interrupt(int64_t pFdoData, int64_t interrupt) {
    // 0x1ce18
    int64_t result; // 0x1ce18
    return result;
}

// Address range: 0x1ce1a - 0x1ce48
int64_t smi_disable_interrupt2(int64_t a1, int64_t a2) {
    // 0x1ce1a
    mcount();
    int64_t * v1 = (int64_t *)(a1 + 0x57f8); // 0x1ce23
    *(int32_t *)(*v1 + 2072) = (int32_t)a2;
    int32_t v2 = *(int32_t *)(*v1 + 2068); // 0x1ce3f
    return (int64_t)(v2 & -256) | (int64_t)(v2 == 0);
}

// Address range: 0x1ce48 - 0x1ce49
int64_t smi_enable_interrupt2(void) {
    // 0x1ce48
    int64_t result; // 0x1ce48
    return result;
}

// From module:   /root/asv5220\smiInterrupt.c
// Address range: 0x1ce4a - 0x1ce7a
// Line range:    814 - 863
char smi_cancel_dma_A(int64_t pFdoData) {
    // 0x1ce4a
    mcount();
    int64_t * v1 = (int64_t *)(pFdoData + 0x57f8); // 0x1ce51
    int64_t v2; // 0x1ce4a
    *(int32_t *)(*v1 + 2076) = (int32_t)v2;
    return v2 == (int64_t)*(int32_t *)(*v1 + 2068);
}

// Address range: 0x1ce7a - 0x1ce98
int64_t smi_cancel_dma_A2(int64_t a1) {
    // 0x1ce7a
    mcount();
    uint32_t result = *(int32_t *)(*(int64_t *)(a1 + 0x62b8) + *(int64_t *)(a1 + 0x57f8)); // 0x1ce91
    return result;
}

// From module:   /root/asv5220\smiInterrupt.c
// Address range: 0x1ce9a - 0x1ce9d
// Line range:    871 - 921
char smi_cancel_dma_B(int64_t pFdoData) {
    // 0x1ce9a
    int64_t v1; // 0x1ce9a
    int64_t v2; // 0x1ce9a
    bool v3; // 0x1ce9a
    return v3 ? v1 : v2;
}

// Address range: 0x1ce9e - 0x1ceca
int64_t function_1ce9e(int64_t a1) {
    // 0x1ce9e
    int64_t v1; // 0x1ce9e
    char v2 = *(char *)(v1 + 0x137501fa); // 0x1ce9e
    int64_t v3 = *(int64_t *)(a1 + 0x57f8); // 0x1cea7
    int64_t v4 = *(int64_t *)(a1 + 0x62b8); // 0x1ceae
    *(int32_t *)(v4 + v3) = (int32_t)(v1 & 0xffffff00 | (int64_t)(v2 + (char)v1)) & -3;
    smi_disable_interrupt2(a1, (int64_t)*(char *)(a1 + 0x58ec));
    return &g1;
}

// Address range: 0x1ceca - 0x1ceef
int64_t smi_cancel_dma_B2(int64_t a1) {
    // 0x1ceca
    mcount();
    uint32_t result = *(int32_t *)(*(int64_t *)(a1 + 0x6300) + *(int64_t *)(a1 + 0x57f8)); // 0x1cee1
    return result;
}

// From module:   /root/asv5220\smiInterrupt.c
// Address range: 0x1cef0 - 0x1cf20
// Line range:    924 - 1088
void smi_portA_dpc(char * pDpc, char * deferredContext, char * systemArgument1, char * systemArgument2) {
    int64_t v1 = (int64_t)pDpc;
    int64_t v2; // 0x1cef0
    int32_t * v3 = (int32_t *)(v2 + (int64_t)&g5); // 0x1cef1
    *v3 = *v3 + (int32_t)(int64_t)deferredContext;
    int64_t v4 = *(int64_t *)(v1 + 0x6300); // 0x1cefe
    int64_t v5; // 0x1cef0
    *(int32_t *)(v4 + *(int64_t *)(v1 + 0x57f8)) = (int32_t)v5 & -3;
    smi_disable_interrupt2(v1, 4 * (int64_t)*(char *)(v1 + 0x58ed));
}

// Address range: 0x1cf20 - 0x1d007
int64_t smi_portA_dpc2(int64_t a1, int64_t a2) {
    // 0x1cf20
    mcount();
    uint64_t v1 = *(int64_t *)(a2 + 0x5900); // 0x1cf29
    if (v1 % 2 != 0) {
        if ((char)&g1 == 0) {
            // 0x1cfe7
            return *(int64_t *)(a2 + 0x57f8);
        }
    } else {
        if (((char)(v1 >> (int64_t)&g1) & (char)&g1) == (char)&g1) {
            // 0x1cfe7
            return *(int64_t *)(a2 + 0x57f8);
        }
    }
    int64_t v2 = *(int64_t *)(a2 + 0x57f8); // 0x1cf43
    if ((*(int32_t *)(*(int64_t *)(a2 + 0x62b8) + v2) & 48) != 16 || *(char *)(a2 + 0x58ec) % 2 == 0) {
        // 0x1cfe7
        return *(int64_t *)(a2 + 0x57f8);
    }
    // 0x1cf75
    if (*(int32_t *)(*(int64_t *)(a2 + 0x6288) + v2) % 0x400000 != 0xe520) {
        // 0x1cf96
        *(char *)(a2 + 0x5959) = (char)&g1;
    }
    // 0x1cfe7
    return *(int64_t *)(a2 + 0x57f8);
}

// From module:   /root/asv5220\smiInterrupt.c
// Address range: 0x1d007 - 0x1d037
// Line range:    1091 - 1595
void smi_portB_dpc(char * pDpc, char * deferredContext, char * systemArgument1, char * systemArgument2) {
    int64_t v1 = *(int64_t *)((int64_t)deferredContext + 0x62b8); // 0x1d007
    int64_t v2; // 0x1d007
    *(int32_t *)(v1 + v2) = (int32_t)(int64_t)systemArgument1;
}

// Address range: 0x1d037 - 0x1d11f
int64_t smi_portB_dpc2(int64_t a1, int64_t a2) {
    // 0x1d037
    mcount();
    uint64_t v1 = *(int64_t *)(a2 + 0x5900); // 0x1d040
    if ((v1 & 4) != 0) {
        if ((char)&g1 == 0) {
            // 0x1d0ff
            return *(int64_t *)(a2 + 0x57f8);
        }
    } else {
        if (((char)(v1 >> (int64_t)&g33) & (char)&g1) == (char)&g1) {
            // 0x1d0ff
            return *(int64_t *)(a2 + 0x57f8);
        }
    }
    int64_t v2 = *(int64_t *)(a2 + 0x57f8); // 0x1d05b
    if ((*(int32_t *)(*(int64_t *)(a2 + 0x6300) + v2) & 48) != 16 || *(char *)(a2 + 0x58ed) % 2 == 0) {
        // 0x1d0ff
        return *(int64_t *)(a2 + 0x57f8);
    }
    // 0x1d08d
    if (*(int32_t *)(*(int64_t *)(a2 + 0x62d0) + v2) % 0x400000 != 0xe520) {
        // 0x1d0ae
        *(char *)(a2 + 0x5958) = (char)&g1;
    }
    // 0x1d0ff
    return *(int64_t *)(a2 + 0x57f8);
}

// From module:   /root/asv5220\smiInterrupt.c
// Address range: 0x1d11f - 0x1d14f
// Line range:    711 - 806
char smi_cfg_dma_B(int64_t pFdoData) {
    // 0x1d11f
    int64_t v1; // 0x1d11f
    int64_t v2; // 0x1d11f
    int64_t result = *(int64_t *)(v1 + 0x6300) + v2; // 0x1d11f
    int64_t v3; // 0x1d11f
    *(int32_t *)result = (int32_t)v3;
    return result;
}

// Address range: 0x1d14f - 0x1d23a
int64_t smi_cfg_dma_B2(int64_t a1) {
    // 0x1d14f
    mcount();
    smi_enable_interrupt2();
    SmiCalculateMemAddr2(a1);
    int64_t * v1; // 0x1d14f
    int64_t * v2; // 0x1d14f
    if (*(char *)(a1 + 0x58ed) % 2 == 0) {
        // 0x1d14f
        v2 = (int64_t *)(a1 + 0x6300);
        v1 = (int64_t *)(a1 + 0x57f8);
    } else {
        int64_t * v3 = (int64_t *)(a1 + 0x57f8);
        int64_t v4 = *v3; // 0x1d18f
        int64_t * v5 = (int64_t *)(a1 + 0x6300);
        int64_t v6 = *(int64_t *)(a1 + 0x62c0); // 0x1d1a8
        *(int32_t *)(v6 + v4) = (int32_t)*(int64_t *)(a1 + 0x58d0);
        *(int32_t *)(*(int64_t *)(a1 + 0x62c8) + *v3) = 0;
        *(int32_t *)(*(int64_t *)(a1 + 0x62d8) + *v3) = 0x11c0e520;
        *(int32_t *)(*v5 + *v3) = *(int32_t *)(*v5 + v4) | 3;
        v2 = v5;
        v1 = v3;
    }
    int64_t v7 = *v1; // 0x1d203
    int64_t v8 = *(int64_t *)(a1 + 0x62e0); // 0x1d21c
    *(int32_t *)(v8 + v7) = (int32_t)*(int64_t *)(a1 + 0x58d8);
    *(int32_t *)(*(int64_t *)(a1 + 0x62e8) + *v1) = 0;
    return (int64_t)*(int32_t *)(*v2 + v7);
}

// From module:   /root/asv5220\smiInterrupt.c
// Address range: 0x1d240 - 0x1d270
// Line range:    608 - 703
char smi_cfg_dma_A(int64_t pFdoData) {
    // 0x1d240
    int64_t result; // 0x1d240
    char * v1 = (char *)(result + (int64_t)&g33); // 0x1d240
    int64_t v2; // 0x1d240
    *v1 = *v1 + (char)v2;
    return result;
}

// Address range: 0x1d246 - 0x1d269
int64_t function_1d246(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1d246
    int64_t v1; // 0x1d246
    *(char *)v1 = 2 * (char)v1;
    *(int32_t *)a4 = 0x11c0e520;
    int64_t v2; // 0x1d246
    int64_t v3 = *(int64_t *)(v2 + 0x57f8); // 0x1d254
    int64_t v4 = *(int64_t *)(v2 + 0x6300); // 0x1d25b
    *(int32_t *)(v4 + v3) = (int32_t)v1 | (int32_t)&g34;
    return &g1;
}

// Address range: 0x1d270 - 0x1d355
int64_t smi_cfg_dma_A2(int64_t a1) {
    // 0x1d270
    mcount();
    smi_enable_interrupt2();
    SmiCalculateMemAddr2(a1);
    int64_t * v1; // 0x1d270
    int64_t * v2; // 0x1d270
    if (*(char *)(a1 + 0x58ec) % 2 == 0) {
        // 0x1d270
        v2 = (int64_t *)(a1 + 0x62b8);
        v1 = (int64_t *)(a1 + 0x57f8);
    } else {
        int64_t * v3 = (int64_t *)(a1 + 0x57f8);
        int64_t v4 = *v3; // 0x1d2aa
        int64_t * v5 = (int64_t *)(a1 + 0x62b8);
        int64_t v6 = *(int64_t *)(a1 + 0x6278); // 0x1d2c3
        *(int32_t *)(v6 + v4) = (int32_t)*(int64_t *)(a1 + 0x58c0);
        *(int32_t *)(*(int64_t *)(a1 + 0x6280) + *v3) = 0;
        *(int32_t *)(*(int64_t *)(a1 + 0x6290) + *v3) = 0x11c0e520;
        *(int32_t *)(*v5 + *v3) = *(int32_t *)(*v5 + v4) | 3;
        v2 = v5;
        v1 = v3;
    }
    int64_t v7 = *v1; // 0x1d31e
    int64_t v8 = *(int64_t *)(a1 + 0x6298); // 0x1d337
    *(int32_t *)(v8 + v7) = (int32_t)*(int64_t *)(a1 + 0x58c8);
    *(int32_t *)(*(int64_t *)(a1 + 0x62a0) + *v1) = 0;
    return (int64_t)*(int32_t *)(*v2 + v7);
}

// From module:   /root/asv5220\smiInterrupt.c
// Address range: 0x1d35b - 0x1d38b
// Line range:    60 - 501
int32_t smi_interrupt_handler(int32_t irq, char * dev_instance) {
    // 0x1d35b
    int64_t v1; // 0x1d35b
    char * v2 = (char *)(v1 + (int64_t)&g33); // 0x1d35b
    int64_t v3; // 0x1d35b
    *v2 = *v2 + (char)v3;
    int64_t v4 = ((v1 & v3) >> (int64_t)&g95) % 256 << (int64_t)&g95 | v3 & -0xff01; // 0x1d364
    char v5 = *(char *)v4; // 0x1d366
    int32_t v6 = *(int32_t *)0x4d36f; // 0x1d369
    *(int32_t *)0x4d36f = v6 + (int32_t)v4 + (int32_t)((v5 & 128 >> (char)&g95) != 0);
    int64_t v7; // 0x1d35b
    int64_t v8 = *(int64_t *)(v7 + 0x57f8); // 0x1d36f
    *(int32_t *)(*(int64_t *)(v7 + 0x62b8) + v8) = (int32_t)v1;
    return &g1;
}

// Address range: 0x1d38b - 0x1d66c
int64_t smi_interrupt_handler2(int64_t a1, int64_t a2) {
    // 0x1d38b
    mcount();
    *(char *)a2 = (char)&g1;
    int64_t * v1 = (int64_t *)(a2 + 0x57f8); // 0x1d3b2
    uint32_t v2 = *(int32_t *)(*v1 + 2056); // 0x1d3bf
    int64_t * v3 = (int64_t *)(a2 + 0x5900); // 0x1d3c5
    *v3 = (int64_t)v2;
    int64_t v4 = 0; // 0x1d3d6
    if (v2 % 4 != 0) {
        // 0x1d3dc
        smi_clear_interrupt2(a2);
        uint64_t v5 = *v3; // 0x1d3e4
        int64_t v6 = v5 % 2 != 0 ? 0 : v5 >> (int64_t)&g1 & (int64_t)(int32_t)&g1;
        int64_t v7 = *v1; // 0x1d3f9
        int64_t * v8 = (int64_t *)(a2 + 0x62b8); // 0x1d400
        int32_t v9 = *(int32_t *)(*v8 + v7); // 0x1d407
        char v10 = v6; // 0x1d40d
        if (v10 == 0) {
            if ((v9 & 48) == 16) {
                // 0x1d424
                if (*(char *)(a2 + 0x58ec) % 2 != 0) {
                    // 0x1d42d
                    if (*(int32_t *)(*(int64_t *)(a2 + 0x6288) + v7) % 0x400000 == 0xe520) {
                        // 0x1d455
                        writeStorageBuff2(*(int64_t *)(a2 + 0x58a0), *(int64_t *)(a2 + 1224), 0xe520);
                    } else {
                        // 0x1d44c
                        *(char *)(a2 + 0x5959) = (char)&g1;
                    }
                }
            }
        }
        // 0x1d4ce
        v4 = v6;
        if ((*(char *)(a2 + 0x58f9) || v10) == 0) {
            // 0x1d4dc
            v4 = v6;
            if (*(char *)(a2 + 0x58ec) % 2 != 0) {
                // 0x1d4e5
                *(int32_t *)(*v8 + *v1) = v9 | 2;
                v4 = v6;
            }
        }
    }
    // 0x1d523
    smi_clear_interrupt2(a2);
    int64_t v11 = *v3; // 0x1d535
    char v12 = 0; // 0x1d53e
    if ((v11 & 4) == 0) {
        // 0x1d548
        v12 = (v11 & 8) != 0 ? (char)&g1 : (char)v4;
    }
    int64_t v13 = *v1; // 0x1d553
    int64_t * v14 = (int64_t *)(a2 + 0x6300); // 0x1d55a
    int64_t v15 = *v14 + v13; // 0x1d55a
    uint32_t v16 = *(int32_t *)v15; // 0x1d561
    uint64_t v17 = (int64_t)v16; // 0x1d564
    int64_t v18 = v15; // 0x1d56e
    char * v19; // 0x1d38b
    int64_t result2; // 0x1d38b
    if (v12 != 0) {
        goto lab_0x1d5c9;
    } else {
        int64_t v20 = v17 / 16 % 4; // 0x1d576
        v18 = v20;
        if (v20 != 1) {
            goto lab_0x1d5c9;
        } else {
            char * v21 = (char *)(a2 + 0x58ed);
            v18 = v20;
            if (*v21 % 2 == 0) {
                goto lab_0x1d5c9;
            } else {
                uint32_t v22 = *(int32_t *)(*(int64_t *)(a2 + 0x62d0) + v13) % 0x400000; // 0x1d597
                if (v22 == 0xe520) {
                    int64_t v23 = *(int64_t *)(a2 + 0x58b0); // 0x1d5b6
                    v19 = v21;
                    result2 = writeStorageBuff2(v23, *(int64_t *)(a2 + 1232), 0xe520);
                } else {
                    // 0x1d5a6
                    *(char *)(a2 + 0x5958) = (char)&g1;
                    v19 = v21;
                    result2 = v22;
                }
                goto lab_0x1d636;
            }
        }
    }
  lab_0x1d5c9:;
    int64_t result = v18; // 0x1d5cd
    if (v12 == (char)&g1) {
        int64_t v24 = v17 / 0x100000 % 4; // 0x1d5d7
        result = v24;
        if (v24 == 1) {
            // 0x1d5df
            result = v24;
            if ((*(char *)(a2 + 0x58ed) & 2) != 0) {
                uint32_t v25 = *(int32_t *)(*(int64_t *)(a2 + 0x62f0) + v13) % 0x400000; // 0x1d5f8
                if (v25 == 0xe520) {
                    int64_t v26 = *(int64_t *)(a2 + 0x58b8); // 0x1d617
                    result = writeStorageBuff2(v26, *(int64_t *)(a2 + 1232), 0xe520);
                } else {
                    // 0x1d607
                    *(char *)(a2 + 0x5958) = (char)&g1;
                    result = v25;
                }
            }
        }
    }
    // 0x1d628
    if (v12 != 0) {
        // 0x1d656
        return result;
    }
    // 0x1d628
    v19 = (char *)(a2 + 0x58ed);
    result2 = result;
    goto lab_0x1d636;
  lab_0x1d636:
    // 0x1d636
    if (*v19 % 2 == 0) {
        // 0x1d656
        return result2;
    }
    int64_t result3 = *v14 + *v1; // 0x1d64a
    *(int32_t *)result3 = v16 | 2;
    return result3;
}

// From module:   /root/asv5220\b_cas_card.c
// Address range: 0x1d670 - 0x1d691
// Line range:    343 - 361
int64_t private_data5(char * bcas) {
    // 0x1d670
    int64_t v1; // 0x1d670
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x1d670
    int64_t v3; // 0x1d670
    *(int32_t *)(*(int64_t *)(v3 + 0x6300) + v1) = (int32_t)v2;
    *(char *)v3 = 0;
    return &g1;
}

// From module:   /root/asv5220\b_cas_card.c
// Address range: 0x1d694 - 0x1d695
// Line range:    438 - 441
int32_t load_be_uint16(char * p) {
    // 0x1d694
    int64_t result; // 0x1d694
    return result;
}

// Address range: 0x1d695 - 0x1d69b
int64_t function_1d695(void) {
    // 0x1d695
    int64_t result; // 0x1d695
    return result;
}

// Address range: 0x1d6a0 - 0x1d6a9
int64_t private_data6(void) {
    // 0x1d6a0
    return mcount();
}

// From module:   /root/asv5220\b_cas_card.c
// Address range: 0x1d6ab - 0x1d6c4
// Line range:    376 - 436
int32_t connect_card(int64_t prv, int64_t bcas) {
    // 0x1d6ab
    int64_t v1; // 0x1d6ab
    return (v1 & 0xffffffff) + 1128 == prv ? (int32_t)v1 : 0;
}

// Address range: 0x1d6c4 - 0x1d6db
int64_t load_be_uint16_(int64_t a1) {
    // 0x1d6c4
    mcount();
    unsigned char v1 = *(char *)(a1 + (int64_t)&g1); // 0x1d6cd
    int64_t v2; // 0x1d6c4
    return (int32_t)v2 % 256 << (int32_t)&g95 | (int32_t)v1;
}

// Address range: 0x1d6db - 0x1d7d8
int64_t connect_card2(int64_t a1, int64_t a2) {
    // 0x1d6db
    mcount();
    *(int64_t *)(a1 + 40) = 0;
    *(int64_t *)(a1 + 48) = 0;
    *(int64_t *)(a1 + 56) = 0;
    *(int64_t *)(a1 + 64) = 0;
    *(int64_t *)(a1 + 72) = 0;
    *(int32_t *)(a1 + 80) = 0;
    abort();
    // UNREACHABLE
}

// From module:   /root/asv5220\b_cas_card.c
// Address range: 0x1d7d9 - 0x1d809
// Line range:    261 - 317
int32_t proc_emm_b_cas_card(char * bcas, char * src, int32_t len) {
    // 0x1d7d9
    int64_t v1; // 0x1d7d9
    int64_t v2; // 0x1d7d9
    *(int32_t *)v1 = (int32_t)v2;
    int64_t v3; // 0x1d7d9
    int64_t v4 = load_be_uint16_(v3 + (int64_t)&g25); // 0x1d7e0
    int64_t v5; // 0x1d7d9
    *(int32_t *)(v5 + 80) = (int32_t)v4;
    return &g1;
}

// Address range: 0x1d809 - 0x1d917
int64_t proc_emm_b_cas_card2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1d809
    mcount();
    int64_t v1 = private_data6(); // 0x1d833
    int32_t v2 = a3;
    if (v2 < 1 || a2 == 0 || v1 == 0) {
        // 0x1d90f
        return 0xffffffff;
    }
    // 0x1d856
    connect_card2(v1, a1);
    int64_t * v3 = (int64_t *)(v1 + (int64_t)&g13); // 0x1d864
    *(int32_t *)*v3 = 0x3690;
    *(char *)(*v3 + (int64_t)&g86) = (char)a3;
    int64_t v4; // 0x1d809
    memcpy(*v3 + (int64_t)&g89, a2, 0x100000000 * a3 / 0x100000000, v4);
    int64_t v5 = *v3; // 0x1d88f
    *(char *)(v5 + (a3 + (int64_t)(int32_t)&g89 & 0xffffffff) * (int64_t)&g1) = 0;
    uint32_t v6 = v2 + (int32_t)&g91; // 0x1d8a9
    if (v6 == 0) {
        // 0x1d90f
        return 0;
    }
    int64_t v7 = 0; // 0x1d8ac
    while (v6 > (int32_t)v7) {
        // 0x1d8db
        v7 &= 0xffffffff;
    }
    // 0x1d90f
    return 0;
}

// From module:   /root/asv5220\b_cas_card.c
// Address range: 0x1d919 - 0x1d949
// Line range:    189 - 239
int32_t proc_ecm_b_cas_card(char * bcas, int64_t dst, char * src, int32_t len) {
    // 0x1d919
    *(int32_t *)bcas = __asm_insd((int16_t)(int64_t)src);
    return unknown_fffffffff077646b();
}

// Address range: 0x1d949 - 0x1da63
int64_t proc_ecm_b_cas_card2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1d949
    mcount();
    int64_t v1 = private_data6(); // 0x1d976
    int32_t v2 = a4;
    if (v2 < 1 || a3 == 0 || a2 == 0 || v1 == 0) {
        // 0x1da5b
        return 0xffffffff;
    }
    // 0x1d9a2
    connect_card2(v1, a1);
    int64_t * v3 = (int64_t *)(v1 + (int64_t)&g13); // 0x1d9b0
    *(int32_t *)*v3 = 0x3490;
    *(char *)(*v3 + (int64_t)&g86) = (char)a4;
    memcpy(*v3 + (int64_t)&g89, a3, 0x100000000 * a4 / 0x100000000, a4);
    int64_t v4 = *v3; // 0x1d9db
    *(char *)(v4 + (a4 + (int64_t)(int32_t)&g89 & 0xffffffff) * (int64_t)&g1) = 0;
    uint32_t v5 = v2 + (int32_t)&g91; // 0x1d9f5
    if (v5 == 0) {
        // 0x1da5b
        return 0;
    }
    int64_t v6 = 0; // 0x1d9f8
    while (v5 > (int32_t)v6) {
        // 0x1da27
        v6 &= 0xffffffff;
    }
    // 0x1da5b
    return 0;
}

// From module:   /root/asv5220\b_cas_card.c
// Address range: 0x1da65 - 0x1da95
// Line range:    162 - 180
int32_t get_init_status_b_cas_card(char * bcas, int64_t stat) {
    // 0x1da65
    int64_t v1; // 0x1da65
    *(int32_t *)bcas = __asm_insd((int16_t)v1);
    return unknown_fffffffff07765b7();
}

// Address range: 0x1da95 - 0x1dafa
int64_t get_init_status_b_cas_card2(int64_t a1, int64_t a2) {
    // 0x1da95
    mcount();
    int64_t result = private_data6(); // 0x1daa2
    if (a2 != 0 != result != 0) {
        // 0x1dab1
        return result;
    }
    int64_t v1 = result + 40; // 0x1dac6
    int64_t result2 = 1084; // 0x1dad2
    int64_t v2 = v1; // 0x1dad2
    int64_t v3 = a2; // 0x1dad2
    if (((char)a2 & (char)&g86) != 0) {
        // 0x1dad4
        *(int32_t *)a2 = *(int32_t *)v1;
        result2 = 1080;
        v2 = result + 44;
        v3 = a2 + (int64_t)&g86;
    }
    // 0x1dae3
    __asm_rep_movsq_memcpy((char *)v3, (char *)v2, 135);
    return result2;
}

// From module:   /root/asv5220\b_cas_card.c
// Address range: 0x1dafb - 0x1db2b
// Line range:    363 - 374
void teardown3(int64_t prv) {
    // 0x1dafb
    int64_t v1; // 0x1dafb
    int64_t v2 = v1 + (int64_t)(uint32_t)(int32_t)&g86 & 0xffffffff; // 0x1dafb
    int64_t v3; // 0x1dafb
    int32_t v4 = v3;
    int64_t v5 = v2; // 0x1db05
    int64_t v6; // 0x1dafb
    if ((v4 & (int32_t)&g25) != 0) {
        int64_t v7 = v2 * (int64_t)&g1; // 0x1db07
        *(int16_t *)(v7 + prv) = *(int16_t *)(v7 + v6);
        v5 = v2 + (int64_t)&g25;
    }
    if ((v4 & (int32_t)&g1) != 0) {
        int64_t v8 = v5 * (int64_t)&g1; // 0x1db1a
        *(char *)(v8 + prv) = *(char *)(v8 + v6);
    }
}

// Address range: 0x1db2b - 0x1db40
int64_t teardown4(int64_t a1) {
    // 0x1db2b
    return mcount();
}

// From module:   /root/asv5220\b_cas_card.c
// Address range: 0x1db41 - 0x1db71
// Line range:    127 - 160
int32_t init_b_cas_card(char * bcas) {
    int64_t v1 = (int64_t)bcas;
    int64_t result; // 0x1db41
    int64_t v2; // 0x1db41
    if ((int32_t)v1 != 0) {
        int64_t v3 = kfree(v1); // 0x1db45
        *(int64_t *)(v2 + (int64_t)&g95) = 0;
        result = v3;
    }
    // 0x1db52
    *(int64_t *)(v2 + (int64_t)&g2) = 0;
    *(int64_t *)(v2 + (int64_t)&g13) = 0;
    *(int64_t *)(v2 + (int64_t)&g26) = 0;
    return result;
}

// Address range: 0x1db71 - 0x1dc51
int64_t init_b_cas_card2(int64_t a1) {
    // 0x1db71
    mcount();
    int64_t v1 = private_data6(); // 0x1db95
    teardown4(v1);
    int64_t v2 = *(int64_t *)0x3edb8; // 0x1dbb3
    int64_t v3 = kmem_cache_alloc_notrace(v2, (int64_t *)&g26); // 0x1dbc2
    slab_buffer_size(v2);
    if (g84 != 0) {
        // 0x1dbe5
        if (g85 != 0) {
            int64_t v4 = 0x100000000000000 * g85 / 0x100000000000000 + (int64_t)&g95; // 0x1dc0f
            int64_t v5 = v4; // 0x1dc1c
            while (*(int64_t *)v4 != 0) {
                // 0x1dbf5
                v4 = 0x100000000000000 * v5 / 0x100000000000000 + (int64_t)&g95;
                v5 = v4;
            }
        }
    }
    int64_t * v6 = (int64_t *)(v1 + (int64_t)&g95); // 0x1dc21
    *v6 = v3;
    memset(v3, 0, 0x2100);
    int64_t result = *v6; // 0x1dc3e
    *(int64_t *)(v1 + (int64_t)&g2) = result;
    *(int64_t *)(v1 + (int64_t)&g13) = result + 256;
    return result;
}

// From module:   /root/asv5220\b_cas_card.c
// Address range: 0x1dc51 - 0x1dc81
// Line range:    113 - 125
void release_b_cas_card(char * bcas) {
    // 0x1dc51
    int64_t v1; // 0x1dc51
    int64_t v2; // 0x1dc51
    *(int64_t *)(v1 + (int64_t)&g26) = v2 + 0x1100;
    int64_t v3; // 0x1dc51
    connect_card2(v1, v3);
}

// Address range: 0x1dc81 - 0x1dc82
int64_t release_b_cas_card2(void) {
    // 0x1dc81
    int64_t result; // 0x1dc81
    return result;
}

// From module:   /root/asv5220\b_cas_card.c
// Address range: 0x1dc83 - 0x1dcb3
// Line range:    73 - 101
int64_t create_b_cas_card(char * DevExt, int32_t (*bcas_callback)(char *, char *, int32_t, char, char *)) {
    // 0x1dc83
    mcount();
    int64_t v1 = private_data6(); // 0x1dc8f
    int64_t result = 0; // 0x1dc9a
    if (v1 != 0) {
        // 0x1dc9c
        teardown4(v1);
        result = kfree(v1);
    }
    // 0x1dcac
    return result;
}

// Address range: 0x1dcb3 - 0x1dd77
int64_t create_b_cas_card2(int64_t a1, int64_t a2) {
    // 0x1dcb3
    mcount();
    int64_t v1 = *(int64_t *)0x3ed70; // 0x1dcda
    int64_t v2 = kmem_cache_alloc_notrace(v1, (int64_t *)&g26); // 0x1dce9
    slab_buffer_size(v1);
    if (g84 != 0) {
        // 0x1dd0c
        if (g85 != 0) {
            int64_t v3 = 0x100000000000000 * g85 / 0x100000000000000 + (int64_t)&g95; // 0x1dd36
            int64_t v4 = v3; // 0x1dd43
            while (*(int64_t *)v3 != 0) {
                // 0x1dd1c
                v3 = 0x100000000000000 * v4 / 0x100000000000000 + (int64_t)&g95;
                v4 = v3;
            }
        }
    }
    // 0x1dd45
    __asm_rep_stosq_memset((char *)v2, 0, 189);
    *(int64_t *)v2 = a1;
    int64_t result = v2 + 1128; // 0x1dd5d
    *(int64_t *)result = v2;
    *(int64_t *)(v2 + 1136) = 0;
    *(int64_t *)(v2 + 1144) = 0;
    return result;
}

// From module:   /root/asv5220\FUSB.c
// Address range: 0x1dd7c - 0x1dd8c
// Line range:    189 - 255
int64_t FUSB_ProcessSysControlIrp(char * DeviceObject, char * Irp) {
    // 0x1dd7c
    int64_t v1; // 0x1dd7c
    *(char *)v1 = 2 * (char)v1;
    int64_t result; // 0x1dd7c
    char * v2 = (char *)(result - 57); // 0x1dd7e
    int64_t v3; // 0x1dd7c
    char v4 = v3; // 0x1dd7e
    *v2 = *v2 + v4;
    int64_t v5 = result;
    *(char *)v5 = *(char *)&result & (char)v5;
    int64_t v6 = result;
    *(char *)v6 = *(char *)&result + (char)v6;
    char * v7 = (char *)(result - 57); // 0x1dd86
    *v7 = *v7 + v4;
    int64_t v8 = result;
    *(char *)v8 = *(char *)&result - (char)v8;
    return result;
}

// From module:   /root/asv5220\FUSB.c
// Address range: 0x1dd8c - 0x1dd96
// Line range:    259 - 291
void FUSB_Unload(char * DriverObject) {
    // 0x1dd8c
    int64_t v1; // 0x1dd8c
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x1dd8c
    char * v3 = (char *)(v2 + 104 + 4 * v2); // 0x1dd8e
    char v4 = v2; // 0x1dd8e
    *v3 = *v3 + v4;
    char * v5 = (char *)(v1 - 117); // 0x1dd92
    *v5 = *v5 ^ v4;
}

// From module:   /root/asv5220\FUSB.c
// Address range: 0x1dd97 - 0x1dda7
// Line range:    512 - 628
int64_t FUSB_CallUSBD(char * DeviceObject, char * Urb) {
    // 0x1dd97
    int64_t result; // 0x1dd97
    return result;
}

// From module:   /root/asv5220\FUSB.c
// Address range: 0x1dda7 - 0x1dda9
// Line range:    632 - 740
int64_t FUSB_ConfigureDevice(char * DeviceObject) {
    // 0x1dda7
    int64_t result; // 0x1dda7
    return result;
}

// Address range: 0x1ddac - 0x1ddb5
int64_t FUSB_ProcessSysControlIrp2(void) {
    // 0x1ddac
    return mcount();
}

// From module:   /root/asv5220\FUSB.c
// Address range: 0x1ddb7 - 0x1ddbc
// Line range:    744 - 1028
int64_t FUSB_SelectInterface(char * DeviceObject, char * ConfigurationDescriptor) {
    // 0x1ddb7
    int64_t result; // 0x1ddb7
    *(char *)result = 2 * (char)result;
    return result;
}

// Address range: 0x1ddbc - 0x1ddc7
int64_t FUSB_Unload2(void) {
    // 0x1ddbc
    return mcount();
}

// From module:   /root/asv5220\FUSB.c
// Address range: 0x1ddc7 - 0x1ddd7
// Line range:    1033 - 1143
int64_t FUSB_ResetPipe(char * DeviceObject, char * PipeInfo, char ClearStall) {
    // 0x1ddc7
    mcount();
    return &g1;
}

// From module:   /root/asv5220\FUSB.c
// Address range: 0x1ddd7 - 0x1dde7
// Line range:    1149 - 1215
int64_t FUSB_DecrementIoCount(char * DeviceObject) {
    // 0x1ddd7
    mcount();
    return 0;
}

// From module:   /root/asv5220\FUSB.c
// Address range: 0x1dde7 - 0x1ddf0
// Line range:    1219 - 1258
void FUSB_IncrementIoCount(char * DeviceObject) {
    // 0x1dde7
    mcount();
}

// From module:   /root/asv5220\FUSB.c
// Address range: 0x1ddf2 - 0x1ddf7
// Line range:    383 - 508
int64_t FUSB_CreateDeviceObject(char * DriverObject, char * PhysicalDeviceObject, char ** DeviceObject, char * DeviceExtensionForBDA, char bForBDA) {
    // 0x1ddf2
    int64_t result; // 0x1ddf2
    *(char *)result = 2 * (char)result;
    return result;
}

// Address range: 0x1ddf7 - 0x1de07
int64_t FUSB_ResetPipe2(void) {
    // 0x1ddf7
    mcount();
    return 0;
}

// Address range: 0x1de07 - 0x1de17
int64_t FUSB_DecrementIoCount2(int64_t a1) {
    // 0x1de07
    mcount();
    return 0;
}

// Address range: 0x1de17 - 0x1de22
int64_t FUSB_IncrementIoCount2(int64_t a1) {
    // 0x1de17
    return mcount();
}

// Address range: 0x1de22 - 0x1e121
int64_t FUSB_CreateDeviceObject2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t * a5) {
    // 0x1de22
    mcount();
    NT_SUCCESS2((int64_t)&g1);
    int64_t v1 = (char)(int64_t)a5 != 0 ? a4 : 0; // 0x1de4d
    NT_SUCCESS2((int64_t)&g1);
    *(int64_t *)(v1 + 216) = 0x500000;
    int64_t v2 = 0; // 0x1de71
    int64_t v3 = v1; // 0x1de71
    *(char *)(v3 + 1152) = 0;
    *(char *)(v3 + 888) = 0;
    int64_t v4 = v2 + v1;
    *(int64_t *)(v4 + 896) = 0;
    *(int64_t *)(v4 + 1024) = 0;
    *(int64_t *)(v4 + 960) = 0;
    *(int64_t *)(v4 + 1088) = 0;
    v3 += (int64_t)&g1;
    while (v2 != 64 - (int64_t)&g95) {
        // 0x1de76
        v2 += (int64_t)&g95;
        *(char *)(v3 + 1152) = 0;
        *(char *)(v3 + 888) = 0;
        v4 = v2 + v1;
        *(int64_t *)(v4 + 896) = 0;
        *(int64_t *)(v4 + 1024) = 0;
        *(int64_t *)(v4 + 960) = 0;
        *(int64_t *)(v4 + 1088) = 0;
        v3 += (int64_t)&g1;
    }
    // 0x1dec2
    *(char *)(v1 + 0x4faf) = 0;
    *(char *)(v1 + 0x4fb0) = 0;
    *(char *)(v1 + 0x4fb1) = 0;
    *(char *)(v1 + 0x4fb2) = 0;
    *(int32_t *)(v1 + (int64_t)&g13) = 0;
    __init_waitqueue_head(v1 + (int64_t)&g26, 0, v3, a4);
    *(int32_t *)(v1 + 120) = 0;
    __init_waitqueue_head(v1 + 128, 0, v3, a4);
    *(int32_t *)(v1 + 56) = 0;
    __init_waitqueue_head(v1 + 64, 0, v3, a4);
    *(int32_t *)(v1 + 88) = 0;
    __init_waitqueue_head(v1 + 96, 0, v3, a4);
    int64_t v5 = v1 + 160; // 0x1df3d
    *(int32_t *)(v1 + 152) = 0;
    *(int32_t *)(v1 + 156) = (int32_t)&g1;
    *(int64_t *)v5 = v5;
    *(int64_t *)(v1 + 168) = v5;
    int64_t v6 = v1 + 232; // 0x1df66
    *(int32_t *)(v1 + 224) = 0;
    *(int32_t *)(v1 + 228) = (int32_t)&g1;
    *(int64_t *)v6 = v6;
    *(int64_t *)(v1 + 240) = v6;
    int64_t v7 = v1 + 256; // 0x1df8f
    *(int32_t *)(v1 + 248) = 0;
    *(int32_t *)(v1 + 252) = (int32_t)&g1;
    *(int64_t *)v7 = v7;
    *(int64_t *)(v1 + 264) = v7;
    int64_t v8 = v1 + 280; // 0x1dfb8
    *(int32_t *)(v1 + 272) = 0;
    *(int32_t *)(v1 + 276) = (int32_t)&g1;
    *(int64_t *)v8 = v8;
    *(int64_t *)(v1 + 288) = v8;
    int64_t v9 = v1 + 328; // 0x1dfe1
    *(int32_t *)(v1 + 320) = 0;
    *(int32_t *)(v1 + 324) = (int32_t)&g1;
    *(int64_t *)v9 = v9;
    *(int64_t *)(v1 + 336) = v9;
    int64_t v10 = v1 + 352; // 0x1e00a
    *(int32_t *)(v1 + 344) = 0;
    *(int32_t *)(v1 + 348) = (int32_t)&g1;
    *(int64_t *)v10 = v10;
    *(int64_t *)(v1 + 360) = v10;
    int64_t v11 = v1 + 400; // 0x1e033
    int64_t v12 = v1 + 424; // 0x1e03a
    *(int32_t *)(v1 + 416) = 0;
    *(int32_t *)(v1 + 420) = (int32_t)&g1;
    *(int64_t *)v12 = v12;
    *(int64_t *)(v1 + 432) = v12;
    int64_t v13 = v1 + 448; // 0x1e063
    *(int32_t *)(v1 + 440) = 0;
    *(int32_t *)(v1 + 444) = (int32_t)&g1;
    *(int64_t *)v13 = v13;
    *(int64_t *)(v1 + 456) = v13;
    int64_t v14 = v1 + 376; // 0x1e08c
    *(int32_t *)(v1 + 368) = 0;
    *(int32_t *)(v1 + 372) = (int32_t)&g1;
    *(int64_t *)v14 = v14;
    *(int64_t *)(v1 + 384) = v14;
    *(int32_t *)(v1 + (int64_t)&g15) = 0;
    *(int32_t *)(v1 + 396) = (int32_t)&g1;
    *(int64_t *)v11 = v11;
    *(int64_t *)(v1 + 408) = v11;
    *(int64_t *)(v1 + 0x5678) = 0;
    *(int64_t *)(v1 + 0x5690) = 0;
    *(int64_t *)(v1 + 0x5680) = 0;
    int64_t result = v1 + 0x5920; // 0x1e0f8
    *(int32_t *)(v1 + 0x5918) = 0;
    *(int32_t *)(v1 + 0x591c) = (int32_t)&g1;
    *(int64_t *)result = result;
    *(int64_t *)(v1 + 0x5928) = result;
    return result;
}

// From module:   /root/asv5220\FUSB.c
// Address range: 0x1e124 - 0x1e154
// Line range:    78 - 182
int64_t DriverEntry(char * DriverObject, char * RegistryPath) {
    // 0x1e124
    uint64_t v1; // 0x1e124
    int64_t v2; // 0x1e124
    int64_t v3 = (v2 + (v1 >> (uint64_t)(int64_t)&g95)) % 256 << (uint64_t)(int64_t)&g95 | v1 & -0xff01; // 0x1e127
    *(int32_t *)v2 = (int32_t)v2 ^ 89;
    int64_t v4; // 0x1e124
    int64_t v5 = v4;
    *(char *)v5 = *(char *)&v4 + (char)v5;
    int64_t v6 = v4;
    *(char *)v6 = *(char *)&v4 + (char)v6;
    int64_t v7 = v4;
    *(char *)v7 = *(char *)&v4 + (char)v7;
    *(int32_t *)(v3 + 0x5934) = (int32_t)&g1;
    *(int64_t *)(v3 + 0x5938) = v4;
    *(int64_t *)(v3 + 0x5940) = v4;
    return &g1;
}

// Address range: 0x1e154 - 0x1e160
int64_t DriverEntry2(int64_t a1) {
    // 0x1e154
    return mcount();
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nmicmn.c
// Address range: 0x1e160 - 0x1e184
// Line range:    47 - 52
void nmi_delay(int64_t pPrivate, int32_t msec) {
    // 0x1e160
    bool v1; // 0x1e160
    if (msec != 0 != !v1) {
        // 0x1e167
        return;
    }
    // 0x1e16e
    g79 = 0;
    g80 = 0;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nmicmn.c
// Address range: 0x1e185 - 0x1e190
// Line range:    54 - 63
int32_t nmi_get_tick(int64_t pPrivate) {
    // 0x1e185
    int64_t result; // 0x1e185
    return result;
}

// Address range: 0x1e190 - 0x1e1ad
int64_t nmi_delay2(int64_t a1, int64_t * a2) {
    // 0x1e190
    mcount();
    uint64_t v1; // 0x1e190
    return *(int64_t *)(184 * (v1 % 256));
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x1e1ad - 0x1e1b5
// Line range:    448 - 537
int16_t nmi_log10(int64_t x) {
    // 0x1e1ad
    int64_t result; // 0x1e1ad
    return result;
}

// Address range: 0x1e1b5 - 0x1e1dd
int64_t nmi_get_tick2(int64_t a1) {
    // 0x1e1b5
    mcount();
    return 0;
}

// Address range: 0x1e1dd - 0x1e467
int64_t nmi_log10_(uint64_t a1) {
    // 0x1e1dd
    mcount();
    if (a1 < 256) {
        // 0x1e1ef
        return a1 % 256 + 0xfffffe98;
    }
    if (a1 < 512) {
        unsigned char v1 = *(char *)(a1 >> (uint64_t)(int64_t)&g1); // 0x1e20c
        return (int64_t)v1 + 0xfffffeb0;
    }
    if (a1 < 1024) {
        unsigned char v2 = *(char *)(a1 >> (uint64_t)(int64_t)&g25); // 0x1e22a
        return (int64_t)v2 + 0xfffffec8;
    }
    if (a1 < 2048) {
        unsigned char v3 = *(char *)(a1 >> (uint64_t)(int64_t)&g33); // 0x1e248
        return (int64_t)v3 + 0xfffffee0;
    }
    if (a1 <= (uint64_t)(int64_t)&g106) {
        unsigned char v4 = *(char *)(a1 >> (uint64_t)(int64_t)&g86); // 0x1e266
        return (int64_t)v4 + 0xfffffef8;
    }
    if (a1 < 0x2000) {
        unsigned char v5 = *(char *)(a1 >> (uint64_t)(int64_t)&g89); // 0x1e284
        return (int64_t)v5 + 0xffffff10 & 0xffffffff;
    }
    if (a1 < 0x4000) {
        unsigned char v6 = *(char *)(a1 >> (uint64_t)(int64_t)&g91); // 0x1e2a2
        return (int64_t)v6 + 0xffffff28 & 0xffffffff;
    }
    if (a1 < 0x8000) {
        unsigned char v7 = *(char *)(a1 >> (uint64_t)(int64_t)&g94); // 0x1e2c0
        return (int64_t)v7 + 0xffffff40 & 0xffffffff;
    }
    if (a1 < 0x10000) {
        unsigned char v8 = *(char *)(a1 >> (uint64_t)(int64_t)&g95); // 0x1e2de
        return (int64_t)v8 + 0xffffff58 & 0xffffffff;
    }
    if (a1 < 0x20000) {
        unsigned char v9 = *(char *)(a1 >> (uint64_t)(int64_t)&g97); // 0x1e2fc
        return (int64_t)v9 + 0xffffff70 & 0xffffffff;
    }
    if (a1 < 0x40000) {
        unsigned char v10 = *(char *)(a1 >> (uint64_t)(int64_t)&g98); // 0x1e31a
        return (int64_t)v10 + 0xffffff88 & 0xffffffff;
    }
    if (a1 < 0x80000) {
        unsigned char v11 = *(char *)(a1 >> (uint64_t)(int64_t)&g99); // 0x1e336
        return (int64_t)v11 + 0xffffffa0 & 0xffffffff;
    }
    if (a1 < 0x100000) {
        unsigned char v12 = *(char *)(a1 >> (uint64_t)(int64_t)"GNU"); // 0x1e352
        return (int64_t)v12 + 0xffffffb8 & 0xffffffff;
    }
    if (a1 < 0x200000) {
        unsigned char v13 = *(char *)(a1 >> (uint64_t)(int64_t)"NU"); // 0x1e36e
        return (int64_t)v13 + 0xffffffd0 & 0xffffffff;
    }
    if (a1 < 0x400000) {
        unsigned char v14 = *(char *)(a1 >> (uint64_t)(int64_t)&g103); // 0x1e38a
        return (int64_t)v14 - (int64_t)(int32_t)&g13 & 0xffffffff;
    }
    if (a1 < 0x800000) {
        unsigned char result = *(char *)(a1 >> (uint64_t)(int64_t)&g105); // 0x1e3a6
        return result;
    }
    if (a1 < 0x1000000) {
        unsigned char v15 = *(char *)(a1 >> (uint64_t)(int64_t)&g2); // 0x1e3bf
        return (int64_t)v15 + (int64_t)(int32_t)&g13 & 0xffffffff;
    }
    if (a1 < 0x2000000) {
        unsigned char v16 = *(char *)(a1 >> (uint64_t)(int64_t)&g3); // 0x1e3db
        return (int64_t)v16 + 48;
    }
    if (a1 < 0x4000000) {
        unsigned char v17 = *(char *)(a1 >> (uint64_t)(int64_t)&g4); // 0x1e3f7
        return (int64_t)v17 + 72;
    }
    if (a1 < 0x8000000) {
        unsigned char v18 = *(char *)(a1 >> (uint64_t)(int64_t)&g5); // 0x1e413
        return (int64_t)v18 + 96;
    }
    if (a1 < 0x10000000) {
        unsigned char v19 = *(char *)(a1 >> (uint64_t)(int64_t)&g7); // 0x1e42c
        return (int64_t)v19 + 120;
    }
    if (a1 < 0x20000000) {
        unsigned char v20 = *(char *)(a1 >> (uint64_t)(int64_t)&g9); // 0x1e445
        return (int64_t)v20 + 144;
    }
    unsigned char result2 = *(char *)(a1 >> (uint64_t)(int64_t)&g10); // 0x1e460
    return result2;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x1e46b - 0x1e470
// Line range:    2878 - 2888
void nm131_fm_set_scan_level(int64_t pPrivate, int32_t level) {
    // 0x1e46b
    return;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x1e486 - 0x1e49b
// Line range:    2890 - 2907
void nm131_fm_get_window_rssi(int32_t * orssi, int32_t len, int32_t * wrssi, int32_t * overth) {
    uint64_t v1 = (int64_t)overth;
    int64_t v2; // 0x1e486
    char * v3 = (char *)(v2 - 63); // 0x1e488
    unsigned char v4 = *v3; // 0x1e488
    char v5 = v1; // 0x1e488
    unsigned char v6 = v4 + v5; // 0x1e488
    int64_t v7; // 0x1e486
    unsigned char v8 = v6 + (char)(-1 - (char)v7 < (char)(v1 >> (int64_t)&g95)); // 0x1e488
    bool v9 = -1 - (char)v7 < (char)(v1 >> (int64_t)&g95) ? v8 <= v4 : v6 < v4; // 0x1e488
    *v3 = v8;
    int64_t v10; // 0x1e486
    int64_t v11 = v10;
    __asm_out((int16_t)(int64_t)wrssi, (int32_t)v11);
    int64_t v12; // 0x1e486
    *(char *)orssi = *(char *)&v12 - v5 + (char)v9;
    *(char *)v11 = 2 * (char)v11;
    int64_t v13 = v10;
    *(char *)v13 = *(char *)&v10 + (char)v13;
}

// Address range: 0x1e49b - 0x1e4b6
int64_t nm131_fm_set_scan_level2(int64_t a1, int64_t a2) {
    // 0x1e49b
    mcount();
    uint64_t v1; // 0x1e49b
    int64_t result = 184 * (v1 % 256); // 0x1e4a7
    *(int32_t *)result = (int32_t)a2;
    return result;
}

// Address range: 0x1e4b6 - 0x1e552
int64_t nm131_fm_get_window_rssi2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a1;
    mcount();
    int64_t v2 = (a2 + 0xffffffff & 0xffffffff) * (int64_t)&g86; // 0x1e4d4
    *(int32_t *)a4 = *(int32_t *)a1 >> (int32_t)&g95;
    int32_t * v3 = (int32_t *)v1; // 0x1e4ea
    *v3 = *v3 % 256;
    int64_t v4 = &g86; // 0x1e4f8
    if (v2 != 0) {
        int64_t v5 = v4 * (int64_t)&g1; // 0x1e4e1
        int32_t v6 = *(int32_t *)(v5 + v1); // 0x1e4e1
        *(int32_t *)(v5 + a4) = v6 >> (int32_t)&g95;
        int32_t * v7 = (int32_t *)(v1 + v5); // 0x1e4ea
        *v7 = *v7 % 256;
        v4 += (int64_t)&g86;
        while (v4 != v2 + (int64_t)&g86) {
            // 0x1e4e1
            v5 = v4 * (int64_t)&g1;
            v6 = *(int32_t *)(v5 + v1);
            *(int32_t *)(v5 + a4) = v6 >> (int32_t)&g95;
            v7 = (int32_t *)(v1 + v5);
            *v7 = *v7 % 256;
            v4 += (int64_t)&g86;
        }
    }
    uint32_t result = *(int32_t *)(v1 + (int64_t)&g86) + 2 * *(int32_t *)&v1; // 0x1e52f
    *(int32_t *)a3 = result;
    return result;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x1e555 - 0x1e585
// Line range:    2938 - 3049
void nm131_fm_select_channel_list(int64_t pPrivate, int32_t * orssi, int32_t * wrssi, int32_t * clist, int32_t * nc, int32_t cmax, int32_t clen, int32_t * overth) {
    int64_t v1 = (int64_t)clist;
    int64_t v2; // 0x1e555
    int64_t v3 = (v2 + 65) % 256 | v2 & -256; // 0x1e555
    *(int32_t *)(v3 + v1) = (int32_t)v3;
    int32_t * v4 = (int32_t *)(v1 * (int64_t)&g1 + (int64_t)nc); // 0x1e55a
    int32_t v5 = *v4; // 0x1e55a
    int64_t v6; // 0x1e555
    *v4 = (int32_t)(0x100000000 * v6 / 0x100000000 * (int64_t)v5 >> (int64_t)&g26) - (v5 >> (int32_t)&g24);
}

// Address range: 0x1e585 - 0x1e7cf
int64_t nm131_fm_select_channel_list2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, uint32_t result) {
    // 0x1e585
    mcount();
    return result;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x1e7d1 - 0x1e801
// Line range:    3051 - 3138
int32_t nm131_fm_seek_select(int32_t * rssi, int32_t * overth, int32_t sz) {
    // 0x1e7d1
    int64_t result; // 0x1e7d1
    return result;
}

// Address range: 0x1e801 - 0x1e893
int64_t nm131_fm_seek_select2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x1e801
    mcount();
    if ((int32_t)a3 != (int32_t)&g94) {
        int32_t v1 = 2 * *(int32_t *)(a2 + (int64_t)&g95); // 0x1e86c
        int32_t v2 = *(int32_t *)(a2 + (int64_t)"GNU"); // 0x1e879
        int32_t v3 = v1 - v2; // 0x1e879
        return v3 == 0 | v3 < 0 != ((v3 ^ v1) & (v1 ^ v2)) < 0;
    }
    uint32_t v4 = 2 * *(int32_t *)(a2 + (int64_t)"GNU"); // 0x1e812
    int64_t result = 0; // 0x1e832
    if (*(int32_t *)(a2 + (int64_t)&g7) >= v4) {
        int32_t v5 = *(int32_t *)(a2 + (int64_t)&g2); // 0x1e834
        int32_t v6 = v4 - v5; // 0x1e834
        result = v6 == 0 | v6 < 0 != ((v6 ^ v4) & (v5 ^ v4)) < 0;
    }
    // 0x1e83d
    return result;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x1e894 - 0x1e8c4
// Line range:    3164 - 3177
void nm131_set_scan_level(int64_t pPrivate, int32_t level) {
    // 0x1e894
    return;
}

// Address range: 0x1e8c4 - 0x1e8df
int64_t nm131_set_scan_level2(int64_t a1, int64_t * a2) {
    // 0x1e8c4
    return mcount();
}

// Address range: 0x1e8df - 0x1e8f7
int64_t function_1e8df(void) {
    // 0x1e8df
    uint64_t v1; // 0x1e8df
    int64_t result = 184 * (v1 % 256); // 0x1e8e2
    *(int16_t *)result = 65;
    return result;
}

// Address range: 0x1e8f7 - 0x1e90c
int64_t function_1e8f7(void) {
    // 0x1e8f7
    uint64_t v1; // 0x1e8f7
    int64_t result = 184 * (v1 % 256); // 0x1e8fa
    *(int16_t *)result = 60;
    return result;
}

// Address range: 0x1e90c - 0x1e921
int64_t function_1e90c(void) {
    // 0x1e90c
    uint64_t v1; // 0x1e90c
    int64_t result = 184 * (v1 % 256); // 0x1e90f
    *(int16_t *)result = 55;
    return result;
}

// Address range: 0x1e921 - 0x1e936
int64_t function_1e921(void) {
    // 0x1e921
    uint64_t v1; // 0x1e921
    int64_t result = 184 * (v1 % 256); // 0x1e924
    *(int16_t *)result = 50;
    return result;
}

// Address range: 0x1e936 - 0x1e94b
int64_t function_1e936(void) {
    // 0x1e936
    uint64_t v1; // 0x1e936
    int64_t result = 184 * (v1 % 256); // 0x1e939
    *(int16_t *)result = 45;
    return result;
}

// From module:   /root/asv5220/./NMI131\NMI131.c
// Address range: 0x1e95a - 0x1e960
// Line range:    118 - 121
int64_t NMI131_GetTime(void) {
    // 0x1e95a
    int64_t v1; // 0x1e95a
    *(char *)v1 = 2 * (char)v1;
    int64_t result; // 0x1e95a
    int64_t v2 = result;
    *(char *)v2 = *(char *)&result - (char)v2;
    return result;
}

// From module:   /root/asv5220/./NMI131\NMI131.c
// Address range: 0x1e96c - 0x1e975
// Line range:    187 - 192
int32_t NMI131_GetReadBlockSize(void) {
    // 0x1e96c
    int64_t v1; // 0x1e96c
    *(char *)v1 = (char)v1;
    int64_t result; // 0x1e96c
    int64_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// From module:   /root/asv5220/./NMI131\NMI131.c
// Address range: 0x1e97c - 0x1e98a
// Line range:    193 - 198
int32_t NMI131_GetWriteBlockSize(void) {
    // 0x1e97c
    int64_t v1; // 0x1e97c
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x1e97c
    char * v3 = (char *)(v2 - 57); // 0x1e97e
    int64_t result; // 0x1e97c
    *v3 = *v3 + (char)(result >> (int64_t)&g95);
    *(char *)result = *(char *)&result;
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    return result;
}

// Address range: 0x1e98a - 0x1e98b
int64_t NMI131_GetTime2(void) {
    // 0x1e98a
    int64_t result; // 0x1e98a
    return result;
}

// From module:   /root/asv5220/./NMI131\NMI131.c
// Address range: 0x1e98c - 0x1e993
// Line range:    199 - 202
void NMI131_Log(char * pString) {
    // 0x1e98c
    mcount();
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1e997 - 0x1e99c
// Line range:    167 - 203
char BLACKWIDOW_GetChipInfo(int64_t ptCommunication, char ** ppcTunerString, int64_t * pulChipVersion, int64_t * pulChipId) {
    // 0x1e997
    int64_t v1; // 0x1e997
    int64_t v2; // 0x1e997
    return (char)v2 + (char)v1;
}

// Address range: 0x1e99c - 0x1e9ac
int64_t NMI131_GetReadBlockSize2(void) {
    // 0x1e99c
    mcount();
    return (int64_t)&g26;
}

// Address range: 0x1e9ac - 0x1e9bc
int64_t NMI131_GetWriteBlockSize2(void) {
    // 0x1e9ac
    mcount();
    return (int64_t)&g26;
}

// Address range: 0x1e9bc - 0x1e9c7
int64_t NMI131_Log2(void) {
    // 0x1e9bc
    return mcount();
}

// Address range: 0x1e9c7 - 0x1ea4a
int64_t BLACKWIDOW_GetChipInfo2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1e9c7
    mcount();
    *(int64_t *)a4 = 0;
    int64_t v1; // bp-48, 0x1e9c7
    return &v1;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1ea4e - 0x1ea51
// Line range:    1299 - 1306
char BLACKWIDOW_GetSelectedGainMode(int64_t ptCommunication, int32_t * peGainMode, int32_t * pePowerDetectValue) {
    // 0x1ea4e
    int64_t result; // 0x1ea4e
    char * v1 = (char *)(result - 119); // 0x1ea4e
    int64_t v2; // 0x1ea4e
    *v1 = *v1 + (char)v2;
    return result;
}

// Address range: 0x1ea52 - 0x1ea64
int64_t function_1ea52(void) {
    // 0x1ea52
    int64_t v1; // 0x1ea52
    int64_t v2; // 0x1ea52
    *(int64_t *)v1 = *(int64_t *)(v2 - 40);
    int64_t result; // 0x1ea52
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1ea72 - 0x1ea7e
// Line range:    1732 - 1769
char BLACKWIDOW_GetPLLLockStatus(int64_t ptCommunication, char * pbPllLockStatus) {
    // 0x1ea72
    return unknown_fffffffff06f75c4();
}

// Address range: 0x1ea7e - 0x1eaa2
int64_t BLACKWIDOW_GetSelectedGainMode2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1ea7e
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 40); // 0x1ea87
    *(int32_t *)a2 = *(int32_t *)(v1 + 160);
    *(int32_t *)a3 = *(int32_t *)(v1 + 164);
    return &g1;
}

// Address range: 0x1eaa2 - 0x1ead5
int64_t BLACKWIDOW_GetPLLLockStatus2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1eaa2
    mcount();
    int64_t v1; // bp-32, 0x1eaa2
    return &v1;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1ead9 - 0x1eb09
// Line range:    2174 - 2262
char BLACKWIDOW_GetPowerMode(int64_t ptCommunication, int32_t * pePowerMode) {
    // 0x1ead9
    int64_t v1; // 0x1ead9
    char result = v1;
    *(char *)v1 = 2 * result;
    if (result != 0) {
        // 0x1eafa
        int64_t v2; // 0x1ead9
        int64_t v3 = *(int64_t *)(v2 - 24); // 0x1eafa
        int64_t v4; // 0x1ead9
        *(char *)v4 = (char)(v3 == (int64_t)&g1);
    }
    // 0x1eb02
    return result;
}

// Address range: 0x1eb09 - 0x1ee10
int64_t BLACKWIDOW_GetPowerMode2(int64_t a1, int64_t a2) {
    // 0x1eb09
    mcount();
    int32_t v1 = 0; // bp-64, 0x1eb30
    int32_t * v2 = (int32_t *)a2; // 0x1eb38
    *v2 = (int32_t)&g86;
    uint64_t v3 = (int64_t)(v1 % 256); // 0x1eb67
    char v4 = v1; // 0x1ec18
    int64_t result = &v1; // 0x1ecd8
    int64_t v5 = (char)result != 0 ? (int64_t)(v1 & 224) : 0;
    if ((v3 & 129) == 129) {
        if ((v3 & 137) == 137) {
            if (v4 < 0 == (v3 & 174) == 174) {
                if ((v1 & 192) == 192 == v4 == -1 == v5 == 192 && (v4 & 8) != 0) {
                    if ((char)result != 0) {
                        // 0x1edba
                        *v2 = 0;
                    }
                    // 0x1ee08
                    return result;
                }
            }
        }
    }
    if (v3 % 2 != 0) {
        // 0x1ee08
        return result;
    }
    if ((v3 & 137) != 0) {
        // 0x1ee08
        return result;
    }
    if (v4 < 0 || (v3 & 175) != 0) {
        // 0x1ee08
        return result;
    }
    if ((v1 & 192) == 0 == v4 == 0 == v5 == 0) {
        // 0x1edf8
        *v2 = (0x1000000 * v1 / 0x1000000 >> (int32_t)&g24) + (int32_t)&g33;
    }
    // 0x1ee08
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1ee12 - 0x1ee42
// Line range:    2386 - 2420
char BLACKWIDOW_EnableLoopThrough(int64_t ptCommunication, char bEnable) {
    // 0x1ee12
    int64_t v1; // 0x1ee12
    *(int32_t *)ptCommunication = __asm_insd((int16_t)v1);
    return unknown_fffffffff0777964();
}

// Address range: 0x1ee42 - 0x1eec6
int64_t BLACKWIDOW_EnableLoopThrough2(int64_t a1, int64_t * a2) {
    // 0x1ee42
    mcount();
    if (a1 == 0) {
        CheckThresholdValidity(0);
    }
    int32_t v1 = 0; // bp-32, 0x1ee69
    int64_t result = 0; // 0x1ee9c
    if ((char)(int64_t)&v1 == 0) {
        CheckThresholdValidity(a1);
        result = v1 & 247;
    }
    // 0x1ee9e
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1eecb - 0x1eede
// Line range:    2443 - 2454
int64_t BLACKWIDOW_GetXtalFreqHz(int64_t ptCommunication) {
    // 0x1eecb
    int64_t result; // 0x1eecb
    *(char *)result = 2 * (char)result;
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1eede - 0x1eef1
// Line range:    2471 - 2484
void BLACKWIDOW_SetXtalFreqHz(int64_t ptCommunication, int64_t ulFreqHz) {
    // 0x1eede
    return;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1eef1 - 0x1eefb
// Line range:    2595 - 2625
char CheckThresholdValidity(int64_t ptThrehold) {
    // 0x1eef1
    int64_t result; // 0x1eef1
    return result;
}

// Address range: 0x1eefb - 0x1ef0e
int64_t BLACKWIDOW_GetXtalFreqHz2(int64_t a1) {
    // 0x1eefb
    mcount();
    return *(int64_t *)(*(int64_t *)(a1 + 40) + 8);
}

// Address range: 0x1ef0e - 0x1ef17
int64_t BLACKWIDOW_SetXtalFreqHz2(void) {
    // 0x1ef0e
    return mcount();
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1ef1a - 0x1ef21
// Line range:    1017 - 1055
char BLACKWIDOW_ConfigureGainMode(int64_t ptCommunication, int64_t ptThrehold, int64_t ptGainModeConfiguration) {
    // 0x1ef1a
    int64_t result; // 0x1ef1a
    char * v1 = (char *)(result - 119); // 0x1ef1a
    int64_t v2; // 0x1ef1a
    *v1 = *v1 - (char)v2;
    return result;
}

// Address range: 0x1ef21 - 0x1ef4a
int64_t CheckThresholdValidity2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1ef21
    int64_t result; // 0x1ef21
    return result;
}

// Address range: 0x1ef4a - 0x1f028
int64_t BLACKWIDOW_ConfigureGainMode2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1ef4a
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 40); // 0x1ef6b
    int64_t result = CheckThresholdValidity2(a2, a2, a3 & -256 | (int64_t)(a2 == 0)); // 0x1ef88
    int64_t v2; // 0x1ef4a
    *(int32_t *)(v1 + 16) = (int32_t)v2;
    *(int32_t *)(v1 + 20) = *(int32_t *)(a2 + (int64_t)&g86);
    uint32_t v3 = *(int32_t *)(a2 + (int64_t)&g95); // 0x1efa7
    *(int32_t *)(v1 + 24) = v3;
    *(int64_t *)(v1 + 28) = (int64_t)v3;
    *(int64_t *)(v1 + 36) = *(int64_t *)(a3 + (int64_t)&g95);
    *(int64_t *)(v1 + 44) = *(int64_t *)(a3 + (int64_t)&g2);
    *(int64_t *)(v1 + 52) = *(int64_t *)(a3 + (int64_t)&g13);
    *(int64_t *)(v1 + 60) = *(int64_t *)(a3 + (int64_t)&g26);
    *(int64_t *)(v1 + 68) = *(int64_t *)(a3 + 40);
    *(int64_t *)(v1 + 76) = *(int64_t *)(a3 + 48);
    *(int64_t *)(v1 + 84) = *(int64_t *)(a3 + 56);
    *(int64_t *)(v1 + 92) = *(int64_t *)(a3 + 64);
    *(int64_t *)(v1 + 100) = *(int64_t *)(a3 + 72);
    *(int64_t *)(v1 + 108) = *(int64_t *)(a3 + 80);
    *(int64_t *)(v1 + 116) = *(int64_t *)(a3 + 88);
    *(int64_t *)(v1 + 124) = *(int64_t *)(a3 + 96);
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1f028 - 0x1f04c
// Line range:    2641 - 2654
void LeftShift(int64_t * ulNumMSB, int64_t * ulNumLSB) {
    // 0x1f028
    int64_t v1; // 0x1f028
    int64_t v2; // 0x1f028
    *(int64_t *)(v1 + 140) = *(int64_t *)(v2 + 112);
    *(int64_t *)(v1 + 148) = *(int64_t *)(v2 + 120);
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1f050 - 0x1f058
// Line range:    2664 - 2683
void Add(int64_t * pulResMSB, int64_t * pulResLSB, int64_t ulAddMSB, int64_t ulAddLSB) {
    // 0x1f050
    int64_t v1; // 0x1f050
    char * v2 = (char *)(4 * ulAddLSB + 108 + v1); // 0x1f050
    *v2 = *v2 | (char)ulAddLSB;
}

// Address range: 0x1f058 - 0x1f080
int64_t LeftShift2(int64_t a1, uint64_t a2) {
    // 0x1f058
    mcount();
    *(int64_t *)a1 = (a2 >> (uint64_t)(int64_t)&g24) + a1 * (int64_t)&g25;
    int64_t result = 2 * a2 & 0xfffffffe; // 0x1f078
    *(int64_t *)a2 = result;
    return result;
}

// Address range: 0x1f080 - 0x1f092
int64_t Add2(int64_t a1, int64_t result) {
    // 0x1f080
    mcount();
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1f094 - 0x1f0c4
// Line range:    2711 - 2747
void Mult(int64_t ulOp1, int64_t ulOp2, int64_t * pulResMSB, int64_t * pulResLSB) {
    uint64_t v1 = (int64_t)pulResLSB;
    int64_t v2 = &g1; // 0x1f09e
    uint64_t v3; // 0x1f094
    uint64_t v4; // 0x1f094
    if (v4 < v3) {
        // 0x1f0a0
        v2 = 0xffffffff - v4 <= v1;
    }
    // 0x1f0b4
    *(int64_t *)ulOp2 = v4 * (int64_t)&g1 + v1;
    *(int64_t *)ulOp1 = (int64_t)pulResMSB * (int64_t)&g1 + ulOp1 + v2;
}

// Address range: 0x1f0c4 - 0x1f123
int64_t Mult2(int64_t a1, int64_t a2, int64_t * a3, int64_t * a4, int64_t * a5) {
    // 0x1f0c4
    return mcount();
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1f125 - 0x1f146
// Line range:    2749 - 2782
char IsBigger(int64_t ulValMSB, int64_t ulValLSB, int64_t ulWithMSB, int64_t ulWithLSB) {
    // 0x1f125
    int64_t v1; // 0x1f125
    Add2(*(int64_t *)(v1 - 64), ulValLSB);
    int64_t v2; // 0x1f125
    int64_t v3; // 0x1f125
    return LeftShift2(v2, v3);
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1f147 - 0x1f155
// Line range:    2784 - 2849
void Div(int64_t ulNumMSB, int64_t ulNumLSB, int64_t ulDenom, int64_t * pulResMSB, int64_t * pulResLSB) {
    // 0x1f147
    return;
}

// Address range: 0x1f155 - 0x1f177
int64_t IsBigger2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4) {
    // 0x1f155
    mcount();
    if (a1 > a3) {
        // 0x1f175
        return &g1;
    }
    int64_t result = 0; // 0x1f16d
    if (a1 >= a3) {
        // 0x1f16f
        result = a2 > a4;
    }
    // 0x1f175
    return result;
}

// Address range: 0x1f177 - 0x1f2b7
int64_t Div2(int64_t a1, int64_t a2, int64_t result, int64_t * a4, int64_t * a5) {
    // 0x1f177
    mcount();
    *a4 = 0;
    *a5 = 0;
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1f2b9 - 0x1f2e9
// Line range:    3187 - 3329
char BLACKWIDOW_SetEnableBlocks(int64_t ptCommunication, int64_t ptEnableBlocks) {
    // 0x1f2b9
    int64_t v1; // 0x1f2b9
    int64_t v2 = v1 - 56; // 0x1f2bc
    int64_t v3; // 0x1f2b9
    *(int32_t *)v2 = (int32_t)v3;
    int64_t v4 = *(int64_t *)(v1 - 48); // 0x1f2c3
    int64_t v5; // 0x1f2b9
    int64_t v6; // 0x1f2b9
    return IsBigger2(v5, v6, v4, *(int64_t *)v2);
}

// Address range: 0x1f2e9 - 0x1f5af
int64_t BLACKWIDOW_SetEnableBlocks2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1f2e9
    mcount();
    unsigned char v1 = *(char *)(a2 + (int64_t)&g33); // 0x1f3fb
    unsigned char v2 = *(char *)(a2 + (int64_t)&g25); // 0x1f40a
    unsigned char v3 = *(char *)(a2 + (int64_t)&g1); // 0x1f429
    unsigned char v4 = *(char *)(a2 + (int64_t)&g97); // 0x1f580
    unsigned char v5 = *(char *)(a2 + (int64_t)&g98); // 0x1f590
    int64_t v6; // 0x1f2e9
    return ((int64_t)v5 & (int64_t)(int32_t)&g1) << (int64_t)&g91 | ((int64_t)v4 << (int64_t)&g94) % 256 | 0x100000000000000 * (int64_t)((int32_t)v1 << (int32_t)&g94 & 128 | ((int32_t)v6 & (int32_t)&g1 & 255) << (int32_t)&g33 | ((int32_t)v2 & (int32_t)&g1) << (int32_t)&g89 | ((int32_t)v3 & (int32_t)&g1) << (int32_t)&g25) / 0x100000000000000 & -193;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1f5b3 - 0x1f5e3
// Line range:    3348 - 3465
char BLACKWIDOW_GetEnableBlocks(int64_t ptCommunication, int64_t ptEnableBlocks) {
    // 0x1f5b3
    int64_t v1; // 0x1f5b3
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x1f5b3
    char * v3 = (char *)(v2 - 71); // 0x1f5b5
    int64_t result; // 0x1f5b3
    *v3 = *v3 + (char)result;
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int64_t v5 = result;
    *(char *)v5 = *(char *)&result + (char)v5;
    return result;
}

// Address range: 0x1f5e3 - 0x1f7a3
int64_t BLACKWIDOW_GetEnableBlocks2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1f5e3
    mcount();
    *(char *)(a2 + (int64_t)&g91) = 0;
    *(char *)(a2 + (int64_t)&g94) = 0;
    char v1 = 0; // bp-32, 0x1f663
    *(char *)(a2 + (int64_t)&g33) = 0;
    *(char *)(a2 + (int64_t)&g25) = 0;
    *(char *)a2 = 0;
    *(char *)(a2 + (int64_t)&g1) = 0;
    *(char *)(a2 + (int64_t)&g86) = v1;
    *(char *)(a2 + (int64_t)&g89) = v1;
    *(char *)(a2 + (int64_t)&g95) = v1;
    return &v1;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1f7a4 - 0x1f7d4
// Line range:    3483 - 3506
char BLACKWIDOW_SetPowerDetectorConfig(int64_t ptCommunication, int32_t eGainShiftValue) {
    // 0x1f7a4
    int64_t v1; // 0x1f7a4
    char result = v1; // 0x1f7ac
    if (result != 0) {
        // 0x1f7b0
        int64_t v2; // 0x1f7a4
        uint64_t v3 = *(int64_t *)(v2 - 24); // 0x1f7b0
        int64_t v4; // 0x1f7a4
        *(char *)(v4 + (int64_t)&g97) = (char)(v3 >> (int64_t)&g94) & (char)&g1;
        *(char *)(v4 + (int64_t)&g98) = (char)(v3 >> (int64_t)&g91) & (char)&g1;
    }
    // 0x1f7cb
    return result;
}

// Address range: 0x1f7d4 - 0x1f7f2
int64_t BLACKWIDOW_SetPowerDetectorConfig2(int64_t a1, int64_t a2) {
    // 0x1f7d4
    mcount();
    return 0;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1f7f4 - 0x1f824
// Line range:    3523 - 3574
char BLACKWIDOW_GetPowerDetect(int64_t ptCommunication, int32_t * ptPowerDetect) {
    // 0x1f7f4
    int64_t v1; // 0x1f7f4
    return (char)v1 & (char)&g95;
}

// Address range: 0x1f7f7 - 0x1f822
int64_t function_1f7f7(void) {
    // 0x1f7f7
    int64_t v1; // 0x1f7f7
    *(char *)v1 = 2 * (char)v1;
    uint64_t v2 = v1 + 36; // 0x1f7fb
    int64_t result = v2 % 256 | v1 & -256; // 0x1f7fb
    int32_t * v3 = (int32_t *)result; // 0x1f7fd
    *v3 = *v3 + (int32_t)result;
    char * v4 = (char *)result; // 0x1f7ff
    *v4 = *v4 + (char)v2;
    return result;
}

// Address range: 0x1f824 - 0x1f91c
int64_t BLACKWIDOW_GetPowerDetect2(int64_t a1, int32_t * a2) {
    // 0x1f824
    mcount();
    *a2 = 0;
    int32_t v1; // bp-32, 0x1f824
    return &v1;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1f920 - 0x1f950
// Line range:    1212 - 1274
char BLACKWIDOW_GetGainMode(int64_t ptCommunication, int64_t ptThrehold, int32_t * peGainMode) {
    // 0x1f920
    int64_t v1; // 0x1f920
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x1f920
    char * v3 = (char *)(v2 - 71); // 0x1f922
    int64_t result; // 0x1f920
    *v3 = *v3 + (char)result;
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int64_t v5 = result;
    *(char *)v5 = *(char *)&result + (char)v5;
    return result;
}

// Address range: 0x1f950 - 0x1f9d0
int64_t BLACKWIDOW_GetGainMode2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1f950
    mcount();
    int32_t v1 = 1023; // bp-44, 0x1f989
    CheckThresholdValidity2(a2, a2, a3);
    int64_t result = BLACKWIDOW_GetPowerDetect2(a1, &v1); // 0x1f9a3
    *(int32_t *)(*(int64_t *)(a1 + 40) + 164) = v1;
    int64_t v2; // 0x1f950
    if (*(int32_t *)&v2 < v1) {
        // 0x1f9d0
        return result;
    }
    // 0x1f9bf
    *(int32_t *)a3 = 0;
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1f9d3 - 0x1fa03
// Line range:    3592 - 3712
char BLACKWIDOW_SetGainLowCurrentConfig(int64_t ptCommunication, int64_t ptGainLowCurrent) {
    // 0x1f9d3
    uint64_t v1; // 0x1f9d3
    int64_t v2; // 0x1f9d3
    *(char *)v1 = (char)v2 + (char)v1;
    int64_t result; // 0x1f9d3
    int64_t v3 = result;
    *(char *)v3 = *(char *)&result + (char)v3;
    char * v4 = (char *)(v1 + 57); // 0x1f9d9
    char v5 = *v4; // 0x1f9d9
    int64_t v6; // 0x1f9d3
    *v4 = v5 + (char)(-1 - (char)v6 < (char)(v1 >> (int64_t)&g95)) + (char)result;
    result &= ((int64_t)(char)&g95 | -256);
    int64_t v7; // 0x1f9d3
    *(int32_t *)v7 = (int32_t)&g33 - 1;
    return result;
}

// Address range: 0x1fa03 - 0x1fccc
int64_t BLACKWIDOW_SetGainLowCurrentConfig2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1fa03
    mcount();
    int32_t v1 = 0; // bp-32, 0x1fa19
    int32_t result = 0; // 0x1fa31
    if (((char)(a1 == 0 || a2 == 0) || (char)&g1) != 0) {
        // 0x1fa33
        v1 = 0;
        result = 0;
        if ((char)(int64_t)&v1 != 0) {
            char v2 = *(char *)(a2 + (int64_t)&g86); // 0x1fa6c
            int32_t v3 = 0; // 0x1fa70
            if (v2 == (char)&g1) {
                // 0x1fa72
                v1 = 64;
                v3 = 64;
            }
            char v4 = *(char *)(a2 + (int64_t)&g89); // 0x1fa7a
            int32_t v5 = v3; // 0x1fa7e
            if (v4 != (char)&g1) {
                // 0x1fa80
                v5 = v3 | 2;
                v1 = v5;
            }
            char v6 = *(char *)(a2 + (int64_t)&g91); // 0x1fa85
            result = v5;
            if (v6 == (char)&g1) {
                int32_t v7 = v5 | 16;
                v1 = v7;
                result = v7;
            }
        }
    }
    // 0x1fa90
    int64_t v8; // 0x1fa03
    uint32_t v9 = (int32_t)v8;
    if (v9 == (int32_t)&g1) {
        // 0x1fb49
        return result;
    }
    if (v9 < (int32_t)&g1) {
        // 0x1fabc
        return result;
    }
    if (v9 == (int32_t)&g25) {
        // 0x1fbd6
        return (int64_t)result | (int64_t)&g1;
    }
    if (v9 == (int32_t)&g33) {
        // 0x1fc6b
        return (int64_t)result | (int64_t)&g1;
    }
    // 0x1fab2
    return 0;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1fcd0 - 0x1fd00
// Line range:    3730 - 3834
char BLACKWIDOW_GetGainLowCurrentConfig(int64_t ptCommunication, int64_t ptGainLowCurrent) {
    // 0x1fcd0
    int64_t v1; // 0x1fcd0
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x1fcd0
    char * v3 = (char *)(v2 - 71); // 0x1fcd2
    int64_t result; // 0x1fcd0
    *v3 = *v3 + (char)result;
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int64_t v5 = result;
    *(char *)v5 = *(char *)&result + (char)v5;
    return result;
}

// Address range: 0x1fd00 - 0x1fdd2
int64_t BLACKWIDOW_GetGainLowCurrentConfig2(int64_t a1, int64_t a2) {
    // 0x1fd00
    mcount();
    char v1 = 0; // bp-32, 0x1fd16
    int64_t result = &v1;
    if (a1 == 0 || a2 == 0 || (char)result == 0) {
        // 0x1fd79
        *(int32_t *)a2 = (int32_t)false;
        return result;
    }
    // 0x1fd73
    *(char *)(a2 + (int64_t)&g86) = 0;
    *(char *)(a2 + (int64_t)&g89) = (char)((v1 & 2) == 0);
    *(char *)(a2 + (int64_t)&g91) = (char)((v1 & 16) != 0);
    if (v1 % 2 != 0) {
        // 0x1fdb9
        return result;
    }
    // 0x1fd79
    *(int32_t *)a2 = (int32_t)((v1 & 64) != 0);
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x1fdd6 - 0x1fe06
// Line range:    3855 - 4010
char BLACKWIDOW_SetGainConfig(int64_t ptCommunication, int64_t ptGain) {
    char * v1 = (char *)(ptGain + (int64_t)&g91); // 0x1fdd6
    uint64_t v2; // 0x1fdd6
    *v1 = *v1 + (char)(v2 >> (int64_t)&g95);
    int64_t v3; // 0x1fdd6
    char result = v3; // 0x1fde5
    if (result != 0) {
        // 0x1fde9
        int64_t v4; // 0x1fdd6
        int64_t v5 = *(int64_t *)(v4 - 24) & 64; // 0x1fded
        int32_t v6 = v5; // 0x1fdf4
        int64_t v7; // 0x1fdd6
        *(int32_t *)v7 = (v6 | 3) - ((int32_t)(v5 == 0) | v6);
    }
    // 0x1fdfd
    return result;
}

// Address range: 0x1fe06 - 0x2004c
int64_t BLACKWIDOW_SetGainConfig2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1fe06
    mcount();
    return 0;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x20050 - 0x20080
// Line range:    1126 - 1178
char BLACKWIDOW_SetGainMode(int64_t ptCommunication, int32_t eGainMode) {
    // 0x20050
    int64_t v1; // 0x20050
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x20050
    char * v3 = (char *)(v2 - 71); // 0x20052
    int64_t result; // 0x20050
    *v3 = *v3 + (char)result;
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int64_t v5 = result;
    *(char *)v5 = *(char *)&result + (char)v5;
    return result;
}

// Address range: 0x20080 - 0x20162
int64_t BLACKWIDOW_SetGainMode2(int64_t a1, uint32_t a2) {
    // 0x20080
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 40); // 0x2009f
    if (a2 == (int32_t)&g1) {
        // 0x200f3
        return *(int64_t *)(v1 + 84);
    }
    if (a2 < (int32_t)&g1) {
        // 0x200ce
        return *(int64_t *)(v1 + 52);
    }
    if (a2 == (int32_t)&g25) {
        // 0x20115
        return *(int64_t *)(v1 + 116);
    }
    // 0x20137
    return *(int64_t *)(v1 + 132);
}

// Address range: 0x2014d - 0x2014f
int64_t function_2014d(void) {
    // 0x2014d
    int64_t result; // 0x2014d
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x20169 - 0x20199
// Line range:    1072 - 1108
char BLACKWIDOW_SetGain(int64_t ptCommunication) {
    // 0x20169
    int64_t v1; // 0x20169
    int64_t v2; // 0x20169
    char result = BLACKWIDOW_SetGainConfig2(ptCommunication, v1, v2); // 0x2016e
    if (result != 0) {
        // 0x20172
        int64_t v3; // 0x20169
        int64_t v4; // 0x20169
        *(int32_t *)(v4 + 160) = (int32_t)v3;
    }
    // 0x20179
    return result;
}

// Address range: 0x20199 - 0x201c0
int64_t BLACKWIDOW_SetGain2(int64_t a1) {
    // 0x20199
    mcount();
    return (int64_t)*(int32_t *)(*(int64_t *)(a1 + 40) + 16);
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x201c2 - 0x201f2
// Line range:    4028 - 4249
char BLACKWIDOW_SetXtalSettings(int64_t ptCommunication, int64_t ptXtalSettings) {
    // 0x201c2
    int64_t v1; // 0x201c2
    int64_t v2 = v1 - (int64_t)&g1; // 0x201c2
    int64_t v3; // 0x201c2
    unsigned char v4 = (char)v3; // 0x201c4
    bool v5; // 0x201c2
    bool v6 = v5 ? v4 - 119 + (char)v5 <= v4 : v4 > 118; // 0x201c4
    __asm_in_625(-117);
    char * v7 = (char *)(v2 - 0x72b717bb); // 0x201ca
    *v7 = *v7 - (char)v2 + (char)v6;
    int64_t v8; // 0x201c2
    __asm_in((int16_t)v8);
    char result = 0; // 0x201de
    int64_t v9; // 0x201c2
    if ((char)BLACKWIDOW_GetGainMode2(ptCommunication, v9 - 32, v8) != 0) {
        // 0x201e0
        int64_t v10; // 0x201c2
        result = BLACKWIDOW_SetGainMode2(v10, *(int32_t *)(v9 - 20));
    }
    // 0x201eb
    return result;
}

// Address range: 0x201f2 - 0x20419
int64_t BLACKWIDOW_SetXtalSettings2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x201f2
    mcount();
    uint32_t v1 = *(int32_t *)(a2 + (int64_t)"GNU"); // 0x20350
    int32_t v2 = 0; // 0x20356
    if (v1 <= (int32_t)&g33) {
        // 0x2035f
        v2 = (int32_t)((int64_t)v1 << (int64_t)&g91) & 192;
    }
    uint32_t v3 = *(int32_t *)(a2 + (int64_t)&g2); // 0x20370
    int32_t v4 = v2; // 0x20376
    if (v3 <= (int32_t)&g33) {
        // 0x2037f
        v4 = v2 | (int32_t)((int64_t)(v3 & (int32_t)&g33) << (int64_t)&g86);
    }
    uint32_t v5 = *(int32_t *)(a2 + (int64_t)&g7); // 0x2038a
    int32_t v6 = v4; // 0x20390
    if (v5 <= (int32_t)&g33) {
        // 0x20399
        v6 = v4 | (int32_t)((int64_t)(v5 & (int32_t)&g33) << (int64_t)&g25);
    }
    int32_t v7 = v6;
    char v8 = *(char *)(a2 + (int64_t)&g13); // 0x203a4
    int32_t v9 = v8 != (char)&g1 ? v7 : v7 | (int32_t)&g25;
    char v10 = *(char *)(a2 + (int64_t)&g16); // 0x203af
    int32_t result = v10 != (char)&g1 ? v9 : v9 | (int32_t)&g1;
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x2041d - 0x2044d
// Line range:    4267 - 4421
char BLACKWIDOW_GetXtalSettings(int64_t ptCommunication, int64_t ptXtalSettings) {
    // 0x2041d
    int64_t v1; // 0x2041d
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x2041d
    char * v3 = (char *)(v2 - 71); // 0x2041f
    int64_t result; // 0x2041d
    *v3 = *v3 + (char)result;
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int64_t v5 = result;
    *(char *)v5 = *(char *)&result + (char)v5;
    return result;
}

// Address range: 0x2044d - 0x2055f
int64_t BLACKWIDOW_GetXtalSettings2(int64_t a1, int64_t a2) {
    // 0x2044d
    mcount();
    char v1 = 0; // bp-32, 0x2046f
    *(char *)a2 = 0;
    *(char *)(a2 + (int64_t)&g1) = (char)((v1 & 64) == 0);
    *(char *)(a2 + (int64_t)&g25) = (char)((v1 & 32) == 0);
    *(int32_t *)(a2 + (int64_t)&g86) = (int32_t)((int64_t)v1 >> (int64_t)&g33) & (int32_t)&g33;
    *(char *)(a2 + (int64_t)&g95) = (char)((v1 & 4) != 0);
    *(char *)(a2 + (int64_t)&g97) = (char)((v1 & 2) != 0);
    *(char *)(a2 + (int64_t)&g98) = (char)(v1 % 2 != 0);
    v1 = 0;
    *(int32_t *)(a2 + (int64_t)"GNU") = 0;
    *(int32_t *)(a2 + (int64_t)&g2) = 0;
    *(int32_t *)(a2 + (int64_t)&g7) = 0;
    *(char *)(a2 + (int64_t)&g13) = 0;
    *(char *)(a2 + (int64_t)&g16) = (char)(v1 % 2 != 0);
    return &v1;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x20563 - 0x20593
// Line range:    4442 - 4535
char BLACKWIDOW_SetXtalExtClkSettings(int64_t ptCommunication, char extClkOvr, char extClkEn, int32_t extClkFiltSel, int32_t extDivSel) {
    // 0x20563
    int64_t v1; // 0x20563
    char result = v1;
    *(char *)v1 = 2 * result;
    int64_t v2; // 0x20563
    int64_t v3 = *(int64_t *)(v2 - 24); // 0x20583
    int64_t v4; // 0x20563
    *(int32_t *)(v4 + (int64_t)&g19) = (int32_t)v3;
    return result;
}

// Address range: 0x20593 - 0x20681
int64_t BLACKWIDOW_SetXtalExtClkSettings2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x20593
    mcount();
    int32_t v1 = (uint32_t)(int32_t)a4 > (uint32_t)(int32_t)&g33 ? 0 : (int32_t)((a4 & (int64_t)(uint32_t)(int32_t)&g33) << (uint64_t)(int64_t)&g86);
    int32_t v2 = v1; // 0x20634
    if ((int32_t)a5 <= (int32_t)&g33) {
        // 0x2063d
        v2 = v1 | (int32_t)((a5 & (int64_t)(int32_t)&g33) << (int64_t)&g25);
    }
    int32_t v3 = v2;
    int32_t v4 = (char)a3 != (char)&g1 ? v3 : v3 | (int32_t)&g25;
    int32_t result = (char)a2 != (char)&g1 ? v4 : v4 | (int32_t)&g1;
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x20685 - 0x206b5
// Line range:    4556 - 4617
char BLACKWIDOW_GetXtalExtClkSettings(int64_t ptCommunication, char * pExtClkOvr, char * pExtClkEn, int32_t * pExtClkFiltSel, int32_t * pExtDivSel) {
    // 0x20685
    int64_t v1; // 0x20685
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// Address range: 0x206b5 - 0x2072d
int64_t BLACKWIDOW_GetXtalExtClkSettings2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x206b5
    mcount();
    *(int32_t *)a4 = 0;
    int64_t v1; // bp-48, 0x206b5
    return &v1;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x2072d - 0x2075d
// Line range:    4635 - 4730
char BLACKWIDOW_SetLoConfig(int64_t ptCommunication, int64_t ptLoSettings) {
    // 0x2072d
    int64_t v1; // 0x2072d
    uint64_t v2; // 0x2072d
    *(int32_t *)v1 = (int32_t)(v2 >> (uint64_t)(int64_t)&g25) & (int32_t)&g33;
    int64_t v3; // 0x2072d
    *(char *)v3 = (char)(((int32_t)v2 & (int32_t)&g25) != 0);
    int64_t v4; // 0x2072d
    int64_t v5 = *(int64_t *)(v4 - 40); // 0x20741
    int64_t v6; // 0x2072d
    *(char *)v6 = (char)v5 & (char)&g1;
    int64_t result; // 0x2072d
    return result;
}

// Address range: 0x2075d - 0x20919
int64_t BLACKWIDOW_SetLoConfig2(int64_t a1, int64_t * a2, int64_t a3) {
    // 0x2075d
    mcount();
    unsigned char result = *(char *)((int64_t)a2 + (int64_t)&g94); // 0x20908
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x2091d - 0x2094d
// Line range:    4748 - 4833
char BLACKWIDOW_GetLoConfig(int64_t ptCommunication, int64_t ptLoSettings) {
    // 0x2091d
    int64_t v1; // 0x2091d
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x2091d
    char * v3 = (char *)(v2 - 71); // 0x2091f
    int64_t result; // 0x2091d
    *v3 = *v3 + (char)result;
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int64_t v5 = result;
    *(char *)v5 = *(char *)&result + (char)v5;
    return result;
}

// Address range: 0x2094d - 0x20a82
int64_t BLACKWIDOW_GetLoConfig2(int64_t a1, int64_t * a2, int64_t a3) {
    int64_t v1 = (int64_t)a2;
    mcount();
    int32_t v2 = 0; // bp-32, 0x20979
    *(char *)a2 = 0;
    *(char *)(v1 + (int64_t)&g1) = 0;
    *(char *)(v1 + (int64_t)&g25) = 0;
    *(char *)(v1 + (int64_t)&g33) = 0;
    *(char *)(v1 + (int64_t)&g86) = 0;
    *(char *)(v1 + (int64_t)&g89) = 0;
    *(char *)(v1 + (int64_t)&g95) = 0;
    *(char *)(v1 + (int64_t)&g91) = 0;
    uint64_t v3 = (int64_t)v2; // 0x20a45
    *(char *)(v1 + (int64_t)&g97) = (char)(v3 >> (int64_t)&g94) & (char)&g1;
    *(char *)(v1 + (int64_t)&g98) = (char)(v3 >> (int64_t)&g89) & (char)&g1;
    *(char *)(v1 + (int64_t)&g99) = (char)(v3 >> (int64_t)&g33) & (char)&g1;
    *(char *)(v1 + (int64_t)"GNU") = (char)(v3 >> (int64_t)&g25) & (char)&g1;
    return &v2;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x20a86 - 0x20ab6
// Line range:    4851 - 4947
char BLACKWIDOW_GetVcoStatus(int64_t ptCommunication, int64_t ptStatus) {
    // 0x20a86
    int64_t v1; // 0x20a86
    char result = v1;
    *(char *)v1 = 2 * result;
    int64_t v2; // 0x20a86
    int64_t v3 = *(int64_t *)(v2 - 24); // 0x20aa6
    int64_t v4; // 0x20a86
    *(char *)(v4 + (int64_t)&g94) = (char)v3;
    return result;
}

// Address range: 0x20ab6 - 0x20c67
int64_t BLACKWIDOW_GetVcoStatus2(int64_t a1, int32_t * a2, int64_t a3) {
    int64_t v1 = (int64_t)a2;
    mcount();
    int32_t v2 = 0; // bp-32, 0x20ae2
    *a2 = 0;
    *(char *)(v1 + (int64_t)&g86) = 0;
    *(char *)(v1 + (int64_t)&g89) = 0;
    *(int32_t *)(v1 + (int64_t)&g95) = 0;
    *(char *)(v1 + (int64_t)"GNU") = 0;
    *(char *)(v1 + (int64_t)"NU") = 0;
    uint64_t v3 = (int64_t)v2; // 0x20bcb
    *(char *)(v1 + (int64_t)&g103) = (char)(v3 >> (int64_t)&g94) & (char)&g1;
    *(char *)(v1 + (int64_t)&g105) = (char)(v3 >> (int64_t)&g91) & (char)&g1;
    *(int32_t *)(v1 + (int64_t)&g2) = (int32_t)(v3 >> (int64_t)&g89) & (int32_t)&g1;
    *(char *)(v1 + (int64_t)&g7) = (char)(v3 >> (int64_t)&g86) & (char)&g1;
    *(char *)(v1 + (int64_t)&g9) = (char)v2;
    return &v2;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x20c68 - 0x20c98
// Line range:    1323 - 2543
char BLACKWIDOW_GetStatus(int64_t ptCommunication, int64_t ptStatus) {
    // 0x20c68
    int64_t v1; // 0x20c68
    uint64_t v2 = (int64_t)*(int32_t *)(v1 - 24); // 0x20c68
    int64_t v3; // 0x20c68
    *(char *)(v3 + (int64_t)&g10) = (char)(v2 >> (int64_t)&g94) & (char)&g1;
    *(char *)(v3 + (int64_t)&g12) = (char)(v2 >> (int64_t)&g89) & (char)&g1;
    *(char *)(v3 + (int64_t)&g13) = (char)(v2 >> (int64_t)&g86) & (char)&g1;
    int64_t result; // 0x20c68
    return result;
}

// Address range: 0x20c98 - 0x20dcd
int64_t BLACKWIDOW_GetStatus2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x20c98
    mcount();
    int32_t v1 = 0; // bp-88, 0x20ccc
    *(char *)(a2 + (int64_t)&g3) = 0;
    BLACKWIDOW_GetVcoStatus2(a1, &v1, 0);
    *(char *)a2 = 0;
    *(char *)(a2 + (int64_t)&g1) = 0;
    *(int32_t *)(a2 + (int64_t)&g86) = (int32_t)&g25;
    *(char *)(a2 + (int64_t)&g95) = 0;
    *(char *)(a2 + (int64_t)&g97) = 0;
    *(char *)(a2 + (int64_t)&g98) = 0;
    *(char *)(a2 + (int64_t)&g99) = 0;
    *(int32_t *)(a2 + (int64_t)"GNU") = (int32_t)&g25;
    *(char *)(a2 + (int64_t)&g2) = 0;
    *(int32_t *)(a2 + (int64_t)&g7) = (int32_t)&g89;
    int64_t v2; // bp-56, 0x20c98
    BLACKWIDOW_GetLoConfig2(a1, &v2, 0);
    return 0;
}

// Address range: 0x20dcd - 0x20dd6
int64_t function_20dcd(void) {
    // 0x20dcd
    int64_t v1; // 0x20dcd
    *(int32_t *)(v1 + (int64_t)&g7) = (int32_t)&g86;
    int64_t result; // 0x20dcd
    return result;
}

// Address range: 0x20dd6 - 0x20e01
int64_t function_20dd6(void) {
    // 0x20dd6
    int64_t v1; // 0x20dd6
    int64_t v2; // 0x20dd6
    if (*(char *)(v1 - 39) != (char)&g1) {
        // 0x20dee
        *(int32_t *)(v2 + (int64_t)&g7) = (int32_t)&g25;
        int64_t result; // 0x20dd6
        return result;
    }
    // 0x20ddf
    int64_t result2; // 0x20dd6
    if (*(char *)(v1 - 38) != (char)&g1) {
        int64_t v3; // 0x20dd6
        int64_t v4; // 0x20dd6
        result2 = BLACKWIDOW_SetPllDividerConfig(v3, v4);
    }
    // 0x20de5
    *(int32_t *)(v2 + (int64_t)&g7) = (int32_t)&g33;
    return result2;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x20e01 - 0x20e31
// Line range:    4966 - 5025
char BLACKWIDOW_SetPllDividerConfig(int64_t ptCommunication, int64_t ptPllDividerSettings) {
    // 0x20e01
    int64_t v1; // 0x20e01
    if (*(char *)(v1 - 38) == 0) {
        // 0x20e07
        int64_t v2; // 0x20e01
        *(int32_t *)(v2 + (int64_t)&g7) = (int32_t)&g1;
    }
    // 0x20e21
    int64_t result; // 0x20e01
    return result;
}

// Address range: 0x20e31 - 0x20f1d
int64_t BLACKWIDOW_SetPllDividerConfig2(int64_t a1, int32_t * a2, int128_t a3) {
    // 0x20e31
    mcount();
    return 0;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x20f21 - 0x20f51
// Line range:    5044 - 5083
char BLACKWIDOW_GetPllDividerConfig(int64_t ptCommunication, int64_t ptPllDividerSettings) {
    // 0x20f21
    int64_t v1; // 0x20f21
    char v2 = v1;
    unsigned char result = 2 * v2; // 0x20f21
    *(char *)v1 = result;
    int64_t v3; // 0x20f21
    char * v4 = (char *)(v3 - 71); // 0x20f23
    *v4 = *v4 + v2;
    char * v5 = (char *)(v1 & -256 | (int64_t)result); // 0x20f28
    *v5 = *v5 + result;
    return result;
}

// Address range: 0x20f51 - 0x20ff8
int64_t BLACKWIDOW_GetPllDividerConfig2(int64_t a1, int32_t * a2, int64_t a3) {
    // 0x20f51
    mcount();
    *a2 = 0;
    *(int64_t *)((int64_t)a2 + (int64_t)&g95) = 0;
    int32_t v1; // bp-32, 0x20f51
    return &v1;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x20ffd - 0x2102d
// Line range:    5102 - 5137
char BLACKWIDOW_GetPllDsmOrderAndFractCorrect(int64_t ptCommunication, int32_t * peDsmOrder, int32_t * peDsmFrac) {
    // 0x20ffd
    int64_t v1; // 0x20ffd
    char * v2 = (char *)(v1 - 72); // 0x20ffd
    unsigned char v3 = *v2; // 0x20ffd
    int64_t v4; // 0x20ffd
    unsigned char v5 = v3 + (char)v4; // 0x20ffd
    *v2 = v5;
    int64_t result; // 0x20ffd
    char v6 = *(char *)&result; // 0x21000
    int64_t v7 = result;
    *(char *)v7 = v6 + (char)(v5 < v3) + (char)v7;
    int64_t v8 = result;
    *(char *)v8 = *(char *)&result + (char)v8;
    int64_t v9; // 0x20ffd
    int64_t v10; // 0x20ffd
    *(int64_t *)(v10 + (int64_t)&g2) = *(int64_t *)(v9 - 24);
    return result;
}

// Address range: 0x2102d - 0x210a2
int64_t BLACKWIDOW_GetPllDsmOrderAndFractCorrect2(int64_t a1, int64_t * a2, int32_t * a3) {
    // 0x2102d
    mcount();
    *a3 = 0;
    int32_t v1; // bp-48, 0x2102d
    return &v1;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x210a6 - 0x210d6
// Line range:    1437 - 1714
char BLACKWIDOW_GetPLLFrequency(int64_t ptCommunication, int64_t * pulPllFrequencyKhz) {
    // 0x210a6
    int64_t v1; // 0x210a6
    char result = v1;
    *(char *)v1 = 2 * result;
    int64_t v2; // 0x210a6
    int64_t v3; // 0x210a6
    *(int32_t *)v2 = (int32_t)*(int64_t *)(v3 - 40);
    return result;
}

// Address range: 0x210d6 - 0x21370
int64_t BLACKWIDOW_GetPLLFrequency2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x210d6
    mcount();
    int32_t v1 = &g25; // bp-152, 0x2111a
    int64_t v2 = 0; // bp-104, 0x21137
    int64_t v3 = 0; // bp-96, 0x2113f
    int64_t v4 = 0; // bp-88, 0x21147
    int64_t v5 = 0; // bp-80, 0x2114f
    int32_t v6 = &g25; // bp-64, 0x2115f
    int64_t v7; // bp-120, 0x210d6
    BLACKWIDOW_GetLoConfig2(a1, &v7, a3);
    int64_t v8; // 0x210d6
    int64_t v9 = (v8 ^ 0xffffffff) + v8; // 0x21185
    int64_t v10; // bp-60, 0x210d6
    BLACKWIDOW_GetPllDsmOrderAndFractCorrect2(a1, &v10, &v6);
    BLACKWIDOW_GetPllDividerConfig2(a1, &v1, (int64_t)&v6);
    uint64_t v11 = (int64_t)&g1; // 0x21232
    int64_t v12 = 128;
    v11 *= 2 * ((int64_t)&g86 + 1);
    int64_t v13 = v12 * 2 * ((int64_t)&g86 + 1); // 0x21239
    while (v13 * v11 < 0x19999999) {
        // 0x2122e
        v12 = v13;
        v11 *= 2 * ((int64_t)&g86 + 1);
        v13 = v12 * 2 * ((int64_t)&g86 + 1);
    }
    // 0x21254
    unsigned char v14; // 0x210d6
    int64_t v15 = v14 < (char)&g1; // 0x21176
    int64_t v16; // 0x210d6
    unsigned char v17; // 0x210d6
    int64_t v18 = (v16 ^ 0xffffffff) + v16 + (int64_t)(v17 < (char)&g1); // 0x21196
    unsigned char v19; // 0x210d6
    int64_t v20 = v9 + (int64_t)(v19 < (char)&g1) & (int64_t)(int32_t)&g25; // 0x2118b
    int64_t v21 = &g1; // 0x2125f
    v21 *= 2 * ((int64_t)&g86 + 1);
    while (v21 < v11) {
        // 0x21254
        v21 *= 2 * ((int64_t)&g86 + 1);
    }
    int64_t v22 = v15 + (int64_t)(char)&g89; // 0x21178
    int64_t v23 = v18 & (int64_t)(int32_t)&g86; // 0x21199
    int64_t v24 = 0; // 0x21292
    uint64_t v25 = v21;
    int64_t v26 = v25 >= v11 ? v25 : v25 * 2 * ((int64_t)&g86 + 1);
    v24 += (int64_t)&g1;
    while (v24 != (int64_t)&g2) {
        // 0x21274
        v25 = v26;
        v26 = v25 >= v11 ? v25 : v25 * 2 * ((int64_t)&g86 + 1);
        v24 += (int64_t)&g1;
    }
    int64_t v27 = (int32_t)&g1 > 0 ? v12 * (2 * ((int64_t)&g86 + 1) << (int64_t)&g25) : v13;
    uint64_t v28 = v1 != 0 ? v27 : v12 * 2 * 2 * ((int64_t)&g86 + 1);
    int64_t v29 = *(int64_t *)(*(int64_t *)(a1 + 40) + 8); // 0x2132f
    Mult2(v28 / (0x100000000 * (v23 * (int64_t)&g1 + v20 + 0x100000000000000 * v22 / 0x100000000000000) / 0x100000000), v29, &v2, &v4, &v2);
    return Div2(v2, v4, v26, &v3, &v5);
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x21371 - 0x213a1
// Line range:    448 - 3118
char BLACKWIDOW_SetFreq(int64_t ptCommunication, int64_t ulFreqkHz, int32_t loDiv) {
    // 0x21371
    int64_t v1; // 0x21371
    *(int64_t *)v1 = 0;
    int64_t result; // 0x21371
    return result;
}

// Address range: 0x213a1 - 0x219e6
int64_t BLACKWIDOW_SetFreq2(int64_t a1, uint64_t a2, int64_t * a3) {
    // 0x213a1
    mcount();
    int64_t * v1 = (int64_t *)(a1 + 40); // 0x213c3
    int32_t v2 = &g25; // bp-60, 0x213c7
    int32_t v3 = &g25; // bp-64, 0x213ce
    if (a2 > 0x2dc6c0 || a1 != 0 != *(int64_t *)(*v1 + 8) != 0) {
        // 0x218f3
        return 0;
    }
    int64_t v4 = BLACKWIDOW_GetPllDsmOrderAndFractCorrect2(a1, (int64_t *)&v2, &v3); // 0x2140f
    if ((char)v4 == 0) {
        // 0x218f3
        return v4 & 0xffffffff & 0xffffffff;
    }
    int64_t v5 = &v3; // 0x21404
    int32_t v6; // bp-120, 0x213a1
    int64_t result = BLACKWIDOW_GetLoConfig2(a1, (int64_t *)&v6, v5); // 0x21425
    int32_t v7 = (int64_t)a3; // 0x2142a
    int64_t v8; // 0x213a1
    if (v7 == 0) {
        // 0x2148b
        v6 = &g1;
        v8 = &g86;
        goto lab_0x214c6;
    } else {
        if (v7 == (int32_t)&g1) {
            // 0x2198e
            v6 = &g1;
            v8 = &g89;
            goto lab_0x214c6;
        } else {
            if (v7 == (int32_t)&g25) {
                // 0x2194e
                v6 = &g1;
                v8 = &g91;
                goto lab_0x214c6;
            } else {
                if (v7 == (int32_t)&g33) {
                    // 0x2190e
                    v6 = &g1;
                    v8 = (int16_t)&g94;
                    goto lab_0x214c6;
                } else {
                    if (a2 < 0x106739 || v7 == (int32_t)&g86) {
                        // 0x219ce
                        return result;
                    }
                    if (a2 < 0x12bce1) {
                        // 0x2190e
                        v6 = &g1;
                        v8 = (int16_t)&g94;
                        goto lab_0x214c6;
                    } else {
                        if (a2 < 0x15dda9) {
                            // 0x2194e
                            v6 = &g1;
                            v8 = &g91;
                            goto lab_0x214c6;
                        } else {
                            if (a2 < 0x1a3ec1) {
                                // 0x2198e
                                v6 = &g1;
                                v8 = &g89;
                                goto lab_0x214c6;
                            } else {
                                // 0x2148b
                                v6 = &g1;
                                v8 = &g86;
                                goto lab_0x214c6;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x214c6:
    // 0x214c6
    if ((char)result != 0) {
        // 0x214ca
        BLACKWIDOW_SetLoConfig2(a1, (int64_t *)&v6, v5);
    }
    int64_t v9 = v3 < (int32_t)&g1 ? (int64_t)(int32_t)&g31 + 1310 : 1310;
    int64_t v10 = v3 < (int32_t)&g1 ? (int64_t)(int32_t)&g105 + 1290 : 1290;
    int64_t v11 = v2 != (int32_t)&g1 ? v9 : v10;
    int64_t v12; // bp-72, 0x213a1
    int64_t v13; // bp-80, 0x213a1
    int64_t v14; // 0x213a1
    Mult2(a2 * ((int64_t)&g86 + 1 + ((int64_t)&g86 + 1) * (int64_t)&g86 << (int64_t)&g25) * v8, 0xf4240, &v12, &v13, (int64_t *)v14);
    int64_t v15; // bp-88, 0x213a1
    int128_t v16; // bp-96, 0x213a1
    Div2(v12, v13, 0, &v15, (int64_t *)&v16);
    int64_t v17; // 0x213a1
    int64_t v18; // 0x213a1
    if (*(int64_t *)(*v1 + 8) < 0x19bfcc1) {
        // 0x21607
        v17 = (int64_t)&g25 & -256 | (int64_t)&g33;
        v18 = &g25;
    } else {
        // 0x21634
        v17 = &g25;
        v18 = &g86;
        if (v11 != 0) {
            // 0x2164a
            v17 = (int64_t)&g25 & -256 | (int64_t)&g33;
            v18 = &g86;
        }
    }
    int64_t v19 = v17;
    int64_t v20 = v16; // 0x21683
    int64_t v21 = 0; // 0x21683
    int64_t v22; // 0x213a1
    if (v11 == 0) {
        uint64_t v23 = v19 * ((int64_t)&g86 + 1 + ((int64_t)&g86 + 1) * (int64_t)&g86 << (int64_t)&g25) / v18;
        if (v23 == 75) {
            // 0x216f1
            v22 = &g1;
            goto lab_0x21713;
        } else {
            if (v23 < 76) {
                if (v23 == 25) {
                    // 0x216dc
                    v22 = &g1;
                    goto lab_0x21713;
                } else {
                    if (v23 != 50) {
                        // 0x216d5
                        v22 = 0;
                        goto lab_0x21713;
                    } else {
                        // 0x216e7
                        v22 = &g1;
                        goto lab_0x21713;
                    }
                }
            } else {
                // 0x216c2
                v22 = &g1;
                switch (v23) {
                    case 100: {
                        goto lab_0x21713;
                    }
                    case 150: {
                        // 0x21705
                        v22 = &g1;
                        goto lab_0x21713;
                    }
                    default: {
                        // 0x216d5
                        v22 = 0;
                        goto lab_0x21713;
                    }
                }
            }
        }
    } else {
        goto lab_0x21730;
    }
  lab_0x21730:;
    int64_t v24 = v21; // 0x2173a
    if (v19 != (int64_t)&g25 && v19 != (int64_t)&g33) {
        // 0x21745
        v24 = v19 != (int64_t)&g1 ? 0 : v21 & 0xffffffff;
    }
    // 0x21761
    int64_t v25; // 0x213a1
    if (v18 == (int64_t)&g25) {
        // 0x21774
        v25 = v24;
    } else {
        // 0x21767
        v25 = 0;
        if (v18 == (int64_t)&g86) {
            // 0x21780
            v25 = v24;
        }
    }
    // 0x2178a
    int64_t v26; // 0x213a1
    int64_t v27; // 0x213a1
    if (v3 != 0) {
        // 0x21819
        v26 = v20;
        v27 = v25;
    } else {
        int64_t v28; // 0x213a1
        int64_t v29; // 0x213a1
        int64_t v30; // 0x213a1
        // 0x217de
        v28 = &g1;
        v30 = 0;
        v29 = -0x7a120;
        // 0x21807
        v26 = v29;
        v27 = v30 + v28 < 128 ? 0 : v25 & 0xffffffff;
    }
    int64_t v31 = v26; // 0x21845
    int64_t v32 = &g1; // 0x2187b
    int64_t v33 = v32; // 0x21883
    while (v32 != (int64_t)&g2) {
        // 0x2184f
        v31 *= 2;
        // 0x2187b
        v32 = v33 + (int64_t)&g1;
        v33 = v32;
    }
    // 0x21885
    if ((char)v27 == 0) {
        // 0x218f3
        return v27 & 0xffffffff;
    }
    // 0x218f3
    return 0;
  lab_0x21713:
    // 0x21713
    v20 = 0;
    v21 = v22;
    goto lab_0x21730;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x219e8 - 0x21a18
// Line range:    5154 - 5288
char BLACKWIDOW_ProgramVcoPor(int64_t ptCommunication) {
    // 0x219e8
    __asm_wait();
    int64_t result; // 0x219e8
    char * v1 = (char *)((result & 0xffffffff) - 57); // 0x219fd
    int64_t v2; // 0x219e8
    *v1 = *v1 + (char)v2;
    return result;
}

// Address range: 0x21a05 - 0x21a0e
int64_t function_21a05(void) {
    // 0x21a05
    int64_t v1; // 0x21a05
    *(char *)v1 = (char)v1;
    int64_t result; // 0x21a05
    int64_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0x21a18 - 0x21ede
int64_t BLACKWIDOW_ProgramVcoPor2(int64_t a1) {
    int64_t result = mcount() & -256 | (int64_t)(a1 != 0); // 0x21a2f
    if (a1 == 0) {
        // 0x21e84
        return result;
    }
    int32_t * v1 = NULL; // bp-32, 0x21a35
    int64_t result2 = (int64_t)&v1; // 0x21a3d
    if ((char)result2 == 0) {
        // 0x21e84
        return result2;
    }
    // 0x21a6e
    v1 = (int32_t *)((int64_t)&g26 | 128);
    if ((char)((int64_t)&g26 || 128) == 0) {
        // 0x21e84
        return (int64_t)&g26 | 128;
    }
    // 0x21d02
    v1 = (int32_t *)(((int64_t)&g26 | 128) & -256 | ((int64_t)&g26 | 128) & 63 | 192);
    result = ((int64_t)&g26 | 128) & -256 | ((int64_t)&g26 | 128) & 63 | 192;
    if ((char)(((int64_t)&g26 | 128) & -256 || ((int64_t)&g26 | 128) & 63 || 192) != 0) {
        // 0x21e02
        v1 = (int32_t *)((((int64_t)&g26 | 128) & -256 | ((int64_t)&g26 | 128) & 63 | 192) & -129);
        result = (((int64_t)&g26 | 128) & -256 | ((int64_t)&g26 | 128) & 63 | 192) & -129;
    }
    // 0x21e84
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x21ede - 0x21f0e
// Line range:    5358 - 5483
char BLACKWIDOW_ProgramVcoChannelChange(int64_t ptCommunication) {
    // 0x21ede
    int64_t result; // 0x21ede
    return result;
}

// Address range: 0x21f0e - 0x22225
int64_t BLACKWIDOW_ProgramVcoChannelChange2(int64_t a1) {
    // 0x21f0e
    mcount();
    char v1 = 0; // bp-48, 0x21f23
    if (a1 == 0 || (char)(int64_t)&v1 == 0) {
        // 0x2218b
        return 0;
    }
    // 0x21f68
    v1 = 64;
    int64_t v2 = &g25; // 0x2214f
    while (v2 - (int64_t)&g1 != 0) {
        // 0x22153
        v2 -= (int64_t)&g1;
    }
    // 0x2218b
    return 64;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x2222b - 0x2225b
// Line range:    5669 - 5700
char BLACKWIDOW_SetBandwidthConfig(int64_t ptCommunication, int32_t eFilterBandwidth, int32_t eGmcBandwidth) {
    // 0x2222b
    int64_t v1; // 0x2222b
    char * v2 = (char *)(v1 - 71); // 0x2222b
    int64_t v3; // 0x2222b
    *v2 = *v2 + (char)v3;
    int64_t result; // 0x2222b
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int64_t v5 = result;
    *(char *)v5 = *(char *)&result + (char)v5;
    return result;
}

// Address range: 0x2225b - 0x222c9
int64_t BLACKWIDOW_SetBandwidthConfig2(int64_t a1, int64_t a2, int32_t a3) {
    // 0x2225b
    return mcount() & -256 | (int64_t)(a1 != 0);
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x222ce - 0x222fe
// Line range:    954 - 999
char BLACKWIDOW_SetFilterBandwidth(int64_t ptCommunication, int64_t ulBandwidthKhz) {
    // 0x222ce
    int64_t v1; // 0x222ce
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// Address range: 0x222fe - 0x22346
int64_t BLACKWIDOW_SetFilterBandwidth2(int64_t a1, int64_t a2) {
    // 0x222fe
    mcount();
    return 0;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_osa.c
// Address range: 0x22347 - 0x2234f
// Line range:    43 - 76
void BLACKWIDOW_Sleep(int64_t ulTimeUs) {
    // 0x22347
    return;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x22352 - 0x22377
// Line range:    5717 - 5770
char BLACKWIDOW_ProgramPllPor(int64_t ptCommunication) {
    // 0x22352
    int64_t result; // 0x22352
    int32_t * v1 = (int32_t *)(result - 119); // 0x22352
    int64_t v2; // 0x22352
    *v1 = *v1 + (int32_t)v2;
    return result;
}

// Address range: 0x22358 - 0x22366
int64_t function_22358(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x22358
    int64_t result; // 0x22358
    return result;
}

// Address range: 0x22377 - 0x22382
int64_t BLACKWIDOW_Sleep2(void) {
    // 0x22377
    return mcount();
}

// Address range: 0x22382 - 0x224b5
int64_t BLACKWIDOW_ProgramPllPor2(int64_t a1) {
    // 0x22382
    return mcount() & -256 | (int64_t)(a1 != 0);
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x224b7 - 0x224e7
// Line range:    1787 - 2156
char BLACKWIDOW_SetPowerMode(int64_t ptCommunication, int32_t ePowerMode) {
    // 0x224b7
    int64_t v1; // 0x224b7
    int64_t v2 = v1 & ((int64_t)(unsigned char)(char)&g1 | -256); // 0x224b7
    char * v3 = (char *)v2; // 0x224b9
    char result = v2; // 0x224b9
    *v3 = *v3 + result;
    int64_t v4; // 0x224b7
    char * v5 = (char *)(v4 - 71); // 0x224bb
    *v5 = *v5 + result;
    *v3 = *v3 + 2 * result;
    return result;
}

// Address range: 0x224e7 - 0x23428
int64_t BLACKWIDOW_SetPowerMode2(int64_t a1, int64_t a2) {
    // 0x224e7
    mcount();
    int32_t v1 = 0; // bp-32, 0x224fd
    if ((int32_t)a2 == 0) {
        // 0x22521
        v1 = 171;
        BLACKWIDOW_ProgramPllPor2(a1);
        return BLACKWIDOW_ProgramVcoPor2(a1);
    }
    if ((char)(int64_t)&v1 != 0) {
        // 0x22f4c
        v1 = 0;
    }
    // 0x233d6
    return 0;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x2342c - 0x2345c
// Line range:    261 - 430
char BLACKWIDOW_Initialize(int64_t ptCommunication, int64_t ptConfig) {
    // 0x2342c
    int64_t v1; // 0x2342c
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x2342c
    char * v3 = (char *)(v2 - 71); // 0x2342e
    int64_t result; // 0x2342c
    *v3 = *v3 + (char)result;
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int64_t v5 = result;
    *(char *)v5 = *(char *)&result + (char)v5;
    return result;
}

// Address range: 0x2345c - 0x2370b
int64_t BLACKWIDOW_Initialize2(int64_t a1, int32_t * a2, int64_t a3) {
    // 0x2345c
    mcount();
    int64_t v1 = *(int64_t *)(a1 + 40); // 0x2346a
    int64_t v2 = *(int64_t *)((int64_t)a2 + (int64_t)&g95); // 0x23484
    *(int64_t *)(v1 + 8) = v2;
    *(int32_t *)(v1 + 16) = 0;
    *(int32_t *)(v1 + 20) = (int32_t)&g94;
    *(int32_t *)(v1 + 24) = 63;
    *(char *)(v1 + 33) = 0;
    *(char *)(v1 + 34) = 0;
    *(char *)(v1 + 32) = 0;
    *(int32_t *)(v1 + 28) = 0;
    int32_t * v3 = (int32_t *)v1; // 0x234b4
    int32_t v4 = *v3; // 0x234b4
    if (v4 != 0) {
        if (v4 != 1) {
            int32_t * v5 = (int32_t *)(v1 + 56);
            if (v4 != 2) {
                // 0x23509
                *v5 = (int32_t)&g33;
                *(int32_t *)(v1 + 36) = (int32_t)&g33;
                *(int32_t *)(v1 + 40) = (int32_t)&g33;
            } else {
                // 0x234f2
                *v5 = (int32_t)&g91;
                *(int32_t *)(v1 + 36) = (int32_t)&g33;
                *(int32_t *)(v1 + 40) = (int32_t)&g1;
            }
        } else {
            // 0x234d6
            *(int32_t *)(v1 + 56) = (int32_t)&g33;
            *(int32_t *)(v1 + 36) = (int32_t)&g33;
            *(int32_t *)(v1 + 40) = (int32_t)&g1;
        }
    } else {
        // 0x234ba
        *(int32_t *)(v1 + 56) = (int32_t)&g33;
        *(int32_t *)(v1 + 36) = (int32_t)&g25;
        *(int32_t *)(v1 + 40) = (int32_t)&g1;
    }
    // 0x2351e
    *(int32_t *)(v1 + 44) = (int32_t)&g89;
    *(int32_t *)(v1 + 48) = (int32_t)&g86;
    *(int32_t *)(v1 + 52) = (int32_t)&g33;
    *(char *)(v1 + 65) = 0;
    *(char *)(v1 + 66) = 0;
    *(char *)(v1 + 64) = 0;
    *(int32_t *)(v1 + 60) = 0;
    int32_t v6 = *v3; // 0x23546
    if (v6 != 0) {
        if (v6 != 1) {
            int32_t * v7 = (int32_t *)(v1 + 88);
            if (v6 != 2) {
                // 0x2359b
                *v7 = (int32_t)&g33;
                *(int32_t *)(v1 + 68) = (int32_t)&g33;
                *(int32_t *)(v1 + 72) = (int32_t)&g33;
            } else {
                // 0x23584
                *v7 = (int32_t)&g91;
                *(int32_t *)(v1 + 68) = (int32_t)&g33;
                *(int32_t *)(v1 + 72) = (int32_t)&g1;
            }
        } else {
            // 0x23568
            *(int32_t *)(v1 + 88) = (int32_t)&g33;
            *(int32_t *)(v1 + 68) = (int32_t)&g33;
            *(int32_t *)(v1 + 72) = (int32_t)&g1;
        }
    } else {
        // 0x2354c
        *(int32_t *)(v1 + 88) = (int32_t)&g33;
        *(int32_t *)(v1 + 68) = (int32_t)&g25;
        *(int32_t *)(v1 + 72) = (int32_t)&g1;
    }
    // 0x235b0
    *(int32_t *)(v1 + 76) = (int32_t)&g89;
    *(int32_t *)(v1 + 80) = (int32_t)&g86;
    *(int32_t *)(v1 + 84) = (int32_t)&g33;
    *(char *)(v1 + 97) = 0;
    *(char *)(v1 + 98) = 0;
    *(char *)(v1 + 96) = 0;
    *(int32_t *)(v1 + 92) = 0;
    int32_t v8 = *v3; // 0x235d8
    if (v8 != 0) {
        if (v8 != 1) {
            int32_t * v9 = (int32_t *)(v1 + 120);
            if (v8 != 2) {
                // 0x2362d
                *v9 = (int32_t)&g33;
                *(int32_t *)(v1 + 100) = (int32_t)&g33;
                *(int32_t *)(v1 + 104) = (int32_t)&g33;
            } else {
                // 0x23616
                *v9 = (int32_t)&g91;
                *(int32_t *)(v1 + 100) = (int32_t)&g33;
                *(int32_t *)(v1 + 104) = (int32_t)&g1;
            }
        } else {
            // 0x235fa
            *(int32_t *)(v1 + 120) = (int32_t)&g33;
            *(int32_t *)(v1 + 100) = (int32_t)&g33;
            *(int32_t *)(v1 + 104) = (int32_t)&g1;
        }
    } else {
        // 0x235de
        *(int32_t *)(v1 + 120) = (int32_t)&g33;
        *(int32_t *)(v1 + 100) = (int32_t)&g25;
        *(int32_t *)(v1 + 104) = (int32_t)&g1;
    }
    // 0x23642
    *(int32_t *)(v1 + 108) = (int32_t)&g89;
    *(int32_t *)(v1 + 112) = (int32_t)&g86;
    *(int32_t *)(v1 + 116) = (int32_t)&g33;
    *(char *)(v1 + 129) = 0;
    *(char *)(v1 + 130) = 0;
    *(char *)(v1 + 128) = 0;
    *(int32_t *)(v1 + 124) = 0;
    uint32_t result = *v3; // 0x23673
    if (result == 0) {
        // 0x23679
        *(int32_t *)(v1 + 152) = (int32_t)&g33;
        *(int32_t *)(v1 + 132) = (int32_t)&g25;
        *(int32_t *)(v1 + 136) = (int32_t)&g1;
        // 0x23701
        *(int32_t *)(v1 + 140) = (int32_t)&g89;
        return result;
    }
    if (result == 1) {
        // 0x2369e
        *(int32_t *)(v1 + 152) = (int32_t)&g33;
        *(int32_t *)(v1 + 132) = (int32_t)&g33;
        *(int32_t *)(v1 + 136) = (int32_t)&g1;
        // 0x23701
        *(int32_t *)(v1 + 140) = (int32_t)&g89;
        return result;
    }
    int32_t * v10 = (int32_t *)(v1 + 152);
    if (result != 2) {
        // 0x236e3
        *v10 = (int32_t)&g33;
        *(int32_t *)(v1 + 132) = (int32_t)&g33;
        *(int32_t *)(v1 + 136) = (int32_t)&g33;
    } else {
        // 0x236c3
        *v10 = (int32_t)&g91;
        *(int32_t *)(v1 + 132) = (int32_t)&g33;
        *(int32_t *)(v1 + 136) = (int32_t)&g1;
    }
    // 0x23701
    *(int32_t *)(v1 + 140) = (int32_t)&g89;
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x23714 - 0x23744
// Line range:    5500 - 5638
char BLACKWIDOW_ProgramVcoChannelChangeSpi(int64_t ptCommunication) {
    // 0x23714
    uint64_t v1; // 0x23714
    unsigned char v2 = (char)(v1 >> (uint64_t)(int64_t)&g95); // 0x23714
    int64_t v3; // 0x23714
    unsigned char v4 = v2 + (char)v3; // 0x23714
    uint64_t v5 = (int64_t)v4 << (int64_t)&g95 | v1 & -0xff01; // 0x23714
    int64_t v6 = v3 + (int64_t)&g34; // 0x23716
    int32_t v7 = *(int32_t *)(v6 + v3 * (int64_t)&g1); // 0x23716
    *(int32_t *)(v6 + v3) = v7 + (int32_t)(v4 < v2);
    int64_t v8; // 0x23714
    char v9 = *(char *)&v8; // 0x2371e
    *(char *)v8 = v9 + (char)(v5 >> (int64_t)&g95);
    int64_t result = BLACKWIDOW_SetPowerMode2(ptCommunication, v8); // 0x23724
    *(int32_t *)(v5 + 160) = (int32_t)&g86;
    *(int32_t *)(v5 + 164) = 1023;
    return result;
}

// Address range: 0x23744 - 0x23b99
int64_t BLACKWIDOW_ProgramVcoChannelChangeSpi2(int64_t a1) {
    int64_t v1 = mcount(); // 0x23755
    if (a1 == 0) {
        // 0x23b77
        return v1 & -256;
    }
    while (true) {
        // continue -> 0x23ae1
    }
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x23b9d - 0x23bc6
// Line range:    898 - 936
char BLACKWIDOW_SetFrequency(int64_t ptCommunication, int64_t ulFreqkHz) {
    // 0x23b9d
    int64_t v1; // 0x23b9d
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x23bcb - 0x23bcd
// Line range:    2285 - 2339
char BLACKWIDOW_SetFrequencyAndBandwidth(int64_t ptCommunication, int64_t ptChannelObj) {
    // 0x23bcb
    int64_t result; // 0x23bcb
    return result;
}

// Address range: 0x23bcd - 0x23bfb
int64_t BLACKWIDOW_SetFrequency2(int64_t a1) {
    // 0x23bcd
    mcount();
    int64_t v1; // 0x23bcd
    int64_t v2 = BLACKWIDOW_SetFreq2(a1, v1, (int64_t *)&g89); // 0x23be3
    int64_t result = v2; // 0x23bea
    if ((char)v2 != 0) {
        // 0x23bec
        result = BLACKWIDOW_ProgramVcoChannelChange2(a1);
    }
    // 0x23bf4
    return result;
}

// Address range: 0x23bfb - 0x23c4e
int64_t BLACKWIDOW_SetFrequencyAndBandwidth2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x23bfb
    mcount();
    BLACKWIDOW_SetFrequency2(a1);
    return (int64_t)*(int16_t *)(a2 + (int64_t)&g13);
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x23c4f - 0x23c75
// Line range:    2357 - 2369
char BLACKWIDOW_Tune(int64_t ptCommunication, int64_t ptChannelObj) {
    // 0x23c4f
    int64_t v1; // 0x23c4f
    int64_t v2; // 0x23c4f
    return -113 * (char)((v2 * (int64_t)(uint32_t)(int32_t)((int64_t)&g86 + 1) & 0xffffffff) * ((int64_t)&g86 + 1) * (int64_t)&g86 + v1);
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\sat_tuner.c
// Address range: 0x23c78 - 0x23c7f
// Line range:    57 - 61
void SAT_TUNER_InitIO(int64_t p_read_func, int64_t p_write_func) {
    // 0x23c78
    return;
}

// Address range: 0x23c7f - 0x23c90
int64_t BLACKWIDOW_Tune2(int64_t a1) {
    // 0x23c7f
    return mcount();
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\sat_tuner.c
// Address range: 0x23c91 - 0x23c92
// Line range:    64 - 76
void SAT_TUNER_SetByteOrder(int64_t p_communication, char little_endian) {
    // 0x23c91
    return;
}

// Address range: 0x23c95 - 0x23ca8
int64_t function_23c95(int64_t a1) {
    // 0x23c95
    int64_t result; // 0x23c95
    int64_t v1; // 0x23c95
    if ((char)v1 != 0) {
        // 0x23c99
        int64_t v2; // 0x23c95
        result = BLACKWIDOW_SetGain2(v2);
    }
    // 0x23ca1
    return result;
}

// Address range: 0x23ca8 - 0x23cb1
int64_t SAT_TUNER_InitIO2(void) {
    // 0x23ca8
    return mcount();
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\sat_tuner.c
// Address range: 0x23cb2 - 0x23cc1
// Line range:    83 - 131
char SAT_TUNER_RegRead(int64_t p_communication, int16_t address, int16_t offset, char start_bit, char num_bit, char num_bytes, int64_t * p_data) {
    // 0x23cb2
    *(int32_t *)&g69 = (int32_t)p_communication;
    g70 = address;
    int64_t result; // 0x23cb2
    return result;
}

// Address range: 0x23cc1 - 0x23ce2
int64_t SAT_TUNER_SetByteOrder2(int64_t a1, int64_t a2) {
    // 0x23cc1
    mcount();
    int64_t result = (char)a2 != (char)&g1 ? 0x1000000 : 0; // 0x23cd8
    *(int64_t *)(a1 + 88) = result;
    return result;
}

// Address range: 0x23ce2 - 0x23e0d
int64_t SAT_TUNER_RegRead2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, uint64_t a5, int64_t a6, int64_t a7) {
    // 0x23ce2
    mcount();
    uint64_t v1 = (int64_t)(0x100000000000000 * a4 / 0x100000000000000); // 0x23cfe
    if ((char)a5 > (char)&g24) {
        // 0x23d26
        *(int32_t *)(a1 + 48) = -1;
        *(int32_t *)(a1 + 52) = 0;
    } else {
        uint64_t v2 = a5 % 64; // 0x23d0f
        int64_t v3 = v2 == 0 ? (int64_t)&g1 - 1 : ((int64_t)&g1 << v2) - 1; // 0x23d15
        *(int64_t *)(a1 + 48) = v3 << v1 % 64;
    }
    // 0x23d34
    if (a1 == 0 || a7 == 0 | *(int64_t *)(a1 + (int64_t)&g13) == 0) {
        // 0x23e0d
        return 0;
    }
    int64_t v4 = a1 + 56; // 0x23d53
    int64_t * v5 = (int64_t *)v4; // 0x23d6e
    *v5 = 0;
    int64_t v6 = 0; // 0x23dbd
    if (*(int64_t *)(a1 + 88) == 0x1000000) {
        char * v7 = (char *)(a1 + 59); // 0x23dc3
        char * v8 = (char *)v4; // 0x23dc6
        char v9 = *v8 ^ *v7; // 0x23dc6
        *v8 = v9;
        char v10 = *v7 ^ v9; // 0x23dcc
        *v7 = v10;
        *v8 = *v8 ^ v10;
        char * v11 = (char *)(a1 + 58); // 0x23ddb
        char * v12 = (char *)(a1 + 57); // 0x23ddf
        char v13 = *v12 ^ *v11; // 0x23ddf
        *v12 = v13;
        char v14 = *v11 ^ v13; // 0x23de3
        *v11 = v14;
        *v12 = *v12 ^ v14;
        v6 = *v5;
    }
    // 0x23deb
    *(int64_t *)a7 = (*(int64_t *)(a1 + 48) & v6) >> v1 % 64;
    // 0x23e0d
    return &g1;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\sat_tuner.c
// Address range: 0x23e0e - 0x23e3e
// Line range:    155 - 227
char SAT_TUNER_RegWrite(int64_t p_communication, int16_t address, int16_t offset, char start_bit, char num_bit, char num_bytes, char rmw, char access, int64_t data) {
    // 0x23e0e
    int64_t result; // 0x23e0e
    return result;
}

// Address range: 0x23e3e - 0x23f3f
int64_t SAT_TUNER_RegWrite2(int64_t a1, int64_t a2, int64_t a3, uint64_t a4, uint64_t a5, int64_t a6, char a7, char a8, int64_t a9) {
    // 0x23e3e
    mcount();
    int64_t v1; // 0x23e3e
    int64_t v2; // 0x23e3e
    if ((unsigned char)(char)a5 > (unsigned char)(char)&g24) {
        int64_t v3 = a1 + 64;
        *(int32_t *)v3 = -1;
        *(int32_t *)(a1 + 68) = 0;
        v2 = *(int64_t *)v3;
        v1 = a4 % 64;
    } else {
        uint64_t v4 = a5 % 64; // 0x23e75
        int64_t v5 = v4 == 0 ? (int64_t)&g1 - 1 : ((int64_t)&g1 << v4) - 1; // 0x23e7b
        uint64_t v6 = a4 % 64;
        int64_t v7 = v5 << v6;
        *(int64_t *)(a1 + 64) = v7;
        v2 = v7;
        v1 = v6;
    }
    int64_t v8 = a1 + 72; // 0x23ea8
    *(int64_t *)v8 = v2 & a9 << (uint64_t)v1;
    int64_t result = &g86; // 0x23ef4
    if (*(int64_t *)(a1 + 88) == 0x1000000) {
        char * v9 = (char *)(a1 + 75); // 0x23efa
        char * v10 = (char *)v8; // 0x23efd
        char v11 = *v10 ^ *v9; // 0x23efd
        *v10 = v11;
        char v12 = *v9 ^ v11; // 0x23f03
        *v9 = v12;
        *v10 = *v10 ^ v12;
        result = a1 + 73;
        char * v13 = (char *)(a1 + 74); // 0x23f12
        char * v14 = (char *)result; // 0x23f15
        char v15 = *v14 ^ *v13; // 0x23f15
        *v14 = v15;
        char v16 = *v13 ^ v15; // 0x23f19
        *v13 = v16;
        *v14 = *v14 ^ v16;
    }
    // 0x23f3f
    return result;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\sat_tuner.c
// Address range: 0x23f93 - 0x23fbb
// Line range:    230 - 238
void SAT_TUNER_strncpy(char * ptStrOut, char * ptStrIn, int32_t uiStrSize) {
    // 0x23f93
    return;
}

// From module:   /root/asv5220/./TDA2014x/../TDA2014x/src\blackwidow_api.c
// Address range: 0x23fbc - 0x23fc3
// Line range:    221 - 243
char BLACKWIDOW_GetDriverVersion(int64_t ptDriverVersion) {
    // 0x23fbc
    int64_t result; // 0x23fbc
    return result;
}

// Address range: 0x23fc3 - 0x23fe5
int64_t SAT_TUNER_strncpy2(int64_t a1, int64_t a2, int64_t * a3) {
    // 0x23fc3
    mcount();
    uint64_t v1; // 0x23fc3
    *(char *)a1 = (char)v1;
    return v1 % 256;
}

// From module:   /root/asv5220/./TDA2014x\TDA2014x.c
// Address range: 0x23fe7 - 0x23fec
// Line range:    139 - 157
char TDA2014x_TunerSetFrequency(char * pDeviceExtension, int64_t TunerDeviceID, int64_t RF) {
    // 0x23fe7
    int64_t result; // 0x23fe7
    return result;
}

// Address range: 0x23fe8 - 0x23fea
int64_t function_23fe8(void) {
    // 0x23fe8
    int64_t result; // 0x23fe8
    return result;
}

// Address range: 0x23fec - 0x24017
int64_t BLACKWIDOW_GetDriverVersion2(int64_t a1) {
    // 0x23fec
    mcount();
    int64_t result = 0; // 0x23ffd
    if (a1 != 0) {
        // 0x23fff
        SAT_TUNER_strncpy2(a1, 0, (int64_t *)&g97);
        result = &g1;
    }
    // 0x24015
    return result;
}

// Address range: 0x24017 - 0x2404d
int64_t TDA2014x_TunerSetFrequency2(int64_t a1, uint64_t a2, uint64_t a3) {
    // 0x24017
    mcount();
    *(int64_t *)((a2 >> (uint64_t)(int64_t)&g1) * ((int64_t)&g25 + 1 << (uint64_t)(int64_t)&g89)) = a1;
    return 0x20c49ba5e353f7cf * (a3 >> (int64_t)&g33);
}

// From module:   /root/asv5220/./TDA2014x\TDA2014x.c
// Address range: 0x24050 - 0x24080
// Line range:    159 - 177
char TDA2014x_TunerCheckLockStatus(char * pDeviceExtension, int64_t TunerDeviceID, char * pLock) {
    // 0x24050
    int64_t v1; // 0x24050
    *(int32_t *)(v1 - 32) = (int32_t)(int64_t)pLock;
    *(int64_t *)(v1 - 16) = 0x70bc;
    *(int32_t *)(v1 - 24) = (int32_t)&g25;
    *(int16_t *)(v1 - 8) = 0x1388;
    int64_t v2; // 0x24050
    return BLACKWIDOW_Tune2(v2 << (int64_t)&g89);
}

// Address range: 0x24080 - 0x240ad
int64_t TDA2014x_TunerCheckLockStatus2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x24080
    mcount();
    int64_t v1 = a2 >> (uint64_t)(int64_t)&g1; // 0x24091
    *(int64_t *)(v1 * ((int64_t)&g25 + 1 << (int64_t)&g89)) = a1;
    return v1 * ((int64_t)&g25 + 1);
}

// From module:   /root/asv5220/./TDA2014x\TDA2014x.c
// Address range: 0x240b1 - 0x240ba
// Line range:    17 - 138
char TDA2014x_TunerInitialization(char * pDeviceExtension, int64_t TunerDeviceID) {
    // 0x240b1
    int64_t v1; // 0x240b1
    *(char *)v1 = 2 * (char)v1;
    return function_ffffffff8a024063();
}

// Address range: 0x240ba - 0x240bd
int64_t function_240ba(void) {
    // 0x240ba
    int64_t result; // 0x240ba
    return result;
}

// Address range: 0x240bd - 0x240e1
int64_t function_240bd(int64_t a1) {
    // 0x240bd
    int64_t v1; // 0x240bd
    char v2 = v1;
    *(char *)v1 = 2 * v2;
    char * v3 = (char *)(v1 + 0x157501fa); // 0x240bf
    *v3 = *v3 + v2;
    int64_t v4; // 0x240bd
    if (v4 != 0) {
        // 0x240cf
        int64_t v5; // 0x240bd
        *(char *)v4 = *(char *)(v5 - 17);
    }
    // 0x240da
    return &g1;
}

// Address range: 0x240e1 - 0x24412
int64_t TDA2014x_TunerInitialization2(int64_t a1, uint64_t a2) {
    // 0x240e1
    mcount();
    int64_t v1 = a2 >> (uint64_t)(int64_t)&g1; // 0x240f2
    int64_t v2 = v1 * (int64_t)&g95; // 0x240f5
    *(int64_t *)v2 = a2;
    int64_t v3 = v1 * (((int64_t)&g86 + 1 << (int64_t)&g25) + (int64_t)&g1) * (int64_t)&g95; // 0x24110
    *(int64_t *)(v3 + 8) = 0;
    int64_t v4 = v1 * 8 * (((int64_t)&g86 + 1 << (int64_t)&g25) + (int64_t)&g1); // 0x24119
    int64_t v5 = v4 + 16; // 0x24119
    *(int32_t *)v5 = 511;
    *(int32_t *)(v4 + 12) = (int32_t)&g86;
    *(char *)v5 = 0;
    *(char *)(v4 + 17) = 0;
    *(char *)(v4 + 18) = 0;
    *(int32_t *)(v4 + 28) = (int32_t)&g95;
    *(int32_t *)(v4 + 32) = (int32_t)&g95;
    *(int32_t *)(v4 + 20) = (int32_t)&g95;
    *(int32_t *)(v4 + 24) = (int32_t)&g2;
    *(int32_t *)v3 = (int32_t)&g86;
    *(int32_t *)(v3 + 4) = 1023;
    uint32_t v6 = (int32_t)v1 & (int32_t)&g33; // 0x2429e
    int64_t v7; // 0x240e1
    if (v6 != 0) {
        int64_t v8 = v6; // 0x2429e
        if (v8 != (int64_t)&g1) {
            int64_t v9 = v1 * (((int64_t)&g86 + 1) * (int64_t)&g86 + 1) * (int64_t)&g95;
            int32_t * v10 = (int32_t *)v9;
            if (v8 != (int64_t)&g25) {
                // 0x242ee
                *v10 = (int32_t)&g33;
                v7 = v9;
            } else {
                // 0x242d9
                *v10 = (int32_t)&g25;
                v7 = v9;
            }
        } else {
            int64_t v11 = v1 * (((int64_t)&g86 + 1) * (int64_t)&g86 + 1) * (int64_t)&g95;
            *(int32_t *)v11 = (int32_t)&g1;
            v7 = v11;
        }
    } else {
        int64_t v12 = v1 * (((int64_t)&g86 + 1) * (int64_t)&g86 + 1) * (int64_t)&g95;
        *(int32_t *)v12 = 0;
        v7 = v12;
    }
    int64_t v13 = v1 * ((int64_t)&g1 + 1 + (int64_t)&g1 << (int64_t)&g89); // 0x24310
    *(int64_t *)v13 = v2;
    *(int64_t *)(v13 + (int64_t)&g95) = 0;
    int64_t v14 = v1 * (((int64_t)&g1 + 1 + (int64_t)&g1) * (int64_t)&g1 + (int64_t)&g1 + 1 + (int64_t)&g1) + (int64_t)&g1 << (int64_t)&g86; // 0x2433a
    *(int64_t *)(v14 * (int64_t)&g1) = 0;
    *(int64_t *)(v14 + 8) = 0;
    int64_t v15 = v1 * ((int64_t)&g1 + 2) + (int64_t)&g1 << (int64_t)&g89; // 0x24356
    *(int64_t *)v15 = a1;
    *(int64_t *)(v15 + (int64_t)&g95) = v7;
    int64_t v16 = v1 * ((int64_t)&g1 + 2 << (int64_t)&g89); // 0x2437a
    *(int64_t *)v16 = 0;
    *(int64_t *)(v16 + (int64_t)&g95) = 0;
    char v17 = &g95; // bp-40, 0x243bf
    BLACKWIDOW_Initialize2(v16, (int32_t *)&v17, 0);
    return BLACKWIDOW_EnableLoopThrough2(v16, (int64_t *)&g1);
}

// From module:   /root/asv5220/./NMI131\NMI131.c
// Address range: 0x24412 - 0x24442
// Line range:    78 - 113
char NMI131_TunerSetFrequency(char * pDeviceExtension, int64_t TunerDeviceID, int64_t RF) {
    // 0x24412
    BLACKWIDOW_Tune2((int64_t)pDeviceExtension);
    DriverDebugMessage2(0);
    return &g1;
}

// Address range: 0x24442 - 0x244e4
int64_t NMI131_TunerSetFrequency2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x24442
    mcount();
    DriverDebugMessage2(0);
    DriverDebugPrint2(0, a3);
    int64_t v1 = a2 >> (uint64_t)(int64_t)&g1; // 0x2447d
    *(int64_t *)(v1 * ((int64_t)&g86 + (int64_t)&g1) * (int64_t)&g95) = a1;
    return v1 * ((int64_t)&g86 + (int64_t)&g1);
}

// From module:   /root/asv5220/./TDA2014x\TDA2014x.c
// Address range: 0x244e7 - 0x24517
// Line range:    183 - 222
void TDA2014x_I2C_Write(char * pUserData, char * p_tuner_handle, char address, char data, int64_t * p_iostatus) {
    // 0x244e7
    return;
}

// Address range: 0x24517 - 0x24553
int64_t TDA2014x_I2C_Write2(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x24517
    return mcount();
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x24554 - 0x2457d
// Line range:    806 - 818
char TC90522DemodulatorPSK_I2C_Write(char * pDeviceExtension, int64_t TunerDeviceID, char SubAddress, char Data) {
    // 0x24554
    int64_t v1; // 0x24554
    char * v2 = (char *)v1; // 0x24556
    *v2 = *v2 + (char)v1;
    char v3 = I2C_PortingLayer_Write2((int64_t)pDeviceExtension, TunerDeviceID, (int64_t)SubAddress, (int64_t)Data);
    char result; // 0x24554
    int64_t v4; // 0x24554
    if (v3 == 0) {
        int64_t v5 = DriverDebugMessage2(0); // 0x24571
        *(int64_t *)v4 = (int64_t)&g1;
        result = v5;
    } else {
        // 0x24561
        *(int64_t *)v4 = 0;
        result = v3;
    }
    // 0x2457d
    return result;
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x2457f - 0x24580
// Line range:    182 - 201
char TC90522_SetTSID(char * pDeviceExtension, int64_t TunerDeviceID, int16_t TSID) {
    // 0x2457f
    int64_t result; // 0x2457f
    return result;
}

// Address range: 0x24580 - 0x24584
int64_t function_24580(void) {
    // 0x24580
    int64_t v1; // 0x24580
    char * v2 = (char *)(v1 - 55); // 0x24580
    bool v3; // 0x24580
    *v2 = (char)v3 - (char)v1 + *v2;
    int64_t result; // 0x24580
    return result;
}

// Address range: 0x24584 - 0x245af
int64_t TC90522DemodulatorPSK_I2C_Write2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x24584
    mcount();
    int64_t v1 = 0x100000000000000 * a3 / 0x100000000000000; // bp-24, 0x24591
    int64_t result = I2C_PortingLayer_Write2(a1, (2 * a2 & (int64_t)(int32_t)&g103) + (int64_t)(int32_t)&g26 & 0xfffffff8, (int64_t)&v1, (int64_t)&g25); // 0x245a8
    return result;
}

// Address range: 0x245af - 0x245e8
int64_t TC90522_SetTSID2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x245af
    mcount();
    return a3 & 0xffffffff;
}

// From module:   /root/asv5220\Japan4x4Tuner.c
// Address range: 0x245ea - 0x24619
// Line range:    140 - 149
char Japan4x4Tuner_TunerSetTSID(int64_t TunerDeviceID, int16_t TSID, char * pDeviceExtension) {
    // 0x245ea
    int64_t result; // 0x245ea
    return result;
}

// Address range: 0x245ed - 0x24607
int64_t function_245ed(void) {
    // 0x245ed
    uint64_t v1; // 0x245ed
    int64_t v2; // 0x245ed
    int64_t v3; // 0x245ed
    return TC90522DemodulatorPSK_I2C_Write2(v2, v3, 144, v1 % 256);
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x24619 - 0x2461a
// Line range:    783 - 795
char TC90522DemodulatorOFDM_I2C_Write(char * pDeviceExtension, int64_t TunerDeviceID, char SubAddress, char Data) {
    // 0x24619
    int64_t result; // 0x24619
    return result;
}

// Address range: 0x2461a - 0x24642
int64_t Japan4x4Tuner_TunerSetTSID2(unsigned char a1, uint64_t a2, int64_t result) {
    // 0x2461a
    mcount();
    if (a1 > 63 || (a1 & (char)&g1) == 0) {
        // 0x24642
        return result;
    }
    // 0x24632
    return TC90522_SetTSID2(result, (int64_t)(char)a1, a2 % 0x10000);
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x24644 - 0x24649
// Line range:    96 - 139
char TC90522_ResetInternal(char * pDeviceExtension, int64_t TunerDeviceID) {
    // 0x24644
    int64_t v1; // 0x24644
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// Address range: 0x24649 - 0x24674
int64_t TC90522DemodulatorOFDM_I2C_Write2(int64_t a1, int64_t a2, int64_t * a3, int64_t a4) {
    // 0x24649
    mcount();
    int64_t v1 = 0x100000000000000 * (int64_t)a3 / 0x100000000000000; // bp-24, 0x24656
    int64_t result = I2C_PortingLayer_Write2(a1, (2 * a2 & (int64_t)(int32_t)&g103) + (int64_t)(int32_t)&g26 & 0xfffffff8, (int64_t)&v1, (int64_t)&g25); // 0x2466d
    return result;
}

// Address range: 0x24674 - 0x24761
int64_t TC90522_ResetInternal2(int64_t a1, int64_t a2) {
    // 0x24674
    mcount();
    if (((char)a2 & (char)&g1) != 0) {
        // 0x24725
        TC90522DemodulatorPSK_I2C_Write2(a1, a2, (int64_t)&g98, 0);
        return TC90522DemodulatorPSK_I2C_Write2(a1, a2, (int64_t)&g2, 176);
    }
    // 0x246a4
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)&g1, 80);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)71, 48);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)37, 0);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)&g26, 0);
    return TC90522DemodulatorOFDM_I2C_Write2(a1, a2, &g31, 77);
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x24761 - 0x24791
// Line range:    10 - 94
char TC90522_Initialization(char * pDeviceExtension, int64_t TunerDeviceID, char ConfigureTransportStreamOutputFlag) {
    char result = 0; // 0x24768
    int64_t v1; // 0x24761
    if ((char)TC90522DemodulatorPSK_I2C_Write2((int64_t)pDeviceExtension, TunerDeviceID, (int64_t)ConfigureTransportStreamOutputFlag, v1) != 0) {
        // 0x2476a
        int64_t v2; // 0x24761
        int64_t v3; // 0x24761
        int64_t v4 = TC90522DemodulatorPSK_I2C_Write2(v2, v3, (int64_t)&g33, (int64_t)&g1); // 0x2477a
        result = v4;
    }
    // 0x24786
    return result;
}

// Address range: 0x24791 - 0x24a39
int64_t TC90522_Initialization2(int64_t a1, int64_t a2, int64_t * a3) {
    // 0x24791
    mcount();
    DriverDebugMessage2(0);
    if (((char)a2 & (char)&g1) != 0) {
        // 0x24963
        TC90522DemodulatorPSK_I2C_Write2(a1, a2, (int64_t)&g5, 0);
        TC90522DemodulatorPSK_I2C_Write2(a1, a2, (int64_t)&g9, 0);
        TC90522DemodulatorPSK_I2C_Write2(a1, a2, (int64_t)&g12, 0);
        TC90522DemodulatorPSK_I2C_Write2(a1, a2, (int64_t)&g19, 0);
        TC90522DemodulatorPSK_I2C_Write2(a1, a2, (int64_t)&g22, 0);
        TC90522DemodulatorPSK_I2C_Write2(a1, a2, (int64_t)&g24, 0);
        TC90522DemodulatorPSK_I2C_Write2(a1, a2, (int64_t)&g94, 49);
        return TC90522DemodulatorPSK_I2C_Write2(a1, a2, (int64_t)&g95, 119);
    }
    // 0x247d2
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)176, 160);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)178, 61);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)179, 37);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)180, 139);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)181, 75);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)182, 63);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)183, 255);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)184, 192);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)&g33, 0);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)&g22, 0);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)&g24, 0);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)&g103, 119);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)&g105, (int64_t)&g5);
    TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)117, (int64_t)&g25);
    return &g1;
}

// From module:   /root/asv5220/./TDA2014x\TDA2014x.c
// Address range: 0x24a3a - 0x24a6a
// Line range:    223 - 278
char TDA2014x_I2C_Read(char * pUserData, char * p_tuner_handle, char address, int64_t * p_iostatus) {
    // 0x24a3a
    int64_t v1; // 0x24a3a
    char * v2 = (char *)v1; // 0x24a3c
    *v2 = *v2 + (char)v1;
    int64_t v3; // 0x24a3a
    int64_t v4; // 0x24a3a
    TC90522DemodulatorPSK_I2C_Write2(v3, v4, (int64_t)address, (int64_t)p_iostatus);
    return &g1;
}

// Address range: 0x24a6a - 0x24b0b
int64_t TDA2014x_I2C_Read2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x24a6a
    mcount();
    char v1 = 0; // bp-41, 0x24a89
    int64_t v2 = -2; // bp-72, 0x24aad
    int64_t v3 = (2 * a2 & (int64_t)(char)&g105) + (int64_t)(char)&g26 & 254; // 0x24ab8
    I2C_PortingLayer_Write2(a1, v3, (int64_t)&v2, (int64_t)&g33);
    char v4 = -2; // bp-56, 0x24ad1
    int64_t result = I2C_PortingLayer_Read2(a1, v3, &v4, (int64_t *)&g25, &v1, (int64_t *)&g1); // 0x24af2
    if ((char)result == 0) {
        // 0x24b04
        return result;
    }
    // 0x24afb
    *(int64_t *)a4 = 0;
    return result;
}

// From module:   /root/asv5220/./NMI131\NMI131.c
// Address range: 0x24b0e - 0x24b3e
// Line range:    161 - 184
char NMI131_ReadRegister(char * pUserData, char i2cAdr, char * rb, int32_t sz) {
    // 0x24b0e
    int64_t v1; // 0x24b0e
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x24b0e
    *(int64_t *)v2 = (int64_t)&g1;
    int64_t v3; // 0x24b0e
    return *(char *)(v3 - 33);
}

// Address range: 0x24b3e - 0x24b65
int64_t NMI131_ReadRegister2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x24b3e
    return mcount();
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x24b66 - 0x24b96
// Line range:    819 - 828
char TC90522DemodulatorPSK_I2C_Read(char * pDeviceExtension, int64_t TunerDeviceID, char SubAddress, char * pData) {
    // 0x24b66
    int64_t v1; // 0x24b66
    int64_t v2 = I2C_PortingLayer_Read2((int64_t)pDeviceExtension, TunerDeviceID, (char *)(int64_t)SubAddress, (int64_t *)&g25, (char *)v1, (int64_t *)pData); // 0x24b76
    char result = v2; // 0x24b7d
    if (result == 0) {
        // 0x24b81
        DriverDebugMessage2(0);
    }
    // 0x24b8d
    return result;
}

// Address range: 0x24b96 - 0x24b97
int64_t TC90522DemodulatorPSK_I2C_Read2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4) {
    // 0x24b96
    int64_t result; // 0x24b96
    return result;
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x24b97 - 0x24bc7
// Line range:    202 - 232
char TC90522_GetTSID(char * pDeviceExtension, int64_t TunerDeviceID, int16_t * TSID) {
    // 0x24b97
    mcount();
    int16_t * v1 = TSID; // bp-4, 0x24ba6
    int64_t v2; // 0x24b97
    int64_t result = I2C_PortingLayer_Read2((int64_t)pDeviceExtension, (2 * TunerDeviceID & (int64_t)(int32_t)&g103) + (int64_t)(int32_t)&g26 & 0xfffffff8, (char *)&v1, (int64_t *)&g1, (char *)v2, (int64_t *)&g1); // 0x24bc0
    return result;
}

// Address range: 0x24bc7 - 0x24c53
int64_t TC90522_GetTSID2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x24bc7
    mcount();
    int32_t v1; // bp-57, 0x24bc7
    int64_t v2 = TC90522DemodulatorPSK_I2C_Read2(a1, a2, 206, (int64_t *)&v1); // 0x24c14
    int64_t result = v2; // 0x24c1b
    bool v3 = (char)&g1 == 0; // 0x24c1b
    char * v4; // bp-58, 0x24bc7
    if ((char)v2 == (char)&g1) {
        // 0x24c1d
        result = TC90522DemodulatorPSK_I2C_Read2(a1, a2, 207, (int64_t *)&v4);
        v3 = (char)result == (char)&g1;
    }
    // 0x24c32
    if (!v3) {
        // 0x24c4c
        *(int16_t *)a3 = 0;
        return result;
    }
    // 0x24c38
    *(int16_t *)a3 = (int16_t)((int32_t)(int64_t)v4 % 256 | v1 % 256 << (int32_t)&g95);
    return Japan4x4Tuner_TunerGetTSID(a1, (int16_t *)a2, v4);
}

// From module:   /root/asv5220\Japan4x4Tuner.c
// Address range: 0x24c53 - 0x24c82
// Line range:    150 - 159
char Japan4x4Tuner_TunerGetTSID(int64_t TunerDeviceID, int16_t * TSID, char * pDeviceExtension) {
    // 0x24c53
    int64_t result; // 0x24c53
    return result;
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x24c82 - 0x24c83
// Line range:    796 - 805
char TC90522DemodulatorOFDM_I2C_Read(char * pDeviceExtension, int64_t TunerDeviceID, char SubAddress, char * pData) {
    // 0x24c82
    int64_t result; // 0x24c82
    return result;
}

// Address range: 0x24c83 - 0x24cb2
int64_t Japan4x4Tuner_TunerGetTSID2(unsigned char a1, int64_t * a2, int64_t a3) {
    // 0x24c83
    mcount();
    int64_t result = 0; // 0x24c93
    if (a1 <= 63 && (a1 & (char)&g1) != 0) {
        // 0x24c9b
        result = TC90522_GetTSID2(a3, (int64_t)a1, (int64_t)a2);
    }
    // 0x24cb0
    return result;
}

// Address range: 0x24cb2 - 0x24cb3
int64_t TC90522DemodulatorOFDM_I2C_Read2(int64_t a1, int64_t a2, int64_t a3, int64_t * a4) {
    // 0x24cb2
    int64_t result; // 0x24cb2
    return result;
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x24cb3 - 0x24ce3
// Line range:    655 - 775
int64_t TC90522DemodulatorGetCN(char * pDeviceExtension, int64_t TunerDeviceID) {
    // 0x24cb3
    mcount();
    int64_t v1; // 0x24cb3
    char v2 = v1; // bp-4, 0x24cc2
    int64_t v3; // 0x24cb3
    int64_t result = I2C_PortingLayer_Read2((int64_t)pDeviceExtension, (2 * TunerDeviceID & (int64_t)(int32_t)&g103) + (int64_t)(int32_t)&g26 & 0xfffffff8, &v2, (int64_t *)&g1, (char *)v3, (int64_t *)&g1); // 0x24cdc
    return result;
}

// Address range: 0x24ce3 - 0x24f9a
int64_t TC90522DemodulatorGetCN2(int64_t a1, int64_t a2) {
    // 0x24ce3
    mcount();
    DriverDebugMessage2(0);
    DriverDebugPrint2(0, a2);
    char v1; // bp-57, 0x24ce3
    if (((char)a2 & (char)&g1) == 0) {
        // 0x24e21
        TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)186, 0);
        TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 176, (int64_t *)&v1);
        TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 139, (int64_t *)&v1);
        TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 140, (int64_t *)&v1);
        TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 141, (int64_t *)&v1);
        DriverDebugPrint2(0, ((int64_t)(unsigned char)v1 << (int64_t)&g95 | (int64_t)v1) << (int64_t)&g95 | (int64_t)v1);
        abort();
        // UNREACHABLE
    }
    // 0x24e8c
    TC90522DemodulatorPSK_I2C_Read2(a1, a2, 195, (int64_t *)&v1);
    TC90522DemodulatorPSK_I2C_Read2(a1, a2, 188, (int64_t *)&v1);
    TC90522DemodulatorPSK_I2C_Read2(a1, a2, 189, (int64_t *)&v1);
    uint64_t v2 = (int64_t)(unsigned char)v1 << (int64_t)&g95 | (int64_t)v1; // 0x24efb
    DriverDebugPrint2(0, v2);
    if (v2 >= 0x8bf2) {
        // 0x24f94
        return (int64_t)&g33;
    }
    // 0x24f38
    abort();
    // UNREACHABLE
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x24f9d - 0x24fb7
// Line range:    313 - 322
char TC90522_GetCN(char * pDeviceExtension, int64_t TunerDeviceID, int64_t * pCnValue) {
    // 0x24f9d
    int64_t v1; // 0x24f9d
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// From module:   /root/asv5220\Japan4x4Tuner.c
// Address range: 0x24fc7 - 0x24fcd
// Line range:    181 - 187
char Japan4x4Tuner_TunerGetCN(int64_t TunerDeviceID, int64_t * pCnValue, char * pDeviceExtension) {
    // 0x24fc7
    int64_t result; // 0x24fc7
    return result;
}

// Address range: 0x24fcd - 0x24feb
int64_t TC90522_GetCN2(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = mcount(); // 0x24fe1
    if (a3 != 0) {
        // 0x24fe3
        result = TC90522DemodulatorGetCN2(a1, a2);
        *(int64_t *)a3 = result;
    }
    // 0x24feb
    return result;
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x24fee - 0x24ff7
// Line range:    435 - 636
char TC90522DemodulatorGetQuality(char * pDeviceExtension, int64_t TunerDeviceID) {
    // 0x24fee
    int64_t v1; // 0x24fee
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// Address range: 0x24ff7 - 0x2501e
int64_t Japan4x4Tuner_TunerGetCN2(unsigned char a1, int64_t a2, int64_t a3) {
    // 0x24ff7
    mcount();
    int64_t result = 0; // 0x2500c
    if (a1 < 64) {
        // 0x2500e
        result = TC90522_GetCN2(a3, (int64_t)a1, a2);
    }
    // 0x2501c
    return result;
}

// Address range: 0x2501e - 0x25308
int64_t TC90522DemodulatorGetQuality2(int64_t a1, uint64_t a2) {
    // 0x2501e
    mcount();
    DriverDebugMessage2(0);
    DriverDebugPrint2(0, a2);
    if (a2 >= 64) {
        // 0x25261
        return (int64_t)&g7;
    }
    int32_t v1; // bp-57, 0x2501e
    if (((char)a2 & (char)&g1) != 0) {
        int64_t v2 = TC90522DemodulatorPSK_I2C_Read2(a1, a2, 195, (int64_t *)&v1); // 0x251c6
        if ((char)v2 != (char)&g1 || ((char)v1 & (char)&g2) != 0) {
            // 0x25261
            return (int64_t)&g7;
        }
        int64_t v3 = TC90522DemodulatorPSK_I2C_Read2(a1, a2, (int64_t)"%(", (int64_t *)&v1); // 0x251ec
        if ((char)v3 != (char)&g1) {
            // 0x25261
            return (int64_t)&g7;
        }
        int64_t v4 = TC90522DemodulatorPSK_I2C_Read2(a1, a2, (int64_t)&g104, (int64_t *)&v1); // 0x25209
        if ((char)v4 != (char)&g1) {
            // 0x25261
            return (int64_t)&g7;
        }
        int64_t v5 = TC90522DemodulatorPSK_I2C_Read2(a1, a2, 237, (int64_t *)&v1); // 0x25226
        if ((char)v5 == (char)&g1) {
            // 0x2522f
            DriverDebugPrint2(0, ((int64_t)(v1 % 256) << (int64_t)&g95 | (int64_t)(v1 % 256)) << (int64_t)&g95 | (int64_t)(v1 % 256));
        }
        // 0x25261
        return (int64_t)&g7;
    }
    int64_t v6 = TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)186, 0); // 0x25088
    if ((char)v6 != (char)&g1) {
        // 0x25261
        return (int64_t)&g7;
    }
    int64_t v7 = TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 176, (int64_t *)&v1); // 0x250a4
    if ((char)v7 != (char)&g1 || ((char)v1 & (char)((int32_t)&g105 & 255)) <= (char)&g94) {
        // 0x25261
        return (int64_t)&g7;
    }
    int64_t v8 = TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 160, (int64_t *)&v1); // 0x250cf
    if ((char)v8 != (char)&g1) {
        // 0x25261
        return (int64_t)&g7;
    }
    int64_t v9 = TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 161, (int64_t *)&v1); // 0x250f0
    if ((char)v9 != (char)&g1) {
        // 0x25261
        return (int64_t)&g7;
    }
    int64_t v10 = TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 162, (int64_t *)&v1); // 0x25111
    if ((char)v10 != (char)&g1) {
        // 0x25261
        return (int64_t)&g7;
    }
    // 0x2511e
    DriverDebugPrint2(0, ((int64_t)(v1 % 256) << (int64_t)&g95 | (int64_t)(v1 % 256)) << (int64_t)&g95 | (int64_t)(v1 % 256));
    int64_t v11 = TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 168, (int64_t *)&v1); // 0x2515b
    if ((char)v11 != (char)&g1) {
        // 0x25261
        return (int64_t)&g7;
    }
    // 0x25168
    TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 169, (int64_t *)&v1);
    return (int64_t)&g7;
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x2530c - 0x25332
// Line range:    303 - 311
char TC90522_GetQuality(char * pDeviceExtension, int64_t TunerDeviceID, char * pQuality) {
    // 0x2530c
    int64_t v1; // 0x2530c
    uint32_t v2 = (int32_t)v1;
    uint32_t v3 = 2 * v2; // 0x2530c
    char result = v3; // 0x2530e
    if (v3 >= v2 && v3 != 0) {
        // 0x25310
        int64_t v4; // 0x2530c
        result = (int32_t)v4 < 0xf4241 ? (char)(2 * (int64_t)(int32_t)&g89 & 0xffffffff) : (char)&g89;
    }
    // 0x25326
    return result;
}

// From module:   /root/asv5220\Japan4x4Tuner.c
// Address range: 0x25335 - 0x25336
// Line range:    174 - 180
char Japan4x4Tuner_TunerGetQuality(int64_t TunerDeviceID, char * pQuality, char * pDeviceExtension) {
    // 0x25335
    int64_t result; // 0x25335
    return result;
}

// Address range: 0x25336 - 0x2533c
int64_t function_25336(void) {
    // 0x25336
    int64_t result; // 0x25336
    return result;
}

// Address range: 0x2533c - 0x25359
int64_t TC90522_GetQuality2(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = mcount(); // 0x25350
    if (a3 != 0) {
        // 0x25352
        result = TC90522DemodulatorGetQuality2(a1, a2);
        *(char *)a3 = (char)result;
    }
    // 0x25359
    return result;
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x2535c - 0x25365
// Line range:    328 - 434
char TC90522DemodulatorGetStrength(char * pDeviceExtension, int64_t TunerDeviceID) {
    // 0x2535c
    int64_t v1; // 0x2535c
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// Address range: 0x25365 - 0x2538c
int64_t Japan4x4Tuner_TunerGetQuality2(unsigned char a1, int64_t a2, int64_t a3) {
    // 0x25365
    mcount();
    int64_t result = 0; // 0x2537a
    if (a1 < 64) {
        // 0x2537c
        result = TC90522_GetQuality2(a3, (int64_t)a1, a2);
    }
    // 0x2538a
    return result;
}

// Address range: 0x2538c - 0x2564b
int64_t TC90522DemodulatorGetStrength2(int64_t a1, uint64_t a2) {
    // 0x2538c
    mcount();
    if (a2 >= 64) {
        // 0x255a4
        return (int64_t)&g7;
    }
    int32_t v1; // bp-57, 0x2538c
    if (((char)a2 & (char)&g1) != 0) {
        int64_t v2 = TC90522DemodulatorPSK_I2C_Read2(a1, a2, 195, (int64_t *)&v1); // 0x25509
        if ((char)v2 != (char)&g1 || ((char)v1 & (char)&g2) != 0) {
            // 0x255a4
            return (int64_t)&g7;
        }
        int64_t v3 = TC90522DemodulatorPSK_I2C_Read2(a1, a2, 240, (int64_t *)&v1); // 0x2552f
        if ((char)v3 != (char)&g1) {
            // 0x255a4
            return (int64_t)&g7;
        }
        int64_t v4 = TC90522DemodulatorPSK_I2C_Read2(a1, a2, 241, (int64_t *)&v1); // 0x2554c
        if ((char)v4 != (char)&g1) {
            // 0x255a4
            return (int64_t)&g7;
        }
        int64_t v5 = TC90522DemodulatorPSK_I2C_Read2(a1, a2, 242, (int64_t *)&v1); // 0x25569
        if ((char)v5 == (char)&g1) {
            // 0x25572
            DriverDebugPrint2(0, ((int64_t)(v1 % 256) << (int64_t)&g95 | (int64_t)(v1 % 256)) << (int64_t)&g95 | (int64_t)(v1 % 256));
        }
        // 0x255a4
        return (int64_t)&g7;
    }
    int64_t v6 = TC90522DemodulatorOFDM_I2C_Write2(a1, a2, (int64_t *)186, 0); // 0x253d1
    if ((char)v6 != (char)&g1) {
        // 0x255a4
        return (int64_t)&g7;
    }
    int64_t v7 = TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 176, (int64_t *)&v1); // 0x253ed
    if ((char)v7 != (char)&g1 || ((char)v1 & (char)((int32_t)&g105 & 255)) <= (char)&g94) {
        // 0x255a4
        return (int64_t)&g7;
    }
    int64_t v8 = TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 157, (int64_t *)&v1); // 0x25418
    if ((char)v8 != (char)&g1) {
        // 0x255a4
        return (int64_t)&g7;
    }
    int64_t v9 = TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 158, (int64_t *)&v1); // 0x25439
    if ((char)v9 != (char)&g1) {
        // 0x255a4
        return (int64_t)&g7;
    }
    int64_t v10 = TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 159, (int64_t *)&v1); // 0x2545a
    if ((char)v10 != (char)&g1) {
        // 0x255a4
        return (int64_t)&g7;
    }
    // 0x25467
    DriverDebugPrint2(0, ((int64_t)(v1 % 256) << (int64_t)&g95 | (int64_t)(v1 % 256)) << (int64_t)&g95 | (int64_t)(v1 % 256));
    int64_t v11 = TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 166, (int64_t *)&v1); // 0x254a4
    if ((char)v11 != (char)&g1) {
        // 0x255a4
        return (int64_t)&g7;
    }
    // 0x254b1
    TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 167, (int64_t *)&v1);
    return (int64_t)&g7;
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x2564f - 0x25675
// Line range:    294 - 302
char TC90522_GetStrength(char * pDeviceExtension, int64_t TunerDeviceID, char * pStrength) {
    // 0x2564f
    int64_t v1; // 0x2564f
    uint32_t v2 = (int32_t)v1;
    uint32_t v3 = 2 * v2; // 0x2564f
    char result = v3; // 0x25651
    if (v3 >= v2 && v3 != 0) {
        // 0x25653
        int64_t v4; // 0x2564f
        result = (int32_t)v4 < 0xf4241 ? (char)(2 * (int64_t)(int32_t)&g89 & 0xffffffff) : (char)&g89;
    }
    // 0x25669
    return result;
}

// From module:   /root/asv5220\Japan4x4Tuner.c
// Address range: 0x25678 - 0x25679
// Line range:    167 - 173
char Japan4x4Tuner_TunerGetStrength(int64_t TunerDeviceID, char * pStrength, char * pDeviceExtension) {
    // 0x25678
    int64_t result; // 0x25678
    return result;
}

// Address range: 0x25679 - 0x2567f
int64_t function_25679(void) {
    // 0x25679
    int64_t result; // 0x25679
    return result;
}

// Address range: 0x2567f - 0x2569c
int64_t TC90522_GetStrength2(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = mcount(); // 0x25693
    if (a3 != 0) {
        // 0x25695
        result = TC90522DemodulatorGetStrength2(a1, a2);
        *(char *)a3 = (char)result;
    }
    // 0x2569c
    return result;
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x2569f - 0x256a8
// Line range:    233 - 293
char TC90522_CheckLock(char * pDeviceExtension, int64_t TunerDeviceID, char * pLock) {
    // 0x2569f
    int64_t v1; // 0x2569f
    char result = v1;
    *(char *)v1 = 2 * result;
    return result;
}

// Address range: 0x256a8 - 0x256cf
int64_t Japan4x4Tuner_TunerGetStrength2(unsigned char a1, int64_t a2, int64_t a3) {
    // 0x256a8
    mcount();
    int64_t result = 0; // 0x256bd
    if (a1 < 64) {
        // 0x256bf
        result = TC90522_GetStrength2(a3, (int64_t)a1, a2);
    }
    // 0x256cd
    return result;
}

// Address range: 0x256cf - 0x257f4
int64_t TC90522_CheckLock2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x256cf
    mcount();
    DriverDebugMessage2(0);
    int64_t result = DriverDebugPrint2(0, a2); // 0x25710
    char * v1 = (char *)a3; // 0x25724
    *v1 = 0;
    if (a2 >= 64) {
        // 0x257ee
        return result;
    }
    int32_t v2; // bp-41, 0x256cf
    if (((char)a2 & (char)&g1) != 0) {
        int64_t result2 = TC90522DemodulatorPSK_I2C_Read2(a1, a2, 195, (int64_t *)&v2); // 0x257c5
        if ((char)result2 != (char)&g1) {
            // 0x257ee
            return result2;
        }
        int64_t result3 = TC90522DemodulatorGetQuality2(a1, a2); // 0x257da
        *v1 = (char)&g1;
        return result3;
    }
    int64_t result4 = TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 128, (int64_t *)&v2); // 0x25746
    if ((char)result4 == 0) {
        // 0x257ee
        return result4;
    }
    // 0x25753
    DriverDebugPrint2(0, (int64_t)(v2 % 256));
    int64_t result5 = TC90522DemodulatorOFDM_I2C_Read2(a1, a2, 176, (int64_t *)&v2); // 0x25781
    if ((char)result5 == 0) {
        // 0x257ee
        return result5;
    }
    // 0x2578a
    DriverDebugPrint2(0, (int64_t)(v2 % 256));
    *v1 = (char)&g1;
    return v2 & (int32_t)&g105 & 255;
}

// From module:   /root/asv5220\Japan4x4Tuner.c
// Address range: 0x257f5 - 0x25810
// Line range:    160 - 166
char Japan4x4Tuner_TunerCheckLockStatus(int64_t TunerDeviceID, char * pLock, char * pDeviceExtension) {
    // 0x257f5
    int64_t result; // 0x257f5
    return result;
}

// From module:   /root/asv5220/./NMI131\NMI131.c
// Address range: 0x2581c - 0x25825
// Line range:    127 - 160
char NMI131_WriteRegister(char * pUserData, char i2cAdr, char * wb, int32_t sz) {
    // 0x2581c
    int64_t result; // 0x2581c
    return result;
}

// Address range: 0x25825 - 0x2584c
int64_t Japan4x4Tuner_TunerCheckLockStatus2(unsigned char a1, int64_t a2, int64_t a3) {
    // 0x25825
    mcount();
    int64_t result = 0; // 0x2583a
    if (a1 < 64) {
        // 0x2583c
        result = TC90522_CheckLock2(a3, (int64_t)a1, a2);
    }
    // 0x2584a
    return result;
}

// Address range: 0x2584c - 0x258cf
int64_t NMI131_WriteRegister2(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x2584c
    mcount();
    int64_t v1 = __kmalloc(a4 + (int64_t)(uint32_t)(int32_t)&g25 & 0xffffffff, (int64_t *)&g26, a3); // 0x25888
    *(char *)v1 = -2;
    *(char *)(v1 + (int64_t)&g1) = -50;
    memcpy(v1 + (int64_t)&g25, a3, a4 & 0xffffffff, a4);
    int64_t result = I2C_PortingLayer_Write2(a1, (a2 * (int64_t)(int32_t)((int64_t)&g1 + 1) & (int64_t)(int32_t)&g103) + (int64_t)(int32_t)&g26 & 0xfffffff8, v1, (a4 + (int64_t)(int16_t)&g25) % 0x10000); // 0x258c3
    return result;
}

// From module:   /root/asv5220/./NMI131\NMI131.c
// Address range: 0x258d4 - 0x258e3
// Line range:    122 - 125
void NMI131_Delay(int32_t delay_ms) {
    // 0x258d4
    int64_t v1; // 0x258d4
    *(char *)v1 = 2 * (char)v1;
    DriverDebugMessage2((int64_t)delay_ms);
    int64_t v2; // 0x258d4
    kfree(v2);
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x258e4 - 0x258e5
// Line range:    779 - 782
void TC90522DemodulatorDelayMilliseconds(int64_t nMinDelayTime) {
    // 0x258e4
    return;
}

// From module:   /root/asv5220/./TC90522\TC90522.c
// Address range: 0x258f4 - 0x25904
// Line range:    140 - 181
char TC90522_ChannelSearch(char * pDeviceExtension, int64_t TunerDeviceID) {
    // 0x258f4
    int64_t result; // 0x258f4
    return result;
}

// Address range: 0x25904 - 0x25914
int64_t NMI131_Delay2(void) {
    // 0x25904
    mcount();
    return msleep_interruptible();
}

// Address range: 0x25914 - 0x25924
int64_t TC90522DemodulatorDelayMilliseconds2(int64_t a1) {
    // 0x25914
    mcount();
    return msleep_interruptible();
}

// Address range: 0x25924 - 0x25940
int64_t TC90522_ChannelSearch2(int64_t a1, int64_t a2) {
    // 0x25924
    return mcount();
}

// Address range: 0x25944 - 0x25a14
int64_t function_25944(int64_t a1, int64_t a2) {
    // 0x25944
    TC90522DemodulatorDelayMilliseconds2(250);
    int64_t v1; // 0x25944
    int64_t v2; // 0x25944
    if (((char)a2 & (char)&g1) != 0) {
        // 0x259c8
        TC90522DemodulatorPSK_I2C_Write2(v1, v2, (int64_t)&g98, 255);
        return TC90522DemodulatorPSK_I2C_Write2(v1, v2, (int64_t)&g2, 178);
    }
    // 0x25950
    TC90522DemodulatorOFDM_I2C_Write2(v1, v2, &g31, 76);
    TC90522DemodulatorOFDM_I2C_Write2(v1, v2, (int64_t *)&g1, 80);
    TC90522DemodulatorOFDM_I2C_Write2(v1, v2, (int64_t *)113, (int64_t)&g1);
    return TC90522DemodulatorOFDM_I2C_Write2(v1, v2, (int64_t *)114, 36);
}

// From module:   /root/asv5220\Japan4x4Tuner.c
// Address range: 0x25a14 - 0x25a44
// Line range:    120 - 139
char Japan4x4Tuner_TunerSetFrequency(int64_t TunerDeviceID, int64_t RF, char * pDeviceExtension) {
    // 0x25a14
    int64_t v1; // 0x25a14
    int64_t v2 = TC90522DemodulatorPSK_I2C_Write2(TunerDeviceID, RF, (int64_t)pDeviceExtension, v1); // 0x25a14
    char result = 0; // 0x25a1b
    if ((char)v2 == (char)&g1) {
        // 0x25a1d
        int64_t v3; // 0x25a14
        int64_t v4; // 0x25a14
        int64_t v5 = TC90522DemodulatorPSK_I2C_Write2(v3, v4, (int64_t)&g33, (int64_t)&g1); // 0x25a2d
        result = v5;
    }
    // 0x25a39
    return result;
}

// Address range: 0x25a44 - 0x25a8e
int64_t Japan4x4Tuner_TunerSetFrequency2(char a1, int64_t a2, int64_t a3) {
    // 0x25a44
    mcount();
    return TC90522_ResetInternal2(a3, (int64_t)a1);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nmicmn.c
// Address range: 0x25a90 - 0x25ac0
// Line range:    317 - 329
void nmi_common_init(int64_t pPrivate, int64_t inp, int64_t ptv) {
    // 0x25a90
    function_eee5a94();
}

// Address range: 0x25ac0 - 0x25d61
int64_t nmi_common_init2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x25b19
    mcount();
    uint64_t v1; // 0x25ac0
    int64_t v2 = 184 * (v1 % 256); // 0x25acf
    __asm_rep_stosq_memset((char *)v2, 0, (int64_t)(184 >> (int32_t)&g33));
    bool v3; // 0x25ac0
    int64_t v4 = v3 ? -8 * (int64_t)(184 >> (int32_t)&g33) : (int64_t)&g95 * (int64_t)(184 >> (int32_t)&g33); // 0x25b21
    int64_t v5 = v4 + v2; // 0x25b21
    int64_t v6 = v5; // 0x25b21
    int64_t v7 = v5; // 0x25b28
    if (((char)&g86 & -72) != 0) {
        // 0x25b2a
        *(int32_t *)v5 = 0;
        v7 = v6 + (int64_t)&g86;
        v6 = v7;
    }
    int64_t v8 = v7; // 0x25b34
    if (((char)&g25 & -72) != 0) {
        // 0x25b36
        *(int16_t *)v7 = 0;
        v8 = v6 + (int64_t)&g25;
        v6 = v8;
    }
    if (((char)&g1 & -72) != 0) {
        // 0x25b43
        *(char *)v8 = 0;
    }
    if (a2 != 0) {
        int64_t v9 = 184 * (int64_t)*(char *)&v6; // 0x25b59
        *(int64_t *)v9 = a2;
        *(int64_t *)(v9 + 8) = *(int64_t *)(a2 + (int64_t)&g95);
        *(int64_t *)(v9 + 16) = *(int64_t *)(a2 + (int64_t)&g2);
        *(int64_t *)(v9 + 24) = *(int64_t *)(a2 + (int64_t)&g13);
        *(int64_t *)(v9 + 32) = *(int64_t *)(a2 + (int64_t)&g26);
        *(int64_t *)(v9 + 40) = *(int64_t *)(a2 + 40);
        *(int64_t *)(v9 + 48) = *(int64_t *)(a2 + 48);
        *(int64_t *)(v9 + 56) = *(int64_t *)(a2 + 56);
        *(int64_t *)(v9 + 64) = *(int64_t *)(a2 + 64);
        *(int64_t *)(v9 + 72) = *(int64_t *)(a2 + 72);
        *(int64_t *)(v9 + 80) = *(int64_t *)(a2 + 80);
        *(int64_t *)(v9 + 88) = *(int64_t *)(a2 + 88);
        *(int64_t *)(v9 + 96) = *(int64_t *)(a2 + 96);
        *(int64_t *)(v9 + 104) = *(int64_t *)(a2 + 104);
    }
    // 0x25bdc
    *(int64_t *)a3 = 0;
    *(int64_t *)(a3 + (int64_t)&g95) = 0;
    *(int64_t *)(a3 + (int64_t)&g2) = 0;
    *(int64_t *)(a3 + (int64_t)&g13) = 0;
    *(int64_t *)(a3 + (int64_t)&g26) = 0;
    *(int64_t *)(a3 + 40) = 0;
    *(int64_t *)(a3 + 48) = 0;
    *(int64_t *)(a3 + 56) = 0;
    *(int64_t *)(a3 + 64) = 0;
    *(int64_t *)(a3 + 72) = 0;
    *(int64_t *)(a3 + 80) = 0;
    *(int64_t *)(a3 + 88) = 0;
    *(int64_t *)(a3 + 96) = 0;
    *(int64_t *)(a3 + 104) = 0;
    *(int64_t *)(a3 + 112) = 0;
    *(int64_t *)(a3 + 120) = 0;
    *(int64_t *)(a3 + 128) = 0;
    *(int64_t *)(a3 + 136) = 0;
    *(int64_t *)(a3 + 144) = 0;
    *(int64_t *)(a3 + 152) = 0;
    *(int64_t *)(a3 + 160) = 0;
    *(int64_t *)(a3 + 168) = 0;
    *(int64_t *)(a3 + 176) = 0;
    *(int64_t *)(a3 + 184) = 0;
    *(int64_t *)(a3 + 192) = 0;
    *(int64_t *)(a3 + 200) = 0;
    *(int64_t *)(a3 + 208) = 0;
    *(int64_t *)(a3 + 216) = 0;
    *(int64_t *)(a3 + 224) = 0;
    *(int64_t *)(a3 + 232) = 0;
    *(int64_t *)(a3 + 240) = 0;
    *(int64_t *)(a3 + 248) = 0;
    *(int64_t *)(a3 + 256) = 0;
    *(int64_t *)(a3 + 264) = 0;
    *(int64_t *)(a3 + 272) = 0;
    *(int64_t *)(a3 + 280) = 0;
    *(int64_t *)(a3 + 288) = 0;
    *(int64_t *)(a3 + 296) = 0;
    *(int64_t *)(a3 + 304) = 0;
    return 0;
}

// From module:   /root/asv5220/./NMI131\NMI131.c
// Address range: 0x25d6a - 0x25d9a
// Line range:    23 - 77
char NMI131_Initialization(char * pDeviceExtension, int64_t TunerDeviceID) {
    // 0x25d6a
    int64_t v1; // 0x25d6a
    char result = v1;
    *(char *)v1 = 2 * result;
    int64_t v2; // 0x25d6a
    *(int64_t *)(v2 + 320) = 0;
    *(int64_t *)(v2 + 328) = 0;
    *(int64_t *)(v2 + 344) = 0;
    *(int64_t *)(v2 + 336) = 0;
    return result;
}

// Address range: 0x25d9a - 0x25ef3
int64_t NMI131_Initialization2(int64_t a1, uint64_t a2) {
    // 0x25d9a
    mcount();
    DriverDebugMessage2(0);
    int64_t v1 = a2 >> (uint64_t)(int64_t)&g1; // 0x25dc1
    int64_t v2 = v1 * ((int64_t)&g86 + (int64_t)&g1) * (int64_t)&g95; // 0x25dd7
    *(int64_t *)(v2 + 8) = 0;
    *(char *)v2 = (char)&g33;
    int64_t v3 = v1 * ((1 << (int64_t)&g94) - (1 << (int64_t)&g86)); // 0x25e09
    int64_t * v4 = (int64_t *)(v1 * (int64_t)&g95); // 0x25e13
    *v4 = v3;
    __asm_rep_stosq_memset((char *)v3, 0, (int64_t)&g103);
    *(int32_t *)v3 = (int32_t)&g13;
    *(int32_t *)(v3 + (int64_t)&g86) = 0;
    *(char *)(v3 + (int64_t)&g95) = (char)a2;
    *(int32_t *)(v3 + (int64_t)"GNU") = (int32_t)&g4;
    *(int64_t *)(v3 + (int64_t)&g26) = 0;
    *(int64_t *)(v3 + (int64_t)&g13) = 0;
    *(int64_t *)(v3 + 40) = 0;
    *(int64_t *)(v3 + 48) = 0;
    *(int64_t *)(v3 + 56) = 0;
    *(int64_t *)(v3 + 64) = 0;
    *(int64_t *)(v3 + 72) = 0;
    *(char *)(v3 + (int64_t)&g2) = 0;
    *(char *)(v3 + 104) = 0;
    *(int32_t *)(v3 + 108) = 0;
    int64_t v5 = v1 * (((int64_t)&g86 + (int64_t)&g1) * (int64_t)&g25 + 1 << (int64_t)&g89); // 0x25e92
    *v4 = v5;
    nmi_common_init2(v2, v3, v5);
    return 0;
}

// From module:   /root/asv5220\Japan4x4Tuner.c
// Address range: 0x25ef7 - 0x25f27
// Line range:    44 - 119
char Japan4x4Tuner_TunerInitialization(int64_t TunerDeviceID, char * pDeviceExtension) {
    // 0x25ef7
    int64_t v1; // 0x25ef7
    char * v2 = (char *)(v1 - 57);
    int64_t v3; // 0x25ef7
    *v2 = *v2 + (char)v3;
    int64_t v4; // 0x25ef7
    *(int32_t *)v4 = -0x18000000;
    int64_t v5 = v4;
    *(char *)v5 = *(char *)&v4 + (char)v5;
    return &g1;
}

// Address range: 0x25f27 - 0x2613e
int64_t Japan4x4Tuner_TunerInitialization2(uint64_t a1, int64_t a2) {
    // 0x25f27
    mcount();
    DriverDebugMessage2(0);
    DriverDebugMessage2(0);
    DriverDebugPrint2(0, a1);
    if (a1 >= 128) {
        int64_t v1 = &g95; // 0x25f27
        switch ((a1 - 144) / 16 || 0x1000000000000000 * a1) {
            case 6: {
                // 0x25fed
                v1 = 56;
            }
            case 0: {
              lab_0x25fed:;
                uint64_t v2 = v1 % 256; // 0x25fed
                TC90522_Initialization2(a2, v2, (int64_t *)&g1);
                NMI131_Initialization2(a2, v2);
                int64_t v3 = 0x100000000 * (v2 + (int64_t)(int32_t)&g1) / 0x100000000; // 0x26014
                TC90522_Initialization2(a2, v3, (int64_t *)&g1);
                TDA2014x_TunerInitialization2(a2, v3);
                int64_t v4 = 0x100000000 * (v2 + (int64_t)(int32_t)&g25) / 0x100000000; // 0x26036
                TC90522_Initialization2(a2, v4, (int64_t *)&g1);
                NMI131_Initialization2(a2, v4);
                int64_t v5 = 0x100000000 * (v2 + (int64_t)(int32_t)&g33) / 0x100000000; // 0x26058
                TC90522_Initialization2(a2, v5, (int64_t *)&g1);
                TDA2014x_TunerInitialization2(a2, v5);
                int64_t v6 = 0x100000000 * (v2 + (int64_t)(int32_t)&g86) / 0x100000000; // 0x2607a
                TC90522_Initialization2(a2, v6, (int64_t *)&g1);
                NMI131_Initialization2(a2, v6);
                int64_t v7 = 0x100000000 * (v2 + (int64_t)(int32_t)&g89) / 0x100000000; // 0x2609c
                TC90522_Initialization2(a2, v7, (int64_t *)&g1);
                TDA2014x_TunerInitialization2(a2, v7);
                int64_t v8 = 0x100000000 * (v2 + (int64_t)(int32_t)&g91) / 0x100000000; // 0x260be
                TC90522_Initialization2(a2, v8, (int64_t *)&g1);
                NMI131_Initialization2(a2, v8);
                int64_t v9 = 0x100000000 * (v2 + (int64_t)(int32_t)&g94) / 0x100000000; // 0x260e0
                TC90522_Initialization2(a2, v9, (int64_t *)&g1);
                return TDA2014x_TunerInitialization2(a2, v9);
            }
            case 1: {
                // 0x25fed
                v1 = &g2;
                // branch (via goto) -> 0x25fed
                goto lab_0x25fed;
            }
            case 2: {
                // 0x25fed
                v1 = (int64_t)&g13;
                // branch (via goto) -> 0x25fed
                goto lab_0x25fed;
            }
            case 3: {
                // 0x25fed
                v1 = (int64_t)&g26;
                // branch (via goto) -> 0x25fed
                goto lab_0x25fed;
            }
            case 4: {
                // 0x25fed
                v1 = 40;
                // branch (via goto) -> 0x25fed
                goto lab_0x25fed;
            }
            case 5: {
                // 0x25fed
                v1 = 48;
                // branch (via goto) -> 0x25fed
                goto lab_0x25fed;
            }
            default: {
                // 0x25fe7
                v1 = 0;
                // branch (via goto) -> 0x25fed
                goto lab_0x25fed;
            }
        }
    }
    int64_t result = TC90522_Initialization2(a2, a1, NULL); // 0x2611d
    if (((char)a1 & (char)&g1) != 0) {
        // 0x2613e
        return result;
    }
    // 0x2612e
    return NMI131_Initialization2(a2, a1);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nmicmn.c
// Address range: 0x2613f - 0x2616f
// Line range:    22 - 40
void nmi_debug(int64_t pPrivate, int32_t zone, char * fmt, ...) {
    // 0x2613f
    int64_t v1; // 0x2613f
    int64_t v2; // 0x2613f
    uint64_t v3 = TDA2014x_TunerInitialization2(v1, v2 & 0xffffffff); // 0x26144
    DriverDebugPrint2(0, v3 % 256);
}

// Address range: 0x2616f - 0x26205
int64_t nmi_debug2(int64_t a1, int64_t * a2, int64_t format, int128_t a4, int64_t a5, int64_t a6) {
    // 0x2616f
    mcount();
    __readgsqword(40);
    int32_t * v1 = (int32_t *)&g13; // bp-376, 0x261ba
    char str = 0; // bp-332, 0x261eb
    int64_t v2; // bp-72, 0x2616f
    vsprintf(&str, format, (int64_t *)&v1, &v2);
    uint64_t v3; // 0x2616f
    return 184 * (v3 % 256);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nmicmn.c
// Address range: 0x26208 - 0x26238
// Line range:    123 - 184
void wReg8(int64_t pPrivate, char adr, char val) {
    // 0x26208
    int64_t v1; // 0x26208
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x26208
    int64_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    int64_t v4; // 0x26208
    int64_t v5 = __readgsqword(40) ^ *(int64_t *)(v4 - 72); // 0x2621e
    v2 = v5;
    if (v5 != 0) {
        // 0x26229
        v2 = __stack_chk_fail();
    }
}

// Address range: 0x26238 - 0x263a7
int64_t wReg8_(int64_t a1, int64_t * a2, int64_t a3) {
    // 0x26238
    mcount();
    uint64_t v1; // 0x26238
    uint64_t v2 = 184 * (v1 % 256); // 0x2624f
    int64_t v3; // 0x26238
    int64_t v4; // 0x26238
    if (*(int64_t *)v2 == 0) {
        // 0x26287
        return nmi_debug2(a1, (int64_t *)&g25, 0, (int128_t)v2, v4, v3);
    }
    char * v5 = (char *)v2; // 0x2627e
    if (*v5 != 0) {
        // 0x26287
        return nmi_debug2(a1, (int64_t *)&g25, 0, (int128_t)v2, v4, v3);
    }
    char v6 = (int64_t)a2; // 0x262a5
    int64_t v7; // 0x26238
    if (v6 == 54) {
        // 0x26374
        return 184 * (int64_t)*(char *)&v7;
    }
    if (v6 == 0) {
        // 0x262e7
        *v5 = (char)a3;
        // 0x26374
        return 184 * (int64_t)*(char *)&v7;
    }
    if (v6 == 52) {
        // 0x2630b
        *v5 = (char)a3;
        // 0x26374
        return 184 * (int64_t)*(char *)&v7;
    }
    if (v6 == 53) {
        // 0x2632c
        *v5 = (char)a3;
        // 0x26374
        return 184 * (int64_t)*(char *)&v7;
    }
    if (v6 == (char)&g89) {
        // 0x2634d
        *v5 = (char)a3;
        // 0x26374
        return 184 * (int64_t)*(char *)&v7;
    }
    if (v6 == (char)&g98) {
        // 0x2636e
        *v5 = (char)a3;
    }
    // 0x26374
    return 184 * (int64_t)*(char *)&v7;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x263a8 - 0x263d8
// Line range:    2581 - 2604
void nm131_lt_ctrl(int64_t pPrivate, char enable) {
    // 0x263a8
    int64_t v1; // 0x263a8
    int64_t v2; // 0x263a8
    uint64_t v3; // 0x263a8
    int64_t v4; // 0x263a8
    nmi_debug2(v3, (int64_t *)&g25, 0, (int128_t)v4, v2, v1);
    *(char *)(184 * (v3 % 256)) = (char)&g1;
}

// Address range: 0x263d8 - 0x263fb
int64_t nm131_lt_ctrl2(int64_t a1, int64_t a2) {
    // 0x263d8
    mcount();
    uint64_t v1; // 0x263d8
    return (int64_t)*(int32_t *)(184 * (v1 % 256));
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x263fc - 0x2642c
// Line range:    2610 - 2642
void nm131_set_video_amplitude(int64_t pPrivate, char amp) {
    // 0x263fc
    uint64_t v1; // 0x263fc
    wReg8_(pPrivate, (int64_t *)&g98, v1 % 8 | 248);
}

// Address range: 0x2642c - 0x26593
int64_t nm131_set_video_amplitude2(uint64_t a1, uint64_t a2) {
    // 0x2642c
    mcount();
    int64_t v1 = 184 * (a1 % 256); // 0x26452
    int32_t * v2 = (int32_t *)v1; // 0x26459
    uint32_t v3 = *v2; // 0x26459
    if (v3 < 2) {
        int64_t result = wReg8_(a1, (int64_t *)52, a2 % 256 ^ 255); // 0x2648d
        *(char *)v1 = (char)a2;
        return result;
    }
    int32_t result2 = v3; // 0x26544
    if ((char)a2 <= (char)&g105 && v3 == 3) {
        // 0x26551
        wReg8_(a1, (int64_t *)52, (127 - a2) % 256);
        result2 = *v2;
    }
    // 0x26569
    return result2;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26593 - 0x265ad
// Line range:    3446 - 3449
void nm131_notch_set(int64_t pPrivate, int32_t en, uint32_t frequency, int32_t width) {
    // 0x26593
    int64_t v1; // 0x26593
    wReg8_(v1, (int64_t *)53, (int64_t)(frequency % 256));
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nmicmn.c
// Address range: 0x265b4 - 0x265c3
// Line range:    71 - 95
char rReg8(int64_t pPrivate, char adr) {
    // 0x265b4
    int64_t v1; // 0x265b4
    char * v2 = (char *)(v1 - 117); // 0x265b4
    int64_t v3; // 0x265b4
    *v2 = *v2 + (char)v3;
    return unknown_fffffffff067f109();
}

// Address range: 0x265c3 - 0x265e4
int64_t nm131_notch_set2(void) {
    // 0x265c3
    mcount();
    int64_t v1; // 0x265c3
    int64_t v2; // 0x265c3
    int64_t v3; // 0x265c3
    int64_t v4; // 0x265c3
    return nmi_debug2(v3, (int64_t *)&g25, 0, (int128_t)v4, v2, v1);
}

// Address range: 0x265e4 - 0x266d5
int64_t rReg8_(uint64_t a1, int64_t a2) {
    // 0x265e4
    mcount();
    int64_t result = 184 * (a1 % 256); // 0x265fb
    int64_t v1; // 0x265e4
    int64_t v2; // 0x265e4
    uint64_t v3; // 0x265e4
    if (*(int64_t *)result == 0) {
        // 0x26629
        nmi_debug2(a1, (int64_t *)&g25, 0, (int128_t)v3, v2, v1);
        return 0;
    }
    // 0x26620
    if (*(char *)result == 0) {
        // 0x2664c
        return result;
    }
    // 0x26629
    nmi_debug2(a1, (int64_t *)&g25, 0, (int128_t)v3, v2, v1);
    return 0;
}

// Address range: 0x266d7 - 0x266da
int64_t function_266d7(void) {
    // 0x266d7
    int64_t result; // 0x266d7
    return result;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x266da - 0x2670a
// Line range:    1846 - 1872
void nm120_rfli_ctrl(int64_t pPrivate, char enable) {
    // 0x266da
    int64_t v1; // 0x266da
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x266da
    int64_t v3; // 0x266da
    uint64_t v4; // 0x266da
    int64_t v5; // 0x266da
    int64_t v6; // 0x266da
    nmi_debug2(v4, (int64_t *)&g25, v5, (int128_t)v6, v3, v2);
    *(char *)(184 * (v4 % 256)) = (char)&g1;
}

// Address range: 0x2670a - 0x26846
int64_t nm120_rfli_ctrl2(uint64_t a1, int64_t a2) {
    // 0x2670a
    mcount();
    uint64_t v1 = a1 % 256; // 0x26731
    if ((char)a2 == 0) {
        int64_t v2 = 184 * v1;
        wReg8_(a1, (int64_t *)43, (int64_t)*(char *)v2);
        return wReg8_(a1, (int64_t *)37, (int64_t)*(char *)(v2 + 11));
    }
    int64_t v3 = rReg8_(a1, 43); // 0x2673e
    int64_t v4 = 184 * v1;
    *(char *)v4 = (char)v3;
    wReg8_(a1, (int64_t *)43, 42);
    *(char *)(v4 + 11) = (char)rReg8_(a1, 37);
    *(char *)(v4 + 12) = (char)rReg8_(a1, 41);
    wReg8_(a1, (int64_t *)37, 250);
    return wReg8_(a1, (int64_t *)41, 239);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x2684a - 0x2687a
// Line range:    1388 - 1397
void nm131_set_lna_gain2(int64_t pPrivate, char g) {
    // 0x2684a
    int64_t v1; // 0x2684a
    char * v2 = (char *)(v1 - 25 + v1 * (int64_t)&g86); // 0x2684a
    *v2 = *v2 + (char)v1;
    int64_t v3; // 0x2684a
    wReg8_(pPrivate, (int64_t *)(int64_t)g, v3);
    int64_t v4; // 0x2684a
    int64_t v5; // 0x2684a
    *(char *)(184 * 0x100000000 * v5 / 0x100000000) = (char)v4;
}

// Address range: 0x2687a - 0x2689b
int64_t nm131_set_lna_gain2_(int64_t a1, char a2) {
    // 0x2687a
    return mcount();
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x2689b - 0x268cb
// Line range:    2648 - 2711
char nm131_get_video_amplitude(int64_t pPrivate) {
    // 0x2689b
    int64_t v1; // 0x2689b
    int64_t v2 = rReg8_(pPrivate, v1); // 0x2689b
    int64_t v3; // 0x2689b
    int64_t v4; // 0x2689b
    int64_t result = wReg8_(v4, (int64_t *)43, v3 & (int64_t)(char)&g24 | v2 & 64 | 32); // 0x268bb
    return result;
}

// Address range: 0x268cb - 0x26a30
int64_t nm131_get_video_amplitude2(void) {
    // 0x268cb
    mcount();
    uint64_t v1; // 0x268cb
    int64_t v2 = 184 * (v1 % 256); // 0x268da
    uint32_t v3 = *(int32_t *)v2; // 0x268e1
    if (v3 < 2) {
        // 0x268ff
        return rReg8_(v1, 52) & 0xffffffff ^ 0xffffffff;
    }
    if (v3 != 3) {
        // 0x26a08
        return (95 - rReg8_(v1, 53)) % 256;
    }
    if (v3 == 13) {
        // 0x269f6
        return (int64_t)*(char *)v2;
    }
    // 0x269d9
    return (127 - rReg8_(v1, 52)) % 256;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26a31 - 0x26a61
// Line range:    1361 - 1386
void nm131_set_lna_gain(int64_t pPrivate, int32_t g) {
    // 0x26a31
    int64_t v1; // 0x26a31
    int64_t v2 = v1 + 0x96b767b8; // 0x26a31
    char * v3 = (char *)(v2 & 0xffffffff); // 0x26a40
    *v3 = *v3 + (char)v2;
}

// Address range: 0x26a61 - 0x26aae
int64_t nm131_set_lna_gain3(int64_t a1, int64_t a2) {
    // 0x26a61
    mcount();
    int64_t v1 = rReg8_(a1, 43) & 0xffffffe0; // 0x26a7c
    int32_t v2 = a2; // 0x26a82
    if (v2 == 0) {
        // 0x26a86
        return v1 | (int64_t)(int32_t)&g26 | (int64_t)(int32_t)&g3;
    }
    if (v2 == (int32_t)&g1) {
        // 0x26a90
        return v1 | (int64_t)(int32_t)&g26 | (int64_t)(int32_t)&g2;
    }
    if (v2 == (int32_t)&g25) {
        // 0x26a9a
        return v1 | (int64_t)(int32_t)&g26 | (int64_t)(int32_t)&g105;
    }
    if (v2 != (int32_t)&g33) {
        // 0x26aae
        return v1 | (int64_t)(int32_t)&g26;
    }
    // 0x26aa4
    return v1 | (int64_t)(int32_t)&g26 | (int64_t)(int32_t)&g103;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nmicmn.c
// Address range: 0x26ab0 - 0x26ae0
// Line range:    97 - 121
int32_t rReg32(int64_t pPrivate, int16_t adr) {
    // 0x26ab0
    int64_t v1; // 0x26ab0
    return ((int32_t)v1 | -0x47ce715) - 0x377cfa8b | (int32_t)(unsigned char)(char)"%(";
}

// Address range: 0x26ae0 - 0x26bc3
int64_t rReg32_(uint64_t a1, int64_t a2) {
    // 0x26ae0
    mcount();
    int64_t result = 184 * (a1 % 256); // 0x26af7
    int64_t v1; // 0x26ae0
    int64_t v2; // 0x26ae0
    uint64_t v3; // 0x26ae0
    if (*(int64_t *)result == 0) {
        // 0x26b25
        nmi_debug2(a1, (int64_t *)&g25, 0, (int128_t)v3, v2, v1);
        return 0;
    }
    // 0x26b1c
    if (*(char *)result == 0) {
        // 0x26b48
        return result;
    }
    // 0x26b25
    nmi_debug2(a1, (int64_t *)&g25, 0, (int128_t)v3, v2, v1);
    return 0;
}

// Address range: 0x26bd5 - 0x26bdb
int64_t function_26bd5(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x26bd5
    int64_t result; // 0x26bd5
    return result;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26bf6 - 0x26c21
// Line range:    2784 - 2797
char nm131_get_mute(int64_t pPrivate) {
    int64_t v1 = pPrivate;
    int64_t v2; // 0x26bf6
    *(char *)v2 = 2 * (char)v2;
    int64_t result; // 0x26bf6
    int64_t v3 = result; // 0x26bf8
    *(char *)v3 = (char)v3;
    int64_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int64_t v5; // 0x26bf6
    int32_t v6 = *(int32_t *)&v1 + (int32_t)v5; // 0x26bff
    *(int32_t *)pPrivate = v6;
    int64_t v7 = v5 - (int64_t)&g1 - (int64_t)&g1; // 0x26c05
    if (v7 == 0) {
        // 0x26c07
        int64_t v8; // 0x26bf6
        unsigned char v9 = *(char *)(v8 - 30); // 0x26c07
        return (int32_t)v9 << (int32_t)&g2;
    }
    unsigned char v10 = *(char *)&v1; // 0x26c0f
    *(char *)v1 = v10 / 2 | v10;
    if (v7 == (int64_t)&g1 || v6 == 0) {
        unsigned char v11 = *(char *)&v1; // 0x26c15
        *(char *)v1 = v11 / 2 | v11;
        return result;
    }
    char * v12 = (char *)(result - 125); // 0x26c1e
    unsigned char v13 = *v12; // 0x26c1e
    *v12 = v13 / 2 | v13;
    return result;
}

// Address range: 0x26c22 - 0x26c26
int64_t function_26c22(void) {
    // 0x26c22
    int64_t v1; // 0x26c22
    char * v2 = (char *)(v1 - 55); // 0x26c22
    bool v3; // 0x26c22
    *v2 = (char)v3 - (char)v1 + *v2;
    int64_t result; // 0x26c22
    return result;
}

// Address range: 0x26c26 - 0x26c2f
int64_t nm131_get_mute2(void) {
    // 0x26c26
    return mcount();
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26c30 - 0x26c60
// Line range:    2744 - 2762
char nm131_get_brightness(int64_t pPrivate) {
    // 0x26c30
    int64_t result; // 0x26c30
    return result;
}

// Address range: 0x26c60 - 0x26c84
int64_t nm131_get_brightness2(void) {
    // 0x26c60
    mcount();
    return 0;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26c89 - 0x26cb9
// Line range:    2552 - 2579
char nm131_get_volume(int64_t pPrivate) {
    // 0x26c89
    uint64_t v1; // 0x26c89
    *(char *)0xc08603 = *(char *)0xc08603 + (char)v1;
    int64_t v2; // 0x26c89
    return 2 * (char)v2 + (char)(v1 >> (int64_t)&g95);
}

// Address range: 0x26c96 - 0x26c9c
int64_t function_26c96(void) {
    // 0x26c96
    return function_4c00000118bec209();
}

// Address range: 0x26c9c - 0x26ca6
int64_t function_26c9c(void) {
    // 0x26c9c
    int64_t v1; // 0x26c9c
    return (uint64_t)(v1 + 0xfffffa00) / 64 % 0x4000000;
}

// Address range: 0x26ca6 - 0x26cb7
int64_t function_26ca6(int64_t a1, int64_t a2, int64_t a3) {
    // 0x26ca6
    return (int64_t)*(char *)(184 * 0x100000000 * a3 / 0x100000000);
}

// Address range: 0x26cb9 - 0x26d28
int64_t nm131_get_volume2(int64_t a1) {
    // 0x26cb9
    mcount();
    int64_t v1 = rReg8_(a1, 53); // 0x26cf1
    uint64_t v2; // 0x26cb9
    if (*(char *)(184 * (v2 % 256)) == 0) {
        // 0x26d20
        return v1 + 0xffffffb0 & 0xffffffff;
    }
    // 0x26d16
    return (95 - v1) % 256;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26d29 - 0x26d2b
// Line range:    2836 - 2842
int32_t nm131_get_overthcount(int64_t pPrivate) {
    // 0x26d29
    int64_t result; // 0x26d29
    return result;
}

// Address range: 0x26d2e - 0x26d31
int64_t function_26d2e(void) {
    // 0x26d2e
    int64_t result; // 0x26d2e
    return result;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26d43 - 0x26d59
// Line range:    1290 - 1300
int16_t nm131_demod_get_pll_level(int64_t pPrivate) {
    int64_t v1 = unknown_ba7333(); // 0x26d43
    char * v2 = (char *)v1; // 0x26d48
    *v2 = *v2 + (char)v1;
    char * v3 = (char *)(v1 - 117); // 0x26d4a
    int64_t v4; // 0x26d43
    *v3 = *v3 + (char)v4;
    return unknown_fffffffff067f89f();
}

// Address range: 0x26d59 - 0x26d6c
int64_t nm131_get_overthcount2(int64_t a1) {
    // 0x26d59
    mcount();
    return rReg32_(a1, 596);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26d6c - 0x26d73
// Line range:    1276 - 1288
int32_t nm131_demod_get_freq_offset(int64_t pPrivate) {
    // 0x26d6c
    int64_t v1; // 0x26d6c
    return (uint32_t)(int32_t)v1 % 0x10000;
}

// Address range: 0x26d73 - 0x26d9c
int64_t nm131_demod_get_pll_level2(int64_t a1) {
    // 0x26d73
    mcount();
    int64_t v1 = rReg32_(a1, 492); // 0x26d81
    int32_t v2 = (int32_t)v1 >> (int32_t)&g98 & -0xfc01;
    return (int16_t)v2 >= 512 ? v2 - 1024 : v2;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26d9c - 0x26dcc
// Line range:    1249 - 1274
int16_t nm131_demod_get_snr(int64_t pPrivate) {
    // 0x26d9c
    mcount();
    int64_t v1 = rReg32_(pPrivate, 488); // 0x26daa
    int64_t v2 = v1 * (int64_t)(int32_t)&g86; // 0x26daf
    return ((int32_t)((-0x31fe307b * v1 * 0x100000000 * (int64_t)(int32_t)&g86 / 0x100000000 >> (int64_t)&g26) + (v2 & 0xfffffffe) * (int64_t)&g1) >> (int32_t)"NU") - ((int32_t)v2 >> (int32_t)&g24);
}

// Address range: 0x26dcc - 0x26dee
int64_t nm131_demod_get_snr2(int64_t a1) {
    // 0x26dcc
    mcount();
    return rReg32_(a1, 536);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26dee - 0x26e09
// Line range:    1238 - 1247
char nm131_demod_get_cpll_lock(int64_t pPrivate) {
    // 0x26dee
    return (int32_t)pPrivate << (uint32_t)(int32_t)&g105;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26e09 - 0x26e1e
// Line range:    1217 - 1236
char nm131_demod_get_agc_lock(int64_t pPrivate) {
    // 0x26e09
    uint64_t v1; // 0x26e09
    uint64_t v2; // 0x26e09
    uint64_t v3; // 0x26e09
    int64_t v4 = nmi_log10_((int64_t)((uint128_t)(0x8000000000000000 * (int128_t)v1 | (int128_t)v3) / (uint128_t)(int128_t)v2)); // 0x26e0f
    return (char)v4 * (char)((int64_t)(int32_t)((int64_t)&g86 + 1) * (int64_t)(int32_t)((int64_t)&g86 + 1));
}

// Address range: 0x26e1e - 0x26e39
int64_t nm131_demod_get_cpll_lock2(int64_t a1) {
    // 0x26e1e
    mcount();
    int64_t v1 = rReg32_(a1, 480); // 0x26e2c
    return v1 & -256 | (int64_t)((int32_t)v1 == (int32_t)&g1);
}

// Address range: 0x26e39 - 0x26e4f
int64_t nm131_demod_get_agc_lock2(int64_t a1) {
    // 0x26e39
    return mcount();
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26e52 - 0x26e53
// Line range:    1200 - 1215
int64_t nm131_demod_dagc_gain(int64_t pPrivate) {
    // 0x26e52
    int64_t result; // 0x26e52
    return result;
}

// Address range: 0x26e53 - 0x26e56
int64_t function_26e53(void) {
    // 0x26e53
    int64_t result; // 0x26e53
    return result;
}

// Address range: 0x26e57 - 0x26e82
int64_t function_26e57(int64_t a1) {
    // 0x26e57
    int64_t v1; // 0x26e57
    int64_t v2; // 0x26e57
    bool v3; // 0x26e57
    if (v3) {
        // 0x26e68
        v1 = rReg32_(v2, 396);
    } else {
        // 0x26e59
        v1 = rReg32_(v2, 340);
    }
    int64_t v4 = v1;
    return v4 & -256 | (int64_t)((int32_t)v4 == (int32_t)&g1);
}

// Address range: 0x26e82 - 0x26e8e
int64_t nm131_demod_dagc_gain2(int64_t a1) {
    // 0x26e82
    mcount();
    uint64_t v1; // 0x26e82
    return v1 % 256;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26e93 - 0x26ec3
// Line range:    1326 - 1334
void nm131_demod_get_status(int64_t pPrivate, int64_t p) {
    // 0x26e93
    int64_t v1; // 0x26e93
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x26e93
    if (*(char *)&v2 != 0) {
        // 0x26eb5
        rReg32_(pPrivate, 404);
    } else {
        // 0x26ea4
        rReg32_(pPrivate, 348);
    }
}

// Address range: 0x26ec3 - 0x26eeb
int64_t nm131_demod_get_status2(int64_t a1, int64_t a2) {
    // 0x26ec3
    mcount();
    int64_t v1 = nm131_demod_get_agc_lock2(a1); // 0x26ed5
    *(char *)(a2 + (int64_t)&g2) = (char)v1;
    int64_t result = nm131_demod_get_cpll_lock2(a1); // 0x26ee0
    *(char *)(a2 + (int64_t)&g3) = (char)result;
    return result;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x26eeb - 0x26f1b
// Line range:    1522 - 1707
void nm131_get_lna_gain(int64_t pPrivate, int64_t pg) {
    // 0x26eeb
    int64_t v1; // 0x26eeb
    *(int64_t *)v1 = nm131_demod_dagc_gain2(pPrivate);
    int64_t v2; // 0x26eeb
    *(int16_t *)(v1 + (int64_t)"GNU") = (int16_t)nm131_demod_get_snr2(v2);
    int16_t v3 = nm131_demod_get_snr(v2); // 0x26f02
    *(int32_t *)(v1 + (int64_t)&g95) = (int32_t)v3;
    int64_t v4 = nm131_demod_get_pll_level2(v2); // 0x26f0d
    *(int16_t *)(v1 + (int64_t)&g103) = (int16_t)v4;
}

// Address range: 0x26f1b - 0x27690
int64_t nm131_get_lna_gain2(int64_t a1, int64_t * a2) {
    int64_t v1 = (int64_t)a2;
    mcount();
    unsigned char v2 = (char)rReg8_(a1, 62);
    if ((char)rReg8_(a1, 45) != 0) {
        if (v2 == (char)&g12) {
            // 0x27091
            *(int16_t *)a2 = 300;
            *(char *)(v1 + (int64_t)&g94) = -24;
            goto lab_0x270dc;
        } else {
            if (v2 > (char)&g12) {
                if (v2 == 63) {
                    // 0x270b2
                    *(int16_t *)a2 = 1200;
                    *(char *)(v1 + (int64_t)&g94) = (char)"%(";
                    goto lab_0x270dc;
                } else {
                    if (v2 < 64) {
                        if (v2 == (char)&g24) {
                            // 0x2709c
                            *(int16_t *)a2 = 600;
                            *(char *)(v1 + (int64_t)&g94) = -23;
                            goto lab_0x270dc;
                        } else {
                            if (v2 != 47) {
                                // 0x270d3
                                *(int16_t *)a2 = -900;
                                *(char *)(v1 + (int64_t)&g94) = -29;
                                goto lab_0x270dc;
                            } else {
                                // 0x270a7
                                *(int16_t *)a2 = 900;
                                *(char *)(v1 + (int64_t)&g94) = -22;
                                goto lab_0x270dc;
                            }
                        }
                    } else {
                        if (v2 == 95) {
                            // 0x270bd
                            *(int16_t *)a2 = 1400;
                            *(char *)(v1 + (int64_t)&g94) = (char)&g104;
                            goto lab_0x270dc;
                        } else {
                            if (v2 != 127) {
                                // 0x270d3
                                *(int16_t *)a2 = -900;
                                *(char *)(v1 + (int64_t)&g94) = -29;
                                goto lab_0x270dc;
                            } else {
                                // 0x270c8
                                *(int16_t *)a2 = 1700;
                                *(char *)(v1 + (int64_t)&g94) = -19;
                                goto lab_0x270dc;
                            }
                        }
                    }
                }
            } else {
                if (v2 == (char)&g94) {
                    // 0x27070
                    *(int16_t *)a2 = -400;
                    *(char *)(v1 + (int64_t)&g94) = -27;
                    goto lab_0x270dc;
                } else {
                    if (v2 > (char)&g94) {
                        if (v2 == (char)&g99) {
                            // 0x2707b
                            *(int16_t *)a2 = -100;
                            *(char *)(v1 + (int64_t)&g94) = -26;
                            goto lab_0x270dc;
                        } else {
                            if (v2 != (char)&g105) {
                                // 0x270d3
                                *(int16_t *)a2 = -900;
                                *(char *)(v1 + (int64_t)&g94) = -29;
                                goto lab_0x270dc;
                            } else {
                                // 0x27086
                                *(int16_t *)a2 = 100;
                                *(char *)(v1 + (int64_t)&g94) = -25;
                                goto lab_0x270dc;
                            }
                        }
                    } else {
                        if (v2 == (char)&g33) {
                            // 0x2705a
                            *(int16_t *)a2 = -900;
                            *(char *)(v1 + (int64_t)&g94) = -29;
                            goto lab_0x270dc;
                        } else {
                            if (v2 != (char)&g89) {
                                // 0x270d3
                                *(int16_t *)a2 = -900;
                                *(char *)(v1 + (int64_t)&g94) = -29;
                                goto lab_0x270dc;
                            } else {
                                // 0x27065
                                *(int16_t *)a2 = -700;
                                *(char *)(v1 + (int64_t)&g94) = -28;
                                goto lab_0x270dc;
                            }
                        }
                    }
                }
            }
        }
    } else {
        if (v2 == (char)&g105) {
            // 0x26fa2
            *(int16_t *)a2 = 100;
            *(char *)(v1 + (int64_t)&g94) = -28;
            goto lab_0x270dc;
        } else {
            if (v2 > (char)&g105) {
                switch (v2) {
                    case 63: {
                        // 0x26fbe
                        *(int16_t *)a2 = 1200;
                        *(char *)(v1 + (int64_t)&g94) = -26;
                        goto lab_0x270dc;
                    }
                    case 127: {
                        // 0x26fcc
                        *(int16_t *)a2 = 1700;
                        *(char *)(v1 + (int64_t)&g94) = -25;
                        goto lab_0x270dc;
                    }
                    default: {
                        if (v2 != (char)&g24) {
                            // 0x26fda
                            *(int16_t *)a2 = -900;
                            *(char *)(v1 + (int64_t)&g94) = -30;
                            goto lab_0x270dc;
                        } else {
                            // 0x26fb0
                            *(int16_t *)a2 = 600;
                            *(char *)(v1 + (int64_t)&g94) = -27;
                            goto lab_0x270dc;
                        }
                    }
                }
            } else {
                if (v2 == (char)&g33) {
                    // 0x26f86
                    *(int16_t *)a2 = -900;
                    *(char *)(v1 + (int64_t)&g94) = -30;
                    goto lab_0x270dc;
                } else {
                    if (v2 != (char)&g94) {
                        // 0x26fda
                        *(int16_t *)a2 = -900;
                        *(char *)(v1 + (int64_t)&g94) = -30;
                        goto lab_0x270dc;
                    } else {
                        // 0x26f94
                        *(int16_t *)a2 = -400;
                        *(char *)(v1 + (int64_t)&g94) = -29;
                        goto lab_0x270dc;
                    }
                }
            }
        }
    }
  lab_0x270dc:;
    // 0x270dc
    uint64_t v3; // 0x26f1b
    if (*(char *)(184 * (v3 % 256)) != 0) {
        char * v4 = (char *)(v1 + (int64_t)&g94); // 0x270f1
        *v4 = *v4 % 64;
    }
    int64_t v5 = rReg8_(a1, 64); // 0x270fd
    int64_t v6 = rReg8_(a1, 65); // 0x2710d
    uint32_t v7 = (int32_t)v6 % 256 >> (int32_t)&g89 | (int32_t)v5 % 256 * (int32_t)&g95; // 0x27127
    if (v7 == (int32_t)&g12) {
        // 0x272a1
        *(int16_t *)(v1 + (int64_t)&g25) = 240;
        *(char *)(v1 + (int64_t)&g91) = -24;
        goto lab_0x27317;
    } else {
        if (v7 > (int32_t)&g12) {
            if (v7 == 127) {
                // 0x27259
                *(int16_t *)(v1 + (int64_t)&g25) = 1370;
                *(char *)(v1 + (int64_t)&g91) = -19;
                goto lab_0x27317;
            } else {
                if (v7 < 128) {
                    if (v7 == 47) {
                        // 0x27286
                        *(int16_t *)(v1 + (int64_t)&g25) = 750;
                        *(char *)(v1 + (int64_t)&g91) = -22;
                        goto lab_0x27317;
                    } else {
                        if (v7 < 48) {
                            if (v7 != (int32_t)&g24) {
                                // 0x2730d
                                *(int16_t *)(v1 + (int64_t)&g25) = 0x26ac;
                                *(char *)(v1 + (int64_t)&g91) = 0;
                                goto lab_0x27317;
                            } else {
                                // 0x27295
                                *(int16_t *)(v1 + (int64_t)&g25) = 450;
                                *(char *)(v1 + (int64_t)&g91) = -23;
                                goto lab_0x27317;
                            }
                        } else {
                            if (v7 == 63) {
                                // 0x27277
                                *(int16_t *)(v1 + (int64_t)&g25) = 950;
                                *(char *)(v1 + (int64_t)&g91) = (char)"%(";
                                goto lab_0x27317;
                            } else {
                                if (v7 != 95) {
                                    // 0x2730d
                                    *(int16_t *)(v1 + (int64_t)&g25) = 0x26ac;
                                    *(char *)(v1 + (int64_t)&g91) = 0;
                                    goto lab_0x27317;
                                } else {
                                    // 0x27268
                                    *(int16_t *)(v1 + (int64_t)&g25) = 1200;
                                    *(char *)(v1 + (int64_t)&g91) = (char)&g104;
                                    goto lab_0x27317;
                                }
                            }
                        }
                    }
                } else {
                    if (v7 == 511) {
                        // 0x2723b
                        *(int16_t *)(v1 + (int64_t)&g25) = 2280;
                        *(char *)(v1 + (int64_t)&g91) = -17;
                        goto lab_0x27317;
                    } else {
                        if (v7 < 512) {
                            if (v7 != 255) {
                                // 0x2730d
                                *(int16_t *)(v1 + (int64_t)&g25) = 0x26ac;
                                *(char *)(v1 + (int64_t)&g91) = 0;
                                goto lab_0x27317;
                            } else {
                                // 0x2724a
                                *(int16_t *)(v1 + (int64_t)&g25) = 1670;
                                *(char *)(v1 + (int64_t)&g91) = -18;
                                goto lab_0x27317;
                            }
                        } else {
                            if (v7 == 1023) {
                                // 0x2722c
                                *(int16_t *)(v1 + (int64_t)&g25) = 2860;
                                *(char *)(v1 + (int64_t)&g91) = -16;
                                goto lab_0x27317;
                            } else {
                                if (v7 != 2047) {
                                    // 0x2730d
                                    *(int16_t *)(v1 + (int64_t)&g25) = 0x26ac;
                                    *(char *)(v1 + (int64_t)&g91) = 0;
                                    goto lab_0x27317;
                                } else {
                                    // 0x2721d
                                    *(int16_t *)(v1 + (int64_t)&g25) = 3480;
                                    *(char *)(v1 + (int64_t)&g91) = -15;
                                    goto lab_0x27317;
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if (v7 == (int32_t)&g33) {
                // 0x272dd
                *(int16_t *)(v1 + (int64_t)&g25) = -1230;
                *(char *)(v1 + (int64_t)&g91) = -29;
                goto lab_0x27317;
            } else {
                if (v7 > (int32_t)&g33) {
                    if (v7 == (int32_t)&g94) {
                        // 0x272c5
                        *(int16_t *)(v1 + (int64_t)&g25) = -700;
                        *(char *)(v1 + (int64_t)&g91) = -27;
                        goto lab_0x27317;
                    } else {
                        if (v7 > (int32_t)&g94) {
                            if (v7 == (int32_t)&g99) {
                                // 0x272b9
                                *(int16_t *)(v1 + (int64_t)&g25) = -350;
                                *(char *)(v1 + (int64_t)&g91) = -26;
                                goto lab_0x27317;
                            } else {
                                if (v7 != (int32_t)&g105) {
                                    // 0x2730d
                                    *(int16_t *)(v1 + (int64_t)&g25) = 0x26ac;
                                    *(char *)(v1 + (int64_t)&g91) = 0;
                                    goto lab_0x27317;
                                } else {
                                    // 0x272ad
                                    *(int16_t *)(v1 + (int64_t)&g25) = -90;
                                    *(char *)(v1 + (int64_t)&g91) = -25;
                                    goto lab_0x27317;
                                }
                            }
                        } else {
                            if (v7 != (int32_t)&g89) {
                                // 0x2730d
                                *(int16_t *)(v1 + (int64_t)&g25) = 0x26ac;
                                *(char *)(v1 + (int64_t)&g91) = 0;
                                goto lab_0x27317;
                            } else {
                                // 0x272d1
                                *(int16_t *)(v1 + (int64_t)&g25) = -900;
                                *(char *)(v1 + (int64_t)&g91) = -28;
                                goto lab_0x27317;
                            }
                        }
                    }
                } else {
                    if (v7 == (int32_t)&g1) {
                        // 0x272f5
                        *(int16_t *)(v1 + (int64_t)&g25) = -1800;
                        *(char *)(v1 + (int64_t)&g91) = -31;
                    } else {
                        int16_t * v8 = (int16_t *)(v1 + (int64_t)&g25);
                        if (v7 > (int32_t)&g1) {
                            // 0x272e9
                            *v8 = -1500;
                            *(char *)(v1 + (int64_t)&g91) = -30;
                        } else {
                            // 0x27301
                            *v8 = -2000;
                            *(char *)(v1 + (int64_t)&g91) = -32;
                        }
                    }
                    goto lab_0x27317;
                }
            }
        }
    }
  lab_0x27317:;
    // 0x27317
    int64_t v9; // 0x26f1b
    int32_t * v10 = (int32_t *)(184 * (int64_t)*(char *)&v9); // 0x27326
    uint32_t result = *v10;
    int64_t v11; // 0x26f1b
    int16_t v12; // 0x26f1b
    int64_t v13; // 0x27343
    if (result != 13) {
        // 0x274b3
        v11 = 1450;
        switch (result) {
            case 6: {
                goto lab_0x275a8;
            }
            case 8: {
                goto lab_0x275a8;
            }
            case 12: {
                goto lab_0x275a8;
            }
            case 14: {
                goto lab_0x275a8;
            }
            case 15: {
                goto lab_0x275a8;
            }
            default: {
                if (result != 16) {
                    // 0x2760a
                    if (result < 0x7735940 || result < 0x18054ac0) {
                        // 0x27690
                        return result;
                    }
                    int64_t result2 = 0xffffff9c; // 0x27645
                    if (result >= 0x21f98280) {
                        // 0x2765c
                        result2 = result < 0x2d4cae00 ? 0xffffffe2 : 50;
                    }
                    // 0x27690
                    return result2;
                }
                // 0x274d6
                v11 = 1450;
                if (result < 0x7cee6c0) {
                    goto lab_0x275a8;
                } else {
                    if (result < 0x10642ac0) {
                        // 0x27500
                        if (*(char *)(v1 + (int64_t)&g91) != -15) {
                            // 0x2759a
                            v11 = 1300;
                            goto lab_0x275a8;
                        } else {
                            // 0x27592
                            v11 = 1200;
                            goto lab_0x275a8;
                        }
                    } else {
                        if (result < 0x14dc9380) {
                            // 0x2751d
                            v11 = 1050;
                            if (*(char *)(v1 + (int64_t)&g91) != -15) {
                                // 0x275a2
                                v11 = 1150;
                                goto lab_0x275a8;
                            } else {
                                goto lab_0x275a8;
                            }
                        } else {
                            if (result < 0x1ad27480) {
                                // 0x27539
                                v11 = (int64_t)"%(";
                                if (*(char *)(v1 + (int64_t)&g91) != -15) {
                                    // 0x27592
                                    v11 = 1200;
                                    goto lab_0x275a8;
                                } else {
                                    goto lab_0x275a8;
                                }
                            } else {
                                if (result < 0x21f98280) {
                                    // 0x27555
                                    v11 = *(char *)(v1 + (int64_t)&g91) != -15 ? 1250 : 1100;
                                    goto lab_0x275a8;
                                } else {
                                    char v14 = *(char *)(v1 + (int64_t)&g91);
                                    if (result < 0x2aea5400) {
                                        // 0x27576
                                        v11 = 1350;
                                        if (v14 != -15) {
                                            goto lab_0x275a8;
                                        } else {
                                            // 0x275a2
                                            v11 = 1150;
                                            goto lab_0x275a8;
                                        }
                                    } else {
                                        // 0x27584
                                        v11 = 1450;
                                        if (v14 == -15) {
                                            // 0x2759a
                                            v11 = 1300;
                                            goto lab_0x275a8;
                                        } else {
                                            goto lab_0x275a8;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        uint64_t v15 = nm131_demod_dagc_gain2(a1); // 0x27338
        v13 = nmi_log10_(v15);
        uint64_t v16 = v15 >> (int64_t)&g105; // 0x27348
        if (*v10 < 0x5f767a1) {
            // 0x2736f
            v12 = 260 * (int16_t)&g1;
            if (v16 - 100 > (int64_t)&g5) {
                // 0x27383
                v12 = 140 * (int16_t)&g1;
                if (v16 - 120 > (int64_t)&g105) {
                    // 0x27397
                    v12 = 0;
                    if (v16 - 136 > (int64_t)"GNU") {
                        // 0x273ab
                        v12 = -200 * (int16_t)&g1;
                        if (v16 - 149 > (int64_t)&g97) {
                            // 0x273c2
                            v12 = -400 * (int16_t)&g1;
                            if (v16 - 159 > (int64_t)&g89) {
                                // 0x273d9
                                v12 = -700 * (int16_t)&g1;
                                if (v16 < 165) {
                                    char v17 = *(char *)(v1 + (int64_t)&g91); // 0x273eb
                                    v12 = 430 * (int16_t)&g1;
                                    if (v17 + (char)&g2 > (char)&g1) {
                                        // 0x273fb
                                        v12 = 520 * (int16_t)&g1;
                                        if (v17 != -17) {
                                            // 0x2748e
                                            v12 = 340 * (int16_t)&g1;
                                            goto lab_0x27493;
                                        } else {
                                            goto lab_0x27493;
                                        }
                                    } else {
                                        goto lab_0x27493;
                                    }
                                } else {
                                    goto lab_0x27493;
                                }
                            } else {
                                goto lab_0x27493;
                            }
                        } else {
                            goto lab_0x27493;
                        }
                    } else {
                        goto lab_0x27493;
                    }
                } else {
                    goto lab_0x27493;
                }
            } else {
                goto lab_0x27493;
            }
        } else {
            // 0x27409
            v12 = 380 * (int16_t)&g1;
            if (v16 - 113 > (int64_t)&g22) {
                // 0x27419
                v12 = 330 * (int16_t)&g1;
                if (v16 - 143 > (int64_t)&g28) {
                    // 0x27429
                    v12 = 250 * (int16_t)&g1;
                    if (v16 - 177 > (int64_t)&g22) {
                        // 0x2743c
                        v12 = 110 * (int16_t)&g1;
                        if (v16 - 207 > (int64_t)&g16) {
                            // 0x2744c
                            v12 = -240 * (int16_t)&g1;
                            if (v16 - 233 > (int64_t)&g5) {
                                // 0x2745f
                                v12 = -500 * (int16_t)&g1;
                                if (v16 < 253) {
                                    char v18 = *(char *)(v1 + (int64_t)&g91); // 0x2746d
                                    v12 = 430 * (int16_t)&g1;
                                    if (v18 + (char)&g2 > (char)&g1) {
                                        // 0x27479
                                        v12 = 520 * (int16_t)&g1;
                                        if (v18 != -17) {
                                            // 0x2748e
                                            v12 = 340 * (int16_t)&g1;
                                            goto lab_0x27493;
                                        } else {
                                            goto lab_0x27493;
                                        }
                                    } else {
                                        goto lab_0x27493;
                                    }
                                } else {
                                    goto lab_0x27493;
                                }
                            } else {
                                goto lab_0x27493;
                            }
                        } else {
                            goto lab_0x27493;
                        }
                    } else {
                        goto lab_0x27493;
                    }
                } else {
                    goto lab_0x27493;
                }
            } else {
                goto lab_0x27493;
            }
        }
    }
  lab_0x275a8:;
    int64_t v19 = nmi_log10_(nm131_demod_dagc_gain2(a1)); // 0x275b3
    int64_t v20 = rReg32_(a1, 356); // 0x275c3
    int64_t v21 = nmi_log10_((int64_t)((int32_t)v20 << (int32_t)&g105)); // 0x275cf
    int64_t v22 = -(int64_t)*(int16_t *)(v1 + (int64_t)&g25); // 0x275d8
    int64_t v23; // 0x26f1b
    int16_t v24 = *(int16_t *)&v23; // 0x275da
    int64_t v25 = v11 + 0xffffe0ac + ((v22 & 0xffff0000 | (int64_t)((int16_t)v22 - v24)) + (v21 * (int64_t)(int32_t)((int64_t)&g86 + 1) * (int64_t)(int32_t)((int64_t)&g86 + 1) & 0xffffffff)) * (int64_t)&g1; // 0x275eb
    *(int16_t *)(v1 + (int64_t)&g86) = (int16_t)(v25 - v19 * (int64_t)(int32_t)((int64_t)&g86 + 1) * (int64_t)(int16_t)((int64_t)&g86 + 1));
    return v25 & 0xffffffff;
  lab_0x27493:;
    int64_t v26 = -(int64_t)*(int16_t *)(v1 + (int64_t)&g25); // 0x27497
    int16_t v27 = *(int16_t *)&v23; // 0x27499
    uint16_t v28 = (int16_t)v26 - v27 + (int16_t)v13 * -1 * (int16_t)((int64_t)&g86 + 1) * (int16_t)((int64_t)&g86 + 1); // 0x274a4
    *(int16_t *)(v1 + (int64_t)&g86) = v28 + v12;
    return v26 & 0xffff0000 | (int64_t)v28;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x27691 - 0x276c1
// Line range:    1709 - 1844
void nm120_rfli_track(int64_t pPrivate, int64_t p) {
    // 0x27691
    int64_t v1; // 0x27691
    int64_t v2 = nm131_demod_dagc_gain2((int64_t)&v1); // 0x27693
    int64_t v3 = nmi_log10_(v2); // 0x2769b
    int64_t v4; // 0x27691
    int16_t v5 = *(int16_t *)(v4 + (int64_t)&g25); // 0x276a0
    int64_t v6; // 0x27691
    *(int16_t *)(v4 + (int64_t)&g86) = (int16_t)v6 - (int16_t)v4 - v5 + (int16_t)v3 * -1 * (int16_t)((int64_t)&g86 + 1) * (int16_t)((int64_t)&g86 + 1);
}

// Address range: 0x276c1 - 0x27823
int64_t nm120_rfli_track2(int64_t a1, int64_t a2) {
    // 0x276c1
    mcount();
    int64_t v1; // bp-40, 0x276c1
    nm131_get_lna_gain2(a1, &v1);
    int128_t v2; // 0x276c1
    if (*(char *)(a2 + (int64_t)&g86) == 0) {
        // 0x27729
        *(char *)(a1 + (int64_t)&g2) = (char)v2;
    } else {
        int64_t v3 = *(int64_t *)(a2 + (int64_t)&g95); // 0x276ff
        char * v4 = (char *)(a1 + (int64_t)&g2); // 0x2770c
        unsigned char v5 = *v4; // 0x2770c
        *v4 = (char)(((0x8000 - v3) * (int64_t)v5 + v3 * ((int64_t)v2 % 256)) / 0x8000);
    }
    int64_t v6 = nm131_demod_dagc_gain2(a1); // 0x27733
    if (*(char *)(a2 + 56) == 0) {
        // 0x2776a
        *(int64_t *)(a1 + (int64_t)&g13) = v6;
    } else {
        int64_t v7 = *(int64_t *)(a2 + 64); // 0x27740
        int64_t v8 = a1 + (int64_t)&g13; // 0x27756
        uint32_t v9 = *(int32_t *)v8; // 0x27756
        *(int64_t *)v8 = ((0x8000 - v7) * (int64_t)v9 + v7 * (v6 & 0xffffffff)) / 0x8000;
    }
    // 0x2776e
    char * v10; // 0x276c1
    char v11; // 0x276c1
    int64_t v12; // 0x276c1
    if (*(char *)(a2 + (int64_t)&g2) == 0) {
        char * v13 = (char *)(a1 + (int64_t)&g26);
        unsigned char v14 = *v13; // 0x277aa
        unsigned char v15 = *(char *)(a1 + (int64_t)&g2);
        int64_t result = v15;
        if (v14 > (char)"GNU") {
            // 0x277c3
            if (v15 > *(char *)(a2 + (int64_t)&g25)) {
                // 0x277a5
                return (int64_t)"NU";
            }
            // 0x277ce
            if (*(char *)(a2 + (int64_t)&g33) <= v15) {
                // 0x277a5
                return result;
            }
            char v16 = *(char *)(a2 + 72); // 0x277fc
            *v13 = v16;
            // 0x27805
            return nm131_set_lna_gain2_(a1, v16);
        }
        // 0x277b0
        if (v15 > *(char *)&v12) {
            // 0x277a5
            return (int64_t)"NU";
        }
        // 0x277ba
        v11 = v14;
        v10 = v13;
        if (*(char *)(a2 + (int64_t)&g1) <= v15) {
            // 0x277a5
            return result;
        }
    } else {
        // 0x27776
        int64_t v17; // 0x276c1
        if (*(char *)(a1 + (int64_t)&g2) > *(char *)&v12) {
            uint64_t v18 = *(int64_t *)(a1 + (int64_t)&g13); // 0x27785
            v17 = v18;
            if (v18 > *(int64_t *)(a2 + (int64_t)&g13)) {
                // 0x277a5
                return (int64_t)"NU";
            }
        } else {
            // 0x27776
            v17 = *(int64_t *)(a1 + (int64_t)&g13);
        }
        uint64_t result2 = *(int64_t *)(a2 + (int64_t)&g26); // 0x2779a
        if (v17 >= result2) {
            // 0x277a5
            return result2;
        }
        char * v19 = (char *)(a1 + (int64_t)&g26);
        v11 = *v19;
        v10 = v19;
    }
    unsigned char v20 = v11 - (char)&g1; // 0x277ea
    char v21 = v20 > (char)&g25 ? v20 : (char)&g33; // 0x277f7
    *v10 = v21;
    // 0x27805
    return nm131_set_lna_gain2_(a1, v21);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x27824 - 0x27854
// Line range:    3718 - 3754
void wReg8Debug(int64_t pPrivate, char adr, char val8) {
    // 0x27824
    return;
}

// Address range: 0x27854 - 0x2796b
int64_t wReg8Debug2(int64_t a1, uint64_t a2, uint64_t a3) {
    // 0x27854
    mcount();
    wReg8_(a1, (int64_t *)(a2 % 256), a3 % 256);
    uint64_t v1; // 0x27854
    int64_t result = 184 * (v1 % 256);
    uint32_t v2 = *(int32_t *)result;
    if ((char)a2 == 52) {
        if (v2 >= 2) {
            // 0x278d0
            *(char *)result = 0;
            return result;
        }
        unsigned char v3 = (char)a3; // 0x278a4
        if (v3 < 240) {
            // 0x278b9
            *(char *)result = 0;
            return result;
        }
        // 0x278aa
        *(char *)result = -1 - v3;
        return result;
    }
    if (v2 >= 2) {
        // 0x27961
        return result;
    }
    int64_t v4 = a3 & 0xffffffff; // 0x27879
    int64_t v5 = v4 + 0xffffffb0; // 0x27903
    if ((char)v5 > (char)&g105) {
        // 0x2794d
        *(char *)result = 0;
        return v5 & 0xffffffff;
    }
    // 0x2790b
    if ((int32_t)rReg32_(a1, 636) == 0x1818) {
        // 0x2791f
        *(char *)result = (char)&g2;
        return result;
    }
    uint64_t v6 = 95 - v4; // 0x27941
    *(char *)result = (char)v6;
    return v6 % 256;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x27970 - 0x279a0
// Line range:    2844 - 2877
int16_t nm131_adec_get_rssi(int64_t pPrivate) {
    // 0x27970
    int64_t result; // 0x27970
    *(char *)result = 2 * (char)result;
    return result;
}

// Address range: 0x279a0 - 0x27a5d
int64_t nm131_adec_get_rssi2(int64_t a1) {
    // 0x279a0
    mcount();
    uint64_t v1 = rReg32_(a1, 588) & 0xffffffff; // 0x279ce
    int64_t v2; // 0x279a0
    int64_t v3; // 0x279a0
    nmi_debug2(a1, (int64_t *)64, 0, (int128_t)v1, v3, v2);
    int64_t v4 = nmi_log10_((v1 << (int64_t)&g30) / 0x8000000000); // 0x279f7
    int64_t v5 = nmi_log10_(nm131_demod_dagc_gain2(a1)); // 0x27a0a
    int16_t v6; // bp-56, 0x279a0
    nm131_get_lna_gain2(a1, (int64_t *)&v6);
    uint32_t v7; // 0x279a0
    int32_t v8 = -((v7 % 0x10000)); // 0x27a22
    int16_t v9 = (int16_t)v8 + 0x2c88 - v6 + ((int16_t)v5 + (int16_t)v4) * -1 * (int16_t)((int64_t)&g86 + 1) * (int16_t)((int64_t)&g86 + 1); // 0x27a42
    int64_t v10 = v9 < 0 ? 0 : (int64_t)(v8 & -0x10000 | (int32_t)v9); // 0x27a4b
    int16_t v11 = v10; // 0x27a4e
    int16_t v12 = v11 - 0x319c; // 0x27a4e
    return v12 < 0 == (0x319b - v11 & v11) < 0 == (v12 != 0) ? 0x319c : v10;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x27a5f - 0x27a8f
// Line range:    3206 - 3214
int32_t nm131_get_chipid(int64_t pPrivate) {
    // 0x27a5f
    int64_t v1; // 0x27a5f
    int16_t v2 = v1; // 0x27a5f
    int16_t v3 = (int16_t)*(char *)(v1 + 0x41000000); // 0x27a5f
    int64_t v4 = v1 & -0x10000 | (int64_t)(v2 / v3 % 256) | (int64_t)(256 * (v2 % v3)); // 0x27a5f
    int64_t result = v4; // 0x27a6f
    int64_t v5; // 0x27a5f
    if ((int32_t)v5 == 0x5b8d800) {
        int16_t v6 = v4; // 0x27a71
        int16_t v7 = v6 - 1699; // 0x27a71
        result = v7 == 0 | v7 < 0 != (1698 - v6 & v6) < 0 ? 0 : v4 & 0xffffffff;
    }
    // 0x27a7d
    return result;
}

// Address range: 0x27a8f - 0x27ab8
int64_t nm131_get_chipid2(int64_t a1) {
    // 0x27a8f
    mcount();
    return rReg32_(a1, 1020);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nmicmn.c
// Address range: 0x27ab9 - 0x27aba
// Line range:    221 - 295
void wRegBurst(int64_t pPrivate, int32_t adr, char * bd, int32_t sz) {
    // 0x27ab9
    return;
}

// Address range: 0x27abc - 0x27ae9
int64_t function_27abc(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x27abc
    int64_t v1; // 0x27abc
    int32_t * v2 = (int32_t *)(v1 - 119); // 0x27abc
    *v2 = *v2 + (int32_t)&g1;
    int64_t v3; // 0x27abc
    int32_t * v4 = (int32_t *)(v3 - 57); // 0x27ac1
    uint32_t v5 = *v4; // 0x27ac1
    *v4 = v5 / 4 | v5 << (int32_t)&g23;
    int64_t v6 = v3;
    *(char *)v6 = *(char *)&v3 + (char)v6;
    int64_t v7 = v3;
    *(char *)v7 = *(char *)&v3 + (char)v7;
    int64_t v8; // 0x27abc
    int64_t v9; // 0x27abc
    int64_t v10; // 0x27abc
    nmi_debug2(v10, (int64_t *)&g2, a3, (int128_t)(a4 - (int64_t)&g1), v9, v8);
    int64_t v11; // 0x27abc
    return v11 & 0xffffffff;
}

// Address range: 0x27ae9 - 0x27c85
int64_t wRegBurst2(uint64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a1;
    mcount();
    __readgsqword(40);
    uint32_t v2 = (int32_t)a4; // 0x27b27
    if (v2 >= 1025) {
        // 0x27b29
        int64_t v3; // 0x27ae9
        int64_t v4; // 0x27ae9
        return nmi_debug2(a1, (int64_t *)&g25, 0, (int128_t)a4, v4, v3);
    }
    if ((int32_t)a2 < 55) {
        if ((int32_t)((a2 & 0xffffffff) * (int64_t)&g1 + a4) >= 55) {
            char * v5 = (char *)((54 - a2 & 0xffffffff) + a3);
            unsigned char v6 = *v5;
            if (*(int32_t *)(184 * (a1 % 256)) == 0) {
                // 0x27b74
                *v5 = v6 % 128;
            } else {
                // 0x27b60
                *v5 = v6 | -128;
            }
        }
    }
    int64_t result = 184 * (int64_t)*(char *)&v1;
    int64_t v7 = *(int64_t *)result; // 0x27b91
    int32_t v8 = &g1; // 0x27ba5
    if (v7 != 0) {
        uint32_t v9 = (int32_t)v7 - 2; // 0x27bac
        v8 = v9 < 256 ? v9 : 256;
    }
    uint32_t v10 = v8;
    uint32_t v11 = v10 < v2 ? v10 : v2; // 0x27bf7
    int64_t v12; // bp-326, 0x27ae9
    memcpy((int64_t)&v12, a3, (int64_t)v11, a4);
    return result;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nmicmn.c
// Address range: 0x27c86 - 0x27cb6
// Line range:    186 - 219
void wReg32(int64_t pPrivate, int16_t adr, int32_t val) {
    // 0x27c86
    return;
}

// Address range: 0x27cb6 - 0x27d64
int64_t wReg32_(uint64_t a1, int64_t a2, int64_t * a3) {
    // 0x27cb6
    mcount();
    uint64_t result = 184 * (a1 % 256); // 0x27ccd
    int64_t v1; // 0x27cb6
    int64_t v2; // 0x27cb6
    if (*(int64_t *)result == 0) {
        // 0x27cfb
        return nmi_debug2(a1, (int64_t *)&g25, 0, (int128_t)result, v2, v1);
    }
    // 0x27cf2
    if (*(char *)result == 0) {
        // 0x27d16
        return result;
    }
    // 0x27cfb
    return nmi_debug2(a1, (int64_t *)&g25, 0, (int128_t)result, v2, v1);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x27d65 - 0x27d95
// Line range:    2803 - 2835
void nm131_fm_overmod(int64_t pPrivate, char fmovermod) {
    // 0x27d65
    int64_t v1; // 0x27d65
    int64_t v2; // 0x27d65
    uint64_t v3; // 0x27d65
    int64_t v4; // 0x27d65
    nmi_debug2(v3, (int64_t *)&g25, 0, (int128_t)v4, v2, v1);
    *(char *)(184 * (v3 % 256)) = (char)&g1;
}

// Address range: 0x27d95 - 0x27eb2
int64_t nm131_fm_overmod2(uint64_t a1, int64_t a2) {
    // 0x27d95
    mcount();
    int64_t result = 184 * (a1 % 256); // 0x27dd1
    int32_t * v1 = (int32_t *)result; // 0x27dd8
    uint32_t v2 = *v1; // 0x27dd8
    if (v2 != 2) {
        if ((char)a2 != 0) {
            // 0x27dfc
            wReg32_(a1, 592, (int64_t *)&g86);
            // 0x27e50
            return wReg32_(a1, 636, (int64_t *)2827);
        }
        unsigned char v3 = *(char *)(int64_t)v2; // 0x27e1d
        int64_t v4 = v3; // 0x27e1d
        int64_t v5 = v4; // 0x27e26
        if (v3 == 0) {
            // 0x27e28
            v5 = *(char *)result == 1 ? (int64_t)(int32_t)&g25 : v4;
        }
        // 0x27e41
        wReg32_(a1, 592, (int64_t *)v5);
    } else {
        // 0x27de1
        wReg32_(a1, 592, (int64_t *)&g25);
        if ((char)a2 != 0) {
            // 0x27e50
            return wReg32_(a1, 636, (int64_t *)2827);
        }
    }
    // 0x27e64
    if (*v1 >= 2) {
        // 0x27eb2
        return result;
    }
    // 0x27e77
    if (*(char *)result != 16) {
        // 0x27e9e
        return wReg32_(a1, 636, (int64_t *)0x1010);
    }
    // 0x27e8a
    return wReg32_(a1, 636, (int64_t *)0x1818);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x27eb3 - 0x27ee3
// Line range:    1336 - 1354
void nm120_nolock_reset(int64_t pPrivate) {
    // 0x27eb3
    int64_t v1; // 0x27eb3
    int64_t v2; // 0x27eb3
    bool v3; // 0x27eb3
    *(char *)v2 = (char)v2 + (char)v1 + (char)v3;
    int64_t v4; // 0x27eb3
    int64_t v5 = v4;
    *(char *)v5 = *(char *)&v4 + (char)v5;
    int64_t v6; // 0x27eb3
    wReg32_(v6, 636, (int64_t *)v1);
    int64_t v7; // 0x27eb3
    int64_t v8; // 0x27eb3
    *(char *)(184 * 0x100000000 * v8 / 0x100000000) = (char)v7;
}

// Address range: 0x27ee3 - 0x27f3a
int64_t nm120_nolock_reset2(int64_t a1) {
    // 0x27ee3
    mcount();
    int64_t v1 = rReg32_(a1, 260) & 0xffffffdf; // 0x27eff
    wReg32_(a1, 260, (int64_t *)v1);
    nmi_delay2(a1, (int64_t *)&g98);
    int64_t result = wReg32_(a1, 260, (int64_t *)(v1 | (int64_t)(int32_t)&g26)); // 0x27f2e
    return result;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x27f3c - 0x27f45
// Line range:    2764 - 2782
void nm131_set_mute(int64_t pPrivate, char mute) {
    // 0x27f3c
    int64_t v1; // 0x27f3c
    *(int32_t *)v1 = 2 * (int32_t)v1;
    char * v2 = (char *)(v1 - 119); // 0x27f3e
    int64_t v3; // 0x27f3c
    *v2 = *v2 + (char)v3;
    int64_t v4; // 0x27f3c
    int64_t v5; // 0x27f3c
    __asm_outsd((int16_t)v5, *(int32_t *)&v4);
}

// Address range: 0x27f47 - 0x27f6c
int64_t function_27f47(int64_t a1, int64_t a2) {
    // 0x27f47
    int64_t v1; // 0x27f47
    nmi_delay2(v1, (int64_t *)&g98);
    int64_t v2; // 0x27f47
    return wReg32_(v1, 260, (int64_t *)(v2 & 0xffffffef));
}

// Address range: 0x27f6c - 0x27fd4
int64_t nm131_set_mute2(int64_t a1, int64_t a2) {
    // 0x27f6c
    mcount();
    return rReg32_(a1, 53) & 0xffffffef;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x27fd4 - 0x28004
// Line range:    2717 - 2738
void nm131_set_brightness(int64_t pPrivate, char brightness) {
    // 0x27fd4
    int64_t v1; // 0x27fd4
    int64_t v2; // 0x27fd4
    int64_t v3; // 0x27fd4
    bool v4; // 0x27fd4
    wReg32_(v1, 53, (int64_t *)((!v4 ? v3 : v2) & 0xffffffff));
    int64_t v5; // 0x27fd4
    int64_t v6; // 0x27fd4
    *(char *)(184 * 0x100000000 * v6 / 0x100000000) = (char)v5;
}

// Address range: 0x28004 - 0x2805e
int64_t nm131_set_brightness2(int64_t a1, int64_t a2) {
    // 0x28004
    mcount();
    return rReg32_(a1, 512);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x28063 - 0x28093
// Line range:    2518 - 2547
void nm131_set_volume(int64_t pPrivate, char vol) {
    // 0x28063
    int64_t v1; // 0x28063
    *(char *)v1 = 2 * (char)v1;
}

// Address range: 0x28069 - 0x28085
int64_t function_28069(void) {
    // 0x28069
    int64_t v1; // 0x28069
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x28069
    int64_t v3; // 0x28069
    int64_t v4; // 0x28069
    int64_t result = wReg32_(v3, v2, (int64_t *)v4); // 0x2806e
    int64_t v5; // 0x28069
    int64_t v6; // 0x28069
    *(char *)(184 * 0x100000000 * v6 / 0x100000000) = (char)v5;
    return result;
}

// Address range: 0x28093 - 0x2819a
int64_t nm131_set_volume2(uint64_t a1, int64_t a2) {
    // 0x28093
    mcount();
    int64_t v1 = 184 * (a1 % 256); // 0x280be
    unsigned char v2 = (char)a2; // 0x280d2
    unsigned char v3 = *(char *)(v1 | 1);
    if (v2 > (char)&g105) {
        int64_t result = wReg8_(a1, (int64_t *)53, (int64_t)(95 - v3)); // 0x2816f
        if (*(char *)(v1 + 14) == 0) {
            // 0x28190
            return result;
        }
        // 0x2817c
        return wReg32_(a1, 636, (int64_t *)2827);
    }
    int64_t v4 = v3 < v2 ? (int64_t)v3 : a2; // 0x280eb
    wReg8_(a1, (int64_t *)53, (95 - v4) % 256);
    int64_t result2; // 0x28093
    if (*(char *)(v1 + 14) == 0) {
        // 0x28120
        result2 = wReg32_(a1, 636, (int64_t *)0x1010);
    } else {
        // 0x2810c
        result2 = wReg32_(a1, 636, (int64_t *)2827);
    }
    // 0x28132
    *(char *)v1 = (char)v4;
    return result2;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x2819b - 0x281cb
// Line range:    1874 - 1913
void nm131_invert_spectum(int64_t pPrivate, int32_t invert) {
    // 0x2819b
    int64_t v1; // 0x2819b
    int64_t v2; // 0x2819b
    wReg32_(v1 & 0xffffffff, (int64_t)invert, (int64_t *)v2);
    int64_t v3; // 0x2819b
    *(char *)(184 * 0x100000000 * v3 / 0x100000000) = (char)&g2;
}

// Address range: 0x281cb - 0x2832a
int64_t nm131_invert_spectum2(int64_t a1, int64_t a2) {
    // 0x281cb
    mcount();
    rReg32_(a1, (int64_t)&g29);
    uint64_t v1; // 0x281cb
    int64_t v2 = 184 * (v1 % 256); // 0x2822f
    uint32_t v3 = *(int32_t *)v2; // 0x28236
    uint32_t v4 = *(int32_t *)(4 * (int64_t)v3); // 0x2823c
    int64_t v5 = 512 * (0x10624dd3 * (int64_t)v4 >> (int64_t)&g26);
    if ((int32_t)a2 == 0) {
        // 0x28252
        return ((int32_t)v5 & -0x20000) / (v3 / 0x20000 + 843);
    }
    // 0x282c4
    if (*(char *)v2 != 0) {
        // 0x28305
        return v5 & 0xfffe0000;
    }
    // 0x282d7
    return ((int32_t)v5 & -0x20000) / (v3 / 0x20000 + 843);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x2832a - 0x2835a
// Line range:    1302 - 1324
void nm131_demod_soft_reset(int64_t pPrivate) {
    // 0x2832a
    int64_t v1; // 0x2832a
    int64_t v2; // 0x2832a
    int64_t v3; // 0x2832a
    int64_t v4; // 0x2832a
    int64_t v5; // 0x2832a
    wReg32_(v2, (int64_t)&g29, (int64_t *)((uint64_t)((uint64_t)(v5 & 0xffffffff | (v3 & 0xffffffff) << (uint64_t)(int64_t)&g26) / (uint64_t)(pPrivate & 0xffffffff) + v1) % 0x400000 | v4 & 0xffc00000));
}

// Address range: 0x2835a - 0x283cd
int64_t nm131_demod_soft_reset2(int64_t a1) {
    // 0x2835a
    mcount();
    int64_t v1 = rReg32_(a1, 260); // 0x2836e
    wReg32_(a1, 260, (int64_t *)((v1 | (int64_t)(int32_t)&g1) & 0xffffffff));
    int64_t v2 = v1 | (int64_t)(int32_t)&g3; // 0x28388
    wReg32_(a1, 260, (int64_t *)(v2 & 0xffffffff));
    wReg32_(a1, 260, (int64_t *)(v2 & 0xffffffef));
    return wReg32_(a1, 260, (int64_t *)(v2 & 0x87ffffef | 0x30000000));
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x283cf - 0x283d1
// Line range:    3755 - 3779
void wReg32Debug(int64_t pPrivate, int16_t adr, int32_t val32) {
    // 0x283cf
    __asm_in_625(-1);
}

// Address range: 0x283d3 - 0x283ff
int64_t function_283d3(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x283d3
    int64_t v1; // 0x283d3
    wReg32_(v1, 260, (int64_t *)a3);
    int64_t v2; // 0x283d3
    return wReg32_(v1, 260, (int64_t *)(v2 & 0xdfffffff | 0x20000000));
}

// Address range: 0x283ff - 0x284c3
int64_t wReg32Debug2(int64_t a1, uint64_t a2, int64_t a3) {
    // 0x283ff
    mcount();
    uint64_t v1; // 0x283ff
    uint64_t v2 = v1 % 256; // 0x28427
    int64_t result = wReg32_(a1, a2 % 0x10000, (int64_t *)a3); // 0x2842e
    if ((int16_t)a2 == 272) {
        // 0x2843a
        *(int32_t *)(184 * v2) = (int32_t)a3;
        return result;
    }
    int64_t result2 = rReg8_(a1, 53); // 0x28463
    char v3 = result2;
    if (v3 - 80 > (char)&g105) {
        // 0x284b9
        return result2;
    }
    int64_t result3 = 184 * v2;
    if ((int32_t)a3 != 0x1818) {
        // 0x2849f
        *(char *)result3 = 95 - v3;
        return result2;
    }
    // 0x2848c
    *(char *)result3 = (char)&g2;
    return result3;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x284c4 - 0x284f4
// Line range:    3678 - 3710
void nm131_software_wake_up_lt(int64_t pPrivate) {
    // 0x284c4
    int64_t v1; // 0x284c4
    *(char *)v1 = 0;
}

// Address range: 0x284f4 - 0x285d8
int64_t nm131_software_wake_up_lt2(int64_t a1) {
    // 0x284f4
    mcount();
    uint64_t v1; // 0x284f4
    int64_t v2 = 184 * (v1 % 256); // 0x28514
    wReg8_(a1, NULL, (int64_t)*(char *)(v2 | 3));
    int64_t v3 = rReg32_(a1, 260); // 0x28533
    wReg32_(a1, 260, (int64_t *)((v3 | (int64_t)(int32_t)&g28) & 0xffffffef));
    int64_t v4 = rReg8_(a1, (int64_t)&g94); // 0x28555
    wReg8_(a1, (int64_t *)&g94, v4 & 191 | 64);
    int64_t v5 = rReg8_(a1, (int64_t)&g99); // 0x28577
    wReg8_(a1, (int64_t *)&g99, (v5 | (int64_t)(char)&g2) % 256);
    wReg8_(a1, (int64_t *)52, (int64_t)*(char *)(v2 | 4));
    wReg8_(a1, (int64_t *)53, (int64_t)*(char *)(v2 | 5));
    char * v6 = (char *)(v2 | 6); // 0x285b7
    wReg8_(a1, (int64_t *)&g89, (int64_t)*v6);
    unsigned char result = *v6; // 0x285ca
    *(char *)v2 = result;
    return result;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x285d9 - 0x28609
// Line range:    3588 - 3602
void nm131_software_sleep(int64_t pPrivate) {
    // 0x285d9
    int64_t v1; // 0x285d9
    int64_t v2; // 0x285d9
    int64_t v3; // 0x285d9
    wReg8_(v3, (int64_t *)&g98, (int64_t)*(char *)(v1 + 7 + v2));
    int64_t v4; // 0x285d9
    int64_t v5; // 0x285d9
    unsigned char v6 = *(char *)(v5 + (int64_t)&g95 + v4 * (int64_t)&g1); // 0x285eb
    wReg8_(v3, (int64_t *)54, (int64_t)v6);
}

// Address range: 0x28609 - 0x28679
int64_t nm131_software_sleep2(int64_t a1) {
    // 0x28609
    mcount();
    wReg32_(a1, 260, (int64_t *)(rReg32_(a1, 260) & 0xfffffffe));
    wReg8_(a1, NULL, (int64_t)&g86);
    wReg8_(a1, (int64_t *)52, 0);
    return wReg8_(a1, (int64_t *)53, 0);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x2867b - 0x2867f
// Line range:    561 - 1196
void nm131_demod_config(int64_t pPrivate, int64_t tune, int32_t clk_off_f, int32_t tuneMode) {
    // 0x2867b
    return;
}

// Address range: 0x28681 - 0x286ab
int64_t function_28681(int64_t a1, int64_t a2) {
    // 0x28681
    int64_t v1; // 0x28681
    wReg8_(v1, NULL, 0);
    int64_t v2; // 0x28681
    int64_t result = wReg32_(v1, 260, (int64_t *)((v2 | (int64_t)(uint32_t)(int32_t)&g1) & 0xffffffff)); // 0x286a1
    return result;
}

// Address range: 0x286ab - 0x293fb
int64_t nm131_demod_config2(int64_t a1, int64_t a2, uint32_t a3, int32_t a4) {
    // 0x286ab
    mcount();
    uint32_t v1 = *(int32_t *)(a2 + (int64_t)"GNU"); // 0x286d6
    uint32_t v2 = *(int32_t *)(a2 + (int64_t)&g2); // 0x286da
    int32_t v3 = *(int32_t *)(a2 + (int64_t)&g86); // 0x286de
    uint32_t v4 = *(int32_t *)(a2 + (int64_t)&g95); // 0x286e4
    char v5 = *(char *)(a2 + (int64_t)&g7); // 0x286ea
    int32_t v6 = *(int32_t *)(a2 + (int64_t)&g13); // 0x286f1
    char v7 = *(char *)(a2 + (int64_t)&g19); // 0x286f7
    char v8 = *(char *)(a2 + (int64_t)&g22); // 0x286fe
    uint64_t v9; // 0x286ab
    int64_t v10 = 184 * (v9 % 256); // 0x28708
    int32_t * v11 = (int32_t *)v10; // 0x2870f
    int32_t v12 = *v11; // 0x2870f
    int32_t v13 = v12; // 0x2871f
    if ((v12 & 0xfff00) != 0x13100) {
        goto lab_0x28775;
    } else {
        if (v12 == v2 == v12 == v1) {
            goto lab_0x287e5;
        } else {
            int64_t * v14 = v2 < (int32_t)&g25 ? (int64_t *)0x58c19c7 : (int64_t *)0x2d8c19c7;
            wReg32_(a1, 448, v1 == (int32_t)"NU" ? (int64_t *)0x358cffff : v14);
            v13 = *v11;
            goto lab_0x28775;
        }
    }
  lab_0x28775:;
    int32_t v15 = v13; // 0x2877f
    if (v15 == v1 != (v15 == v2)) {
        if (v1 != (int32_t)&g2 == (v1 != (int32_t)&g105 && v1 != (int32_t)&g103 && v1 != (int32_t)"GNU" && v1 != (int32_t)&g91 && v1 != (int32_t)&g95)) {
            // 0x287d3
            wReg32_(a1, 304, (int64_t *)448);
        } else {
            // 0x287bf
            wReg32_(a1, 304, (int64_t *)512);
        }
    }
    goto lab_0x287e5;
  lab_0x287e5:;
    uint32_t v16 = *(int32_t *)(a2 + 36); // 0x287e5
    if (v16 == 0) {
        if (v2 > (int32_t)&g1) {
            // 0x28809
            if ((*v11 & 0xffff00) != 0x13000) {
                if (v1 != (int32_t)&g2 != (v1 != (int32_t)&g105 && v1 != (int32_t)&g103 && v1 != (int32_t)"GNU" && v1 != (int32_t)&g91 && v1 != (int32_t)&g95)) {
                    int64_t v17; // 0x286ab
                    if ((int32_t)v17 < 0x11e1a300) {
                        // 0x2887a
                        wReg32_(a1, 356, (int64_t *)1536);
                    } else {
                        // 0x28866
                        wReg32_(a1, 356, (int64_t *)1280);
                    }
                }
            } else {
                // 0x28825
                wReg32_(a1, 356, (int64_t *)768);
            }
        }
    } else {
        // 0x287ed
        wReg32_(a1, 356, (int64_t *)(int64_t)v16);
    }
    // 0x2888c
    if (*v11 != v2) {
        int64_t v18 = rReg32_(a1, 564) & 0xf1ffffff; // 0x288ae
        if (v2 > (int32_t)&g1) {
            // 0x288e9
            wReg32_(a1, 564, (int64_t *)(v18 | 0x8000000));
            wReg32_(a1, (int64_t)&g27, (int64_t *)1024);
        } else {
            int64_t v19 = v2 == (int32_t)&g1 ? v18 | 0x4000000 : v18; // 0x288c5
            wReg32_(a1, 564, (int64_t *)v19);
            wReg32_(a1, (int64_t)&g27, (int64_t *)256);
        }
    }
    int32_t v20 = *v11; // 0x28918
    if (v20 == v1 != (v20 == v2)) {
        int64_t v21 = rReg32_(a1, 640); // 0x28940
        int64_t v22; // 0x286ab
        if (v2 != 0) {
            if (v2 == (int32_t)&g1) {
                int64_t v23 = (v21 | (int64_t)(int32_t)&g1) & 0xffffffff;
                return wReg32_(a1, 640, (int64_t *)(v23 & 0xffffffff));
            }
            // 0x28987
            if (v2 != (int32_t)&g86) {
                // 0x293ec
                return wReg32_(a1, 640, (int64_t *)(v21 & 0xffffffff));
            }
            int64_t v24 = (*v11 & 0xfff00) == 0x13100 ? v21 & 0xfffffffe : v21; // 0x289b2
            wReg32_(a1, 640, (int64_t *)(v24 & 0xffffffff));
            int64_t v25 = rReg32_(a1, 568); // 0x289cc
            wReg32_(a1, 568, (int64_t *)(((v25 & 0xffffc000) >> (int64_t)&g95 | (int64_t)(char)&g95) % 256 << (int64_t)&g95 | v25 & 0xffff0000));
            v22 = rReg32_(a1, 812) & 0xbfffbfff;
        } else {
            // 0x2894a
            wReg32_(a1, 640, (int64_t *)(v21 & 0xfffffffe));
            int64_t v26 = rReg32_(a1, 568); // 0x28964
            wReg32_(a1, 568, (int64_t *)(((v26 & 0xffffc000) >> (int64_t)&g95 | (int64_t)(char)&g95) % 256 << (int64_t)&g95 | v26 & 0xffff0000));
            v22 = rReg32_(a1, 812) & 0xbfffbfff | 0x40004000;
        }
        // 0x28a36
        wReg32_(a1, 812, (int64_t *)v22);
    }
    int32_t v27 = 0; // 0x28a53
    int64_t v28 = 0; // 0x28a53
    if (v5 != 0) {
        // 0x28a55
        v27 = v1 != 0 == (v1 != (int32_t)"NU") ? 0x1d905 : 0x1b5ea;
        v28 = v1 != (int32_t)"NU" ? 0x125e : 1238;
    }
    int64_t v29 = v1; // 0x286d6
    uint32_t v30 = (a3 >> (int32_t)&g1) / 3375 + 0x4000; // 0x28a9b
    int32_t * v31 = (int32_t *)(v29 * (int64_t)&g86); // 0x28aa2
    uint32_t v32 = *v31; // 0x28aa2
    wReg32_(a1, 560, (int64_t *)(int64_t)(0x4000 * (int32_t)(2 * (int64_t)v32 + v28) / v30 | 0x80000));
    if (a4 != (int32_t)&g25) {
        if (v8 == 0) {
            unsigned char v33 = *(char *)v29; // 0x28b06
            int64_t v34 = v33; // 0x28b06
            int64_t v35 = v5 == (char)&g1 ? (int64_t)(int32_t)&g25 : v34;
            wReg32_(a1, 592, (int64_t *)(v33 != 0 ? v34 : v35));
        } else {
            // 0x28aef
            wReg32_(a1, 592, (int64_t *)&g86);
        }
    } else {
        // 0x28ad5
        wReg32_(a1, 592, (int64_t *)&g25);
    }
    // 0x28b2a
    if (*v11 < 2) {
        if (v8 == 0) {
            // 0x28b57
            if (*(char *)v10 != 16) {
                // 0x28b7e
                wReg32_(a1, 636, (int64_t *)0x1010);
            } else {
                // 0x28b6a
                wReg32_(a1, 636, (int64_t *)0x1818);
            }
        } else {
            // 0x28b43
            wReg32_(a1, 636, (int64_t *)2827);
        }
    } else {
        // 0x28b92
        wReg32_(a1, 636, (int64_t *)0x1010);
    }
    int64_t v36 = (int64_t)((*v31 << (int32_t)&g103) / v30); // 0x28bb8
    wReg32_(a1, 444, (int64_t *)(v7 != 0 ? v36 | 0x300000 : v36));
    if (*v11 != v1) {
        int64_t v37; // 0x286ab
        int64_t v38; // 0x286ab
        if (v1 != (int32_t)"NU") {
            // 0x28c96
            wReg32_(a1, 456, (int64_t *)0x8079);
            wReg32_(a1, 460, (int64_t *)0x8079);
            wReg32_(a1, 464, (int64_t *)0x8079);
            wReg32_(a1, 272, (int64_t *)0x4c52);
            nmi_debug2(a1, (int64_t *)&g2, 0, (int128_t)v28, v38, v37);
            *v11 = 0x4c52;
            wReg32_(a1, 620, (int64_t *)&g25);
            wReg32_(a1, 624, (int64_t *)&g91);
        } else {
            // 0x28bf8
            wReg32_(a1, 456, (int64_t *)0x8000);
            wReg32_(a1, 460, (int64_t *)0x8000);
            wReg32_(a1, 464, (int64_t *)0x8000);
            wReg32_(a1, 272, (int64_t *)&g25);
            *v11 = (int32_t)&g25;
            nmi_debug2(a1, (int64_t *)&g2, 0, (int128_t)v28, v38, v37);
            wReg32_(a1, 620, NULL);
            wReg32_(a1, 624, (int64_t *)&g89);
        }
    }
    if (v2 > (int32_t)&g1) {
        if (v2 != (int32_t)&g25) {
            if (v2 == (int32_t)&g86) {
                uint32_t v39 = (a3 >> (int32_t)&g3) + 843; // 0x28e9c
                int64_t v40 = rReg32_(a1, (int64_t)&g29); // 0x28eac
                wReg32_(a1, (int64_t)&g29, (int64_t *)(int64_t)((0x1000000 * (int32_t)(0x10624dd3 * (int64_t)v4 >> (int64_t)&g26) / 0x1000000 / 512 << (int32_t)&g3) / v39 & -0x38400001 | (int32_t)v40 & -0x38800000 | 0x8000000));
                int32_t v41 = v5 == 0 ? 0 : v27; // 0x28eea
                int64_t v42 = rReg32_(a1, 564); // 0x28f07
                wReg32_(a1, 564, (int64_t *)(int64_t)((int32_t)v42 & -0x30400000 | (0x1000000 * (int32_t)(0x10624dd3 * (int64_t)(v41 + v3) >> (int64_t)&g26) / 0x1000000 / 512 << (int32_t)&g3) / v39 & -0x30000001));
            }
        } else {
            int32_t v43 = *v31;
            int32_t v44 = v7 != 0 ? -v43 : v43;
            int64_t v45 = rReg32_(a1, (int64_t)&g29); // 0x28e2e
            wReg32_(a1, (int64_t)&g29, (int64_t *)(v45 & 0xc7800000 | 2 * (int64_t)(((int32_t)(1024 * (0x10624dd3 * (int64_t)(v44 + v4) >> (int64_t)&g26)) & -0x10000) / ((a3 >> (int32_t)&g103) + 0x1a5e)) & 0xc7bffffe | 0x8000000));
            wReg32_(a1, 564, (int64_t *)(rReg32_(a1, 564) & 0xcfc00000));
        }
    } else {
        // 0x28d39
        if (*v11 != v2) {
            // 0x28d4c
            wReg32_(a1, (int64_t)&g29, (int64_t *)0x30000000);
        }
        int32_t v46 = *v31; // 0x28d61
        int64_t v47 = rReg32_(a1, 564); // 0x28d76
        int32_t v48 = (int32_t)v47 & -0x30400000 | (v46 << (int32_t)&g105) / (a3 / 3375 + 0x8000) & -0x30000001; // 0x28dad
        uint32_t v49 = v2 == (int32_t)&g1 ? v48 | 0x10000000 : v48; // 0x28dbe
        wReg32_(a1, 564, (int64_t *)(int64_t)v49);
    }
    int32_t v50 = v1; // 0x28f4d
    if (*v11 == v1) {
        goto lab_0x29003;
    } else {
        int64_t v51 = rReg32_(a1, 300);
        uint64_t v52 = v51 & 0xffff8f7f;
        if (v1 != (int32_t)&g89 == (v1 != (int32_t)&g94)) {
            // 0x28fa7
            wReg32_(a1, 300, (int64_t *)((v52 >> (int64_t)&g95 | (int64_t)(char)&g2) % 256 << (int64_t)&g95 | v51 & 0xffff007f));
            wReg32_(a1, 312, (int64_t *)0x5b18);
            wReg32_(a1, 328, (int64_t *)0x1ff082);
        } else {
            // 0x28f5f
            wReg32_(a1, 300, (int64_t *)v52);
            wReg32_(a1, 312, (int64_t *)0x5ad6);
            wReg32_(a1, 328, (int64_t *)0x1001);
        }
        int32_t v53 = *v11; // 0x28ffa
        v50 = v53;
        if (v53 != v1) {
            goto lab_0x29020;
        } else {
            goto lab_0x29003;
        }
    }
  lab_0x29003:
    // 0x29003
    if (v2 > (int32_t)&g1 == v50 == v2) {
        goto lab_0x290b8;
    } else {
        goto lab_0x29020;
    }
  lab_0x290b8:;
    int32_t v54 = a3 >> (int32_t)&g89;
    int64_t v55; // 0x286ab
    if (v1 != 0 == (v1 != (int32_t)"NU")) {
        int64_t v56 = (int32_t)(0x26d60dd * (int64_t)((864 * v54 - 0x4e058000) / 64) >> (int64_t)&g26) >> (int32_t)&g89 & -16 | 3; // 0x29110
        int64_t v57 = v1 != (int32_t)&g89 == (v1 != (int32_t)&g94) ? v56 : v56 | 0x1390000;
        v55 = v57;
    } else {
        // 0x290c3
        v55 = (int32_t)(0x26d60dd * (int64_t)((858 * v54 - 0x4f41e800) / 64) >> (int64_t)&g26) >> (int32_t)&g89 & -16 | 3;
    }
    // 0x29125
    wReg32_(a1, 528, (int64_t *)v55);
    int64_t v58 = rReg32_(a1, 260) & 0x87ffffc0; // 0x2913f
    int64_t v59 = v58 | 0x10000011; // 0x29144
    int64_t v60; // 0x286ab
    if (v2 != (int32_t)&g25) {
        // 0x2917b
        v60 = v59 | (v2 == (int32_t)&g1 ? 14 : 6);
    } else {
        // 0x2914f
        v60 = v59;
        if (v1 != (int32_t)&g105 && v1 != (int32_t)&g103 && v1 != (int32_t)"GNU" && v1 != (int32_t)&g91 && v1 != (int32_t)&g95) {
            // 0x2916d
            v60 = v1 != (int32_t)&g2 ? v58 | 0x10000013 : v59;
        }
    }
    unsigned char v61 = *(char *)v29;
    int64_t v62 = (int64_t)(a3 > 0x2a3000 == v61 == 0) + (int64_t)v61; // 0x291ae
    if (*(char *)(a2 + 41) != 0) {
        // 0x291b0
        v62 = (int64_t)*(char *)(a2 + 42);
    }
    uint64_t v63 = 2048 * v62 & 0xfffff800 | v60 & 0xffff87ff; // 0x291bb
    int32_t v64 = v61;
    int32_t v65 = v64 << (int32_t)&g105 | (int32_t)(v63 / 256 % 128 << (int64_t)&g95 | v63 & 0xffff00ff); // 0x291c3
    int64_t v66; // 0x286ab
    if (v2 > (int32_t)&g1) {
        int32_t v67 = *v31; // 0x29207
        int32_t v68 = a3 < 0x383ffd ? (int32_t)(a3 > 0x1c1ff8) : (int32_t)&g25;
        int64_t v69 = v67 + v68 << (int32_t)&g2 & -0x3f00001 | v65 & -0x3ff0001; // 0x293d6
        if (v2 != (int32_t)&g25) {
            // 0x292e9
            v66 = v69;
            if (v1 != (int32_t)&g2 && v1 != (int32_t)&g105 && v1 != (int32_t)&g103 && v1 != (int32_t)"GNU" && v1 != (int32_t)&g95 && v1 != (int32_t)&g91 && v2 == (int32_t)&g86) {
                // 0x29313
                v66 = v1 != -1 ? v69 | 0x1900000 : v69;
            }
            goto lab_0x29323;
        } else {
            int32_t v70 = *v11; // 0x2926c
            int32_t v71 = v70 & 0xfff00; // 0x29275
            if (v71 == 0x12000) {
                // 0x2928f
                v66 = v69 | 0xa00000;
                goto lab_0x29323;
            } else {
                int32_t v72 = v70 & 0xffff00;
                if (v72 != 0x13000) {
                    int64_t v73 = v69 | 0x200000;
                    v66 = v73;
                    if (v71 != 0x13100 != v72 != 0x813000) {
                        if (v6 != 0) {
                            if (v6 != (int32_t)&g1) {
                                if (v6 != (int32_t)&g25) {
                                    // 0x292d7
                                    v66 = v6 == (int32_t)&g33 ? v69 | 0x2a00000 : v73;
                                } else {
                                    // 0x292ce
                                    v66 = v69 | 0x2200000;
                                }
                            } else {
                                // 0x292bf
                                v66 = v69 | 0xa00000;
                            }
                        } else {
                            // 0x292b0
                            v66 = v69 | 0x2600000;
                        }
                    }
                    goto lab_0x29323;
                } else {
                    // 0x2928f
                    v66 = v69 | 0xa00000;
                    goto lab_0x29323;
                }
            }
        }
    } else {
        // 0x291cb
        v66 = v64 + (int32_t)(a3 > 0x2a3000) << (int32_t)&g2 & -0x3f00001 | v65 & -0x3ff0001 | 0x1800000;
        goto lab_0x29323;
    }
  lab_0x29020:;
    uint64_t v74 = rReg32_(a1, 512); // 0x29028
    uint64_t v75; // 0x286ab
    int64_t v76; // 0x286ab
    int64_t v77; // 0x286ab
    if (v1 != (int32_t)&g89 == (v1 != (int32_t)&g94)) {
        int64_t v78 = ((v74 >> (int64_t)&g95) % 128 | 128) << (int64_t)&g95 & 0xffffc000 | v74 & 0xffff0000; // 0x2905b
        v76 = v78;
        if (v2 > (int32_t)&g1) {
            // 0x29067
            v75 = v78;
            v77 = (v75 >> (int64_t)&g95 | (int64_t)(char)&g95) % 256 << (int64_t)&g95 | v75 & -0xff01;
            // 0x290ab
            wReg32_(a1, 512, (int64_t *)v77);
            goto lab_0x290b8;
        } else {
            goto lab_0x2906c;
        }
    } else {
        if (v2 > (int32_t)&g1) {
            int64_t v79 = ((v74 >> (int64_t)&g95) % 128 | 128) << (int64_t)&g95 & 0xffffc000 | v74 & 0xffff0000; // 0x29054
            // 0x29067
            v75 = v79;
            v77 = (v75 >> (int64_t)&g95 | (int64_t)(char)&g95) % 256 << (int64_t)&g95 | v75 & -0xff01;
            // 0x290ab
            wReg32_(a1, 512, (int64_t *)v77);
            goto lab_0x290b8;
        } else {
            // 0x2903f
            v76 = v74 & 0xffff4000;
            goto lab_0x2906c;
        }
    }
  lab_0x29323:
    // 0x29323
    wReg32_(a1, 260, (int64_t *)(v66 & 0xffffffff));
    int64_t v80 = v66 & 0xdfffffcf; // 0x29333
    int64_t * v81 = (int64_t *)(v80 | 0x20000020); // 0x29349
    wReg32_(a1, 260, v81);
    nmi_delay2(a1, (int64_t *)&g1);
    rReg32_(a1, 808);
    wReg32_(a1, 260, (int64_t *)(v80 | 0x20000000));
    return wReg32_(a1, 260, v81);
  lab_0x2906c:;
    char * v82 = (char *)v10; // 0x29076
    unsigned char v83 = *v82; // 0x29076
    char v84 = v83; // 0x2907d
    if (v83 >= 33) {
        // 0x2907f
        *v82 = (char)&g26;
        v84 = (char)&g26;
    }
    // 0x29090
    v77 = 64 * (int64_t)v84 + 1536 | v76 & 0xffffffff;
    // 0x290ab
    wReg32_(a1, 512, (int64_t *)v77);
    goto lab_0x290b8;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x293fe - 0x2942e
// Line range:    2442 - 2460
void nm131_tune_internal(int64_t pPrivate, int64_t tune, int32_t tuneMode) {
    // 0x293fe
    int64_t v1; // 0x293fe
    *(char *)v1 = 2 * (char)v1;
    int64_t v2; // 0x293fe
    rReg32_(v2, tune);
}

// Address range: 0x2942e - 0x2a725
int64_t nm131_tune_internal2(int64_t a1, int64_t a2, int64_t * a3) {
    // 0x2942e
    mcount();
    int64_t result = __readgsqword(40); // 0x2944d
    int32_t * v1 = (int32_t *)(a2 + (int64_t)"GNU"); // 0x29487
    uint32_t v2 = *v1; // 0x29487
    int32_t * v3 = (int32_t *)(a2 + (int64_t)&g2); // 0x2948d
    uint32_t v4 = *v3; // 0x2948d
    int32_t * v5 = (int32_t *)(a2 + (int64_t)&g13); // 0x29493
    int32_t v6 = *v5; // 0x29493
    char * v7 = (char *)(a2 + (int64_t)&g19); // 0x29499
    uint64_t v8; // 0x2942e
    int64_t v9 = 184 * (v8 % 256); // 0x294a4
    int32_t * v10 = (int32_t *)v9; // 0x294ab
    int32_t v11 = *v10; // 0x294ab
    char * v12 = (char *)(v9 | 1);
    bool v13 = v2 == (int32_t)&g91 | v2 == (int32_t)&g95;
    bool v14 = v2 == (int32_t)&g105 | v2 == (int32_t)&g103 | v2 == (int32_t)"GNU" | v13;
    char * v15 = (char *)v9;
    int64_t v16; // bp-8, 0x2942e
    int64_t v17 = (int64_t)&v16 - 64;
    char * v18 = (char *)(a2 + 40);
    int32_t v19 = v11; // 0x294c6
    uint32_t v20 = v11; // 0x294c6
    int32_t v21 = 0; // 0x294c6
    uint32_t v22; // 0x2942e
    uint64_t v23; // 0x2942e
    int64_t v24; // 0x2942e
    while (true) {
      lab_0x294ca:
        // 0x294ca
        v22 = v20;
        v23 = v24 & 0xffffffff;
        if ((v19 & 0xffff00) != 0x13000) {
            goto lab_0x295e3;
        } else {
            int64_t v25; // 0x2959f
            if (v23 == 0x23e1ca80) {
                // 0x29597
                v25 = rReg8_(a1, (int64_t)&g28);
                wReg8_(a1, (int64_t *)&g28, v25 & 252 | 2);
                goto lab_0x295e3;
            } else {
                int64_t v26; // 0x295c6
                if (v23 < 0x23e1ca81) {
                    if (v23 == 0xa3140c0) {
                        // 0x29597
                        v25 = rReg8_(a1, (int64_t)&g28);
                        wReg8_(a1, (int64_t *)&g28, v25 & 252 | 2);
                        goto lab_0x295e3;
                    } else {
                        if (v23 < 0xa3140c1) {
                            if (v23 != 0x8c30ac0) {
                                // 0x295be
                                v26 = rReg8_(a1, (int64_t)&g28);
                                wReg8_(a1, (int64_t *)&g28, v26 & 252 | 1);
                                goto lab_0x295e3;
                            } else {
                                int64_t v27 = rReg8_(a1, (int64_t)&g28); // 0x2957d
                                wReg8_(a1, (int64_t *)&g28, (v27 | (int64_t)(char)&g33) % 256);
                                goto lab_0x295e3;
                            }
                        } else {
                            if (v23 != 0x1e28f280 == (v23 != 0x21055e80)) {
                                // 0x295be
                                v26 = rReg8_(a1, (int64_t)&g28);
                                wReg8_(a1, (int64_t *)&g28, v26 & 252 | 1);
                                goto lab_0x295e3;
                            } else {
                                // 0x29597
                                v25 = rReg8_(a1, (int64_t)&g28);
                                wReg8_(a1, (int64_t *)&g28, v25 & 252 | 2);
                                goto lab_0x295e3;
                            }
                        }
                    }
                } else {
                    if (v23 == 0x2c770e80) {
                        // 0x29597
                        v25 = rReg8_(a1, (int64_t)&g28);
                        wReg8_(a1, (int64_t *)&g28, v25 & 252 | 2);
                        goto lab_0x295e3;
                    } else {
                        if (v23 < 0x2c770e81) {
                            if (v23 != 0x26be3680 == (v23 != 0x299aa280)) {
                                // 0x295be
                                v26 = rReg8_(a1, (int64_t)&g28);
                                wReg8_(a1, (int64_t *)&g28, v26 & 252 | 1);
                                goto lab_0x295e3;
                            } else {
                                // 0x29597
                                v25 = rReg8_(a1, (int64_t)&g28);
                                wReg8_(a1, (int64_t *)&g28, v25 & 252 | 2);
                                goto lab_0x295e3;
                            }
                        } else {
                            if (v23 != 0x2f537a80 == (v23 != 0x322fe680)) {
                                // 0x295be
                                v26 = rReg8_(a1, (int64_t)&g28);
                                wReg8_(a1, (int64_t *)&g28, v26 & 252 | 1);
                                goto lab_0x295e3;
                            } else {
                                // 0x29597
                                v25 = rReg8_(a1, (int64_t)&g28);
                                wReg8_(a1, (int64_t *)&g28, v25 & 252 | 2);
                                goto lab_0x295e3;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x2989f:;
    // 0x2989f
    uint32_t v28; // 0x29828
    int64_t v29 = 0x1000000000000 * (int64_t)(v28 / v20) / 0x1000000000000; // 0x2989f
    int32_t v30 = (int32_t)(0x26d60dd * (int64_t)(v28 >> (int32_t)&g91) >> (int64_t)&g26) >> (int32_t)&g89; // 0x298b7
    unsigned char v31 = (char)v30; // 0x298ba
    int32_t v32 = v31 < 16 ? (int32_t)&g2 : v30;
    uint32_t v33 = v31 < 32 ? v32 : (int32_t)&g24;
    wReg8_(a1, (int64_t *)&g1, (int64_t)(((int16_t)v29 >> (int16_t)&g1) % 256));
    uint32_t v34; // 0x29872
    wReg8_(a1, (int64_t *)&g25, (int64_t)((int32_t)v29 & (int32_t)&g1 & 255 | 2 * v34 & 254));
    uint32_t v35; // 0x2986f
    wReg8_(a1, (int64_t *)&g33, (int64_t)(v35 / 0x80000 % 256));
    uint32_t v36; // 0x29875
    wReg8_(a1, (int64_t *)&g86, (int64_t)(v36 / 0x8000 | (v33 << (int32_t)&g86) % 256));
    int64_t v37 = rReg8_(a1, (int64_t)&g22); // 0x2995a
    uint64_t v38; // 0x2942e
    wReg8_(a1, (int64_t *)&g22, (int64_t)(((int32_t)v37 & (int32_t)&g24 | (int32_t)v38 << (int32_t)&g89) % 256));
    if (*v18 == 0) {
        // 0x29997
        if ((*v10 & 0xfff00) == 0x12000) {
            goto lab_0x29a05;
        } else {
            if (v36 != 0) {
                // 0x299ce
                wReg8_(a1, (int64_t *)&g18, (int64_t)&g103);
            } else {
                // 0x299ba
                wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
            }
            goto lab_0x299e0;
        }
    } else {
        // 0x29983
        wReg8_(a1, (int64_t *)&g18, (int64_t)&g103);
        goto lab_0x299e0;
    }
  lab_0x295e3:;
    int64_t v39 = v2 != (int32_t)"NU" ? v23 : v23 + 0xffca9820; // 0x295f2
    unsigned char v40 = *(char *)(a2 + (int64_t)&g26); // 0x295f7
    uint32_t v41; // 0x2942e
    int64_t v42; // 0x2942e
    if (v40 == 0) {
        // 0x29616
        int64_t v43; // 0x2942e
        if (*(char *)(184 * (int64_t)*(char *)&v43) == 0) {
            if (v2 != (int32_t)"NU") {
                // 0x29664
                v41 = (int32_t)v39;
                if (v2 != (int32_t)&g86) {
                    goto lab_0x296ae;
                } else {
                    if (v41 < 0xce60081 || v41 < 0xa099481 || v41 < 0xb77ca81) {
                        // 0x29694
                        *v12 = (char)&g103;
                        v42 = (int64_t)&g33;
                        goto lab_0x29740;
                    } else {
                        goto lab_0x296ae;
                    }
                }
            } else {
                // 0x2964a
                *v12 = (char)&g105;
                v42 = 0xffffff87;
                goto lab_0x29740;
            }
        } else {
            // 0x2962a
            *v12 = (char)&g105;
            v42 = 0xffffff87;
            goto lab_0x29740;
        }
    } else {
        // 0x29601
        *v12 = (char)&g105;
        v42 = v40;
        goto lab_0x29740;
    }
  lab_0x29740:;
    uint64_t v44 = v42;
    char v45 = v44; // 0x29744
    if (*v15 != v45) {
        // 0x2974c
        wReg8_(a1, (int64_t *)&g89, v44 % 256);
        *v15 = v45;
    }
    int32_t v46 = *(int32_t *)((int64_t)v2 * (int64_t)&g86);
    uint32_t v47 = (*v7 != 0 ? -v46 : v46) + (int32_t)v39;
    int64_t v48 = (int64_t)&g94; // 0x29798
    if (v47 >= 0x328b741) {
        int64_t v49 = &g91;
        int64_t v50 = 0; // 0x2942e
        v48 = v49;
        while (*(int32_t *)v50 < v47) {
            int64_t v51 = v49 - (int64_t)(int32_t)&g1; // 0x297a7
            int64_t v52 = v51 & 0xffffffff; // 0x297a7
            v50 -= (int64_t)&g86;
            int64_t v53 = v52; // 0x297b3
            v48 = v52;
            if ((char)v51 == (char)&g1) {
                // break -> 0x297b5
                break;
            }
            v49 = v53;
            v48 = v49;
        }
    }
    // 0x297b5
    v38 = v48;
    *v10 = v47;
    int64_t v54 = &g1; // 0x297d9
    int64_t v55 = v54; // 0x297e1
    while (v54 != (int64_t)&g95) {
        // 0x297c5
        v54 = v55 + (int64_t)&g1;
        v55 = v54;
    }
    char * v56 = (char *)(v54 * (int64_t)&g95); // 0x297e3
    wReg8_(a1, (int64_t *)&g95, (int64_t)*v56);
    wReg8_(a1, (int64_t *)&g97, (int64_t)*v56);
    unsigned char v57 = *(char *)(v17 + v38 % 256 * (int64_t)&g1); // 0x29811
    int64_t v58 = rReg8_(a1, (int64_t)&g28); // 0x29833
    int32_t v59 = (int32_t)v58 & (int32_t)&g33; // 0x2983b
    int32_t v60; // 0x2942e
    if (v59 == (int32_t)&g25) {
        // 0x29851
        v60 = v22 << (int32_t)&g1;
    } else {
        int32_t v61 = v59 != (int32_t)&g33 ? v22 : v22 >> (int32_t)&g1; // 0x29848
        v60 = v61;
    }
    // 0x29854
    v28 = ((int32_t)v57 << (int32_t)&g33) * ((int32_t)(0x10624dd3 * (int64_t)v47 >> (int64_t)&g26) >> (int32_t)&g91);
    v20 = v60;
    v35 = 0x80000000 / v20 * (v28 % v20);
    v34 = v35 / 0x1000;
    v36 = v34 % 0x80000;
    if (v21 == 0 != (*v18 == 0) || v36 == 0) {
        // break -> 0x2989f
        goto lab_0x2989f;
    }
    // 0x2988c
    v19 = *v10;
    v24 = v23 + (int64_t)(int32_t)"%(";
    v21 = &g1;
    goto lab_0x294ca;
  lab_0x296ae:
    if (v41 < 0x72d2881) {
        // 0x296bc
        *v12 = (char)&g103;
        v42 = &g89;
        goto lab_0x29740;
    } else {
        if (v2 == -1 || v2 == (int32_t)&g2 || v14) {
            // 0x2972b
            *v12 = (char)&g105;
            v42 = 0xffffff85;
            goto lab_0x29740;
        } else {
            if (v41 < 0xe9e37d1 || v41 < 0x21d1d641) {
                // 0x29714
                *v12 = (char)&g105;
                v42 = 0xffffff87;
                goto lab_0x29740;
            } else {
                // 0x2972b
                *v12 = (char)&g105;
                v42 = 0xffffff85;
                goto lab_0x29740;
            }
        }
    }
  lab_0x29a05:
    if (v47 < 0x11e1a300) {
        // 0x29b18
        wReg8_(a1, (int64_t *)37, 120);
        wReg8_(a1, (int64_t *)39, 127);
        wReg8_(a1, (int64_t *)41, 127);
        wReg8_(a1, (int64_t *)46, (int64_t)&g4);
        if (v47 < 0x93d1cc0) {
            // 0x29b38
            wReg8_(a1, (int64_t *)54, 84);
            goto lab_0x2a47a;
        } else {
            // 0x29b21
            wReg8_(a1, (int64_t *)54, 124);
            goto lab_0x2a47a;
        }
    } else {
        // 0x29a12
        if (*v15 == 0) {
            // 0x29a4c
            wReg8_(a1, (int64_t *)37, 244);
        } else {
            // 0x29a26
            *v15 = -12;
            wReg8_(a1, (int64_t *)37, 250);
        }
        // 0x29a5e
        wReg8_(a1, (int64_t *)39, 239);
        if (*v15 == 0) {
            // 0x29aaa
            wReg8_(a1, (int64_t *)41, 79);
        } else {
            // 0x29a84
            *v15 = 79;
            wReg8_(a1, (int64_t *)41, 239);
        }
        // 0x29b18
        wReg8_(a1, (int64_t *)46, 52);
        // 0x29b21
        wReg8_(a1, (int64_t *)54, 124);
        goto lab_0x2a47a;
    }
  lab_0x299e0:;
    int32_t v62 = *v10; // 0x299eb
    int32_t v63 = v62 & 0xfff00; // 0x299f3
    bool v64; // 0x2942e
    if (v63 != 0x12000) {
        int32_t v65 = v62 & 0xffff00;
        if (v65 != 0x13000) {
            if (v65 != 0x813000) {
                if (v63 != 0x13100) {
                    goto lab_0x2a601;
                } else {
                    bool v66 = v2 == (int32_t)&g103 | v2 == (int32_t)"GNU" | v13;
                    v64 = v2 == (int32_t)&g105 | v66;
                    if (v2 != (int32_t)&g2 == !v64) {
                        // 0x2a07c
                        wReg8_(a1, (int64_t *)&g103, 37);
                        wReg8_(a1, (int64_t *)37, 233);
                    } else {
                        // 0x2a056
                        wReg8_(a1, (int64_t *)&g103, 69);
                        wReg8_(a1, (int64_t *)37, 250);
                    }
                    if (v2 == -1 || v2 == (int32_t)&g2 || v64) {
                        // 0x2a0e6
                        wReg8_(a1, (int64_t *)46, 86);
                    } else {
                        // 0x2a0d2
                        wReg8_(a1, (int64_t *)46, (int64_t)&g30);
                    }
                    if (v4 != (int32_t)&g25 || v66) {
                        // 0x2a144
                        wReg8_(a1, (int64_t *)38, 130);
                        if (v4 > (int32_t)&g1) {
                            goto lab_0x2a285;
                        } else {
                            // 0x2a160
                            wReg8_(a1, (int64_t *)39, 175);
                            wReg8_(a1, (int64_t *)41, 175);
                            wReg8_(a1, (int64_t *)48, (int64_t)&g105);
                            wReg8_(a1, (int64_t *)50, (int64_t)&g105);
                            if (v2 == (int32_t)"NU") {
                                // 0x2a1ec
                                wReg8_(a1, (int64_t *)52, 96);
                            } else {
                                unsigned char v67 = *v15; // 0x2a1b9
                                if (v67 < 16) {
                                    // 0x2a1c4
                                    wReg8_(a1, (int64_t *)52, (int64_t)(-1 - v67));
                                } else {
                                    // 0x2a1d8
                                    wReg8_(a1, (int64_t *)52, 240);
                                }
                            }
                            unsigned char v68 = *v15; // 0x2a209
                            if (v68 < 16) {
                                // 0x2a22a
                                wReg8_(a1, (int64_t *)53, (int64_t)(95 - v68));
                            } else {
                                // 0x2a25c
                                wReg8_(a1, (int64_t *)53, 80);
                            }
                            // 0x2a26e
                            wReg8_(a1, (int64_t *)54, 84);
                            goto lab_0x2a47a;
                        }
                    } else {
                        // 0x2a10f
                        wReg8_(a1, (int64_t *)38, 128);
                        goto lab_0x2a285;
                    }
                }
            } else {
                if (v2 != (int32_t)&g2 == !v14) {
                    // 0x29f8b
                    wReg8_(a1, (int64_t *)&g103, 37);
                    wReg8_(a1, (int64_t *)37, 233);
                    wReg8_(a1, (int64_t *)38, 128);
                    wReg8_(a1, (int64_t *)39, (int64_t)&g1);
                    wReg8_(a1, (int64_t *)41, (int64_t)&g1);
                    wReg8_(a1, (int64_t *)48, (int64_t)&g1);
                    wReg8_(a1, (int64_t *)50, (int64_t)&g1);
                    wReg8_(a1, (int64_t *)54, 84);
                    goto lab_0x2a47a;
                } else {
                    // 0x29dd7
                    wReg8_(a1, (int64_t *)&g103, 69);
                    wReg8_(a1, (int64_t *)37, 250);
                    wReg8_(a1, (int64_t *)38, 130);
                    if (v47 < 0x30c1b080) {
                        if (v47 < 0x2ed96880) {
                            if (v47 < 0x2d6b3280) {
                                // 0x29f54
                                wReg8_(a1, (int64_t *)39, 127);
                                wReg8_(a1, (int64_t *)41, 127);
                                wReg8_(a1, (int64_t *)48, 223);
                                wReg8_(a1, (int64_t *)50, 223);
                                if (v47 < 0x93d1cc0) {
                                    // 0x29f74
                                    wReg8_(a1, (int64_t *)54, 84);
                                    goto lab_0x2a47a;
                                } else {
                                    // 0x29f5d
                                    wReg8_(a1, (int64_t *)54, 124);
                                    goto lab_0x2a47a;
                                }
                            } else {
                                // 0x29ec2
                                wReg8_(a1, (int64_t *)39, 95);
                                wReg8_(a1, (int64_t *)41, 95);
                                wReg8_(a1, (int64_t *)48, 223);
                                wReg8_(a1, (int64_t *)50, 223);
                                // 0x29f5d
                                wReg8_(a1, (int64_t *)54, 124);
                                goto lab_0x2a47a;
                            }
                        } else {
                            // 0x29e6c
                            wReg8_(a1, (int64_t *)39, 63);
                            wReg8_(a1, (int64_t *)41, 63);
                            wReg8_(a1, (int64_t *)48, 223);
                            wReg8_(a1, (int64_t *)50, 223);
                            // 0x29f5d
                            wReg8_(a1, (int64_t *)54, 124);
                            goto lab_0x2a47a;
                        }
                    } else {
                        // 0x29e16
                        wReg8_(a1, (int64_t *)39, 63);
                        wReg8_(a1, (int64_t *)41, 63);
                        wReg8_(a1, (int64_t *)48, 175);
                        wReg8_(a1, (int64_t *)50, 175);
                        // 0x29f5d
                        wReg8_(a1, (int64_t *)54, 124);
                        goto lab_0x2a47a;
                    }
                }
            }
        } else {
            if (v47 == 0xb9f76c0) {
                // 0x29b97
                wReg8_(a1, (int64_t *)&g103, 69);
                goto lab_0x29bbd;
            } else {
                if (v47 < 0xb9f76c1) {
                    if (v47 != 0x8c30ac0 == (v47 != 0xa3140c0)) {
                        // 0x29bab
                        wReg8_(a1, (int64_t *)&g103, 37);
                        goto lab_0x29bbd;
                    } else {
                        // 0x29b97
                        wReg8_(a1, (int64_t *)&g103, 69);
                        goto lab_0x29bbd;
                    }
                } else {
                    if (v47 != 0xd0dacc0 == (v47 != 0xe7be2c0)) {
                        // 0x29bab
                        wReg8_(a1, (int64_t *)&g103, 37);
                        goto lab_0x29bbd;
                    } else {
                        // 0x29b97
                        wReg8_(a1, (int64_t *)&g103, 69);
                        goto lab_0x29bbd;
                    }
                }
            }
        }
    } else {
        goto lab_0x29a05;
    }
  lab_0x2a47a:;
    int32_t v69 = *v10; // 0x2a485
    if ((v69 & 0xffff00) == 0x813000) {
        goto lab_0x2a4ab;
    } else {
        if ((v69 & 0xfff00) != 0x13100) {
            goto lab_0x2a601;
        } else {
            goto lab_0x2a4ab;
        }
    }
  lab_0x2a4ab:
    if (v2 == -1 || v2 == (int32_t)&g2 || v2 == (int32_t)&g105 || v2 == (int32_t)&g103 || v2 == (int32_t)"GNU" || v2 == (int32_t)&g95 || v2 == (int32_t)&g91 || v4 != (int32_t)&g25) {
        if (v4 > (int32_t)&g1) {
            // 0x2a5dd
            wReg8_(a1, (int64_t *)52, 120);
            wReg8_(a1, (int64_t *)53, 84);
        }
    } else {
        if (v6 != (int32_t)&g1 != v6 != (int32_t)&g33) {
            unsigned char v70 = *v15; // 0x2a512
            if (v70 < 16) {
                // 0x2a51d
                wReg8_(a1, (int64_t *)52, (int64_t)(127 - v70));
            } else {
                // 0x2a536
                wReg8_(a1, (int64_t *)52, 112);
            }
        }
        uint32_t v71 = v6 - (int32_t)&g25; // 0x2a54b
        if (v71 > (int32_t)&g1 != v6 != 0) {
            unsigned char v72 = *v15; // 0x2a564
            if (v72 < 16) {
                // 0x2a56f
                wReg8_(a1, (int64_t *)53, (int64_t)(95 - v72));
            } else {
                // 0x2a588
                wReg8_(a1, (int64_t *)53, 80);
            }
        }
        if (v6 != (int32_t)&g1 && v6 != (int32_t)&g33) {
            // 0x2a5a6
            wReg8_(a1, (int64_t *)52, 96);
        }
        if (v6 != 0 && v71 > (int32_t)&g1) {
            // 0x2a5c3
            wReg8_(a1, (int64_t *)53, 64);
        }
    }
    goto lab_0x2a601;
  lab_0x2a601:
    if (v2 != (int32_t)&g2 == !v14) {
        // 0x2a673
        wReg8_(a1, (int64_t *)55, 132);
    } else {
        if (v47 < 0x11e1a300) {
            if (v47 < 0x93d1cc0) {
                // 0x2a65f
                wReg8_(a1, (int64_t *)55, 132);
            } else {
                // 0x2a64b
                wReg8_(a1, (int64_t *)55, 156);
            }
        } else {
            // 0x2a62e
            wReg8_(a1, (int64_t *)55, 132);
        }
    }
    unsigned char v73 = *(char *)(a2 + (int64_t)&g28); // 0x2a685
    if (v73 != 0) {
        // 0x2a68f
        wReg8_(a1, (int64_t *)53, (int64_t)v73);
    }
    int32_t v74 = (v28 << (int32_t)&g97) / (v33 % 256) - 0x6978000; // 0x298e1
    int32_t v75 = (int64_t)a3; // 0x2a69f
    nm131_demod_config2(a1, a2, v74, v75);
    *v10 = v74;
    *(int32_t *)(v9 + 8) = *v1;
    int32_t * v76 = (int32_t *)(v9 + 12); // 0x2a6d9
    *v76 = *v3;
    *(int32_t *)(v9 | 4) = v75;
    *v76 = *v5;
    *(char *)(v9 + 13) = *v7;
    *(char *)(v9 + 14) = *(char *)(a2 + (int64_t)&g22);
    *(char *)(v9 + 15) = *(char *)(a2 + (int64_t)&g7);
    return result;
  lab_0x29bbd:
    if (v2 != (int32_t)&g2 == !v14) {
        // 0x29c3f
        wReg8_(a1, (int64_t *)37, 233);
        wReg8_(a1, (int64_t *)46, 86);
    } else {
        if (v47 != 0x6dac2c0 == (v47 != 0x754d4c0)) {
            // 0x29c19
            wReg8_(a1, (int64_t *)37, 86);
            wReg8_(a1, (int64_t *)46, 86);
        } else {
            // 0x29bf3
            wReg8_(a1, (int64_t *)37, 67);
            wReg8_(a1, (int64_t *)46, 120);
        }
    }
    if (v47 < 0x848f8c0) {
        // 0x29c92
        wReg8_(a1, (int64_t *)48, 223);
        wReg8_(a1, (int64_t *)50, 223);
    } else {
        // 0x29c6c
        wReg8_(a1, (int64_t *)48, (int64_t)&g1);
        wReg8_(a1, (int64_t *)50, (int64_t)&g1);
    }
    // 0x29cb6
    if (*v18 == 0) {
        goto lab_0x2a47a;
    } else {
        if (v47 == 0x11584ec0) {
            // 0x29d76
            wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
            goto lab_0x2a47a;
        } else {
            if (v47 < 0x11584ec1) {
                if (v47 == 0xb9f76c0) {
                    // 0x29d76
                    wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                    goto lab_0x2a47a;
                } else {
                    if (v47 < 0xb9f76c1) {
                        switch (v47) {
                            case 0x8c30ac0: {
                                // 0x29d76
                                wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                                goto lab_0x2a47a;
                            }
                            case 0xa3140c0: {
                                // 0x29d76
                                wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                                goto lab_0x2a47a;
                            }
                            default: {
                                if (v47 != 0x754d4c0) {
                                    // 0x29d8d
                                    wReg8_(a1, (int64_t *)&g18, (int64_t)&g103);
                                    goto lab_0x2a47a;
                                } else {
                                    // 0x29d76
                                    wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                                    goto lab_0x2a47a;
                                }
                            }
                        }
                    } else {
                        switch (v47) {
                            case 0xe7be2c0: {
                                // 0x29d76
                                wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                                goto lab_0x2a47a;
                            }
                            case 0xfea18c0: {
                                // 0x29d76
                                wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                                goto lab_0x2a47a;
                            }
                            default: {
                                if (v47 != 0xd0dacc0) {
                                    // 0x29d8d
                                    wReg8_(a1, (int64_t *)&g18, (int64_t)&g103);
                                    goto lab_0x2a47a;
                                } else {
                                    // 0x29d76
                                    wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                                    goto lab_0x2a47a;
                                }
                            }
                        }
                    }
                }
            } else {
                if (v47 == 0x171126c0) {
                    // 0x29d76
                    wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                    goto lab_0x2a47a;
                } else {
                    if (v47 < 0x171126c1) {
                        switch (v47) {
                            case 0x1434bac0: {
                                // 0x29d76
                                wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                                goto lab_0x2a47a;
                            }
                            case 0x15a2f0c0: {
                                // 0x29d76
                                wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                                goto lab_0x2a47a;
                            }
                            default: {
                                if (v47 != 0x12c684c0) {
                                    // 0x29d8d
                                    wReg8_(a1, (int64_t *)&g18, (int64_t)&g103);
                                    goto lab_0x2a47a;
                                } else {
                                    // 0x29d76
                                    wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                                    goto lab_0x2a47a;
                                }
                            }
                        }
                    } else {
                        switch (v47) {
                            case 0x19ed92c0: {
                                // 0x29d76
                                wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                                goto lab_0x2a47a;
                            }
                            case 0x1b5bc8c0: {
                                // 0x29d76
                                wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                                goto lab_0x2a47a;
                            }
                            default: {
                                if (v47 != 0x187f5cc0) {
                                    // 0x29d8d
                                    wReg8_(a1, (int64_t *)&g18, (int64_t)&g103);
                                    goto lab_0x2a47a;
                                } else {
                                    // 0x29d76
                                    wReg8_(a1, (int64_t *)&g18, (int64_t)&g95);
                                    goto lab_0x2a47a;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x2a285:
    if (v2 != (int32_t)&g2 == !v64) {
        // 0x2a420
        wReg8_(a1, (int64_t *)39, (int64_t)&g1);
        wReg8_(a1, (int64_t *)41, (int64_t)&g1);
        wReg8_(a1, (int64_t *)48, (int64_t)&g1);
        wReg8_(a1, (int64_t *)50, (int64_t)&g1);
        wReg8_(a1, (int64_t *)54, 84);
        goto lab_0x2a47a;
    } else {
        if (v47 < 0x30c1b080) {
            if (v47 < 0x2ed96880) {
                if (v47 < 0x2d6b3280) {
                    // 0x2a3ef
                    wReg8_(a1, (int64_t *)39, 127);
                    wReg8_(a1, (int64_t *)41, 127);
                    wReg8_(a1, (int64_t *)48, 223);
                    wReg8_(a1, (int64_t *)50, 223);
                    if (v47 < 0x93d1cc0) {
                        // 0x2a40c
                        wReg8_(a1, (int64_t *)54, 84);
                        goto lab_0x2a47a;
                    } else {
                        // 0x2a3f8
                        wReg8_(a1, (int64_t *)54, 124);
                        goto lab_0x2a47a;
                    }
                } else {
                    // 0x2a35d
                    wReg8_(a1, (int64_t *)39, 95);
                    wReg8_(a1, (int64_t *)41, 95);
                    wReg8_(a1, (int64_t *)48, 223);
                    wReg8_(a1, (int64_t *)50, 223);
                    // 0x2a3f8
                    wReg8_(a1, (int64_t *)54, 124);
                    goto lab_0x2a47a;
                }
            } else {
                // 0x2a307
                wReg8_(a1, (int64_t *)39, 63);
                wReg8_(a1, (int64_t *)41, 63);
                wReg8_(a1, (int64_t *)48, 223);
                wReg8_(a1, (int64_t *)50, 223);
                // 0x2a3f8
                wReg8_(a1, (int64_t *)54, 124);
                goto lab_0x2a47a;
            }
        } else {
            // 0x2a2b1
            wReg8_(a1, (int64_t *)39, 63);
            wReg8_(a1, (int64_t *)41, 63);
            wReg8_(a1, (int64_t *)48, 175);
            wReg8_(a1, (int64_t *)50, 175);
            // 0x2a3f8
            wReg8_(a1, (int64_t *)54, 124);
            goto lab_0x2a47a;
        }
    }
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x2a72d - 0x2a749
// Line range:    3140 - 3157
void nm131_fm_scan(int64_t pPrivate, int64_t p) {
    // 0x2a72d
    int64_t v1; // 0x2a72d
    char * v2 = (char *)(p - 21 + v1 * (int64_t)&g1); // 0x2a72d
    uint64_t v3; // 0x2a72d
    *v2 = *v2 + (char)(v3 >> (int64_t)&g95);
}

// Address range: 0x2a749 - 0x2a75d
int64_t function_2a749(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x2a749
    return __stack_chk_fail();
}

// Address range: 0x2a75d - 0x2a7a8
int64_t nm131_fm_scan2(int64_t a1, int64_t a2) {
    // 0x2a75d
    mcount();
    int64_t v1; // bp-72, 0x2a75d
    __asm_rep_stosq_memset((char *)&v1, 0, (int64_t)&g89);
    bool v2; // 0x2a75d
    int64_t v3 = v2 ? -8 * (int64_t)&g89 : (int64_t)&g95 * (int64_t)&g89; // 0x2a784
    *(int32_t *)(v3 + (int64_t)&v1) = 0;
    int64_t v4; // 0x2a75d
    return (int64_t)*(int32_t *)&v4;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x2a7aa - 0x2a7ab
// Line range:    3179 - 3198
void nm131_scan(int64_t pPrivate, int64_t p) {
    // 0x2a7aa
    int64_t v1; // 0x2a7aa
    __asm_in((int16_t)v1);
}

// Address range: 0x2a7ad - 0x2a7da
int64_t function_2a7ad(int64_t a1, int64_t a2) {
    // 0x2a7ad
    int64_t v1; // 0x2a7ad
    nmi_delay2(v1, (int64_t *)&g7);
    int64_t v2 = nm131_adec_get_rssi2(v1); // 0x2a7bd
    int64_t v3; // 0x2a7ad
    *(int16_t *)(v3 + (int64_t)&g86) = (int16_t)v2;
    int64_t result = nm131_get_overthcount2(v1); // 0x2a7c9
    *(int32_t *)(v3 + (int64_t)&g95) = (int32_t)result;
    return result;
}

// Address range: 0x2a7da - 0x2a818
int64_t nm131_scan2(int64_t a1, int64_t * a2) {
    // 0x2a7da
    mcount();
    nm131_tune_internal2(a1, (int64_t)a2, (int64_t *)&g1);
    nmi_delay2(a1, (int64_t *)&g23);
    int64_t v1 = rReg32_(a1, 492); // 0x2a80b
    return ((int32_t)v1 >> (int32_t)&g98) % 1024;
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x2a819 - 0x2a81c
// Line range:    3608 - 3677
void nm131_software_sleep_lt(int64_t pPrivate) {
    // 0x2a819
    return;
}

// Address range: 0x2a81e - 0x2a849
int64_t function_2a81e(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x2a81e
    int64_t v1; // 0x2a81e
    int32_t v2 = v1; // 0x2a81e
    int64_t v3 = v2 < 512 == (511 - v2 & v2) < 0 ? a3 : v1;
    int32_t v4 = v3; // 0x2a826
    int64_t v5; // 0x2a81e
    *(int32_t *)(v5 + 48) = v4;
    int64_t v6; // 0x2a81e
    int32_t v7 = (int32_t)*(int16_t *)(184 * (int64_t)*(char *)&v6); // 0x2a83c
    int32_t v8 = v4 - v7; // 0x2a83c
    *(char *)(v5 + 44) = (char)(v8 < 0 == ((v8 ^ v4) & (v4 ^ v7)) < 0);
    return v3 & 0xffffffff;
}

// Address range: 0x2a849 - 0x2aa3e
int64_t nm131_software_sleep_lt2(int64_t a1) {
    // 0x2a849
    mcount();
    int64_t v1; // bp-88, 0x2a849
    int64_t v2 = &v1; // 0x2a864
    __asm_rep_stosq_memset((char *)&v1, 0, (int64_t)&g89);
    bool v3; // 0x2a849
    int64_t v4 = v3 ? -8 * (int64_t)&g89 : (int64_t)&g95 * (int64_t)&g89; // 0x2a875
    *(int32_t *)(v4 + v2) = 0;
    v1 = 0x1c40aa80;
    nm131_tune_internal2(a1, v2, NULL);
    uint64_t v5; // 0x2a849
    int64_t v6 = 184 * (v5 % 256); // 0x2a8b1
    *(char *)(v6 | 2) = (char)&g1;
    int64_t v7 = rReg32_(a1, 260); // 0x2a8c6
    wReg32_(a1, 260, (int64_t *)(v7 & 0xffffffde | (int64_t)(int32_t)&g2));
    *(char *)(v6 | 3) = (char)rReg8_(a1, 0);
    wReg8_(a1, NULL, (int64_t)"NU");
    int64_t v8 = rReg8_(a1, (int64_t)&g94); // 0x2a90c
    wReg8_(a1, (int64_t *)&g94, v8 & 191);
    int64_t v9 = rReg8_(a1, (int64_t)&g97); // 0x2a92e
    wReg8_(a1, (int64_t *)&g97, v9 & 239);
    int64_t v10 = rReg8_(a1, (int64_t)&g99); // 0x2a950
    wReg8_(a1, (int64_t *)&g99, v10 & 239);
    *(char *)(v6 | 4) = (char)rReg8_(a1, 52);
    wReg8_(a1, (int64_t *)52, 0);
    *(char *)(v6 | 5) = (char)rReg8_(a1, 53);
    wReg8_(a1, (int64_t *)53, 0);
    *(char *)(v6 | 6) = (char)rReg8_(a1, (int64_t)&g89);
    wReg8_(a1, (int64_t *)&g89, (int64_t)&g89);
    *(char *)v6 = (char)&g89;
    *(char *)(v6 | 7) = (char)rReg8_(a1, (int64_t)&g98);
    int64_t v11; // 0x2a849
    uint32_t v12 = *(int32_t *)(184 * (int64_t)*(char *)&v11); // 0x2a9fb
    int64_t v13 = 244; // 0x2aa09
    if (v12 < 4) {
        // 0x2aa0b
        v13 = (int64_t)(*(char *)(int64_t)v12 | -12);
    }
    // 0x2aa14
    wReg8_(a1, (int64_t *)&g98, v13);
    return rReg8_(a1, 54);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x2aa3f - 0x2aa6f
// Line range:    3372 - 3400
void nm131_notch_ctl(int64_t pPrivate, int32_t en, int32_t width) {
    // 0x2aa3f
    int64_t v1; // 0x2aa3f
    int64_t v2 = 184 * v1 & 0xfffffff8; // 0x2aa3f
    int64_t v3; // 0x2aa3f
    int64_t v4; // 0x2aa3f
    *(char *)(v3 + 8 + v2) = (char)v4;
    int64_t v5; // 0x2aa3f
    wReg8_(v5, (int64_t *)54, 120);
    *(char *)((v2 | 2) + v3) = 0;
}

// Address range: 0x2aa6f - 0x2ab4b
int64_t nm131_notch_ctl2(int64_t a1, int64_t a2, int64_t a3) {
    // 0x2aa6f
    mcount();
    uint64_t v1; // 0x2aa6f
    int64_t result = 184 * (v1 % 256);
    if ((int32_t)a2 == 0) {
        // 0x2ab2a
        return result;
    }
    int32_t * v2 = (int32_t *)result; // 0x2aa95
    uint32_t v3 = *v2; // 0x2aa95
    int64_t v4; // 0x2aa6f
    int64_t v5; // 0x2aa6f
    if (v3 == 13) {
        // 0x2aac7
        return nmi_debug2(a1, (int64_t *)&g2, 0, (int128_t)v3, v5, v4);
    }
    uint32_t v6 = v3 & -0x7003;
    uint32_t v7 = v6 | ((int32_t)a3 & (int32_t)&g94) << (int32_t)"GNU"; // 0x2aaf1
    *v2 = v7;
    wReg32_(a1, 272, (int64_t *)(int64_t)v7);
    return nmi_debug2(a1, (int64_t *)&g2, 0, (int128_t)v6, v5, v4);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x2ab4b - 0x2ab7b
// Line range:    3453 - 3505
void nm131_notch_spur(int64_t pPrivate) {
    // 0x2ab4b
    int64_t v1; // 0x2ab4b
    int64_t v2; // 0x2ab4b
    *(int32_t *)v2 = (int32_t)v1;
    wReg32_(pPrivate, 272, (int64_t *)v1);
    int64_t v3; // 0x2ab4b
    int64_t v4; // 0x2ab4b
    int64_t v5; // 0x2ab4b
    int64_t v6; // 0x2ab4b
    nmi_debug2(v5, (int64_t *)&g2, 0, (int128_t)v6, v4, v3);
}

// Address range: 0x2ab7b - 0x2ac90
int64_t nm131_notch_spur2(int64_t a1) {
    // 0x2ab7b
    mcount();
    uint64_t v1; // 0x2ab7b
    int32_t v2 = *(int32_t *)(184 * (v1 % 256)); // 0x2ab97
    switch (v2) {
        default: {
            if (v2 != 13) {
                // 0x2abd9
                return nm131_notch_ctl2(a1, 0, 0);
            }
        }
        case 6: {
        }
        case 8: {
        }
        case 12: {
        }
        case 14: {
        }
        case 15: {
        }
        case 16: {
            // 0x2abc2
            return nm131_notch_ctl2(a1, 0, 0);
        }
    }
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x2ac91 - 0x2acc1
// Line range:    2463 - 2512
int32_t nm131_tune(int64_t pPrivate, int64_t tune) {
    // 0x2ac91
    int64_t v1; // 0x2ac91
    if (v1 == (int64_t)&g1) {
        // 0x2ac97
        int64_t v2; // 0x2ac91
        return (int32_t)*(int16_t *)(v2 + (int64_t)&g103);
    }
    // 0x2aca7
    int64_t v3; // 0x2ac91
    return (int32_t)v3 | 193;
}

// Address range: 0x2acc1 - 0x2add2
int64_t nm131_tune2(uint64_t a1, int64_t a2) {
    // 0x2acc1
    mcount();
    uint32_t v1 = *(int32_t *)(a2 + (int64_t)&g2); // 0x2acfc
    if (v1 > (int32_t)&g1) {
        // 0x2adbb
        return 184 * (a1 % 256);
    }
    // 0x2ad06
    if (*(int32_t *)(a2 + (int64_t)"GNU") == (int32_t)"NU") {
        // 0x2ad0c
        return nm131_tune_internal2(a1, a2, NULL);
    }
    // 0x2ad1b
    if (*(char *)(a2 + (int64_t)&g9) != 0) {
        // 0x2ada7
        nm131_tune_internal2(a1, a2, NULL);
        return nm131_notch_spur2(a1);
    }
    int64_t v2 = a2; // bp-88, 0x2ad28
    nm131_scan2(a1, &v2);
    int32_t v3 = nm131_demod_get_snr(a1); // 0x2ad78
    int32_t v4 = v3 >> (int32_t)&g24; // 0x2ad7a
    if ((v4 ^ v3) - v4 >= 0x7531) {
        // 0x2ad8b
        *(int32_t *)a2 = v3 + (int32_t)a2;
        nm131_tune_internal2(a1, a2, NULL);
    }
    // 0x2ad9d
    return nm131_notch_spur2(a1);
}

// From module:   /root/asv5220/./NMI131/../NMI131/src\nm131.c
// Address range: 0x2add6 - 0x2ae06
// Line range:    3259 - 3354
int32_t nm131_chip_init(int64_t pPrivate) {
    // 0x2add6
    int64_t result; // 0x2add6
    return result;
}

// Address range: 0x2ae06 - 0x2b2b8
int64_t nm131_chip_init2(int64_t a1) {
    // 0x2ae06
    mcount();
    int64_t v1 = nm131_get_chipid2(a1); // 0x2ae23
    uint64_t v2; // 0x2ae06
    int64_t v3 = 184 * (v2 % 256); // 0x2ae2b
    int32_t * v4 = (int32_t *)v3; // 0x2ae32
    *v4 = (int32_t)v1;
    int64_t v5; // 0x2ae06
    int64_t v6; // 0x2ae06
    switch (v1 & 0xfff00) {
        case 0x13100: {
            goto lab_0x2ae86;
        }
        case 0x12000: {
            goto lab_0x2ae86;
        }
        default: {
            switch (v1 & 0xffff00) {
                case 0x13000: {
                    goto lab_0x2ae86;
                }
                case 0x813000: {
                    goto lab_0x2ae86;
                }
                default: {
                    // 0x2ae63
                    int64_t v7; // 0x2ae06
                    nmi_debug2(a1, (int64_t *)&g25, 0, (int128_t)v7, v6, v5);
                    // 0x2b261
                    return 0xffffffff;
                }
            }
        }
    }
  lab_0x2ae86:
    // 0x2ae86
    nm131_set_scan_level2(a1, (int64_t *)&g94);
    int64_t v8 = v3 | 4; // 0x2aeab
    *(int32_t *)v8 = -1;
    int64_t v9 = v3 + 8; // 0x2aeb3
    *(char *)v9 = (char)&g105;
    *(char *)v3 = (char)&g105;
    *(char *)(v3 + 9) = (char)&g105;
    *(char *)(v3 + 10) = (char)&g95;
    *(int32_t *)v9 = -1;
    *(int32_t *)(v3 + 12) = -1;
    *v4 = 0x45c2;
    *(char *)(v3 + 11) = -121;
    int64_t v10; // 0x2ae06
    int32_t * v11 = (int32_t *)(184 * (int64_t)*(char *)&v10); // 0x2af02
    *v11 = *v11 * (int32_t)"%(";
    int64_t v12 = 184 * (int64_t)*(char *)&v10; // 0x2af14
    int32_t v13 = *(int32_t *)v12; // 0x2af1b
    if (v13 != 0) {
        int64_t v14 = *(int64_t *)v12; // 0x2af2b
        int64_t v15; // 0x2ae06
        if (v13 < 61) {
            int64_t v16 = v13; // 0x2af36
            v15 = v16;
            if (v13 < 0) {
                int64_t v17 = nmi_get_tick2(a1); // 0x2b273
                nmi_debug2(a1, (int64_t *)&g2, 0, (int128_t)(v17 & 0xffffffff), v6, v5);
                wRegBurst2(a1, 0, v14, v16);
                return nmi_get_tick2(a1);
            }
        } else {
            int64_t v18 = nmi_get_tick2(a1); // 0x2af46
            nmi_debug2(a1, (int64_t *)&g2, 0, (int128_t)(v18 & 0xffffffff), v6, v5);
            v15 = 60;
        }
        int64_t v19 = v14; // 0x2af78
        int64_t v20 = 0; // 0x2af78
        *(char *)v19 = (char)v20;
        v20 = v20 + (int64_t)(int32_t)&g1 & 0xffffffff;
        v19++;
        while (v20 < v15) {
            // 0x2af84
            *(char *)v19 = (char)v20;
            v20 = v20 + (int64_t)(int32_t)&g1 & 0xffffffff;
            v19++;
        }
        int64_t v21 = nmi_get_tick2(a1); // 0x2af95
        nmi_debug2(a1, (int64_t *)&g2, 0, (int128_t)(v21 & 0xffffffff), v6, v5);
        wRegBurst2(a1, 0, v14, v15);
        int64_t v22 = nmi_get_tick2(a1); // 0x2afcc
        nmi_debug2(a1, (int64_t *)&g2, 0, (int128_t)(v22 & 0xffffffff), v6, v5);
        int64_t v23 = v14; // 0x2afec
        uint64_t v24 = 0;
        int64_t v25 = rReg8_(a1, v24 % 256); // 0x2aff7
        *(char *)v23 = (char)v25;
        while ((int32_t)v25 % 256 == (int32_t)v24) {
            int64_t v26 = v24 + (int64_t)(int32_t)&g1 & 0xffffffff; // 0x2b007
            v23++;
            if (v26 >= v15) {
                goto lab_0x2b055;
            }
            v24 = v26;
            v25 = rReg8_(a1, v24 % 256);
            *(char *)v23 = (char)v25;
        }
        if (v15 > v24) {
            int64_t v27 = nmi_get_tick2(a1); // 0x2b029
            nmi_debug2(a1, (int64_t *)&g2, 0, (int128_t)(v27 & 0xffffffff), v24, v24);
        } else {
          lab_0x2b055:;
            int64_t v28 = nmi_get_tick2(a1); // 0x2b058
            nmi_debug2(a1, (int64_t *)&g2, 0, (int128_t)(v28 & 0xffffffff), v6, v5);
        }
    }
    int64_t v29 = 184 * (int64_t)*(char *)&v10;
    if (*(char *)v29 != 0) {
        // 0x2b261
        return 0;
    }
    int64_t v30 = 0;
    unsigned char v31 = *(char *)v30; // 0x2b0a9
    unsigned char v32 = *(char *)(v30 * (int64_t)&g1); // 0x2b0ae
    wReg8_(a1, (int64_t *)(int64_t)v32, (int64_t)v31);
    int64_t v33 = v30 + (int64_t)&g25; // 0x2b0bb
    while (v30 != 60 - (int64_t)&g25) {
        // 0x2b0a9
        v30 = v33;
        v31 = *(char *)v30;
        v32 = *(char *)(v30 * (int64_t)&g1);
        wReg8_(a1, (int64_t *)(int64_t)v32, (int64_t)v31);
        v33 = v30 + (int64_t)&g25;
    }
    uint64_t v34 = rReg8_(a1, 54); // 0x2b0cd
    uint64_t v35 = *(int32_t *)v29 == 0 ? v34 % 128 : v34 | 128; // 0x2b0ed
    wReg8_(a1, (int64_t *)54, v35 % 256);
    wReg32_(a1, 356, (int64_t *)2048);
    wReg32_(a1, 448, (int64_t *)0x2d8c19c7);
    int32_t v36 = *v4; // 0x2b134
    if ((v36 & 0xfff00) != 0x12000) {
        int32_t v37 = v36 & 0xffff00;
        int64_t v38 = 0; // 0x2b185
        if (v37 != 0x13000) {
            if (v37 == 0x813000) {
                // 0x2b1bf
                wReg8_(a1, (int64_t *)40, 0);
                wReg8_(a1, (int64_t *)46, 86);
                wReg8_(a1, (int64_t *)52, 120);
            }
        } else {
            unsigned char v39 = *(char *)v38; // 0x2b19a
            unsigned char v40 = *(char *)(v38 * (int64_t)&g1); // 0x2b19f
            wReg8_(a1, (int64_t *)(int64_t)v40, (int64_t)v39);
            int64_t v41 = v38 + (int64_t)&g25; // 0x2b1ac
            v38 = v41;
            while (v41 != (int64_t)&g103) {
                // 0x2b19a
                v39 = *(char *)v38;
                v40 = *(char *)(v38 * (int64_t)&g1);
                wReg8_(a1, (int64_t *)(int64_t)v40, (int64_t)v39);
                v41 = v38 + (int64_t)&g25;
                v38 = v41;
            }
        }
    } else {
        int64_t v42 = v33 & -256; // 0x2b153
        unsigned char v43 = *(char *)(v42 * (int64_t)&g1); // 0x2b15f
        wReg8_(a1, (int64_t *)(int64_t)v43, (int64_t)*(char *)v42);
        v42 += (int64_t)&g25;
        while (v42 != (int64_t)&g4) {
            // 0x2b15a
            v43 = *(char *)(v42 * (int64_t)&g1);
            wReg8_(a1, (int64_t *)(int64_t)v43, (int64_t)*(char *)v42);
            v42 += (int64_t)&g25;
        }
    }
    // 0x2b20f
    *(char *)(v3 | 2) = 0;
    *(char *)(v3 | 3) = (char)rReg8_(a1, 0);
    *(char *)v8 = (char)rReg8_(a1, 52);
    *(char *)(v3 | 5) = (char)rReg8_(a1, 53);
    // 0x2b261
    return 0;
}

// From module:   /root/asv5220\I2C_PortingLayer.c
// Address range: 0x2b2bc - 0x2b2cf
// Line range:    36 - 43
char I2C_PortingLayer_Write(char * pDeviceExtension, char I2CDeviceAddress, char * pWriteBuffer, int16_t WriteBufferLength) {
    int64_t v1 = WriteBufferLength;
    char * v2 = (char *)(v1 - 25 + v1 * (int64_t)&g86); // 0x2b2bc
    *v2 = *v2 + (char)WriteBufferLength;
    int64_t v3; // 0x2b2bc
    int64_t v4; // 0x2b2bc
    return nmi_debug2((int64_t)pDeviceExtension, (int64_t *)(int64_t)I2CDeviceAddress, (int64_t)pWriteBuffer, (int128_t)WriteBufferLength, v4, v3);
}

// From module:   /root/asv5220\I2C_PortingLayer.c
// Address range: 0x2b2e2 - 0x2b2e3
// Line range:    44 - 52
char I2C_PortingLayer_Read(char * pDeviceExtension, char I2CDeviceAddress, char * pWriteBuffer, int16_t WriteBufferLength, char * pReadBuffer, int16_t ReadBufferLength) {
    // 0x2b2e2
    int64_t result; // 0x2b2e2
    return result;
}

// Address range: 0x2b2e5 - 0x2b2ea
int64_t function_2b2e5(void) {
    // 0x2b2e5
    int64_t result; // 0x2b2e5
    return result;
}

// Address range: 0x2b2ec - 0x2b312
int64_t I2C_PortingLayer_Write2(int64_t a1, uint64_t a2, int64_t a3, int64_t a4) {
    // 0x2b2ec
    mcount();
    return TLIB_I2C_Write_Middle2(a1, a2 % 256, 0);
}

// Address range: 0x2b312 - 0x2b362
int64_t I2C_PortingLayer_Read2(int64_t a1, uint64_t a2, char * a3, int64_t * a4, char * a5, int64_t * a6) {
    // 0x2b312
    mcount();
    return TLIB_I2C_Write_Middle2(a1, a2 % 256, 0);
}

// From module:   /root/asv5220\debug_log.c
// Address range: 0x2b364 - 0x2b36e
// Line range:    49 - 54
void DriverDebugMessage(char * Msg) {
    // 0x2b364
    return;
}

// From module:   /root/asv5220\debug_log.c
// Address range: 0x2b36f - 0x2b378
// Line range:    58 - 60
void DriverDebugPrint(char * format, ...) {
    // 0x2b36f
    int64_t v1; // 0x2b36f
    int64_t v2; // 0x2b36f
    int64_t v3; // 0x2b36f
    int64_t v4; // 0x2b36f
    int64_t v5; // 0x2b36f
    TLIB_I2C_Read_Middle2((int64_t)format, v3, v4, v5, v2, v1);
}

// Address range: 0x2b378 - 0x2b394
int64_t function_2b378(void) {
    // 0x2b378
    int64_t v1; // 0x2b378
    int64_t v2; // 0x2b378
    return v1 & (int64_t)(uint32_t)(int32_t)&g1 & v2;
}

// Address range: 0x2b394 - 0x2b39f
int64_t DriverDebugMessage2(int64_t a1) {
    // 0x2b394
    return mcount();
}

// Address range: 0x2b39f - 0x2b3aa
int64_t DriverDebugPrint2(int64_t a1, int64_t a2) {
    // 0x2b39f
    return mcount();
}

// Address range: 0x2b3ac - 0x2b3cf
int64_t asv5220_fini2(void) {
    // 0x2b3ac
    mcount();
    pci_unregister_driver(0);
    return class_destroy(g76);
}

// Address range: 0x2b3cf - 0x2b5e7
int64_t asv5220_finidev(int64_t a1) {
    // 0x2b3cf
    mcount();
    int64_t v1 = a1 + 144; // 0x2b3e8
    int64_t v2 = dev_get_drvdata(v1); // 0x2b3f2
    int64_t * v3 = (int64_t *)(v2 + 1304); // 0x2b3fa
    DTV_PollingThreadClose2(*v3);
    ASV5220_BcasThreadClose2(*v3);
    DTV_UnInit2(*v3);
    int64_t * v4 = (int64_t *)(v2 + 1296); // 0x2b41e
    DTV_PollingThreadClose2(*v4);
    ASV5220_BcasThreadClose2(*v4);
    DTV_UnInit2(*v4);
    int64_t * v5 = (int64_t *)(v2 + 1288); // 0x2b442
    DTV_PollingThreadClose2(*v5);
    ASV5220_BcasThreadClose2(*v5);
    DTV_UnInit2(*v5);
    int64_t * v6 = (int64_t *)(v2 + 1280); // 0x2b466
    DTV_PollingThreadClose2(*v6);
    ASV5220_BcasThreadClose2(*v6);
    DTV_UnInit2(*v6);
    int64_t * v7 = (int64_t *)(v2 + 1272); // 0x2b48a
    DTV_PollingThreadClose2(*v7);
    ASV5220_BcasThreadClose2(*v7);
    DTV_UnInit2(*v7);
    int64_t * v8 = (int64_t *)(v2 + (int64_t)&g88); // 0x2b4ae
    DTV_PollingThreadClose2(*v8);
    ASV5220_BcasThreadClose2(*v8);
    DTV_UnInit2(*v8);
    int64_t * v9 = (int64_t *)(v2 + 1256); // 0x2b4d2
    DTV_PollingThreadClose2(*v9);
    ASV5220_BcasThreadClose2(*v9);
    DTV_UnInit2(*v9);
    int64_t * v10 = (int64_t *)(v2 + (int64_t)&g87); // 0x2b4f6
    DTV_PollingThreadClose2(*v10);
    ASV5220_BcasThreadClose2(*v10);
    DTV_UnInit2(*v10);
    *(char *)(v2 + 0x53d8) = (char)&g1;
    *(int64_t *)(8 * (int64_t)*(int32_t *)(v2 + 0x6328)) = 0;
    int32_t * v11 = (int32_t *)(v2 + 0x6320);
    int64_t v12 = 0; // 0x2b545
    int32_t v13 = &g95; // 0x2b545
    cdev_del(v2 + 0x6330 + 104 * 0x100000000 * v12 / 0x100000000);
    uint32_t v14 = *v11; // 0x2b55f
    device_destroy(g76, v14 % 0x100000 + (int32_t)v12 | v14 & -0x100000);
    v13 -= (int32_t)&g1;
    v12 = v12 + (int64_t)(int32_t)&g1 & 0xffffffff;
    while (v13 != 0) {
        // 0x2b54b
        cdev_del(v2 + 0x6330 + 104 * 0x100000000 * v12 / 0x100000000);
        v14 = *v11;
        device_destroy(g76, v14 % 0x100000 + (int32_t)v12 | v14 & -0x100000);
        v13 -= (int32_t)&g1;
        v12 = v12 + (int64_t)(int32_t)&g1 & 0xffffffff;
    }
    // 0x2b58e
    unregister_chrdev_region(*v11, *(int32_t *)&g50);
    FUSBDTV_Stop2(v2);
    FUSBDTV_Remove2(v2);
    pci_iounmap(a1, *(int64_t *)(v2 + 0x57f8));
    pci_release_regions(a1);
    dev_set_drvdata(v1, 0);
    return pci_disable_device(a1);
}

// Address range: 0x2b5e7 - 0x2bb6a
int64_t asv5220_initdev(int64_t a1) {
    // 0x2b62e
    mcount();
    int64_t v1 = pci_enable_device(a1); // 0x2b631
    if ((int32_t)v1 != 0) {
        // 0x2bb58
        return v1 & 0xffffffff & 0xffffffff;
    }
    int64_t v2 = pci_set_dma_mask(a1, 0xffffffff); // 0x2b649
    int64_t v3 = v2 & 0xffffffff; // 0x2b64e
    if ((int32_t)v2 != 0) {
        // 0x2b655
        printk(0);
        // 0x2bb50
        pci_disable_device(a1);
        // 0x2bb58
        return v3 & 0xffffffff;
    }
    int32_t * v4 = (int32_t *)(a1 + 56); // 0x2b66c
    int64_t * v5 = (int64_t *)(a1 + (int64_t)&g2); // 0x2b670
    char v6; // bp-58, 0x2b5e7
    pci_bus_read_config_word(*v5, *v4, (int64_t *)&g86, (int64_t *)&v6);
    if ((v6 & (char)&g86) == 0) {
        // 0x2b684
        pci_set_master(a1);
        pci_bus_read_config_word(*v5, *v4, (int64_t *)&g86, (int64_t *)&v6);
        if ((v6 & (char)&g86) == 0) {
            // 0x2b6a8
            printk(0);
            // 0x2bb50
            pci_disable_device(a1);
            // 0x2bb58
            return 0xfffffffb;
        }
    }
    int64_t v7 = pci_request_regions(a1, 0); // 0x2b6cb
    if ((int32_t)v7 < 0) {
        // 0x2bb50
        pci_disable_device(a1);
        // 0x2bb58
        return v7 & 0xffffffff & 0xffffffff;
    }
    int64_t v8 = pci_iomap(a1, 0, 0); // 0x2b6e9
    if (v8 == 0) {
        // 0x2bb42
        pci_release_regions(a1);
        // 0x2bb50
        pci_disable_device(a1);
        // 0x2bb58
        return 0xfffffffb;
    }
    // 0x2b7b8
    int64_t v9; // bp-72, 0x2b5e7
    FUSBDTV_Add2(&v9);
    *(int64_t *)(v9 + 0x57f0) = a1;
    *(int64_t *)(v9 + 0x57f8) = v8;
    *(int64_t *)(v9 + 0x5808) = (int64_t)*(int32_t *)(a1 + 692);
    __mutex_init(v9 + 0x6670, 0, 0);
    alloc_chrdev_region(v9 + 0x6320, g72, *(int32_t *)&g50, 0);
    *(int32_t *)&g71 = g73 >> (int32_t)&g7;
    int64_t v10 = v9; // 0x2b77b
    *(int32_t *)(v10 + 0x6324) = *(int32_t *)(v10 + 0x6320) % 0x100000;
    int64_t v11 = 0; // 0x2b7c3
    int64_t v12 = 0; // 0x2b7c3
    int64_t v13 = *(int64_t *)(v9 + (int64_t)&g87 + 0x100000000 * v12 / 0x100000000 * (int64_t)&g95); // 0x2b7dc
    __mutex_init(v13 + 0x929b8, 0, 0);
    uint32_t v14 = *(int32_t *)(v9 + 0x6320); // 0x2b803
    *(int32_t *)(v13 + 0x929dc) = v14 % 0x100000 + (int32_t)v12;
    int32_t * v15 = (int32_t *)v11; // 0x2b81b
    *(int32_t *)(v13 + 0x929d8) = *v15;
    *(int32_t *)(v13 + 0x929e0) = *v15;
    int64_t v16 = v12 + (int64_t)(int32_t)&g1; // 0x2b837
    v11 += (int64_t)&g86;
    v12 = v16 & 0xffffffff;
    int32_t v17 = &g95; // 0x2b843
    int64_t v18 = 0; // 0x2b843
    while ((int32_t)v16 != (int32_t)&g95) {
        // 0x2b7d5
        v13 = *(int64_t *)(v9 + (int64_t)&g87 + 0x100000000 * v12 / 0x100000000 * (int64_t)&g95);
        __mutex_init(v13 + 0x929b8, 0, 0);
        v14 = *(int32_t *)(v9 + 0x6320);
        *(int32_t *)(v13 + 0x929dc) = v14 % 0x100000 + (int32_t)v12;
        v15 = (int32_t *)v11;
        *(int32_t *)(v13 + 0x929d8) = *v15;
        *(int32_t *)(v13 + 0x929e0) = *v15;
        v16 = v12 + (int64_t)(int32_t)&g1;
        v11 += (int64_t)&g86;
        v12 = v16 & 0xffffffff;
        v17 = &g95;
        v18 = 0;
    }
    int64_t v19 = 104 * 0x100000000 * v18 / 0x100000000;
    int64_t v20 = v19 + 0x6330; // 0x2b858
    cdev_init(v20 + v9, 0);
    *(int64_t *)(v9 + 0x6370 + v19) = 0;
    uint32_t v21 = *(int32_t *)(v9 + 0x6320); // 0x2b887
    int32_t v22 = v18;
    cdev_add(v9 + v20, v21 % 0x100000 + v22 | v21 & -0x100000, (int64_t *)&g1);
    uint32_t v23 = *(int32_t *)(v9 + 0x6320); // 0x2b8b0
    int32_t v24 = v23 % 0x100000 + v22; // 0x2b8bd
    int32_t v25 = *(int32_t *)(v9 + 0x6328); // 0x2b8c0
    device_create(g76, 0, v24 | v23 & -0x100000, 0, 0, (int64_t)(8 * v25 + v24));
    int32_t v26 = v17 - (int32_t)&g1; // 0x2b8f5
    v17 = v26;
    v18 = v18 + (int64_t)(int32_t)&g1 & 0xffffffff;
    while (v26 != 0) {
        // 0x2b851
        v19 = 104 * 0x100000000 * v18 / 0x100000000;
        v20 = v19 + 0x6330;
        cdev_init(v20 + v9, 0);
        *(int64_t *)(v9 + 0x6370 + v19) = 0;
        v21 = *(int32_t *)(v9 + 0x6320);
        v22 = v18;
        cdev_add(v9 + v20, v21 % 0x100000 + v22 | v21 & -0x100000, (int64_t *)&g1);
        v23 = *(int32_t *)(v9 + 0x6320);
        v24 = v23 % 0x100000 + v22;
        v25 = *(int32_t *)(v9 + 0x6328);
        device_create(g76, 0, v24 | v23 & -0x100000, 0, 0, (int64_t)(8 * v25 + v24));
        v26 = v17 - (int32_t)&g1;
        v17 = v26;
        v18 = v18 + (int64_t)(int32_t)&g1 & 0xffffffff;
    }
    // 0x2b8ff
    FUSBDTV_Start2(v9);
    dev_set_drvdata(a1 + 144, v9);
    *(char *)(v9 + 0x53d8) = 0;
    *(char *)(v9 + 0x53d9) = 0;
    TC_MOS_POWER2(v9, 0, (int64_t *)&g1);
    int64_t v27 = *(int64_t *)(v9 + (int64_t)&g87); // 0x2b94c
    int64_t v28 = DTV_Init2(v27, (int64_t *)&g25, (int64_t *)&g1); // 0x2b95d
    if ((int32_t)v28 == (int32_t)&g1) {
        // 0x2b967
        DTV_PollingThreadInit2(*(int64_t *)(v9 + (int64_t)&g87));
        ASV5220_BcasThreadInit2(*(int64_t *)(v9 + (int64_t)&g87));
    }
    int64_t v29 = *(int64_t *)(v9 + 1256); // 0x2b98b
    int64_t v30 = DTV_Init2(v29, (int64_t *)&g25, (int64_t *)&g1); // 0x2b99c
    if ((int32_t)v30 == (int32_t)&g1) {
        // 0x2b9a6
        DTV_PollingThreadInit2(*(int64_t *)(v9 + 1256));
        ASV5220_BcasThreadInit2(*(int64_t *)(v9 + 1256));
    }
    int64_t v31 = *(int64_t *)(v9 + (int64_t)&g88); // 0x2b9ca
    int64_t v32 = DTV_Init2(v31, (int64_t *)&g25, (int64_t *)&g1); // 0x2b9db
    if ((int32_t)v32 == (int32_t)&g1) {
        // 0x2b9e5
        DTV_PollingThreadInit2(*(int64_t *)(v9 + (int64_t)&g88));
        ASV5220_BcasThreadInit2(*(int64_t *)(v9 + (int64_t)&g88));
    }
    int64_t v33 = *(int64_t *)(v9 + 1272); // 0x2ba09
    int64_t v34 = DTV_Init2(v33, (int64_t *)&g25, (int64_t *)&g1); // 0x2ba1a
    if ((int32_t)v34 == (int32_t)&g1) {
        // 0x2ba24
        DTV_PollingThreadInit2(*(int64_t *)(v9 + 1272));
        ASV5220_BcasThreadInit2(*(int64_t *)(v9 + 1272));
    }
    int64_t v35 = *(int64_t *)(v9 + 1280); // 0x2ba48
    int64_t v36 = DTV_Init2(v35, (int64_t *)&g25, (int64_t *)&g1); // 0x2ba59
    if ((int32_t)v36 == (int32_t)&g1) {
        // 0x2ba63
        DTV_PollingThreadInit2(*(int64_t *)(v9 + 1280));
        ASV5220_BcasThreadInit2(*(int64_t *)(v9 + 1280));
    }
    int64_t v37 = *(int64_t *)(v9 + 1288); // 0x2ba87
    int64_t v38 = DTV_Init2(v37, (int64_t *)&g25, (int64_t *)&g1); // 0x2ba98
    if ((int32_t)v38 == (int32_t)&g1) {
        // 0x2baa2
        DTV_PollingThreadInit2(*(int64_t *)(v9 + 1288));
        ASV5220_BcasThreadInit2(*(int64_t *)(v9 + 1288));
    }
    int64_t v39 = *(int64_t *)(v9 + 1296); // 0x2bac6
    int64_t v40 = DTV_Init2(v39, (int64_t *)&g25, (int64_t *)&g1); // 0x2bad7
    if ((int32_t)v40 == (int32_t)&g1) {
        // 0x2bae1
        DTV_PollingThreadInit2(*(int64_t *)(v9 + 1296));
        ASV5220_BcasThreadInit2(*(int64_t *)(v9 + 1296));
    }
    int64_t v41 = *(int64_t *)(v9 + 1304); // 0x2bb05
    int64_t v42 = DTV_Init2(v41, (int64_t *)&g25, (int64_t *)&g1); // 0x2bb16
    if ((int32_t)v42 == (int32_t)&g1) {
        // 0x2bb20
        DTV_PollingThreadInit2(*(int64_t *)(v9 + 1304));
        ASV5220_BcasThreadInit2(*(int64_t *)(v9 + 1304));
    }
    // 0x2bb58
    return v3 & 0xffffffff;
}

// Address range: 0x2bb6a - 0x2bbd5
int64_t init_module(void) {
    int64_t result = __class_create(0, 0, 0); // 0x2bb83
    g76 = result;
    if (result >= 0xfffffffffffff001) {
        // 0x2bbd3
        return result;
    }
    int64_t v1 = 0; // 0x2bb9e
    *(int64_t *)v1 = 0;
    while (v1 != 64 - (int64_t)&g95) {
        // 0x2bba7
        v1 += (int64_t)&g95;
        *(int64_t *)v1 = 0;
    }
    // 0x2bbd3
    return __pci_register_driver(0, 0, 0);
}

// Address range: 0xc8a05c8 - 0xc8a05c9
int64_t function_c8a05c8(void) {
    // 0xc8a05c8
    int64_t result; // 0xc8a05c8
    return result;
}

// Address range: 0xeee5a94 - 0xeee5a95
int64_t function_eee5a94(void) {
    // 0xeee5a94
    int64_t result; // 0xeee5a94
    return result;
}

// Address range: 0x4c00000118bec209 - 0x4c00000118bec20a
int64_t function_4c00000118bec209(void) {
    // 0x4c00000118bec209
    int64_t result; // 0x4c00000118bec209
    return result;
}

// Address range: 0xffffffff8a024063 - 0xffffffff8a024064
int64_t function_ffffffff8a024063(void) {
    // 0xffffffff8a024063
    int64_t result; // 0xffffffff8a024063
    return result;
}

// Address range: 0xffffffffc801ed24 - 0xffffffffc801ed25
int64_t function_ffffffffc801ed24(void) {
    // 0xffffffffc801ed24
    int64_t result; // 0xffffffffc801ed24
    return result;
}

// Address range: 0xfffffffff3c9dcc7 - 0xfffffffff3c9dcc8
int64_t function_fffffffff3c9dcc7(void) {
    // 0xfffffffff3c9dcc7
    int64_t result; // 0xfffffffff3c9dcc7
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.6)
// Detected language: C
// Detected functions: 1430
